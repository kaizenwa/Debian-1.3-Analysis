\input texinfo    @c -*-texinfo-*-
%
% doc.gpm - main file for the documentation
%
% Copyright 1994,1995   rubini@ipvvis.unipv.it (Alessandro Rubini)
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ascii, you should "make gpmdoc.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use two extra features:
%       - The '%' as a comment marker ("\%" -> "%")
%       - leading blanks are allowed (and removed)
%

@comment %**start of header
@setfilename gpm.info
@settitle gpm-Linux @value{version}
@iftex
@afourpaper
@end iftex
@comment %**end of header

@syncodeindex tp fn
@syncodeindex vr fn

@ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* gpm-Linux: (gpm.info).           A mouse server for the Linux console
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@end ignore

@setchapternewpage off

@set version 1.10    %RELEASE
@set update-month July 1996

@c allow changing the predefined style
@tex
\input localstyle.tex
@end tex

@finalout

@ifinfo
%ASCII_BEGIN

This file is a user's and programmer's manual for gpm @value{version}.

Copyright (C) 1994,1995 Alessandro Rubini

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end ifinfo

@setchapternewpage odd
@titlepage
@c use the new format for titles
@title gpm-Linux @value{version}
@subtitle A general purpose mouse server for the Linux console
@subtitle @value{update-month}

@author by Alessandro Rubini (@code{rubini@@ipvvis.unipv.it})

@end titlepage
@setchapternewpage off
@headings single

@ifinfo
This file documents the @value{version} release of the "General Purpose
Mouse" (gpm) server for the Linux text console (@value{update-month}).

@node Top, Overview, (dir), (dir)
@top gpm-Linux

@menu
* Overview::                    
* Server Invocation::           
* Gpm Internals::               
* The ClientLib::               
* Demo Clients::                
* Function Index::              
@end menu

@end ifinfo
%##########################################################################
%##########################################################################

@node Overview, Server Invocation, Top, Top
@chapter Overview
@cindex Overview of Gpm
@cindex Gpm Overview


The @dfn{gpm} package is a mouse server for the Linux console.
It is meant to provide cooked mouse events to text-only applications,
such as editors and simple menu-based apps. Its roots come from the
@file{selection-1.5} package, by Andrew Haylett.

The first application to support the mouse has been ``The Midnite Commander'',
by Miguel de Icaza.  @file{mc-0.11} and later releases offer
mouse support if you have the mouse server running on your system.
The file @file{t-mouse.el} provides support for using the
mouse from within Emacs. @xref{Emacs Support}

As of release 0.96, a default-handler is released with gpm, and can be
used to handle Control-Mouse events to draw menus on the screen.
The @t{gpm-root} program, however, needs kernel 1.1.73 or newer.
@xref{gpm-root}

Release 1.00 is an incompatible one (is is incompatible with releases
older than 0.97), but is compatible with a future kernel-level mouse
driver. With 1.0 the high level library is availabel, together with a
demonstration/test program. A small utility to help in detecting your
mouse-type is also included.

@menu
* Building the Release::        
@end menu

%=========================================================================
@node Building the Release,  , Overview, Overview
@section Compiling and Installing
@cindex Building Gpm

Just say @samp{make && make install} to your shell. You'll need gpm
installed to compile the latest release of @cite{The Mouseless Commander}
with mouse support enabled.

Binaries are no more released with the package, mainly because my compiler
and libraries are quite old, so it's safer for you to compile the package
by yourself. 

If you're reinstalling the package on top of Slackware 2.1 or newer,
meke sure to overwrite or remove the old @t{gpm}. The location of
@t{gpm} within Slackware is @file{/usr/bin}. This is the main reason why
the default @t{PREFIX} in @t{Makefile} is now @t{/usr} and not @t{/usr/local}.

%=========================================================================
%@node Kernel Patches
%@section Kernel Patches
%@cindex Kernel Patches
%@cindex Patches to Apply
%
%Old Linux kernels need to be patched to provide features I rely on. As
%of 1.1.32, however, my patches are in the official release, so you won't
%need any kernel recompilation. Remember, anyway, to enable selection while
%compiling the kernel, or this package won't work.  Refer to
%@file{kernel/README} to probe further.
%
%Other features are needed to run the @t{gpm-root} client. They are
%really functional only since 1.1.73. 1.1.68, however, should be sufficient.
%

%##########################################################################
@node Server Invocation, Gpm Internals, Overview, Top
@chapter Server Invocation
@cindex The Server
@cindex Command Line (gpm)

%MANPAGE gpm.1
%M .TH GPM 1 "February 1995"
%M .UC 4
%M .SH NAME
%M gpm \- a cut and paste utility and mouse server for virtual consoles
%M .SH SYNOPSIS
%M .B gpm
%M [
%M .I options
%M ]
%M .br
%M .SH DESCRIPTION
%M This package tries to be a useful
%M mouse server for applications running on the Linux console.  It is
%M heavily based on the "selection" package, and quite a good deal of code
%M comes from selection itself. This package is intended as a replacement
%M for "selection", to provide additional facilities.
%M
%M The information below is extracted from the texinfo file, which is the
%M preferred source of information.

The @code{gpm} executable is meant to act like a daemon (thus, @t{gpmd}
would be a better name for it), in just the same way as @file{selection}
used to. This section is meant to describe the command-line options for
@code{gpm}, while its internals are outlined in the next section.
@xref{Gpm Internals}.

Due to restrictions in the @t{ioctl(TIOCLINUX)} system call, @t{gpm} must
be run by the superuser. The restrictions have been added in the last 1.1
kernels to fix a security hole related to selection and screen dumping.

The server can be configured to match the user's taste, and any application
using the mouse will inherit the server's attitude. Beginning from release
1.2, the mouse `feeling' can be reconfigured by each user logging on
the system console. See the description of ``@t{-q}'' @ref{Server Invocation}.


No user-wide configuration file is provided, because the mouse is a
machine-wide resource. If you feel that different users on a Linux
machine could benefit from personal mouse setup at login, feel free to
email me, and I'll look about it. As of this release, only the
@samp{inword()} look up table can be changed without restarting the
server (but to be able to do it, you have to install @t{gpm} with the
"set-user-id" bit turned on).

As of 0.97 the server program puts itself in the background. To kill @t{gpm}
you can just reinvoke it with the @t{-k} cmdline switch.

@menu
* Special Commands::            
* Command Line::                
* Bugs and Problems::           
@end menu

%M .SH SPECIAL COMMANDS
%==========================================================================

@node Special Commands, Command Line, Server Invocation, Server Invocation
@section Special Commands

Version 1.10 adds the capability to execute @i{special} commands on
certain circumstances. Special commands default to rebooting and halting
the system, but the user can specify his/her personal choice. The
capability to invoke commands using the mouse is a handy one for
programmers, because it allows to issue a clean shutdown when the
keyboard is locked and no network is available to restore the system to
a sane state.

Special commands are toggled by triple-clicking the left and right button --
an unlikely event during normal mouse usage. The easiest way to triple-click
is pressing one of the buttons and triple-click the other one. When special
processing is toggled, a message appears on the console (and the speaker
beeps twice, if you have a speaker); if the user releases all the buttons
and presses one of them again within three seconds, then the special
command corresponding to the button is executed.

The default special commands are:

@table @var
@item left button
        Reboot the system by signalling the init process

@item middle button (if any)
        Execute `@t{/sbin/shutdown -h now}'

@item right button
        Execute `@t{/sbin/shutdown -r now}'
@end table

The @t{-S} commandline switch enables special command processing and
allows to change the three special commands. To accept the default
commands use `@t{-S ""}' (i.e., specify an empty argument).  To specify
your own commands, use a colon-separated list to specify commands
associated to the left, middle and right button. If any of the commands
is empty, it is interpreted as `send a signal to the init process'. This
particular operation is supported, in addition to executing external
commands, because sometimes bad bugs put the system to the impossibility
to fork; in these rare case the programmer should be able to shutdown
the system anyways, and killing init from a running process is the only
way to do it.

As an example, `@t{-S ":telinit s:/sbin/halt"}', associates killing
init to the left button, going single user to the middle one, and halting
the system to the right button.

System administrators should obviously be careful about special
commands, as gpm runs with superuser permissions. Special commands are
best suited for computers whose mouse can be physically accessed only by
trusted people.

%M .SH COMMAND LINE OPTIONS
%==========================================================================
@node Command Line, Bugs and Problems, Special Commands, Server Invocation
@section Command Line Options

Available command line options are the following:

@table @code
@item -a @var{accel}
        Set the acceleration.

@item -b @var{baud}
        Set the baud rate.

@item -B @var{sequence}
        Set the button sequence. ``123'' is the
	normal sequence, ``321'' can be used by left-handed people,
        and ``132'' can be useful with two-button mice (especially within
        Emacs). All the button permutations are allowable.

@item -d @var{delta}
        Set the delta value. When a single motion event
	is longer than @var{delta}, @var{accel} is used as a multiplying
        factor.

@item -D
        Dirty operation (debug only). It causes
        gpm to kill an already running gpm, if any. The default behaviour is
        to not kill it. @xref{Bugs and Problems}.

@item -g @var{number}
        With glidepoint devices, emulate the specified button with tapping.
        @var{number} must be @t{1}, @t{2}, or @t{3}, and refers to the
        button number @i{before} the @t{-B} button remapping is performed.
        This option applies to the mman and ps2 decoding. No button is
        emulated by default because the ps2 tapping is incompatible with
        some normal ps2 mice

@item -h
        Print a summary of command line options.

@item -i @var{interval}
        Set @var{interval} to be used as an upper time limit
	for multiple clicks. If the interval between button-up and
	button-down events is less than @var{limit}, the press is considered
	a double or triple click. Time is in milliseconds.

@item -k 
        Kill a running gpm. This can be used by busmouse users to kill gpm
        before running X (unless they use @t{-R} or the single-open
        limitation is removed from the kernel).

@item -K
        Run kernel-mouse. @t{/dev/kmouse} is configured according to the
        other command line options, and the gpm functionality is run
        in kernel space. This requires the @t{kmouse} module, currently
        available from @t{tsx-11.mit.edu}. This is experimental.

@item -l @var{charset}
        Choose the @code{inword()} look up table. The
	@var{charset} argument is a list of characters. @file{-} is used to
	specify a range and @file{\} is used to escape the next character
        or to provide octal codes.
	Only visible character can appear in @var{charset} because control
	characters can't appear in text-mode video memory, whence selection
	is cut. 


@item -L @var{charset}
        Modify the  @code{inword()} look up table. This option is obsolete
        and will be dropped soon. Use ``@t{-q -l}'' instead.

@item -m @var{filename}
        Choose the mouse file to open. It defaults to @file{/dev/mouse}.

@item -M
        Enable multiple mode. The daemon will read two different mouse devices.
        Any subsequent option will refer to the second device, while any
        preceding option will be used for the first device. This option
        automatically forces the ``repeater'' (@t{-R}) option on.

@item -o @var{lines}
        Toggle modem lines. The @var{lines} argument can be ``@t{dtr}'',
        ``@t{rts}'' or ``@t{both}''. This is needed for some strange serial
        mice.
        
@item -p
        Forces the pointer to be visible while selecting. This is the
        behaviour of @t{selection-1.7}, but it is sometimes confusing.
        The default is not to show the pointer, which can be confusing as well.

@item -q
        Quit after changing mouse behaviour. This is intended to allow users
        to change the mouse ``feeling'' (@t{-a}, @t{-B}, @t{-d}, @t{-i},
        @t{-l}, @t{-p}, @t{-r}) without restarting the server. Since this
        needs root permissions, the system administrators can use the
        `set-uid' bits to enable/disable such capability. Changing mouse
        parameters is nonetheless only allowed from one of the virtual
        consoles. Options are transferred only for the first mouse.

@item -r @var{number}
        Set the responsiveness. A higher
	responsiveness is used for a faster cursor motion.

@item -R
        Causes @t{gpm} to act as a repeater: any mouse data received while
        in graphic mode will be produced on the fifo @file{/dev/gpmdata}
        in mouse-system protocol. This means that you can configure the X
        server to use that fifo as a mouse device. This option is useful for
        bus-mouse owners to override the single-open limitation. It is also
        an easy way to manage those stupid dual-mode mice which force you
        to keep the middle button down while changing video mode. The option
        is forced on by the @t{-M} option.

@item -s @var{number}
        Set the sample rate for the mouse device.

@item -S @var{commands}
        Enable special-command processing, and optionally specify custom
        commands as a colon-separated list. See above for a detailed
        description of special commands.

@item -t @var{name}
        Set the mouse type. Use @samp{-t help} to get a list
	of allowable types. @xref{Mouse Types}.

@item -v
        Print version information and exit.

@item -2
        Force two buttons. This means that the middle button, if any,
        will be taken as it was the right one.

@item -3
        Force three buttons. By default the
        mouse is considered to be a 2-buttons one, until the middle button
        is pressed. If three buttons are there, the right one is used
        to extend the selection, and the middle one is used to paste it.
        Beware: if you use the @samp{-3} option with a 2-buttons mouse, you
        won't be able to paste the selection. 

@end table

@ignore
.SH OPERATION

To select text press the left mouse button and drag the mouse.
To paste text in the same or another console, press the middle button.
The right button is used to extend the selection, like in `xterm'.

Two-button mice use the right button to paste text.

Double and triple clicks select whole wird and whole lines. Use of
the `-P' option is recommended for best visual feedback.

If a trailing space after the contents of a line is highlighted, and if
there is no other text on the remainder of the line, the rest of the
line will be selected automatically. If a number of lines are selected,
highlighted trailing spaces on each line will be removed from the
selection buffer.

Any output on the virtual console holding the selection will clear the
highlighted selection from the screen, to maintain integrity of the
display, although the contents of the paste buffer will be unaffected.

The selection mechanism is disabled if the controlling virtual console
is placed in graphics mode, for example when running X11, and is
re-enabled when text mode is resumed. (But see BUGS section below.)

@end ignore

%MSKIP
@menu
* Bugs and Problems::           
@end menu

@node Bugs and Problems,  , Command Line, Server Invocation
@section Bugs and Problems

%M .SH BUGS
The @code{gpm} server may have problems interacting with X, and with
@code{selection}.

With X11 @code{gpm} has the same problems as @code{selection}. If your
mouse is a single-open device (i.e. a bus mouse), you should kill
@code{gpm} before strating X, or use the ``@t{-R}'' option (see above).
To kill @t{gpm} just invoke @t{gpm -k}. This doesn't apply to serial mice.

@t{gpm} and @t{selection} can't run together, because they will contend
the mouse. They can control two mice independently, however.

Two instances of gpm can't run on the same system. If you have two mice use
the ``@t{-M}'' option (see above).

While the current console is in graphic mode, @t{gpm} sleeps until text mode
is back. Thus, it won't reply to clients. Anyways, it is unlikely that
mouse-eager clients will spur out in hidden consoles. This is not true if
@t{gpm} acts as a repeater.

pre-1.0 gpm releases have problems with kernel 1.2.9 and later, because the
clients must have write permission on the node @t{/var/run/gpmctl}. You
should invoke @t{chmod} on the node or install @t{gpm-1.0} or later (you
have this docs, you have the software).

@ignore

.SH AUTHORS
.nf
Andrew Haylett <ajh@gec-mrc.co.uk> (the original selection code)
Alessandro Rubini <rubini@ipvvis.unipv.it> (all the new features)

Many many contributors, to both selection and gpm.
.fi

.SH FILES
.nf
/dev/mouse      The default mouse device
/var/run/gpmpid The PID of the running gpm
/var/run/gpmctl A control socket for clients
/dev/gpmdata    The fifo written to by a `repeater' (-R) daemon.
.fi

.SH SEE ALSO
.nf
mev(1)      A sample client for the gpm daemon.
gpm-root(1) An handler for Control-Mouse events.

.fi
The info file about `gpm', which gives more complete information and
explains how to write a gpm client.

@end ignore
%MANPAGE END

%##########################################################################
@node Gpm Internals, The ClientLib, Server Invocation, Top
@chapter Gpm Internals
@cindex Internals

The server is organized as a main loop built around a @code{select()}
system call. It responds both to mouse events and to input from the
clients, which are connected to the server through a unix domain
socket. The connection is used to tell the server what a client is
interested in, and to get mouse events.

When no clients are connected to the active console, the server behaves
like the @samp{selection} package by Andrew Haylett, whose code has been
the starting point for @t{gpm}.  I chose to embed selection within gpm
because this is the most straightforward approach --- people is used to
have selection running on all the virtual consoles, and my package won't
break with them. Moreover, my implementation of selection is a little
different from selection-1.6 because much of the processing is made by
the server main loop. Selection, then, is a simple and well-designed
application, whose behaviour can be cloned by clients, by telling the
server to inherit the default response for certain mouse events
(@var{motion} being the most interesting).

@menu
* Events::                      
* Margins::                     
* Event Types::                 
* Mouse Types::                 
* Connection Details::          
* Default Handlers::            
@end menu

%==========================================================================
@node Events, Margins, Gpm Internals, Gpm Internals
@section Events
@cindex Events

Whenever the mouse generates an event, it is dispatched to the active
client for the current console, or to the default handler, if present.
Otherwise selection is run. A default handler is a client process which gets
mouse events form all the virtual consoles. @xref{Default Handlers}.

When a client is involved, it is handled a @code{Gpm_Event}
structure, built by the server. The fields for @code{Gpm_Event} are the
following:
@tindex Gpm_Event

@table @code

@item unsigned char buttons;
	An or-mask of the values @code{GPM_B_LEFT},
	@code{GPM_B_MIDDLE} and @code{GPM_B_RIGHT}. It corresponds to the state
	of the mouse buttons when the event is reported. The current
        implementation of gpm allows at most three buttons.

@item unsigned char modifiers;
	The value of the kernel variable
        @code{shift_state}, as of @file{keyboard.c}, when the event is
        reported. It is a bitmask value, and corrsponds to the least
        significant byte of the value used by the @file{loadkeys}
        program. Use of symbolic
        names in source code is available after inclusion of
        @file{<linux/keyboard.h>}, as exemplified in @file{mev.c}.

@item unsigned short vc;
	The number of the active virtual console when
	the event is reported. The client is not expected to use this value,
	which corresponds to the controlling terminal of the client process,
        unless it gets events form multiple consoles. @xref{Default Handlers}.

@item short x, y;
	The position of the mouse pointer where the event
	is reported. Is is 1-based, to be compatible with @code{selection}
        and @code{libcurses}.

@item short dx, dy;
	The change in position since the last reported
	event.

@item enum Gpm_Etype type;
	A bit-mask, representing the
	type of reported event, as described later. @xref{Event Types}

@item int clicks;
	A counter, which is valid at button-down, drag or
	button-up. It can be 0, 1 or 2 to mean single, double or triple
	click.

@item enum Gpm_Margin margin;
	A bit-mask, telling if the pointer has
	gone out of the visible screen. The indivudual bits are
	named @code{GPM_TOP}, @code{GPM_BOT}, @code{GPM_LFT},
        @code{GPM_RGT}. Only one
	of them is active at a time, to allow using @code{switch} on the
	value. Vertical outrun takes precedence on horizontal outrun.
        @xref{Margins}
@end table

%==========================================================================
@node Margins, Event Types, Events, Gpm Internals
@section How margins are managed

Motion and button-press events are constrained to remain within the
visible screen. This means that the @code{x} will be within 1 and 80 and
@code{y} will be within 1 and 25 when the console is 80x25
cells. However, a client can keep track of movements outside the
screen, by using the @code{dx} and @code{dy} fields, which aren't subject to
clipping.

The server helps applications in detecting margin conditions by filling the
@code{margin} field. Whenever the pointer tries to cross screen boundaries,
it is forced to remain on the border, but a flag is set in @code{margin}.

A different policy is in force for drag and button-release events. In this
case the pointer is allowed to go outside the physical screen by exactly
one position. This allows, for example, selecting to end of line
by dragging down-left. The peculiar situation is nonetheless signaled
through the @code{margin} flags. The client should be careful to 
fit the values within the screen if needed. @xref{Utility Functions}.


%==========================================================================
@node Event Types, Mouse Types, Margins, Gpm Internals
@section Event Types

The @code{type} field int @t{Gpm_Event} is made up of bit-wide
flags. The existing bit masks belong to two groups: bare events and
cooked events. The bit-mask @code{GPM_BARE_EVENTS} is provided to
extract bare events, by and-ing ('@t{&}') it with the @t{type} field.
For any event, exactly one bit will be set in the resulting bitmask.

Bare events are the following:

@table @code
@item GPM_MOVE
	A motion event, with all buttons up.
@item GPM_DRAG
	A motion event, but one or more buttons are kept pressed.
@item GPM_DOWN
	A button press event. The @t{buttons} field will report
        which buttons are pressed after the event.
@item GPM_UP
	A button release event. The @t{buttons} field will report
        which buttons are being released. Nothe that this is different from
        the previous case.
@item GPM_ENTER
        This means "enter in the current Region of Interest", and such 
        event can only happen if the high-level library is used.
        When the type is @t{GPM_ENTER}, all the other fields are undefined.
        @xref{High Level Lib}.
@item GPM_LEAVE
        This is only delivered by the high level library, too. Events
        of type @t{GPM_LEAVE} have all other fields undefined.
@end table

Cooked events are the following:

@table @code
@item GPM_SINGLE
	This bit may be set at button-press,
	drag and button release events, and can be used to identify a
	single press. The time interval used to choose a double click
	from two single clicks is set by a parameter in the daemon
        (configurable at daemon invocation).
@item GPM_DOUBLE
	Used to identify a double click (press, drag, release)
@item GPM_TRIPLE
	Used to identify a triple click (press, drag, release)
@item GPM_MFLAG
	The ``motion flag'' is true if some dragging happened
	between button-press and button-release. It can be used by
	those applications which respond to events at button release.
        It is available at drag and release.
@end table

%==========================================================================
@node Mouse Types, Connection Details, Event Types, Gpm Internals
@section Mouse Types

I chose to isolate anything related to mouse types, because I can't test
them all. The source file @code{mice.c} is made up of type-specific functions,
as well as a table to dispatch computation. The table offers a default device
name for each mouse type as well, but I lack information about some of them.
Contributions in this field are particularly welcome.

The mouse type is specified on command line with the ``@t{-t}'' option. The option
takes an argument, which can be one of the following strings (two different strings
are available sometimes: one is the old selection-compatible name, the other is
the XFree name)

@table @code
@item bare Microsoft
        The microsoft protocol, without any extension. It only reports two
        buttons. If your device has three, you shoudl either try toggling
        the DTR and RTS lines (``@t{-o}'' option) or invoke @t{gpm} with
        ``@t{-t msc}'' while keeping the middle button down. Silly, isn't it?

@item ms 
        This is the original microsoft protocol, with a middle-button extension.
        Some old two-button devices send some spurious packets, which can be
        misunderstood as middle-button events. If this is your case, use
        the @t{bare} mouse type.

@item msc MouseSystems
        This is the standard protocol for three-button serial devices.

@item mman Mouseman
        The protocol used by the new Logitech devices.

@item bm BusMouse
        Some bus devices use this protocol, including those produced
        by Logitech.

@item logi Logitech
        This is the protocol used by old serial Logitech mice.

@item ps2 PS/2
        The protocol used by most busmice. 

@item mm MMSeries
        Title says it all.

@item sun
        An old protocol, retained for compatibility.
@end table

%==========================================================================
@node Connection Details, Default Handlers, Mouse Types, Gpm Internals
@section Connection Details

Each virtual console has a stack of clients attached to it. They talk to
gpm by writing to a control socket and get mouse events by reading
it. Only the top-of-stack client can get events from the server; other
clients in the stack are assumed to be waiting for the top one.  This
behaviour sounds sensible, but may upset some really demanding
application. If you're going to write such application, please call me
back.

In addition to the per-console stacks, another stack is there to store
default-handling clients. xref @xref{Default Handlers}.

Each client registers with the server and tells which events it is
interested in. Events not managed by the client can be handled by the
selection mechanism, which is compiled in the server itself. This
approach simplifies writing clients which respond only to button
press/release events, because highlighting the mouse pointer can be
performed by the server. A default handler in turn can respond only to
mouse events associated with modifier keys, so that selection is used
for any mouse-only event.

Clients are required to fill a @code{Gpm_Connect} structure and pass it to the
server. The structure is made up by four @code{unsigned int} fields.
@xref{Open and Close}.
@tindex Gpm_Connect

@table @code
@item eventMask
	A bitmask of the events the client wants
	to receive. Both bare and cooked events are
	allowed to appear in the mask.

@item defaultMask
	A mask to tell wich events allow
	a default treatment (the selection one). These are mouse events,
	independent of the modifier keys.

@item minMod
	The minimum amount of modifiers
	required by the client. This field is used for default-handlers
	which manage control-mouse events whithout interfering
	with mouse-only ones. @xref{Default Handlers}.

@item maxMod
	The maximum amount of modifiers the client is willing to receive.
        Events featuring a modifier key not included in @t{maxMod} won't
        be passed to the client.
@end table
@noindent
Two more fields are there to tell about the connection itself, and you're
not asked to fill them, because @t{Gpm_Open} will do it for you.

@table @code
@item int pid
	The @code{pid} of the connecting application.
@item int vc
	Which virtual console to gain control of.
@end table

Keyboard modifiers are used to multiplex clients on the same virtual
console. You (as a programmer) don't need to care about the internal
workings (which are detailed in ref @xref{Default Handlers}), but only
need to choose the right values for your application.

Ecamples:
@table @code
@item minMod=0; maxMod=0;
        specifies a client which senses mouse-only events, but neither
        shift-mouse nor alt-mouse nor control-mouse.

@item minMod=0; maxMod=~0;
        is a client which gets any mouse event.

@item minMod=1<<KG_SHIFT; maxMod=1<<KG_SHIFT;
        is a client which senses all shift-mouse events and
        nothing more.

@item minMod=1<<KG_SHIFT; maxMod=~0;
        is a client interested in shift-and-whatever-else mouse events,
        but disregarding mouse-only events.
@end table

If the modifier keys in the event are too few or too many, the event
won't be reported to the client. If the modifiers are right but the
current event is not part of the @code{eventMask}, it is not reported as
well. If the event is not used by the client, it can nonetheless be
passed to another client (a default handler or the internal selection
mechanism), according to the @code{defaultMask}.  If the event has been
already reported to the current application, it will also be passed
along the chain, if the GPM_HARD bit is set the @code{defaultMask}.

Good values for @code{defaultMask} can thus be the following:

@table @code
@item 0
	To sink any event, even those I don't use.
@item ~eventMask
	Pass along any event I don't use.
@item ~GPM_HARD
	Just the same, independently of @code{eventMask}.
@item GPM_MOVE|GPM_HARD
	Pass motion events, even if I use them.
	This is the good choice for an application which wants information on
	mouse motion, but leaves the task of cursor-drawing to the server.
@end table

%==========================================================================
@node Default Handlers,  , Connection Details, Gpm Internals
@section Default Handlers

In addition to console-specific clients, @t{gpm} allows for
console-independent clients -- those clients which handle events ignored
by conventional clients

Keyboard modifiers are used to multiplex the different clients on the
same console, and a default handler should specify a non-zero minimum
modifier set.

To summarize, events which get to the server can be delivered to
the following "clients", orderly:

@bullet{} The current client for the current console, if any.

@bullet{} The default handler, if any.

@bullet{} The builtin `selection' mechanism.

A keyboard modifier which connected with a @t{minMod} equal to the
"Control" modifier and a @t{maxMod} of @t{~0} (all bits on), will then
get any event including the control key, if the application disregards it.

This means that if the foreground application gets only the "Meta" key,
control-mouse is sufficient to invoke the default handler. If the application
gets control-mouse but disregards "Meta", conversely, meta-control-mouse will
invoke the default handler, and meta-mouse will be delivered to selection.

Both the @t{minMod} and @t{maxMod} fields are bitmasks, and their values
are bitwise or-ed and and-ed with the current modifier mask.

@t{gpm-root} is an example of default handler. It gets control-mouse events
by default, and reads user-specific conficuration files in order to draw
menus on the background of your screen. @xref{gpm-root}.

%##########################################################################
@node The ClientLib, Demo Clients, Gpm Internals, Top
@chapter The Client Library

The @code{libgpm.a} archive is meant to provide the mouse protocol at
different levels of abstracion. Applications linking to the @t{gpm}
server are expected to benefit from using the library, as compared to
managing the raw socket interface. Any source file using the library
should include @code{<gpm.h>} to get @t{gpm} specific macros and prototypes.

Delivery of events within the library makes heavy use of the concept
of "Handling Function" (or "handler", for short).

@menu
* Handling Functions::          
* Low Level Library::           
* High Level Lib::              
* Xterm::                       
@end menu

%==========================================================================
@node Handling Functions, Low Level Library, The ClientLib, The ClientLib
@section Handling Functions

A mouse handler is a function which registers itself within the
library, and is called whenever a mouse event is reported to the
application. It is passed two arguments and returns an integer value,
according to the following typedef:

@code{typedef int Gpm_Handler(Gpm_Event *@var{event}, void *@var{clientdata});}
@tindex Gpm_Handler

The @code{event} is used to instantiate the mouse event just received,
and the @code{clientdata} pointer is needed to implement some higher
level functionality. An handler will be tipically invoked by
@code{Gpm_Getc}, or by the high-level library, and the following
discussion assumes the invoking function is @code{Gpm_Getc} (the
high-level library only runs on behalf of @code{Gpm_Getc}).

Handling functions can do whatever they want to, and return to the caller
an integer value, which can be used to generate a keyboard event. This
feature is useful in that often the mouse is a shortcut for something which
could be made by means of the keyboard.

The application main loop can detect if the keyboard event is a physical
or generated one by looking at the global variable @t{gpm_hflag}, which
is not zero only for handler-generated events.

An handling function can generate more than one key in response of a single
mouse event. If it sets the global variable @t{gpm_morekeys} to a non-zero
vairable before returning, it will be invoked again without waiting for
mouse events. You can use @t{gpm_morekeys} as a counter of how
many times you want to be called again -- the client library only compares
it to zero.

The return value from an handler is used as follows:

@table @code
@item EOF
	This value is used to signal a fatal error, and will cause
	@code{Gpm_Getc} to return the same value to the caller, after setting
	@code{gpm_hflag} to 1.

@item 0
	A zero return value means that @code{Gpm_Getc} should go on as
	before, without returning to the caller. The event has been eaten
	by the handler and no key-press is simulated.

@item @var{anything-else}
	Any other value is considered a ``simulated''
	character, and is returned to the caller after setting
	@code{gpm_hflag}.  This allows a quick way to implement yes/no
	boxes abd simple menus without interfering with the main body
	of an existing application. Moreover, if return values greater
	than 255 are used a single switch loop can parse both keyboard
	and mouse events.
@end table

@noindent
A mouse handler is passed as second argument the content of the
@code{gpm_data} variable, i.e. the current clientdata. The clientdata is
almost unuseful unless you use the high-level library, because it holds
a static value. Delivering the clientdata however allows the
high-level management of mouse events to be a superset of the
low-level code, rather than an incompatible alternative.

%==========================================================================
@node Low Level Library, High Level Lib, Handling Functions, The ClientLib
@section Low Level Library

The library offers utility functions to establish the connection and
to get mouse events. They are designed to work painlessly if the
server is not running on the host machine. Xterm support is available
as well. @xref{Xterm}.

@menu
* Variables ::                  
* Open and Close::              
* Getting Events::              
* Utility Functions::           
* Extra Functions::             
@end menu

%--------------------------------------------------------------------------
@node Variables , Open and Close, Low Level Library, Low Level Library
@subsection Global Variables


This is the list of all the global variables present in the client
library:

@table @code
@vindex gpm_flag
@item int gpm_flag
	Initially zero, it is used to tell if the process
	is connected with a mouse server or not. It is used as a counter to
	manage multiple opens as well.
@vindex gpm_tried
@item int gpm_tried
	A flag, used to avoid retrying a connection if
	the server is not available on the system.
@vindex gpm_fd
@item int gpm_fd
	Initially @code{-1}, it is the file descriptor used
	to talk with the server. If we run under xterm, it will be -2.
@vindex gpm_zerobased
@item int gpm_zerobased
	Since selection and curses has always been one-based,
	this variable, zero by default, can be used to trigger zero-based
	coordinates in event reporting. It must be set before opening the mouse
	connection, and never changed later.
@vindex gpm_visiblepointer
@item int gpm_visiblepointer
        If not zero, causes the mouse cursor to be always visible on the
        window. It is zero by default.
@vindex gpm_mx
@vindex gpm_my
@item gpm_mx
@itemx gpm_my
        These variables are used when fitting events inside the screen.
        They are initalized by @t{Gpm_Open}, and never touched any more.
        If your application installs a signal handler for @t{SIGWINCH},
        it should modify these variables. I don't like my simple client
        library to installa signal handler: if the application won't
        resize there's no need to fix event allowed estate.
@vindex gpm_hflag
@item int gpm_hflag
	Used to signal if a character has been generated
	by a mouse handler. @xref{Handling Functions}
@vindex gpm_handler
@vindex gpm_data
@item Gpm_Handler *gpm_handler; void *gpm_data
	Both initially @code{NULL},
	they're used to setup asynchronous mouse handling, as
	described below under the @code{Gpm_Getc()} item.
@vindex gpm_morekeys
@item gpm_morekeys
        Used by the mouse handler to provide more than one key:
        if @t{gpm_morekeys} is not zero, @code{Gpm_Getc} will
        invoke the handler without waiting for events. @t{gpm_morekeys}
        is never set by the mouse library.
@end table


%--------------------------------------------------------------------------
@node Open and Close, Getting Events, Variables , Low Level Library
@subsection Connecting and Disconnecting
%.........................................................................
@deftypefun int Gpm_Open (Gpm_Connect *@var{conn}, int @var{flag});
@findex Gpm_Open

Open a connection with the server. The @var{conn} parameter points to the
connection information for the being-created connection, as already described.
It is passed to the server after filling the @code{pid} and @code{vc} fields.

@var{flag} should be @code{0} for normal applications, those interested
in events related to their own console. The own console is considered to
be the one attached to @code{stdin}, and it must match the string
@samp{/dev/tty*}. A negative value for @var{flag} is used to make the
invoking application a default handler @ref{Default Handlers}, while a
positive value is used to force connection to a particular console,
either for debugging issues or whenever @code{stdin} is not a tty when
@code{Gpm_Open} is invoked.

Multiple opens are allowed, and a stack of @code{Gpm_Connect} structures
is managed by the library. You can, thus, re-open the connection in
order to temporarily change the range of events you're interested
in. When you invoke an external program, for example, you should re-open
the connection with @code{eventMask} zeroed, and @code{defaultMask},
@code{minMod} and @code{maxMod} all equal to @code{~0}.

The return value is either @code{-1} or the file descriptor used to
communicate with the server. When run under xterm, a gpm client gets event
through @t{stdin}, and the return calue for @t{Gpm_Open()} will be @t{-2}.
This value is always available withing @t{gpm_fd}.
@end deftypefun

%.........................................................................
@deftypefun int Gpm_Close (void);
@findex Gpm_Close

Pops the connection stack. It is used to restore the previous situation
after a change in the connection masks. Closes the actual connection
when the stack gets empty. On last close it returns 0, -1 otherwise.
@end deftypefun

%--------------------------------------------------------------------------
@node Getting Events, Utility Functions, Open and Close, Low Level Library
@subsection Getting Events
%.........................................................................
@deftypefun int Gpm_GetEvent (Gpm_Event *@var{event});
@findex Gpm_GetEvent

Reads an event form @code{gpm_fd}. It should be called only when the
@code{gpm_fd} descriptor is reported as readable by a @code{select()}
system call, or it will block until an event arrives (unless you put the
mouse file in non-blocking mode). It returns 1 on success, -1 on
failure, and 0 after closing the connection. Failure can happen if a
signal interrupted the read system call. This function doesn't work with
xterm mouse reporting and is meant for internal use by the library.
@end deftypefun

%.........................................................................
@deftypefun int Gpm_Getc (FILE *@var{f});
@findex Gpm_Getc
@deftypefunx int Gpm_Getchar (void);
@findex Gpm_Getchar

These are intended to be replacements for @code{getc()} and
@code{getchar()} to be used by applications which are interested in the
mouse. Their external behaviour is the same as @code{getc()}, but a mouse
handler gets invoked whenever an event is available. @xref{Handling Functions}.
A mouse handler can force @code{Gpm_Getc} to return a
specific value to the caller, and the ``simulated'' character is
signaled by setting @code{gpm_hflag} to 1.
@end deftypefun

%.........................................................................
@deftypefun int Gpm_Wgetch (WINDOW *@var{win});
@findex Gpm_Wgetc
@deftypefunx int Gpm_Getch (void);
@findex Gpm_Getch

These are intended to be replacements for @code{wgetch()} and
@code{getch()} to be used by applications which are interested in the
mouse. They are the curses equivalent of @t{Gpm_Getchar}.
@end deftypefun

%--------------------------------------------------------------------------
@node Utility Functions, Extra Functions, Getting Events, Low Level Library
@subsection Utility Functions
%.........................................................................
@deftypefun int Gpm_Repeat (int millisecs);
@findex Gpm_Repeat

It returns 1 if no mouse events arrive in the next @t{millicecs}
milliseconds, 0 otherwise. It is meant to be used by those handlers
which need to repeat an action as long as the mouse button is pressed
(@t{while(Gpm_Repeat(200))@dots{}}).
@end deftypefun

%.........................................................................
@deftypefun int Gpm_DrawPointer (int @var{x}, int @var{y}, int @var{fd});
@findex Gpm_DrawPointer
@deftypefunx int GPM_DRAWPOINTER (Gpm_Event *@var{ePtr};)
@findex GPM_DRAWPOINTER

These are actually macros. They should be used to draw the mouse pointer after
mangling the screen (while dragging on a menu, say), because letting it to
the server won't work nicely, due to lack of synchronism between client and
server. The file descriptor should refer to the console. The return value is
0 on success and -1 on failure. @t{Gpm_DrawPointer} is obsolete, and is
retained only for compatibility.
@end deftypefun

%.........................................................................
@deftypefun int Gpm_FitValuesM (int *@var{x}, int *@var{y}, int @var{margin});
@findex Gpm_FitValuesM
@deftypefunx int Gpm_FitValues (@var{x},@var{y});
@findex Gpm_FitValues
@deftypefunx Gpm_FitEvent (@var{ePtr});
@findex Gpm_FitEvent

The first is a function, while the other are macros.
Note that @t{Gpm_FitEvent} does not return values.
These three procedures should be used to fit the pointer inside the visible
screen. They are needed for drag and release event. A connection
bit will be available in the future to force the pointer in the visible
region.

Note that fitting uses @t{gpm_mx} and @t{gpm_my}, which you should
update when necessary. @xref{Variables}.
@end deftypefun

%--------------------------------------------------------------------------
@node Extra Functions,  , Utility Functions, Low Level Library
@subsection Extra Functions
%.........................................................................
@deftypefun char *Gpm_GetLibVersion (int *where);
@findex Gpm_GetLibVersion

This function returns a pointer to a static storage representing the
version number of the library. It is only available from 0.98.2 onward,
and returns a string like ``@t{"0.98.2"}''. The third number is optional,
and the second number will always be reported as two digits; thus 1.10 is
newer thayyn 1.01. The @t{where} pointer, if not null, is used to store
a decimal number representing the version -- 0.98.2 is 9802 and 1.1.8 is
10108.
@end deftypefun

%.........................................................................
@deftypefun char *Gpm_GetServerVersion (int *where);
@findex Gpm_GetServerVersion

This function returns a pointer to a static storage representing the
version number of the server. The version is retrieved through
@t{popen()}, so it could fail (and return @t{NULL})if no @t{gpm} program
is in the current path. Alternatively, it could fail (and return a wrong
value) if the @t{gpm} in the path is not the currently running one.
The function is only available in the clientlibrary version 0.98.2 or
newer, but it works with any daemon, from 0.01 onward. The string returned
can be parsed in the same way as for @t{Gpm_GetLibVersion()}. A preparsed
version is stored in @t{*where} if @t{where} is not null. Both these
functions do their calculations only the first time they are invoked.
@end deftypefun

%.........................................................................
@deftypefun int Gpm_GetSnapshot (Gpm_Event *ePtr);
@findex Gpm_GetSnapshot

This function gives a non-blocking snapshot of the current situation:
it returns the number of mouse buttons, as known to the server, or -1
if that information is not available (under Xterm, or before connecting).
If @t{ePtr} is not null, it is filled with information about the current
state of the mouse. The fields have the following meaning: @t{x,y}: current
position of the cursor; @t{dx,dy} size of the window; @t{vc,modifiers} the
current console and the current shift state; @t{buttons} which buttons
are currently help down; @t{clicks} the number of clicks (0,1,2).
This function is only available from 0.98.2 onward, and will return -1
if run with an older server.

Since this information travels on the same file descriptor as the
events, and applications usually don't want to lose events, the function
returns 0 if the input queue is not empty.

@end deftypefun


%--------------------------------------------------------------------------
@node High Level Lib, Xterm, Low Level Library, The ClientLib
@section High Level Library

The high level library is still part of the main @t{libgpm.a}, but it
acts at a different level of abstraction. The high level library depends
in the lowe-level one, so if you link your application with any object
of the high-level library, you're forced to link in the low-level one too.

If your application runs under xterm, however @t{gpm-xterm} offers all the
needed functionality.

The main role of the high-level library is to define a way to manage
windows (or "Regions of Interest" on your text screen). The regions
are arranged in a stack, and event are delivered to the different
windows according to their position both on the stack and on the screen.
@xref{hltest}.

@menu
* Concepts::                    
* hl-Variables::                
* hl-Functions::                
@end menu

%--------------------------------------------------------------------------
@node Concepts, hl-Variables, High Level Lib, High Level Lib
@subsection Concepts

The high-level library is completely independent of the low-level one,
so it used @t{gpm_handler} and @t{gpm_data} as connection point with
@t{Gpm_Getc()}.

All the functionality is based on the concept of RoI's. each RoI is
descripted by a @t{Gpm_Roi} structure, which is made up by the following
fields:
@tindex Gpm_roi

@table @code

@item short xMin, xMax
        These numbers identify the upper-left corner of the region.
        When events are reported to the region, the event coordinate
        will be relative to this position (zero-based).

@item short yMin, yMax
        These numbers identify the lower-right corner of the region.

@item unsigned short minMod, maxMod
        These modifier masks have the same role within the application as
        the same fields have in inter-application multiplexing.

@item unsigned short eventMask
        It is the mask of events which are to be reported to the current
        region.

@item unsigned short owned
        This is a bit, used to know if the region is owned by the
        library or the application, in order to issue @t{free(0} when
        needed.

@item Gpm_Handler *handler
        The function to be called when events are to be reported to the
        current region.

@item void *clientdata
        The clientdata to be passed to the handler

@item Gpm_Roi *next, *prev
        Links to the RoI chain.

@end table

%--------------------------------------------------------------------------
@node hl-Variables, hl-Functions, Concepts, High Level Lib
@subsection Variables

@table @code
@item Gpm_Roi *gpm_roi
        The linked list of regions (pointer to the top one).
@vindex gpm_roi

@item Gpm_Roi *gpm_current_roi
        The region which got the last event (used to generate enter and
        leave events).
@vindex gpm_current_roi

@item Gpm_Handler *gpm_roi_handler
        This variabel is meant to be set by the user. It is the catch-all
        region of interest, which will be called for any mouse event not
        falling within any registered region. If NULL, the event will be
        discarded.
@vindex gpm_roi_handler

@item void *gpm_roi_data
        the client data to be passed to @t{gpm_roi_handler}.
@vindex gpm_roi_data
@end table

%--------------------------------------------------------------------------
@node hl-Functions,  , hl-Variables, High Level Lib
@subsection Functions



%.........................................................................
@deftypefun Gpm_Roi *Gpm_PushRoi (int xmin, int ymin, int xmax, int ymax,
        int mask, Gpm_Handler *fun, void *xtradata);
@findex Gpm_PushRoi

This function pushes a Region of Interest on top of the stack, after
allocating it and filling with the provided values. @t{fun} is the
function which will be called in order to handle events, and the
roi itself will be passed to the function as clientdata. The Roi is
represented by a @t{struct Gpm_Roi} structure, described in @t{gpm.h}.
The @t{xtradata} field will be used to fill the @t{xtradata} field in
@t{Gpm_Roi}.
the return value is the Roi just pushed (i.e. the top of stack).
@end deftypefun

%.........................................................................
@deftypefun char *Gpm_UseRoi (Gpm_Roi *roi);
@findex Gpm_UseRoi

While @t{Gpm_PushRoi} has to allocate the Region before pushing it, this
function passes a pre-allocated function to the stack manager.
The return value is the Roi just used.
@end deftypefun

%.........................................................................
@deftypefun Gpm_Roi *Gpm_PopRoi (Gpm_Roi *roi);
@findex Gpm_PopRoi

Used to extract a Region of Interest from the stack, this function will
also clear the Region if it is needed.
@end deftypefun

%.........................................................................
@deftypefun Gpm_Roi *Gpm_RaiseRoi (Gpm_Roi *which, Gpm_Roi *before);
@findex Gpm_RaiseRoi

Raise the specified roi, either before the second Roi or at top-of-
stack (if @t{before} is NULL). The return value is the new top-of-stack.
@end deftypefun

%.........................................................................
@deftypefun Gpm_Roi *Gpm_LowerRoi (Gpm_Roi *which, Gpm_Roi *after);
@findex Gpm_LowerRoi

Lower the specified roi, either after the second Roi or at bottom-of-
stack (if @t{before} is NULL). The return value is the new top-of-stack.
@end deftypefun

%.........................................................................
@deftypefun Gpm_Roi *Gpm_HandleRoi (Gpm_Event *ePtr, void * clientdata);
@findex Gpm_HandleRoi

This function, which should not be invoked by the user, is the dispatching
manager within the application for mouse events. This function will
browse the stack of regions of interest in order to notify windows about
@t{Enter} and @t{Leave} events (if they are interested in them), and then
delivers the current event to the relevanto Roi.

If no Roi is interested in he event the @t{*gpm_roi_handler} function
is invoked (if not null), with null clientdata.

Reported events are all those in @t{Gpm_Event}, and also @t{GPM_ENTER}
and @t{GPM_LEAVE}. These can be used to toggle highlighting on a
button or to drop a menu if the menubutton is entered during a drag.
Remember that when Enter or Leave is notified, no other information in
the event item should be used.


@end deftypefun


%==========================================================================
@node Xterm,  , High Level Lib, The ClientLib
@section Running under @t{xterm}

As of release 0.18, @t{gpm}-based applications can run under xterm
without any need for recompilation. The library is designed to convert
xterm mouse events to gpm-style structures, so that the client will
get the same events it got under the Linux console. Moreover,
a source file (@t{gpm-xterm.c}) is available to mimick libgpm under
a different OS than Linux. Porting to other text-based consoles is an open
issue, but I myself have Linux alone.

The goal is to provide a uniform mouse interface with both xterm and the
Linux console. Some features of libgpm would not be available, but if
you run under xterm you know what you get, so you couldn't use them on
the console anyway.

The @t{sample} directory in the distribution tree is meant to show how
a simple mouse-sensitive application can be easily autoconfigured and
compiled. The @t{rmev} program has proved to compile and run smoothly
under Linux (both with and without @t{libgpm.a}), SunOS-4, Solaris-5,
hpux-8.x and Ultrix-3.0.


%##########################################################################
@node Demo Clients, Function Index, The ClientLib, Top
@chapter Demonstration Clients

@menu
* mev::                         
* sample/rmev::                 
* Emacs Support::               
* gpm-root::                    
* hltest::                      
* mouse-testhltest::            
@end menu

%==========================================================================
@node mev, sample/rmev, Demo Clients, Demo Clients
@section @code{mev}


%MANPAGE mev.1
%M .TH MEV 1 "February 1995"
%M .UC 4
%M .SH NAME
%M mev \- a program to report mouse events
%M .SH SYNOPSIS
%M .B mev
%M [
%M .I options
%M ]
%M .br
%M .SH DESCRIPTION
%M The ``mev'' program is part of the gpm package.
%M
%M The information below is extracted from the texinfo file, which is the
%M preferred source of information.

The @code{mev} program is modeled after @code{xev}. It prints to @code{stdout} the
console events it gets, both keyboard and mouse events.

@code{mev}'s default behaviour is to get anything, but command line switches
can be used to set the various fields in the @code{Gpm_Connect} structure, in
order to customize the program's behaviour. I'm using @code{mev} to
handle mouse events to @code{emacs} @xref{Emacs Support}.

Command line switches for @code{mev} are the following:

@table @code
@item -C @var{number}
	Select a virtual console to get events from.
	This is intended to be used for debugging.

@item -d @var{number}
	Choose a default mask. By default the server gets
	any events not belonging to the event mask. The mask can be
	provided either as a
	decimal number, or as a symbolic string.

@item -e @var{number}
	Choose the event mask. By default any event
	is received. The mask can be provided either as a
	decimal number, or as a symbolic string.

@item -E
	Enter emacs mode. In emacs mode events are reported as
	lisp forms rather than numbers. This is the format used by the
	t-mouse package within emacs.

@item -f
        Fit events inside the screen before reporting them. This options
        re-fits drag events, which are allowed to exit the screen border,
        @xref{Margins}.
@item -i
	Interactive. Accepts input from @code{stdin} to change connection
	parameters.

@item -m @var{number}
	Choose the minimum modifier mask. Any event with
	fewer modifiers will not be reported to @code{mev}. It defaults to 0.
	The mask must be provided either as a
	decimal number, or as a symbolic string.

@item -M @var{number}
	Choose the maximum modifier mask. Any event with
	more modifier than specified will not be reported to @code{mev}.
	It defaults to @code{\~0}, i.e. all events are received.
	The mask must be provided either as a
	decimal number, or as a symbolic string.

@item -p
        Requests to draw the pointer during drags. This option is used
        by emacs to avoid invoking @t{ioctl()} from lisp code.
@end table

When the arguments are not decimal integers, they are considered lists
of alphanumeric characters, separated by a single non-alphanumeric
character. I use the comma ``@code{,}'', but any will do.

Allowed names for events are @samp{move}, @samp{drag}, @samp{down} or
@samp{press}, @samp{up} or @samp{release}, @samp{motion} (which is both
@samp{move} adn @samp{drag}), and @samp{hard}.

Allowed names for modifiers are @samp{shift}, @samp{leftAlt},
@samp{rightAlt}, @samp{anyAlt} (one or the other), @samp{control}.

When the @samp{-i} switch is specified, @code{mev} looks at its standard input as
command lines rather than events. The input lines are parsed, and the
commands @samp{push} and @samp{pop} are recognized.

The @samp{push} command, then, accepts the options @samp{-d}, @samp{-e}, @samp{-m}
and @samp{-M}, with the same meaning described above. Unspecified options
retain the previous value and the resulting masks are used to reopen
the connection with the server. @samp{pop} is used to pop the connection
stack. If an empty stack is popped the program exits.

The only other commands recognized are @samp{info}, used to return the
stack depth, and @samp{quit} to premautrely terminate the program.

@ignore
.SH AUTHOR
Alessandro Rubini <rubini@ipvvis.unipv.it>

.SH FILES
.nf
/var/run/gpmctl The socket used to connect to gpm.
.fi

.SH SEE ALSO
.nf
gpm(1)      The mouse server
gpm-root(1) An handler for Control-Mouse events.

.fi
The info file about `gpm', which gives more complete information and
explains how to write a gpm client.

@end ignore
%MANPAGE END

%==========================================================================
@node sample/rmev, Emacs Support, mev, Demo Clients
@section @code{sample/rmev}

@t{rmev} is a reduced version of @t{mev}, but it is designed to be as
portable as possible. It uses a subset of the capabilities of @t{libgpm.a},
but works smoothly on both xterm and the Linux console. It is distributed
with @t{gpm} to show how a curses based application can support the mouse
with a small effort. Most of the xterm decoding is by Janne Kukonlehto.
@xref{Xterm}.

%==========================================================================
@node Emacs Support, gpm-root, sample/rmev, Demo Clients
@section Emacs Support

Emacs support is quite complete as of 0.14.  The enclosed file
@code{t-mouse.el}, also available in byte-compiled form, is used to pass
mouse events to emacs.  @code{t-mouse.elc} is installed in the
@code{lib/emacs/site-lisp} directory of the install tree
(by default @code{/usr}).

Events with modifiers other than Meta are not managed by the library.
Mouse-only and meta-mouse events are passed to the lisp program, which
converts them to be similar to X mouse events inside emacs. Actions are
then invoked through a local keymap.

In my own environment I can use mouse-only and meta mouse within emacs,
shift-mouse to run selection and control-mouse to run @t{gpm-root}.
@xref{gpm-root}.

I suggest to put the following form in your own @code{.emacs} file, to 
avoid loading @code{t-mouse} when you aren't working on the Linux console:

@lisp
(if (and (string-match ".*-linux" system-configuration)
         (or (string-match "linux" (getenv "TERM"))
             (string-match "con.*" (getenv "TERM"))))
    (load-library "t-mouse"))
@end lisp

Mouse events are dispatched through the keymap @code{t-mouse-keymap},
which tries to mimick the behaviour of emacs under X.

The scrollbar sits on the last column of the screen, though it is not
visible.  When you click on the last column, a scroll-bar action is taken.
If this annoys you, please let me know.

If you kill the @file{gpm} server, Emacs won't respond to mouse events
any more. If the server is then restarted, you can invoke `@t{M-x
t-mouse-run}' to restart mouse responsiveness in the editor.

The keymap is configured to handle the following events:

@table @code
@item down-mouse-1
        Jumps to the location of the click, setting the mark.

@item drag-mouse-1
        Drags the emacs pointer to follow your mouse. The mouse cursor
        is displayed as well.

@item mouse-1
        At mouse release, the cursor flashes to the mark (where the
        button was pressed), and point remains at the release location.
        The region remains set, though emacs doesn't allow highlighting
        while in text mode. If no drag happened, button release has no
        effect.

@item down-mouse-2
        This event yanks the top item in the @code{kill-ring}, like the
        key-press of @code{C-y}.

@item down-mouse-3
        Sets point. This can be used after a button-1 event to set the region
        without dragging.

@item double-mouse-1
        Sets the region to a single word, or to all the words surrounding
        the region dragged on. The value of @t{t-mouse-word-syntax} is
        used to tell which syntax classes are considered to be part
        of a word (default ``@t{"w_"}'').

@item triple-mouse-1
        Sets the region to a single line, or to all the lines surrounding
        the region dragged on.

@item double-mouse-3
        Kills the region.

@item mode-line mouse-1
        Selects the window.

@item mode-line drag-mouse-1
        Changes the size of the current window to track the mouse.

@item mode-line mouse-2
        Expands the window to the whole frame.

@item mode-line mouse-3
        Deletes the window.

@item mode-line M-mouse-2
        Splits the window horizontally.

@item mode-line M-mouse-3
        Splits the window vertically

@item vertical-line drag-mouse-1
        Changes the size of the current window to track the mouse.

@item vertical-line mouse-2
        Splits the window horizontally

@item vertical-line mouse-3
        Splits the window horizontally

@item scroll-bar down-mouse-1
        Moves the line at the level where you click up to the top of the
        window. By clicking repeatedly in the same place, you
        can scroll by the same distance over and over.

@item M-down-mouse-1
        Meta-mouse on the window acts in the same way as the scrollbar.

@item scroll-bar down-mouse-2
        This does nothing (jumping has proven bad, due to lack of a visible
        scrollbar on screen).

@item scroll-bar drag-mouse-2
        Dragging on the scroll-bar causes the buffer to scroll. The amount
        of scrolling is controlled by the X position of the mouse, in order
        to overcome the coarse granularity of the scroll-bar. In other words,
        horizonatal motion controls the vertical resolution, while vertical
        motion causes actual scrolling. The maximum vertical resolution is
        such that dragging from top to bottom of window can scan the whole
        buffer.

@item M-drag-mouse-2
        Meta-mouse on the window acts in the same way as the scrollbar.
        This means taht you can use the low-resolution scrollbar without
        grabbing the bar on the right and then lowering the resolution.

@item scroll-bar down-mouse-3
        Moves the line at the top of the window down to the level where
        you click. By clicking repeatedly in the same place, you
        can scroll by the same distance over and over.

@item M-down-mouse-3
        Meta-mouse on the window acts in the same way as the scrollbar.

@end table

%==========================================================================
@node gpm-root, hltest, Emacs Support, Demo Clients
@section The ``gpm-root'' program

%MANPAGE gpm-root.1
%M .TH GPM-ROOT 1 "February 1995"
%M .UC 4
%M .SH NAME
%M gpm-root \- a default handler for gpm, used to draw menus on
%M the root window
%M
%M .SH SYNOPSIS
%M .B gpm-root
%M [
%M .I options
%M ]
%M .br
%M .SH DESCRIPTION

The program @t{gpm-root} is designed to handle Control-Mouse events to
draw menus on the background of the current tty. The actual menus
are described by a configuration file in the user's home directory.

Please note that @t{gpm-root} needs to run with Linux 1.1.73 or
newwer, because previous kernels lack some screen handling capabilities
required by the program.

The program uses the files @t{/dev/vcs*} to draw to the console screen.
These are available only from kernel 1.1.81 onward. If you miss those
device nodes, you should create them using @t{create_vcs} in the
distribution directory. The tool won't run with kernels older than 1.1.81,
because they lacked a full screen dump/restore capability.

Available command line options are the following:

@table @code
@item -m @var{number}
        Choose the modifier to use (by default: control). The modifier
        can be provided either as a number or as a symbolic string.
        Allowed strings are ``shift'', ``anyAlt'', ``leftAlt'',
        ``rightAlt'', ``control''.

@item -u
        Deny using user-specific configuration files. With this
        option on, only @t{/etc/gpm-root.conf} will be used as a source
        of configuration information. This option
        is intended for those system administrators who fear security could
        be broken by this daemon. Thigs should be sufficiently secure, but
        if you find a hole please tell me about it.
@end table

Each time a menu is drawn, the configuration file is reparsed if it has
changed. This allows modification of personal setup without reinvoking
the daemon.

%M The actual configuration file is better introduced by looking at your
%M `@t{/etc/gpm-root.conf}.
%M
%MSKIP

The actual configuration file is better introduced by an example:

@lisp
# sample configuration file for gpm-root
# edit it to suit your taste

button 2 @{
  name "system status"
  foreground red
  background black
  border yellow
  head bright yellow

  ""          f.nop
  "load: "    f.load
  "free:"     f.free
  "---------" f.nop
  "disk usage" f.bgcmd  "du | sort -rn > /tmp/du"
@}

button 3 @{
  name "jump"

  foreground black
  background red
  border bright yellow
  head bright yellow

  "tty1"  f.jptty  "1"
  "tty2"  f.jptty  "2"
  "tty3"  f.jptty  "3"
  "tty4"  f.jptty  "4"
  "tty5"  f.jptty  "5"
  "tty6"  f.jptty  "6"
    ""        f.nop
    "more of them..." @{
          "tty 17" f.jptty  "17"
          @}
 @}
@end lisp
%M .fi

The syntax for the file won't be described here, being it quite apparent
from the example above. Blanks and newlines are unused in parsing the
file, and the layout of the file is free. Comments are allowed in the
file: any hash mark (`@t{#}') found at the beginning of the line or
after white space makes the parser discard anything up to the next
line. To insert quotes (@t{"}) in strings precede them with a backslash.

Note that recursive menus are allowed, to any level of recursion.

Keywords belong to three groups: the ``button'' keyword, the cfg
keywords and the action keywords. They are all described in the table
below:

@table @code
@item button @var{number} @var{menu}
        The ``button'' keyword is used to introduce a menu. It is
        followed by the number of the relevant button (1=left,
        2=middle, 3=right), an open brace, a menu and a closed brace.
        A menu is made up of cfg statements, followed by
        action statements. Cfg statements can come in any order,
        while the order of action statements tells the actual order
        in which actions will appear on the screen, top to bottom.
@end table

The following statements belong to the cfg set.

@table @code
@item name @var{string}
        If the ``name'' keyword is present, the specified
        string will be used as the name for the current menu.

@item background @var{color}
        This statements is used to specify the
        background color to be used in the current menu. The color
        can be specified with one of the eight canonical strings ``black'',
        ``red'', ``cyan'' etc. The background defaults to black.

@item foreground @var{color}
        This statements is used to specify the
        foreground color for menu items. Its value defaults to ``white''.
        An optional ``bright'' keyword can appear before the actual color.

@item border @var{color}
        ``border'' is used to specify the
        border color for the menu. Its value defaults to ``white''.
        An optional ``bright'' keyword can appear before the actual color.

@item head @var{color}
        ``head'' is used to specify the
        foreground color for the title of the menu. Its value defaults
        to ``white''.
        An optional ``bright'' keyword can appear before the actual color.
@end table

The following statements belong to the `action' set.

@table @code
@item @var{string} f.fgcmd @var{cmdstring}
        When the mouse button is
        released above the corresponding menu item, the `cmdstring' is
        pasted in the keyboard queue of the current console. This is
        not yet implemented.

@item @var{string} f.bgcmd @var{cmdstring}
	When the mouse button is released above the
        corresponding menu item, a shell (@t{/bin/sh}) is forked to
        execute the specified command, with @t{stdin}
        connected to @file{/dev/null}, and @t{stdout}, @t{stderr} connected
        to the active console.

@item @var{string} f.jptty @var{ttynumber}
        When the mouse button is
        released above the corresponding menu item, the console is
        switched to the one specified. The `ttynumber' must be specified
        as a string. Any tty can be reached this way, even those which are
        not accessible via the keyboard.

@item @var{string} f.mktty @var{ttynumber}
        When the mouse button is
        released above the corresponding menu item, an unused console is
        selected, and /sbin/agetty is executed in it. The current console
        is switched to the newly opened console. I use this command to save
        kernel memory by opening a single console through @file{/etc/inittab}
        and requesting the others only when i need to login.

@item @var{string} @{ @var{Whole-menu}
        A menu can directly follow the lable string.
        When the mouse pointer leaves the menu frame at the level of `string',
        a second menu is posted on screen.

@item @var{string} f.lock
        When the mouse button is
        released above the corresponding menu item, the keyboard and the
        screen are locked, and only the locking user or the superuser
        can unlock them. This is not yet implemented.

@item @var{string} f.load
        The current loadavg when the menu is posted is concatenated to `string'
        to build the actual message displayed on screen. Nothing happens at
        button release.

@item @var{string} f.free
        The free memory and swap when the menu is posted is concatenated
        to `string'
        to build the actual message displayed on screen. Nothing happens at
        button release.

@item @var{string} f.time
        The current time is formatted with strftime(3), according to
        `string'. The resulting string is
        the actual message displayed on screen. Nothing happens at
        button release.

@item @var{string} f.pipe @var{cmdline}
        When the mouse pointer leaves the menu frame at the level of `string',
        a message box is posted on screen showing the last ten lines
        of the output of `cmdline'. The `cmdline' is executed
        by @file{/bin/sh}. This is not yet implemented.
    
        
@item @var{string} f.nop
        This does nothing, it only displays `string' on the menu.
@end table

The @t{HOME}, @t{LOGNAME} and @t{USER} environment variables are setup
to the values for the invoking user before spawning an external
process (`f.bgcmd', `f.pipe'). The current directory is always @t{/}.

%M .SH BUGS

Known bugs have been fixed. In particular, if you invoke @t{gpm-root}
right after @t{gpm}, it will delasy a few seconds before trying to connect
to the daemon.

@ignore
.SH AUTHOR
Alessandro Rubini <rubini@ipvvis.unipv.it>

.SH FILES
.nf
/var/run/gpmctl     The socket used to connect to gpm.
/etc/gpm-root.conf  The default configuration file.
$(HOME)/.gpm-root   The user configuration file.
/dev/vcs*           Virtual Console Screens
.fi

.SH SEE ALSO
.nf
gpm(1)

.fi
The info file about `gpm', which gives more complete information and
explains how to write a gpm client.

@end ignore
%MANPAGE END

%==========================================================================
@node hltest, mouse-testhltest, gpm-root, Demo Clients
@section @t{hltest}

High-level test is a simple sample application using the high-level
library. It implements something like a window manager for text windows,
though it is small and unuseful.

The application is meant to be read by programmers trying to use the
high-level library. It is equipped with event reporting to help
in understanding the internal workings.

%==========================================================================
@node mouse-testhltest,  , hltest, Demo Clients
@section @t{mouse-test}

This experimental and incomplete application tries to help in detecting
which protocol does your mouse speak. It is able to detect MouseMan
devices, and to choose between "-t ms" (three-buttons aware) and
"-t bare" old two-buttons-only serial mice.

I know the application is buggy, but I only own one mouse device.
If you are interested in this application, just call me and awake me
from my laziness.

%##########################################################################
@node Function Index,  , Demo Clients, Top
@unnumbered API Index

@printindex fn

%@iftex
%@unnumbered Table of Contents
%@contents
%@end iftex


@bye

/*
 * This is because Linus uses 4-wide tabstops,
 * forcing me to use the same default to manage kernel sources
 */

/* Local Variables: */
/* tab-width:8      */
/* End:             */
