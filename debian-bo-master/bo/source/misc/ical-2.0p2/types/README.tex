% Copyright (c) 1995 by Sanjay Ghemawat
% This document is intended to be processed by "glatex" so that embedded
% code fragments can be turned into LaTeX code.  If you do not have access
% to "glatex" and "grind", replace the "%%%grind" directives with
% "\verbatim" commands.

\documentstyle[twocolumn,times]{article}

\catcode`\"=\active%
\def"#1"{{\tt #1}}

\textwidth=10.2in
\textheight=7.4in
\headheight=.3in
\headsep=0in
\footheight=.5in
\footskip=.6in
\oddsidemargin=-0.6in
\evensidemargin=\oddsidemargin
\topmargin=-.8in
\columnwidth=0.5in
\columnsep=0.2in
\columnseprule=0.1ex
\special{papersize=11in,8.5in}

\title{Some Useful Types}
\author{Sanjay Ghemawat}
\date{\today}

\begin{document}

\maketitle

\noindent This document describes some useful C++ classes and routines.

\section{Generic Resizable Arrays}

"Array.h" provides a generic resizable array built out of preprocessor
macros.  These arrays can be stack allocated as long as you are
careful that they do not get copied excessively.  (One reason for
stack allocation of arrays is so that you can use the nice "[]"
syntactic sugar.)

You can declare and implement an array of elements of a specific type
by using the macros "declareArray" and "implementArray".
Example (an array of integers) ---
%%%grind -l c++
declareArray(IntList, int)
implementArray(IntList, int)
%%%grind
Arrays grow and shrink at the high end.  The low end always has index
0.

\subsection{Constructor and Destructors}

%%%grind -l spec
Array()
    effects    Creates empty array

Array(int predict)
    requires   predict >= 0
    effects    Creates empty array.  Extra storage is preallocated
               under the assumption that the array will be grown
               to contain predict elements.  This constructor form
               helps avoids unnecessary copying.

Array(T const* x, int count)
    requires   count >= 0 and x is a pointer to at least count elements.
    effects    creates an array with a copy of the count elements pointed
               to by x.  This constructor is useful for initializing an
               array from a C++ builtin array.

Array(Array const& x)
    effects    creates an array that is a copy of x.

Array(T x, int count)
    requires   count >= 0
    effects    creates an array with count copies of x.

~Array()
    effects    releases all storage for the array.
%%%grind

\subsection{Operations}

%%%grind -l spec
Array& operator=(Array const& x)
    effects    copies the contents of x into *this.

T& operator[](int index) const
    requires   index >= 0 and index < size().
    effects    returns a reference to the indexth element in *this.
               Therefore, you can say things like --
                    Array a;
                    ...
                    a[i] = a[i+1];

T& slot(int index) const
    requires   index >= 0 and index < size().
    effects    returns a reference to the indexth element in *this.
               This operation is identical to operator [].  It is
               just more convenient to use with an Array*.

                    Array* a;
                    ...
                    a->slot(i) = a->slot(i+1);

int  size() const
    effects    returns the number of elements in *this.

T& high() const
    effects    returns a reference to the last element in *this.

void append(T v)
    modifies   *this
    effects    grows array by one by adding v to the high end.

void append(T v, int n)
    requires   n >= 0
    modifies   *this
    effects    grows array by n by adding n copies of v to the high end.

void concat(T const* x, int n)
    requires   n >= 0, x points to at least n Ts.
    modifies   *this
    effects    grows array by n by adding the n elements pointed to by x.

void concat(Array const& x)
    modifies   *this
    effects    append the contents of x to *this.

T remove()
    requires   array is not empty
    modifies   *this
    effects    removes last element and return a copy of it.

void remove(int num)
    requires   num >= 0 and array has at least num elements
    modifies   *this
    effects    removes the last num elements.

void clear()
    modifies   *this
    effects    removes all elements from *this.

void reclaim()
    effects    reclaim unused storage.

T* as_pointer() const
    requires   returned value is not used across changes in array size
               or calls to reclaim.
    effects    returns a pointer to the first element in the array.
               The returned pointer is useful for interacting with
               code that manipulates builtin arrays of T.
%%%grind

\section{Hash Functions}

"hashfuncs.h" and "hashfuncs.C" contain a number of useful hash functions.
All of these hash functions map from a particular type to a non-negative
integer.

%%%grindfile hashfuncs.h

\section{Generic Sets}

"ohashset.h" provides generic sets built on hash tables.
You can use the macros "declareOpenHashSet" and "implementOpenHashSet"
to use these sets.
These macros expect four arguments --- the name of set type being declared
or implemented, the type of set elements, a hash function on set elements,
and a comparison function for set elements.
Example (a set of integers) ---

%%%grind -l c++
#include "hashfuncs.h"
#include "ohashset.h"

declareOpenHashSet(IntSet,int,hash_int,cmp_int)
implementOpenHashSet(IntSet,int,hash_int,cmp_int)
%%%grind

\subsection{Constructors and Destructors}

%%%grind -l c++
Set()
     // effects   Create empty set.

Set(int predict_count)
     // requires  predict_count >= 0
     // effects   Create empty set.
     //
     // The created set will be structured to allow fast growth to
     // predict_count entries.

Set(Set const& s)
     // effects   Create new set with the same contents as "s".

Set& operator=(Set const& s)
     // effects   Replace contents of set with the contents of "s".

~Set()
     // effects   Destroy storage for set.
%%%grind

\subsection{Operations}

%%%grind -l c++
int size() const
    // effects   Return number of elements in set.

bool contains(T t) const
    // effects   Return true iff set contains t

void insert(T t)
    // modifies  this
    // effects	 t is added to this if this did not contain it already.

void remove(T t)
    // modifies  this
    // effects	 Remove t if set contains t.

void clear()
    // modifies  this
    // effects	 All elements are removed from this.

void check()
    // effects   Check various rep invariants.  Die on error.
%%%grind

\subsection{Iteration}

You can iterate over the elements of a set type "Set" with a generator
object of type "Set\_Elements".
%%%grind -l c++
Set_Elements(Set const* table)
    // requires  table is not modified for the lifetime of the generator
                 except via the "del" operator below.
    // effects   Generate each element in table, exactly once.
    //	         Elements may be generated in arbitrary order.

bool ok() const
    // effects   Returns true iff generator can produce more elements.

T get() const
    // requires  "ok()"
    // effects   Return the current element.

void del();
    // requires "get" is not called until generator is advanced.
    // modifies the table
    // effects  Remove the current element from the table.

void next()
    // requires  "ok()"
    // modifies  "this"
    // effects   Consumes the current element.
%%%grind
Example ---
%%%grind -l c++
declareOpenHashSet(Set,int,...)
...
Set* s = new Set;
...
for (Set_Elements i = s; i.ok(); i.next())
    printf("%d\n", i.get());
%%%grind

\section{Generic Maps}

"ohashmap.h" provides generic maps built on hash tables.
You can use the macros "declareOpenHashMap" and "implementOpenHashMap"
to use these maps.
These macros expect five arguments --- the name of map type being declared
or implemented, the type of keys, the type of values bound to keys,
a hash function on keys, and a comparison function for keys.
Example (a map from integers to strings) ---

%%%grind -l c++
#include "hashfuncs.h"
#include "ohashmap.h"

declareOpenHashMap(Map,int,char const*,hash_int,cmp_int)
implementOpenHashMap(Map,int,char const*,hash_int,cmp_int)
%%%grind

\subsection{Constructors and Destructors}

%%%grind -l c++
Map()
     // effects   Create empty map.

Map(int predict_count)
     // requires  predict_count >= 0
     // effects   Create empty map.
     //
     // The created map will be structured to allow fast growth to
     // "predict_count" entries.

Map(Map const& m)
     // effects   Create new map with the same contents as "m".

Map& operator=(Map const& m)
     // effects   Replace contents of map with the contents of "m".

~Map()
     // effects   Destroy storage for map.
%%%grind

\subsection{Operations}

%%%grind -l c++
int size() const
    // effects   Return number of bindings in map.

bool contains(Key k) const
    // effects   Return true iff map has a binding for "k".

bool fetch(Key k, Val& v) const
    // modifies  "v"
    // effects   If map has binding for "k", "post(v) =" value bound to "k"
    //		 and returns TRUE.  Else "post(v) = pre(v)" and returns FALSE.

Val fetch(Key k) const
    // requires  Map contains binding for "k".
    // effects	 Return value from binding for "k".

void store(Key k, Val v)
    // modifies  "this"
    // effects	 Binding "(k->v)" is added to "this". Any previous bindings for
    //		 "k" are removed.

void remove(Key k)
    // modifies  "this"
    // effects	 Any binding for "k" is removed from "this".

void clear()
    // modifies  "this"
    // effects	 All bindings are removed from "this".

void check()
    // effects   Check various rep invariants.  Die on error.
%%%grind

\subsection{Iteration}

You can iterate over the bindings in a map type named "Map" with a generator
object of type "Map\_Bindings".
%%%grind -l c++
Map_Bindings(Map const* table);
    // requires  "table" is not modified for the lifetime of the generator
                 except via the "del" operator below.
    // effects   Generate each binding in "table", exactly once.
    //	         Bindings may be generated in arbitrary order.

bool ok() const
    // effects   Returns true iff generator can produce more bindings.

Key key() const
    // requires  "ok()"
    // effects   Return the key for the current binding.

Val val() const
    // requires  "ok()"
    // effects   Return the value for the current binding.

void del();
    // requires "get" is not called until generator is advanced.
    // modifies the table
    // effects  Remove the current binding from the table.

void next()
    // requires  "ok()"
    // modifies  "this"
    // effects   Consumes the current binding.
%%%grind
Example ---
%%%grind -l c++
declareOpenHashMap(Map,int,char const*,...)
...
Map* m = new Map;
...
for (Map_Bindings i = s; i.ok(); i.next())
    printf("%d: %s\n", i.key(), i.val());
%%%grind

\end{document}
