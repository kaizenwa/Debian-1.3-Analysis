
#include "object.h"
#include "player.h"

#define LOCAL_PLAYER	0x00
#define UDP_PLAYER	0x01
#define MODEM_PLAYER	0x02

void
Player::Remote(int connecttype)
{
	ConnectType = connecttype;
}
int
Player::Remote(void)
{
	return(ConnectType);
}
void
Player::NetFD(int netfd)
{
	Netfd = netfd;
}
int
Player::NetFD(void)
{
	return(Netfd);
}
void
Player::NetAddr(struct sockaddr_in *addr)
{
	myaddr = addr;
}
struct sockaddr *
Player::NetAddr(void) {
	return((struct sockaddr *)myaddr);
}
void
Player::QueueKey(unsigned char Op, unsigned char Type)
{
	/* Drop keys on a full buffer (assumed never to really happen) */
	if ( OutLen >= (BUFSIZ-2) )
		return;

//fprintf(stderr, "Queued key 0x%.2x for frame %d\r\n", Type, NextFrame);
	OutBuf[OutLen++] = Op;
	OutBuf[OutLen++] = Type;
}
void
Player::AssembleFrame(void)
{
	/* Remote Players don't have outbound broadcast packets */
	if ( Remote() )
		return;

	/* Set the next frame number, seed, etc */
}
void
Player::SendFrame(int whom)
{
	switch (gPlayers[whom]->Remote()) {
		case LOCAL_PLAYER:
			/* Don't need to broadcast to myself */
			break;
		case UDP_PLAYER:
			if ( sendto(gPlayers[whom]->NetFD(), (char *)OutBuf,
				OutLen, 0, gPlayers[whom]->NetAddr(),
					sizeof(struct sockaddr) != OutLen) {
				/* Clear errno here so select() doesn't fail */
				errno = 0;
			}
			break;
		case MODEM_PLAYER:
			/* FIXME!  Encapsulate the packet somehow :) */
			if ( write(gPlayers[whom]->NetFD(), OutBuf, OutLen)
								!= OutLen ) {
				/* Clear errno here so select() doesn't fail */
				errno = 0;
			}
			break;
		default:
			fprintf(stderr,
				"Unknown connection type for player %d\n",
								whom);
			break;
	}
	return;
}
