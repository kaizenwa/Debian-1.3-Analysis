
#ifndef _stack_template_
#define _stack_template_

#include <stdlib.h>

template <class ITEM>
class Stack {

public:
	Stack(int chunksize) {
		size = ChunkSize = chunksize;
		base = new ITEM[size];
		height = 0;
	}
	virtual ~Stack() {
		delete[] base;
	}

	int  Size(void) {
		return(height);
	}
	void Add(ITEM *item) {
		if ( height == size )
			Expand();
		memcpy(&base[height++], item, sizeof(ITEM));
	}
#ifdef COPY_ITEM
	void Pop(ITEM *item) {
		if ( ! height ) {
			memset(item, 0, sizeof(ITEM));
			return;
		}
		memcpy(item, &base[--height], sizeof(ITEM));
	}
#else	/* In the interest of speed, return a pointer to the item */
	ITEM *Pop(void) {
		return (height ? &base[--height] : (ITEM *)0);
	}
#endif
	/* Implement a QuickSort on a stack!  Wierd, but true. :) */
	void Sort(int (*cmp_func)(ITEM *item1, ITEM *item2)) {
		qsort(base, height, sizeof(ITEM), 
				(int (*)(const void *, const void *))cmp_func);
	}
	/* "dumpfunc()" has direct access to the stack items */
	// This function isn't really used.
	void Dump(void (*dumpfunc)(ITEM *)) {
		for ( int x=height; x; )
			(*dumpfunc)(&base[--x]);
	}
	void Flush(void) {
		height = 0;
	}

protected:
	int   ChunkSize;
	ITEM *base;
	int   size;
	int   height;
	
	void Expand(void) {
		ITEM *old_base;

		old_base  = base;
		base = new ITEM[size+ChunkSize];
		memcpy(base, old_base, size*sizeof(ITEM));
		size += ChunkSize;
		delete[] old_base;
	}
};

#endif /* _stack_template_ */
