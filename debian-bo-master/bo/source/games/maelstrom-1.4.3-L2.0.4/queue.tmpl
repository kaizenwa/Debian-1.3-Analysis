#include <stdlib.h>

/* Ugh, I want to implement a queue as a stack.  But....

   Here's what we do:

	Have a "bottom" to the stack, and remove items from the bottom.
	If we reach the top, shift all items down, and we keep a stack
	of pointers to items, rather than the items themselves.
*/

template <class ITEM>
class Queue {

public:
	/* We don't check, but chunksize must be >= 1 */
	Queue(int chunksize) {
		size = ChunkSize = chunksize;
		base = new ITEM* [size];
		for ( int i=0; i<size; ++i )
			base[i] = new ITEM;
		bottom = height = 0;
	}
	virtual ~Queue() {
		for ( int i=0; i<size; ++i )
			delete base[i];
		delete[] base;
	}

	int  Size(void) {
		return(height-bottom);
	}
	void Push(ITEM *item) {
		if ( height == size )
			Expand();
		memcpy(base[height++], item, sizeof(ITEM));
	}
	void Pull(ITEM *item) {
		if ( bottom == height ) {
			memset(item, 0, sizeof(ITEM));
			return;
		}
		memcpy(item, base[bottom++], sizeof(ITEM));
	}
	/* "dumpfunc()" has direct access to the stack items */
	// This function isn't really used.
	void Dump(void (*dumpfunc)(ITEM *)) {
		for ( int x=bottom; x<height; )
			(*dumpfunc)(base[++x]);
	}
	void Flush(void) {
		bottom = height = 0;
	}

protected:
	int    ChunkSize;
	ITEM **base;
	int    size;
	int    bottom, height;
	
	void Expand(void) {
		ITEM **old_base;
		int    i;

		/* If bottom is wedged against top, we have a free chunk. :) */
		if ( bottom == height ) {
#ifdef DEBUG_QUEUE
printf("Reclaimed existing Queue space!\r\n");
#endif
			bottom = height = 0;
			return;
		}
#ifdef DEBUG_QUEUE
printf("Copied existing Queue pointers\r\n");
#endif

		/* Otherwise, allocate some more memory */
		old_base = base;
		base = new ITEM* [size+ChunkSize];
		memcpy(base, old_base, size*sizeof(ITEM*));
		i = size-1;
		for ( size += ChunkSize; i<size; ++i )
			base[i] = new ITEM;
		delete[] old_base;
	}
};

