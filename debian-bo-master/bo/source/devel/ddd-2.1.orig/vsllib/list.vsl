// $Id: list.vsl,v 1.4 1997/04/25 06:44:33 zeller Exp $ -- Listen-Makros

// Copyright (C) 1993 Technische Universitaet Braunschweig, Germany.
// Written by Andreas Zeller <zeller@ips.cs.tu-bs.de>.
// 
// This file is part of the DDD Library.
// 
// The DDD Library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
// 
// The DDD Library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Library General Public License for more details.
// 
// You should have received a copy of the GNU Library General Public
// License along with the DDD Library -- see the file COPYING.LIB.
// If not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
// 
// DDD is the data display debugger.
// For details, see the DDD World-Wide-Web page, 
// `http://www.cs.tu-bs.de/softech/ddd/',
// or send a mail to the DDD developers at `ddd@ips.cs.tu-bs.de'.

#include <std.vsl>

// Version
list_version() = "$RCSfile: list.vsl,v $ $Revision: 1.4 $";

// Fuer LISP-Fans
nil = [];

// Tester
isatom([]) = false;
isatom([_ : _]) = false;
isatom(_) = true;
islist(x) = not isatom(x);

// Kopf und Restliste
// car([1, 2, 3]) = 1, cdr([1, 2, 3]) = [2, 3]
car([head : _]) = head;	// Lisp-Notation
cdr([_ : tail]) = tail;
head(...) = car(...);
tail(...) = cdr(...);

// Element an Liste *hinten* anhaengen
// append([1, 2, 3], 4) = [1, 2, 3, 4]
append(list, elem) = list :: [elem];

// Pruefen, ob Element in Liste
// member(1, [1, 2, 3]) = true
member(_, []) = false;
member(elem, [head : tail]) = 
	(elem = head) or member(elem, tail);

// Praefix- und Suffix-Eigenschaft
// prefix([1], [1, 2]) = true, suffix([3], [1, 2]) = false.
prefix([], _) = true;
prefix(_, []) = false;
prefix([h1 : t1], [h2 : t2]) =
	(h1 = h2) and prefix(t1, t2);

suffix([], _) = true;
suffix(_, []) = false;
suffix(list, [h2 : t2]) = 
	(list = [h2 : t2]) or suffix(list, t2);

// Untermenge
// sublist([2, 2], [1, 2, 2, 3]) = true
sublist(_, []) = false;
sublist(list, [h2 : l2]) =
	prefix(list, [h2 : l2]) or sublist(list, l2);

// Laenge
// length([1, 2, 3]) = 3
length([]) = 0;
length([_ : tail]) = 1 + length(tail);

// Element via Index
// elem([4, 5, 6], 0) = 4
elem([head : _], 0) = head;
elem([_ : tail], index) = elem(tail, index - 1);

// Element suchen, Index zurueckgeben
// pos(4, [1, 2, 4]) = 2
pos(elem, [head : tail]) = 
	if head = elem then 0 else 1 + pos(elem, tail) fi;

// Letztes Element
// last([4, 5, 6]) = 6
last([head]) = head;
last([_ : tail]) = last(tail);

// Invertieren
// reverse([3, 4, 5]) = [5, 4, 3]
reverse([]) = [];
reverse([head : tail]) = append(reverse(tail), head);

// Loeschen
// alle Elemente
// delete([4, 5, 5, 6], 5) = [4, 6]
delete([], _) = [];
delete([head : tail], elem) = 
	if elem = head 
	then delete(tail, elem)					// head entfernen
	else [head : delete(tail, elem)]
	fi;

// das erste Element
// select([4, 5, 5, 6], 5) = [4, 5, 6]
select([], _) = [];
select([head : tail], elem) = 
	if elem = head 
	then tail								// head entfernen
	else [head : select(tail, elem)]
	fi;

// "Flache" Liste erzeugen
// flat([[3, 4], [[5], [6]]]) = [3, 4, 5, 6]
flat([]) = [];
flat([head : tail]) = flat(head) :: flat(tail);
flat(x) = [x];


// Sortieren (nach Groesse)
// sort([7, 4, 9]) = [4, 7, 9]
// Quicksort-Verfahren: Liste in zwei Haelften left, right aufspalten; 
// left enthaelt alle Elemente, die < check sind, right den Rest.
// left und right getrennt sortieren und dann wieder zusammenfassen.

sort([]);
sort([x]);
sort([head : tail]);

// Vor erste Liste Element anhaengen
_sort_prepend1(elem, [list1, list2]) = [[elem : list1], list2];

// Vor zweite Liste Element anhaengen
_sort_prepend2(elem, [list1, list2]) = [list1, [elem : list2]];

// Zwei Listen und check wieder zusammenhaengen
_sort_cons3([list1, list2], check) = list1 :: [check] :: list2;

// Zwei Teillisten sortieren
_sort_sort2([list1, list2]) = [sort(list1), sort(list2)];

// Liste gemaess check in zwei Teillisten aufspalten
_sort_split([], _) = [[], []];
_sort_split([head : tail], check) =
	if (head <= check)
	then _sort_prepend1(head, _sort_split(tail, check))
	else _sort_prepend2(head, _sort_split(tail, check))
	fi;

// Sortierung selbst
_sort(list, check) = _sort_cons3(_sort_sort2(_sort_split(list, check)), check);
sort([]) = [];
sort([x]) = [x];
sort([head : tail]) = _sort(tail, head);

// Liste in Zeichenkette umwandeln (Kommanotation)
// list([4, 5, 6]) = "[4, 5, 6]"
_list([head]) = head;
_list([head : tail]) = head & ", " & _list(tail);
_list(atom) = atom;
list([]) = "[]";
list(l) = "[" & _list(l) & "]";
