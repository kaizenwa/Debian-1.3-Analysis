<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Defining Interfaces</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_1.html">previous</A>, <A HREF="manual_3.html">next</A> section.<P>
<H1><A NAME="SEC20" HREF="manual_toc.html#SEC20">Defining Interfaces</A></H1>
<P>
Module interfaces may be defined in either the Object Management Group's CORBA
OMG IDL, or in ILU's native Interface Specification
Language (aka ISL).  This document describes the syntax and
semantics of ISL, and how to translate OMG IDL interfaces
into ISL; see <CITE>CORBA 2.0</CITE> for a specification of the syntax and semantics
of OMG IDL.
<P>
<H2><A NAME="SEC21" HREF="manual_toc.html#SEC21">General Syntax of ISL</A></H2>
<P>
The conventional file suffix for ISL files is <TT>`.isl'</TT>.  Some of the
ILU tools rely on the name of the file being the same as the name of the
interface defined in it, and rely on having only one interface defined in each
<TT>`.isl'</TT> file.
<P>
An ISL interface contains four kinds of statements:  the interface header,
type declarations, exception declarations, and constant declarations.  Each
statement is terminated with a semi-colon.
<P>
Many statements in ISL contain lists:  lists of the fields in a record,
the types in a union, the methods in an object type.  All lists in ISL are
terminated with an <CODE>END</CODE> keyword, and the items in the list are separated by commas.
<P>
Comments may be placed in an ISL file.  They are introduced with the character sequence
<CODE>(*</CODE>, and terminated with <CODE>*)</CODE>.  Comments nest.
<P>
<H3><A NAME="SEC22" HREF="manual_toc.html#SEC22">Identifiers</A></H3>
<P>
All identifiers that appear in ISL are alphanumeric, begin with an
alphabetic character, and may contain hyphens.<A NAME="FOOT1" HREF="manual_foot.html#FOOT1">(1)</A>  Differences in case are not sufficient to distinguish between two identifiers; however, the case of an identifier may be preserved in its mapping to a specific programming language.
<P>
All ILU type names, exception names, and constant names have two parts, an interface identifier and a local identifier.  When writing the full name, the interface identifier comes first, followed by a period, followed by the local identifier.  If the interface identifier is ommitted in a name, it defaults to the interface identifier of the most recently encountered interface header.
<P>
Interface names, type names, exception names, and constant names occur in different name spaces.  Thus is is possible to have a type and an exception with the same name.<A NAME="FOOT2" HREF="manual_foot.html#FOOT2">(2)</A>
<P>
<H3><A NAME="SEC23" HREF="manual_toc.html#SEC23">Reserved Words</A></H3>
<P>
The following words are reserved words in ISL:
<CODE>ARRAY</CODE>,
<CODE>ASYNCHRONOUS</CODE>,
<CODE>AUTHENTICATION</CODE>,
<CODE>BOOLEAN</CODE>,
<CODE>BRAND</CODE>,
<CODE>CARDINAL</CODE>,
<CODE>CHARACTER</CODE>,
<CODE>CLASS</CODE>,
<CODE>COLLECTIBLE</CODE>,
<CODE>CONSTANT</CODE>,
<CODE>DEFAULT</CODE>,
<CODE>END</CODE>,
<CODE>ENUMERATION</CODE>,
<CODE>EXCEPTION</CODE>,
<CODE>FALSE</CODE>,
<CODE>FROM</CODE>,
<CODE>FUNCTIONAL</CODE>,
<CODE>IMPORTS</CODE>,
<CODE>IN</CODE>,
<CODE>INOUT</CODE>,
<CODE>INTEGER</CODE>,
<CODE>INTERFACE</CODE>,
<CODE>LIMIT</CODE>,
<CODE>LONG</CODE>,
<CODE>METHODS</CODE>,
<CODE>OBJECT</CODE>,
<CODE>OF</CODE>,
<CODE>OPTIONAL</CODE>,
<CODE>OTHERS</CODE>,
<CODE>OUT</CODE>,
<CODE>RAISES</CODE>,
<CODE>REAL</CODE>,
<CODE>RECORD</CODE>,
<CODE>SEQUENCE</CODE>,
<CODE>SHORT</CODE>,
<CODE>SIBLING</CODE>,
<CODE>SINGLETON</CODE>,
<CODE>SINK</CODE>,
<CODE>SOURCE</CODE>,
<CODE>SUPERCLASS</CODE>,
<CODE>SUPERCLASSES</CODE>,
<CODE>SUPERTYPES</CODE>,
<CODE>TRUE</CODE>,
<CODE>TYPE</CODE>,
<CODE>TYPEID</CODE>,
<CODE>UNION</CODE>.
<P>
Reserved words may be used as identifiers, by placing them in double quotes,
but may not be used as identifiers without quoting.
<P>
Other identifiers are worth avoiding, as they may cause problems with
specific language implementations.  The identifier <CODE>t</CODE> or <CODE>T</CODE>,
for instance, causes problems with Common Lisp.
Language-specific mappings of ISL should try to avoid these
problems.
<P>
<H2><A NAME="SEC24" HREF="manual_toc.html#SEC24">Statement Syntax</A></H2>
<P>
<H3><A NAME="SEC25" HREF="manual_toc.html#SEC25">The Interface Header</A></H3>
<P>
Each interface is introduced with exactly one interface header of the form
<P>
<PRE>
<CODE>INTERFACE</CODE> <VAR>interface-name</VAR> [ <CODE>BRAND</CODE> <VAR>brand</VAR> ] [ <CODE>IMPORTS</CODE> <VAR>list-of-imported-interfaces</VAR> <CODE>END</CODE> ] <CODE>;</CODE>
</PRE>
<P>
The <VAR>interface-name</VAR> is used by various language-specific productions to
create name spaces in which the types, exceptions, and constants defined in the
interface are declared.  The optional
<VAR>list-of-imported-interfaces</VAR> is a comma-separated list of fields, each of the
form
<P>
<PRE>
<VAR>interface-name</VAR> [ <CODE>FROM</CODE> <VAR>interface-file</VAR> ]
</PRE>
<P>
where <VAR>interface-file</VAR> is the typical poorly defined string that names a file
for your operating system (in our case, UNIX).  Importing an interface allows
the current interface to mention the types, exceptions, and constants
defined in the imported interface, by referring to them as
<P>
<PRE>
<VAR>interface-name</VAR><CODE>.</CODE><VAR>type-or-value-name</VAR>
</PRE>
<P>
If the optional "FROM <VAR>interface-file</VAR>" is not specified for an imported
interface, a sensible site-dependent search policy is followed in an attempt
to locate that interface, typically looking down a path (environment variable <CODE>ILUPATH</CODE> on POSIX systems) of
directories for a file with the name <TT>`<VAR>interface-name</VAR>.isl'</TT>.
<P>
<H3><A NAME="SEC26" HREF="manual_toc.html#SEC26">Type Declarations</A></H3>
<P>
In general, a type is defined with a statement of the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <VAR>type-reference</VAR> | <VAR>construction</VAR> <CODE>;</CODE>
</PRE>
<P>
The form <CODE>TYPE <VAR>type-name</VAR> = <VAR>type-reference</VAR></CODE> is used when you want
to rename an existing type to make its usage clear or give it a name in the current interface.  A <VAR>type-reference</VAR> is
just a <VAR>type-name</VAR>, or a reference to a type name defined in another
interface: <VAR>interface-name</VAR>.<VAR>type-name</VAR>.
<P>
<H4><A NAME="SEC27" HREF="manual_toc.html#SEC27">Primitive types</A></H4>
<P>
The following type "names" are pre-defined:
<P>
<UL>
<LI>
<CODE>INTEGER,</CODE> a 32-bit signed integer value;
<LI>
<CODE>SHORT INTEGER,</CODE> a 16-bit signed integer value;
<LI>
<CODE>LONG INTEGER,</CODE> a 64-bit signed integer value;
<LI>
<CODE>CARDINAL,</CODE> a 32-bit unsigned integer value;
<LI>
<CODE>SHORT CARDINAL</CODE>, a 16-bit unsigned integer value;
<LI>
<CODE>LONG CARDINAL</CODE>, a 64-bit unsigned integer value;
<LI>
<CODE>BYTE</CODE>, an unsigned 8-bit byte value;
<LI>
<CODE>BOOLEAN</CODE>, a logical value either True or False;
<LI>
<CODE>REAL</CODE>, an IEEE 64-bit double-precision floating-point value;
<LI>
<CODE>SHORT REAL</CODE>, an IEEE 32-bit single-precision floating-point value;
<LI>
<CODE>LONG REAL</CODE>, a 128-bit quadruple-precision floating-point value;
<LI>
<CODE>CHARACTER</CODE>, a 16-bit UNICODE/IS-10646 character; and
<LI>
<CODE>SHORT CHARACTER</CODE>, an 8-bit ISO 8859-1 character code (but excluding the octet 8_000).
</UL>
<P>
There is also a special type <CODE>NULL</CODE>, which cannot be used
directly; it has a single value, NULL.
<P>
<H4><A NAME="SEC28" HREF="manual_toc.html#SEC28">Constructor overview</A></H4>
<P>
The form <CODE><CODE>TYPE</CODE> <VAR>type-name</VAR> = <VAR>construction</VAR></CODE> is used when a user needs to
define a new type.  Several simple constructors for more complex data types
are specified:
<P>
<UL>
<LI>
<CODE>ARRAY</CODE>, a fixed-length N-dimensional array of some specified type;
<LI>
<CODE>SEQUENCE</CODE>, a variable-length one-dimensional array of some specified type;
<LI>
<CODE>RECORD</CODE>, a sequence of typed fields, each of which may be of a different type;
<LI>
<CODE>UNION</CODE>, one of a set of specified types;
<LI>
<CODE>OPTIONAL</CODE>, a union with <CODE>NULL</CODE>;
<LI>
<CODE>ENUMERATION</CODE>, a type consisting of an explicitly enumerated set of values;
<LI>
<CODE>OBJECT</CODE>, an ILU object type.
</UL>
<P>
In addition, the automatically-imported interface ILU defines the
short sequence <CODE>CString</CODE> of short character.
<P>
<H4><A NAME="SEC29" HREF="manual_toc.html#SEC29">Array Declarations</A></H4>
<P>
An <CODE>ARRAY</CODE> is a fixed-length N-dimensional array of some type.  It is defined
with a declaration of the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <CODE>ARRAY</CODE> <CODE>OF</CODE> <VAR>dimension-list</VAR> <VAR>base-type-reference</VAR> <CODE>;</CODE>
</PRE>
<P>
where <VAR>dimension-list</VAR> is a comma-separated list of non-negative integers,
each integer specifying the size of a dimension of the array, and
<VAR>base-type-reference</VAR> is a <VAR>type-reference</VAR> to some other ILU type.  For example,
<P>
<PRE>
TYPE SymbolTable = ARRAY OF 400 Symbol;
TYPE Matrix3030 = ARRAY OF 30, 30 REAL;
</PRE>
<P>
The total number of elements in the array may not exceed 4294967295 (2^32-1).
<P>
<H4><A NAME="SEC30" HREF="manual_toc.html#SEC30">Sequence Declarations</A></H4>
<P>
A sequence is a variable-length one-dimensional array of some type.  It is
defined with a declaration of the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> [ <CODE>SHORT</CODE> ] <CODE>SEQUENCE</CODE> <CODE>OF</CODE> <VAR>base-type-reference</VAR> [ <CODE>LIMIT</CODE> <VAR>size</VAR> ] <CODE>;</CODE>
</PRE>
<P>
where <VAR>base-type-reference</VAR> is a <VAR>type-reference</VAR> to some other ILU type.  If the <CODE>LIMIT</CODE>
parameter <VAR>size</VAR> is used, it limits the sequences to having at most <VAR>size</VAR> elements; otherwise the sequences are limited to having at most 4294967295 (2^32-1) elements.
Use of the <CODE>SHORT</CODE> modifier is shorthand for a <CODE>LIMIT</CODE> of 65535 (2^16-1).  Use of the <CODE>LONG</CODE>
modifier is not defined for sequences.
<P>
<H4><A NAME="SEC31" HREF="manual_toc.html#SEC31">Generalized Array Declarations</A></H4>
<P>
This is a proposed language change, not yet accepted.
<P>
The existing language has a weakness: it cannot express coordinated multidimensional variable-length arrays.  Coordinated means that there is only one length per dimension, regardless of how many arrays there are at that level.  An example is a bitmap of variable height and width: all rows are the same length, and all columns are the same length.
<P>
A generalized array type is defined with a declaration of the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <CODE>ARRAY</CODE> <VAR>dim</VAR> , ... <VAR>dim</VAR> <CODE>OF</CODE> <VAR>base-type-reference</VAR> <CODE>;</CODE>
</PRE>
where each <VAR>dim</VAR> is of the form
<PRE>
<VAR>length</VAR> | [ <CODE>LIMIT</CODE> <VAR>maxlen</VAR> | <CODE>SHORT</CODE> ]
</PRE>
<P>
A dimension can be given a fixed length by simply specifying that length.  A variable-length dimension is either left blank (meaning the maximum length is 2**32-1), specified as <CODE>SHORT</CODE> (meaning the maximum length is 2**16-1), or given an explicit maximum length.
<P>
Note that putting the dimensions after the <CODE>OF</CODE> would create a syntactic ambiguity in some cases, concerning grouping of a <CODE>SHORT</CODE>.
 
<H4><A NAME="SEC32" HREF="manual_toc.html#SEC32">Record Declarations</A></H4>
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>= </CODE><CODE>RECORD</CODE> <VAR>fields...</VAR> <CODE>END</CODE><CODE> ;</CODE>
</PRE>
<P>
where <VAR>fields</VAR> is a comma-separated list of <VAR>field</VAR>, which has the form
<P>
<PRE>
<VAR>field-name</VAR> <CODE>:</CODE> <VAR>field-type-reference</VAR>
</PRE>
<P>
A sample record declaration:
<P>
<PRE>
TYPE Symbol = RECORD
  name : string,
  type : TypeInfo,
  address : cardinal
END;
</PRE>
<P>
<H4><A NAME="SEC33" HREF="manual_toc.html#SEC33">Union Declarations</A></H4>
<P>
A union is a type which may take on values of several different types.  To be compliant
with the CORBA notion of unions, the union declaration is much more baroque and complicated
than it really should be.  The declaration has the form:
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> [ <VAR>tag-type</VAR> ] <CODE>UNION</CODE> <VAR>arm-list</VAR> <CODE>END</CODE> [ <CODE>OTHERS</CODE> ] <CODE>;</CODE>
</PRE>
<P>
where <VAR>arm-list</VAR> is a comma-separated list of <VAR>arm</VAR>, each of the form:
<P>
<PRE>
[ <VAR>union-case-name</VAR> <CODE>:</CODE> ] <VAR>type-name</VAR> [ <VAR>arm-valuator</VAR> ]
</PRE>
<P>
where each <VAR>arm-valuator</VAR> is either of the form
<PRE>
<CODE>=</CODE> <CODE>DEFAULT</CODE>
</PRE>
or of the form
<PRE>
<CODE>=</CODE> <VAR>value-list</VAR> <CODE>END</CODE>
</PRE>
and where a <VAR>value-list</VAR> is a comma-separated list of constant values of the tag type.  The tag type must be one of: <CODE>SHORT INTEGER</CODE>, <CODE>SHORT CARDINAL</CODE>, <CODE>INTEGER</CODE>, <CODE>CARDINAL</CODE>, <CODE>BYTE</CODE>, <CODE>BOOLEAN</CODE>, or an enumerated type.  (We should also allow <CODE>SHORT CHARACTER</CODE> and <CODE>CHARACTER</CODE>.)  The tag type is <CODE>SHORT INTEGER</CODE> if not explicitly specified.
<P>
A <VAR>arm-valuator</VAR> must be given for either all or none of the <VAR>arm</VAR>s; if none, the <VAR>arm</VAR>s are assigned single integral values, starting with 0.  <VAR>arm-valuator</VAR>s must be given if the tag type isn't numeric.  All the values appearing in the <VAR>value-list</VAR>s of a union must be different from one another.  <CODE>DEFAULT</CODE> can appear in at most one arm of a union type construction.  <CODE>DEFAULT</CODE> and <CODE>OTHERS</CODE> cannot both appear in the same union.
<P>
A union value consists of a tag value, possibly paired with a second value.  When the tag value is one that appears in, or is implicitly assigned to, an arm of the union type construction, the second value is of the type named in that arm.  Otherwise, the union value is well-formed only if <CODE>DEFAULT</CODE> or <CODE>OTHERS</CODE> appears in the union type construction.  If an arm is valued with <CODE>DEFAULT</CODE>, the second value is of that arm's type.  If <CODE>OTHERS</CODE> appears, there is no second value; it is as if there were a default arm of some trivial type (like C's <CODE>void</CODE> or ML's <CODE>unit</CODE>).
<P>
A simple example:
<PRE>
TYPE StringOrInt = UNION ilu.CString, CARDINAL END;
</PRE>
<P>
A more complex example, that uses an explicit tag type, union case names, and a default arm:
<PRE>
TYPE ColorType = ENUMERATION RGB, CMY, HSV, YIQ, HLS END;
TYPE U2 = ColorType
  UNION
    rgb-field : RGBObject = RGB END,
    others : COLORObject = DEFAULT
  END;
</PRE>
<P>
The union case name is not guaranteed to be present in language-specific mappings.
<P>
ISL unions are logically (and sometimes actually, depending on the programming language)
tagged.  There is a difference between
<PRE>
TYPE T1 = UNION Bar, Baz END;
TYPE T2 = UNION Foo, T1 END;
</PRE>
and
<PRE>
TYPE T1 = UNION Bar, Baz END;
TYPE T2 = UNION Foo, Bar, Baz END;
</PRE>
<P>
<H4><A NAME="SEC34" HREF="manual_toc.html#SEC34">Optional Declarations</A></H4>
<P>
A variable of type <CODE><CODE>OPTIONAL</CODE> Foo</CODE> can have either a value of <CODE>Foo</CODE> or of type <CODE>NULL</CODE>.  It is declared with the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>= </CODE><CODE>OPTIONAL</CODE> <VAR>base-type-reference</VAR> <CODE>;</CODE>
</PRE>
<P>
This should be thought of as roughly equivalent to the declaration
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <CODE>BOOLEAN</CODE> <CODE>UNION</CODE> <VAR>base-type-reference</VAR> <CODE>= TRUE</CODE> <CODE>END</CODE> <CODE>END</CODE> <CODE>OTHERS</CODE> <CODE>;</CODE>
</PRE>
<P>
The difference is that <CODE>OPTIONAL</CODE> types are logically un-tagged.  An optional value is not a pair of (<CODE>BOOLEAN</CODE>, <VAR>base-type-reference</VAR>); rather it is a single value, either a special, distinguished, "null" value or a value of the <VAR>base-type-reference</VAR>.  There is thus no difference between
<PRE>
TYPE Bar = OPTIONAL Foo;
TYPE Baz = OPTIONAL Bar;
</PRE>
and
<PRE>
TYPE Bar = OPTIONAL Foo;
TYPE Baz = OPTIONAL Foo;
</PRE>
<P>
<H4><A NAME="SEC35" HREF="manual_toc.html#SEC35">Enumeration Declarations</A></H4>
<P>
An enumeration is an abstract type whose values are explicitly enumerated.  It is declared with the form
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <CODE>ENUMERATION</CODE> <VAR>values...</VAR> <CODE>END</CODE> <CODE>;</CODE>
</PRE>
<P>
where <VAR>values</VAR> is a comma-separated list of value names, with optional value
ID's that are constants of type <CODE>SHORT CARDINAL</CODE> that
specify the value used to represent the enumeration value
"on the wire".<A NAME="FOOT3" HREF="manual_foot.html#FOOT3">(3)</A>  <EM>Use of value ID's is deprecated.</EM>
<P>
<PRE>
<VAR>value-name</VAR> [ <CODE>=</CODE> <VAR>value-id</VAR> ]
</PRE>
<P>
For example,
<P>
<PRE>
TYPE TapeAction = ENUMERATION
  SkipRecord = 1,
  Rewind = 23,
  Backspace = 49,
  WriteEOF = 0
END;
</PRE>
<P>
All <VAR>value-name</VAR>s and <VAR>value-ID</VAR>s must be unique within an enumeration.  If
<VAR>value-ID</VAR>s are not assigned explicitly, appropriate values will be assigned
automatically in some unspecified way.  An enumeration may have at most 65535 (2^16-1) values.
<P>
<H4><A NAME="SEC36" HREF="manual_toc.html#SEC36">Object Type Declarations</A></H4>
<P>
Object types are described in the following way:
<P>
<PRE>
<CODE>TYPE</CODE> <VAR>type-name</VAR> <CODE>=</CODE> <CODE>OBJECT</CODE>
                        [ <CODE>SINGLETON</CODE> <VAR>protocol-description-string</VAR> ]
                        [ <CODE>DOCUMENTATION</CODE> <VAR>documentation-string</VAR> ]
                        [ <CODE>COLLECTIBLE</CODE> ]
                        [ <CODE>OPTIONAL</CODE> ]
                        [ <CODE>TYPEID</CODE> <VAR>type-id-string</VAR> ]
                        [ <CODE>SUPERTYPES</CODE> <VAR>supertype-list</VAR> <CODE>END</CODE> ]
                        [ <CODE>METHODS</CODE> <VAR>method-list...</VAR> <CODE>END</CODE> ]
                        [ <CODE>BRAND</CODE> <VAR>string-constant</VAR> ] <CODE>;</CODE>
</PRE>
<P>
The keyword <CODE>CLASS</CODE> is a deprecated synonym for <CODE>OBJECT</CODE>, and <CODE>SUPERCLASSES</CODE> is a deprecated synonym for <CODE>SUPERTYPES</CODE>.  Also,
<PRE>
                        [ <CODE>SUPERCLASS</CODE> <VAR>supertype-name</VAR> ]
</PRE>
is a deprecated equivalent to
<PRE>
                        [ <CODE>SUPERTYPES</CODE> <VAR>supertype-name</VAR> <CODE>END</CODE> ]
</PRE>
<P>
The <CODE>SINGLETON</CODE> keyword specifies that instances of this type are
singleton servers, and implies that the discriminator object (the
subject of the call) should not be implicitly marshalled as the first
argument in an RPC.  This is typically used in describing an instance of
an existing RPC service, which is to be modelled in ILU.  The
argument to <CODE>SINGLETON</CODE> is a string in the form of ILU
"protocol-info", which specifies particular protocol-specific
parameters to be used in implementing this object type `on the wire'.  For
example, the Sun RPC calendar manager would use a
<VAR>protocol-description-string</VAR> of <CODE>"sunrpc_2_100068_3"</CODE>,
indicating that it uses a Sun RPC program number of 100068 and
a Sun RPC version of 3.
<P>
The optional <VAR>documentation-string</VAR> is a quoted string, which is passed
on to language-specific bindings where possible, such as with the doc-string
capability in Common Lisp.
<P>
The <CODE>COLLECTIBLE</CODE> keyword specifies that instances of this type are meant to
be garbage collectible, and that methods necessary for this should be
automatically added to its method suite.  For an object type to be collectible,
all ancestor object types must also be collectible.
<P>
The <CODE>OPTIONAL</CODE> keyword specifies that the language-specific <CODE>nil</CODE> value
may be passed, instead of an instance of this object type, anywhere this object type is used.
<EM>This is a CORBA mis-feature, and its use is strongly deprecated.  Better
to explicitly use a different type constructed with the ILU <CODE>OPTIONAL</CODE> keyword.</EM>
<P>
The optional <VAR>supertype-list</VAR> defines an inheritance relationship between the object
types named in the list and the type <VAR>type-name</VAR>.
<P>
The optional <VAR>type-id-string</VAR> can be used to explicitly assign an MSTID
for an object type.  Doing so effectively 
<A NAME="IDX46"></A>
<I>seal</I>s the object type; that is,
changes to the structure of the object type will not be reflected in the MSTID,
so version mismatches will not be caught automatically by ILU.  This is
a dangerous feature (mandated by CORBA).
<P>
The <VAR>string-constant</VAR> in the <CODE>BRAND</CODE> clause, if any, contributes an arbitrary
tag to the structure of the type; omitting the <CODE>BRAND</CODE> clause is equivalent to
giving one with the empty string.  Branding gives the programmer a way to make
two types distinct despite their otherwise having the same structure.  See
an earlier subsection for more details.
<P>
The <VAR>method-list</VAR> is a comma-separated list of procedure
descriptions.  All the methods of an object type have distinct names.
This means that independently-developed supertypes might not be usable together.
<P>
Methods have the syntax:
<P>
<PRE>
[ <CODE>FUNCTIONAL</CODE> ] [ <CODE>ASYNCHRONOUS</CODE> ] <VAR>method-name</VAR> <CODE>(</CODE> [ <VAR>args...</VAR> ] <CODE>)</CODE>
        [ <CODE>:</CODE> <VAR>return-type-reference</VAR> ]
        [ <CODE>RAISES</CODE> <VAR>exceptions...</VAR> <CODE>END</CODE> ]
        [ <CODE>=</CODE> <VAR>procedure-id</VAR> ]
        [ <VAR>documentation-string</VAR> ]
</PRE>
<P>
where the discriminator (the implicit first argument to the method,
the subject of the call, an instance of the object type in question) is not
explicitly listed in the signature.  Each method has zero or more arguments in
a comma-separated list, each element of which is a colon-separated two-ple
<PRE>
[ <VAR>argument-direction</VAR> ] <VAR>argument-name</VAR> <CODE>:</CODE> [ <CODE>SIBLING</CODE> ] <VAR>argument-type-reference</VAR>
</PRE>
The <CODE>SIBLING</CODE>
keyword may only appear on arguments of an object type, to indicate that the
argument should be a sibling object to the discriminator of the method.
The <CODE>FUNCTIONAL</CODE> keyword indicates that the method, for a given set of arguments, is idempotent (i.e., the side effects of one call are the same as the side effects of more than one call) and will always return the same result (or raise the same exception); this
information may be used for caching of return values in the client side stubs.
The optional <VAR>argument-direction</VAR> information is one of the three keywords <CODE>IN</CODE>, <CODE>OUT</CODE>, <CODE>INOUT</CODE>,
specifying whether the parameter is being used as an input parameter, an output parameter, or both.
<P>
A method return type is allowed (again separated from the procedure argument
list by a colon), and a list of possible exceptions may be specified as a
comma-separated list of exception names, bracketed with the keywords RAISES
and END.
<P>
The optional <VAR>procedure-id</VAR> field allows a service description to specify the
procedure code that is used in the RPC request packet for this method.
Procedure ID's are restricted to the range [0,65279], and must be unique
within an interface.  This may only be used in methods on objects marked
with the <CODE>SINGLETON</CODE> attribute.
<P>
If a method is marked with the <CODE>ASYNCHRONOUS</CODE> keyword and does not return a
value or raise an exception, the RPC method call of a surrogate instance will
return after sending the request packet to the RPC partner, as the success of
the call does not depend on the completion of the associated code.  Other RPC
methods  will block in such a way as to allow the scheduler to handle other
events while it is waiting for the call to complete, if the user has
registered the appropriate scheduler hooks with the ILU runtime.
<P>
The optional <VAR>documentation-string</VAR> is a quoted string, which is passed
on to language bindings for which it is meaningful, such as the doc-string
capability in Common Lisp.
<P>
For example:
<P>
<PRE>
TYPE FancyString = OBJECT
  METHODS
    FUNCTIONAL Length () : cardinal,
    Substring (start : cardinal, end : cardinal) : string
      RAISES StartGreaterThanEnd, StartTooLarge, EndTooLarge END,
    Char (index : cardinal) : character
      RAISES BadIndex END
  END;
</PRE>
<P>
Note that the object language in ILU is not intended to be used to fully
<EM>define</EM> an object type, but rather to <EM>describe</EM> it in a simple language
that can be transformed into the different object type definition systems of several
other languages.
<P>
<H3><A NAME="SEC37" HREF="manual_toc.html#SEC37">Exception Declarations</A></H3>
<P>
Exceptions in ILU are raised by ILU methods.  They allow error conditions to
be signalled back to the calling code.  They are declared with a statement of
the form:
<P>
<PRE>
<CODE>EXCEPTION</CODE> <VAR>exception-name</VAR> [ <CODE>:</CODE> <VAR>type-reference</VAR> ] [ <VAR>documentation-string</VAR> ] <CODE>;</CODE>
</PRE>
<P>
The optional <VAR>type-reference</VAR> part of the declaration allows the exception to have
an associated value, to be used in interpretation of the exception.  For
example, an exception BadFilename might have the type <CODE>ilu.CString</CODE>, so that the
actual bad filename can be associated with the exception:
<P>
The optional <VAR>documentation-string</VAR> is a quoted string, which is passed
on to language bindings for which it is meaningful, such as the doc-string
capability in Common Lisp.
<P>
<PRE>
TYPE Filename = ilu.CString;
EXCEPTION BadFileName : Filename "The value is the bad filename";
</PRE>
<P>
Because of the uncertain nature of life in distributed systems, the pre-defined exception
<CODE>ilu.ProtocolError</CODE> (defined in the ILU interface) may be raised by any
method, to indicate that the method could not be handled, for some reason.  It
has the following form:
<P>
<PRE>
TYPE ProtocolErrorDetail = ENUMERATION
                NoSuchClassAtServer = 1,
                BrandMismatch = 2,
                NoSuchMethodOnClass = 3,
                InvalidArguments = 4,
                UnknownObjectInstance = 5,
                UnreachableModule = 6,
                RequestRejectedByModule = 7,
                TimeoutOnRequest = 8,
                UnknownError = 9
        END;

EXCEPTION ProtocolError : ProtocolErrorDetail;
</PRE>
<P>
Signalling of <CODE>ProtocolError</CODE> is never done by user-written server code; it is
reserved to the transport and runtime layers of ILU.
<P>
<H3><A NAME="SEC38" HREF="manual_toc.html#SEC38">Constant Declarations</A></H3>
<P>
For convenience of interface design, constant values for certain simple types
may be defined in ISL with statements of the form
<P>
<PRE>
<CODE>CONSTANT</CODE> <VAR>constant-name</VAR> <CODE>:</CODE> <VAR>constant-type</VAR> <CODE>=</CODE> <VAR>constant-value</VAR> <CODE>;</CODE>
</PRE>
<P>
<H4><A NAME="SEC39" HREF="manual_toc.html#SEC39">Integer, Cardinal, and Byte Constants</A></H4>
<P>
A <VAR>constant-value</VAR> for types that are sub-types of <CODE>INTEGER</CODE>, <CODE>CARDINAL</CODE>, or <CODE>BYTE</CODE>
is specified with the syntax
<P>
<PRE>
[ <VAR>sign</VAR> ] [ <VAR>base-indicator</VAR> ] <VAR>digits</VAR>
</PRE>
<P>
where the optional <VAR>base-indicator</VAR> allows selection of bases 2, 8, 10 or 16.
It is a digit '0' (zero) followed by either the character 'B' for base 2, 'X'
for base 16, 'O' (oh) for base 8, or 'D' for base 10.  The <VAR>sign</VAR> is only
valid for subtypes of <CODE>INTEGER</CODE>; it is either '+' or '-'; if not specified, '+'
is assumed.  The <VAR>base-indicator</VAR> and <VAR>digits</VAR> fields are case-insensitive.
<P>
<H4><A NAME="SEC40" HREF="manual_toc.html#SEC40">Real Constants</A></H4>
<P>
A <VAR>constant-value</VAR> for subtypes of <CODE>REAL</CODE> has the syntax:
<P>
<PRE>
[ <VAR>sign</VAR> ] <VAR>integer</VAR><CODE>.</CODE><VAR>fraction</VAR> [ <CODE>e</CODE> <VAR>exponent</VAR> ]
</PRE>
<P>
where <VAR>integer</VAR> and <VAR>fraction</VAR> are sequences of decimal digits, <VAR>sign</VAR> is
either '+' or '-' ('+' is the default), and <VAR>exponent</VAR> is the power of 10
which the rest of the value is multiplied by (defaults to 0).
<P>
<H4><A NAME="SEC41" HREF="manual_toc.html#SEC41">ilu.CString Constants</A></H4>
<P>
A <VAR>constant-value</VAR> for a sub-type of <CODE>ilu.CString</CODE> has the form
<P>
<PRE>
<CODE>"</CODE><VAR>characters</VAR><CODE>"</CODE>
</PRE>
<P>
where <VAR>characters</VAR> are any ISO-Latin-1 characters except for 8_000.  The
escape character is defined to be '#' (hash).  The escape character may occur
in the string only in the following ways:
<P>
<PRE>
#" -- a single double-quote character
## -- a single escape character
#<VAR>hex-digit</VAR><VAR>hex-digit</VAR> -- the octet 16_<VAR>hex-digit</VAR><VAR>hex-digit</VAR>
#n -- newline
#r -- carriage return
</PRE>
<P>
<H4><A NAME="SEC42" HREF="manual_toc.html#SEC42">Examples of Constants</A></H4>
<P>
<PRE>
CONSTANT Newline : byte = 10;
CONSTANT Pi : short real = 3.14159;
CONSTANT Big : long real = -1.1349e27;  (*  -1.1349 * 10**27   *)
TYPE Filename = ilu.CString;
CONSTANT MyLogin : Filename = "~/.login";
CONSTANT Prompt : ilu.CString = "OK#n ";
CONSTANT HeapBound : cardinal = 0xFFFF39a0;
CONSTANT Pattern1 : cardinal = 0b000001000001;
</PRE>
<P>
<A NAME="IDX47"></A>
<H2><A NAME="SEC43" HREF="manual_toc.html#SEC43">ilu.isl</A></H2>
<P>
The standard interface <CODE>ilu</CODE> can be found in the file <TT>`<VAR>ILUHOME</VAR>/interfaces/ilu.isl'</TT>; it is maintained as <TT>`<VAR>ILUHOME</VAR>/src/stubbers/parser/ilu.isl'</TT>.  Here are its contents:
<P>
<PRE>
INTERFACE ilu BRAND "v1";

TYPE CString = SEQUENCE OF SHORT CHARACTER;

TYPE ProtocolErrorDetail =
  ENUMERATION
    NoSuchClassAtServer,     (* server doesn't handle specified class *)
    BrandMismatch,           (* versions out of sync *)
    NoSuchMethodOnClass,     (* invalid method, or method not implemented *)
    InvalidArguments,        (* bad arguments passed *)
    UnknownObjectInstance,   (* specified instance not on server *)
    UnreachableModule,       (* no path to handler *)
    RequestRejectedByModule, (* request not looked at, for some reason *)
    TimeoutOnRequest,        (* no response from server within timeout *)
    UnknownError             (* catchall error *)
  END;

EXCEPTION ProtocolError : ProtocolErrorDetail;
</PRE>
<P>
The declarations of <CODE>ProtocolErrorDetail</CODE> and <CODE>ProtocolError</CODE> don't belong here, and will be eliminated in favor of a reference manual section explaining the possible errors.
<P>
<H2><A NAME="SEC44" HREF="manual_toc.html#SEC44">Using OMG IDL with ILU</A></H2>
<P>
ILU allows the use of CORBA OMG IDL
<A NAME="FOOT4" HREF="manual_foot.html#FOOT4">(4)</A> instead
of ILU ISL.  It does this by translating the OMG IDL
to its equivalent form in ISL.  Most ILU tools will do this automatically,
based on whether the suffix of the filename argument is <TT>`.isl'</TT> or <TT>`.idl'</TT>.
In addition, the program <CODE>idl2isl</CODE> can be invoked explicitly to create
an ISL version of an OMG IDL interface file.
The program idl2isl translates from IDL to ISL.
IDL is the Interface Definition Language defined by the
Object Management Group.<A NAME="FOOT5" HREF="manual_foot.html#FOOT5">(5)</A>
<P>
<H3><A NAME="SEC45" HREF="manual_toc.html#SEC45">Translation</A></H3>
<P>
On the whole, the translation from IDL to ISL is
a straightforward change of syntax.  There are a few cases, however, where a bit more is needed.
<P>
<H4><A NAME="SEC46" HREF="manual_toc.html#SEC46">Anonymous types</A></H4>
<P>
OMG IDL allows type declarators to be used in certain places in the
syntax (for example, struct members and operation parameters).
ISL does not;
it requires a type name in the corresponding situations.
As a result, it is sometimes necessary for the translator to introduce
a name in the ISL output for those types that are
anonymous in the OMG IDL input.
These names are always of the form
<CODE>AnonType-<VAR>nnn</VAR>-</CODE>, where <VAR>nnn</VAR> is an integer.
<P>
For example, the OMG IDL declaration
<P>
<PRE>
struct str {
	long	f1;
	long	f2[5];
};
</PRE>
is translated into the following ISL:
<PRE>
TYPE AnonType-1- = ARRAY OF 5 INTEGER;
TYPE str = RECORD
	f1 : INTEGER,
	f2 : AnonType-1-
	END;
</PRE>
<P>
<H4><A NAME="SEC47" HREF="manual_toc.html#SEC47">Topmodules mode</A></H4>
When the translator is in this mode (which it is by default),
only <CODE>module</CODE> declarations are allowed at the topmost level.
Each <CODE>module</CODE> translates into an <CODE>INTERFACE</CODE> declaration
in ISL, and the declarations inside each <CODE>module</CODE> go
into the corresponding ISL <CODE>INTERFACE</CODE>.
<P>
If the translator is not in this mode,
all the declarations in the IDL file go into one
ISL <CODE>INTERFACE</CODE> whose name is taken from the OMG IDL
input filename, less the <TT>`.idl'</TT> suffix.
<P>
<H4><A NAME="SEC48" HREF="manual_toc.html#SEC48">Imports mode</A></H4>
When the translator is in this mode (which it is by default),
<CODE>#include</CODE> preprocessor directives are, roughly speaking, turned into
ISL <CODE>IMPORT</CODE> statements.
This mode allows for separate compilation (stub generation) of interfaces.
There are some restrictions:
the <CODE>#include</CODE> directives must occur before any declarations in the
file, and the files that are included must not be fragments.
That is, each must consist of a sequence of whole declarations
(more specifically, <CODE>module</CODE> declarations if in <CODE>topmodules</CODE> mode).
The included files may in turn include other files.
<P>
If the translator is not in this mode,
the input is considered to be the result of preprocessing the file first
and textually substituting the included files,
following the usual behavior of C and C++ compilers.
<P>
<H4><A NAME="SEC49" HREF="manual_toc.html#SEC49">Unsupported constructs</A></H4>
<P>
The IDL types <CODE>Object</CODE> and <CODE>any</CODE> are disallowed
by the translator.
Use of <CODE>context</CODE> clauses on operations is also prohibited.
<P>
<H3><A NAME="SEC50" HREF="manual_toc.html#SEC50">Manual Invocation of <CODE>idl2isl</CODE></A></H3>
<P>
The program is run automatically as an intermediate step
by any of the ILU tools that
take ISL files (normally ending in <TT>`.isl'</TT>)
if the filename ends in <TT>`.idl'</TT>.
<P>
The program may also be run directly, with the following arguments:
<PRE>
<CODE>idl2isl</CODE> { <CODE>-Wb,<VAR>toggle</VAR></CODE> | <CODE>-Wb,!<VAR>toggle</VAR></CODE> }* <CODE><VAR>source</VAR>.idl</CODE>
</PRE>
In this case, it writes the ISL to its standard output.
A toggle is set with an argument
<CODE>-Wb,<VAR>toggle</VAR></CODE>
and cleared with an argument
<CODE>-Wb,!<VAR>toggle</VAR></CODE>.
Toggle settings may also be effected by setting the environment variable
<TT>`IDL2ISL_OPTS'</TT> to a comma-separated list of toggle names,
each of which is either preceded by a <TT>`!'</TT> character (which clears it)
or not (which sets it).
Command-line arguments take precedence over the environment variable
settings.
<P>
The toggles are:
<UL>
<LI>
<CODE>dump</CODE> (default off): produce a dump of the abstract syntax tree.
Used for debugging the translator itself.
<LI>
<CODE>imports</CODE> (default on): set the <CODE>imports</CODE> mode on (explained below).
<LI>
<CODE>topmodules</CODE> (default on): set the <CODE>topmodules</CODE> mode on
(explained below).
</UL>
<P>
<H2><A NAME="SEC51" HREF="manual_toc.html#SEC51">ISL Grammar</A></H2>
<P>
In this grammar, parentheses are used for grouping, vertical-bar
indicates selection, braces indicated optionality, quotation marks
indicate literal keywords or literal punctuation.
<P>
No whitespace is allowed between the parts of a <CODE>radix</CODE>, <CODE>number</CODE>,
or <CODE>quoted-string</CODE>.  Aside from that, whitespace is used to separate
fields where necessary, and excess whitespace is ignored outside of
<CODE>quoted-string</CODE>s.
<P>
Three primitives are used:
<UL>
<LI>
<VAR>name-string</VAR>,
which is a
string consisting of decimal digits, upper and lower-case letters, and
hyphens, beginning with a letter.  It may not be a keyword, unless it
is quoted with double-quotes.
<LI>
<VAR>string</VAR>,
which is any sequence of
characters.
<LI>
<VAR>digits</VAR>,
which is a sequence of digits drawn from the digits
for the particular radix.  The default radix is decimal.
</UL>
<P>
<PRE>
interface = interface-def | interface interface-def

interface-def = interface-declaration other-declarations

interface-declaration = "INTERFACE" <VAR>name-string</VAR>
                        [ "BRAND" brand-string ]
                        [ "IMPORTS" import-list "END" ]
                        ";"

import-name = <VAR>name-string</VAR> [ "FROM" filename ]

import-list = import-name | import-list "," import-name

other-declarations = [ other-declaration other-declarations ]

other-declaration = constant-decl | exception-decl | type-decl

constant-decl = "CONSTANT" <VAR>name-string</VAR> ":" ( integer-const
                                           | cardinal-const
                                           | boolean-const
                                           | byte-const
                                           | float-const
                                           | string-const ) ";"

integer-const = [ "SHORT" | "LONG" ] "INTEGER" "=" [ sign ] number

boolean-const = "BOOLEAN" "=" boolean-value

cardinal-const = [ "SHORT" | "LONG" ] "CARDINAL" "=" number

byte-const = "BYTE" "=" number

float-const = [ "SHORT" | "LONG" ] "REAL" "="
              [sign] <VAR>digits</VAR> [ "." <VAR>digits</VAR> ] [ "e" <VAR>digits</VAR> ]

number = [ radix ] <VAR>digits</VAR>

radix = "0" ( binary | octal | hexadecimal )

binary = "b"

octal = "o"

hexadecimal = "x"

string-const = "ilu.CString" "=" quoted-string

exception-decl = "EXCEPTION" excp-name [ ":" type ] [ doc-string ] ";"

excp-name = <VAR>name-string</VAR>

type-decl = "TYPE" <VAR>name-string</VAR> "=" ( type | type-cons ) ";"

type = primitive-type-name | [ <VAR>name-string</VAR> "." ] <VAR>name-string</VAR>

primitive-type-name = "BYTE"
                    | [ "SHORT" | "LONG" ] "CARDINAL"
                    | [ "SHORT" | "LONG" ] "INTEGER"
                    | [ "SHORT" | "LONG" ] "REAL"
                    | [ "SHORT" ] "CHARACTER"
                    | "BOOLEAN"

type-cons =   record-cons
                | array-cons
                | sequence-cons
                | union-cons
                | optional-cons
                | enum-cons
                | object-cons

record-cons = "RECORD" field-list "END"

field-list = field | field-list "," field

field = <VAR>name-string</VAR> ":" type

sequence-cons = [ "SHORT" ] "SEQUENCE" "OF" type [ "LIMIT" number ]

array-cons = "ARRAY" "OF" dimensions-list type

dimensions-list = number | dimensions-list "," number

union-cons = [ <VAR>int-enum-or-boolean-type</VAR> ] "UNION" union-field-list "END"

union-field-list = union-field | union-field-list "," union-field

union-field = [ <VAR>field-name-string</VAR> ":" ] type [ "=" const-list "END" ]

const-list = const | const-list "," const

const = number | enum-field-name | boolean-value

enum-cons = "ENUMERATION" enum-field-list

enum-field-list = enum-field | enum-field-list "," enum-field

enum-field = <VAR>string</VAR>

boolean-value = "TRUE" | "FALSE"

optional-cons = "OPTIONAL" type

object-cons = "OBJECT" object-attributes

object-attributes = object-feature | object-attributes object-feature

object-feature =  "SINGLETON" singleton-protocol-info
                | "COLLECTIBLE"
                | "OPTIONAL"
                | "DOCUMENTATION" doc-string
                | "TYPEID" type-id-string
                | "BRAND" brand-string
                | "SUPERTYPES" supertype-list "END"
                | "METHODS" method-list "END"

supertype-list = type | supertype-list "," type

singleton-protocol-info = quoted-string

method-list = method | method-list "," method

method = [ "FUNCTIONAL" | "ASYNCHRONOUS" ] <VAR>name-string</VAR>
         arguments [ ":" return-type ] [ "RAISES" exception-list "END"]
         [ doc-string ]

return-type = type

exception-list = excp-name | exception-list "," excp-name

arguments = "(" [ argument-list ] ")"

argument-list = argument | argument-list "," argument

argument = [ "IN" | "OUT" | "INOUT" ] <VAR>name-string</VAR> ":" [ "SIBLING" ] type

doc-string = quoted-string

quoted-string = "\"" <VAR>string</VAR> "\""

</PRE>
<P>
<P>Go to the <A HREF="manual_1.html">previous</A>, <A HREF="manual_3.html">next</A> section.<P>
