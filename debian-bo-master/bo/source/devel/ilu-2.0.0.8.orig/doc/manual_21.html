<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Possible ISL Name Mappings for Target Languages</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_20.html">previous</A>, <A HREF="manual_22.html">next</A> section.<P>
<H1><A NAME="SEC311" HREF="manual_toc.html#SEC311">Possible ISL Name Mappings for Target Languages</A></H1>
<P>
This note outlines a proposal for name mappings and restrictions; this
proposal is not yet accepted.  (Thanks to external standards such as
CORBA, this proposal cannot be implemented for some languages,
such as ANSI C.)  <STRONG>The mappings outlined here are not
necessarily the ones used in the current ILU release.</STRONG>
<P>
This proposal is about how to name things in the various programming
languages, in a way that avoids name clashes.  It imposes no
restrictions on the ISL source.  However, the mappings will
be more straightforward if the ISL source avoids two things:
(1) two or more concsecutive hyphens in a name, and (2) starting an
interface or type name with "ilu-" (in any casing).
<P>
The first step in mapping an ISL to a programming language is
to scan type and interface names for the substring "ilu-" (in any
casing); wherever it occurs, we insert a trailing digit zero.
<P>
In a similar way, we next scan the name for sequences of hyphens.
Wherever two or more hyphens appear consecutively, the digit zero (`0')
is inserted after every other one, starting with inserting a zero after
the second hyphen.
<P>
The following steps assume the first two steps have already been done.
<P>
Where tuples &#60;N1, N2, ... Nk&#62; of ISL names must be mapped into a flat programming namespace, we concatenate the ISL names, with a double hyphen ("--") inserted between each.
<P>
Where ISL names (or tuples thereof) must be mapped, together with ILU-chosen names derived from the ISL names, into a flat programming namespace, the derived names begin with fixed strings specific to the derivation, where the fixed strings begin with "ilu-" (with any case), and a double hyphen is inserted between the fixed string and the ISL name.
<P>
Where ISL names (or tuples thereof), and possibly ILU-chosen names derived from the ISL names, must be mapped, together with a fixed set of ILU-chosen names, into a flat programming namespace, the fixed ILU-chosen names begin with "ilu-" (with any case) and do not include a double hyphen.
<P>
The final step is to translate hyphens to underscores, for programming languages that accept underscores but not hyphens in names.
<P>
Following is a specification of how names are mapped in each language.  The notation "[N]" is used to denote the application of the first two steps and the last step.  Examples of "[..]" are:
<PRE>
[Foo] =&#62; Foo
[foo-bar] =&#62; foo-bar
[wait----for--it-] =&#62; wait--0--0for--0-it-
[iluminate] =&#62; iluminate
[ilu--uli] =&#62; ilu-0--0uli
</PRE>
The mappings also use the notation "[[..]]" to denote the mapping of a type-reference.
<P>
<H2><A NAME="SEC312" HREF="manual_toc.html#SEC312">C mapping</A></H2>
<P>
[ This mapping, while clean, will never be adopted because of the more problematic mapping specified by the OMG's CORBA document. ]
<P>
Item <CODE>N</CODE> from interface <CODE>I</CODE> is mapped to <CODE>[I]__[N]</CODE>.  <CODE>[[I.N]] = [I]__[N]</CODE>; <CODE>[[N]] = [I]__[N]</CODE>, where <CODE>I</CODE> is the current interface.
<P>
An enumerated value named <CODE>V</CODE>, of type <CODE>T</CODE> in interface <CODE>I</CODE> is mapped to <CODE>[I]__[T]__[V]</CODE>.
<P>
A declaration of a record type <CODE>T</CODE> in interface <CODE>I</CODE> with fields <CODE>F1:TR1</CODE>, ... <CODE>Fn:TRn</CODE> is mapped to
<PRE>
typedef struct {[[TR1]] F1; ... [[TRn]] Fn} [I]__[T];
</PRE>
<P>
A declaration of a union type <CODE>T</CODE> in interface <CODE>I</CODE> of types <CODE>TR1</CODE>, ... <CODE>TRn</CODE> is mapped to
<PRE>
typedef enum {[[I.T]]__[[TR1]], ... [[I.T]]__[[TRn]]} ilu_tags__[[I.T]];
typedef struct {ilu_tags__[[I.T]] tag;
    union {
        [[TR1]] [[TR1]];
        ...
        [[TRn]] [[TRn]];
    } val;
} [[I.T]];
</PRE>
<P>
For passing exceptions through the method calls in interface <CODE>I</CODE>, the following auxiliary declaration is generated (supposing exceptions <CODE>ER1:TR1</CODE>, ... <CODE>ER2:TR2</CODE> are raised):
<PRE>
typedef struct {
    ilu_Exception returnCode;
    union {
        [[TR1]] [[ER1]];
        ...
        [[TRn]] [[ERn]];
    } val;
} ilu_Status__[I];
</PRE>
<P>
An object type named <CODE>T</CODE> in interface <CODE>I</CODE> with methods <CODE>M1</CODE>, ... <CODE>Mn</CODE> maps to
<PRE>
typedef ilu_Ojbect [[I.T]];
[result-type-1] [I]__[T]__[M1]([[I.T]] ilu_self,
    [[arg-type-1-1]] [arg-name-1-1], ...
    [[arg-type-1-k]] [arg-name-1-k]);
...
</PRE>
<P>
<H2><A NAME="SEC313" HREF="manual_toc.html#SEC313">C++ mapping</A></H2>
<P>
Item <CODE>N</CODE> from interface <CODE>I</CODE> is mapped to <CODE>[I]__[N]</CODE>.  <CODE>[[I.N]] = [I]__[N]</CODE>; <CODE>[[N]] = [I]__[N]</CODE>, where <CODE>I</CODE> is the current interface.
<P>
A declaration of an enumerated type named <CODE>T</CODE> in interface <CODE>I</CODE> containing values <CODE>V1</CODE>, ... <CODE>Vn</CODE> is mapped to <CODE>typedef enum {[V1], ... [Vn]} [I]__[T]</CODE>.
<P>
Record and union declarations are mapped as for C.  The exception status declaration is as for C.
<P>
<H2><A NAME="SEC314" HREF="manual_toc.html#SEC314">Modula-3 mapping</A></H2>
<P>
ILU interface <CODE>I</CODE> is mapped to Modula-3 interface <CODE>[I]</CODE>; within an interface, item <CODE>N</CODE> is mapped to item <CODE>[N]</CODE>.  <CODE>[[I.N]] = [I].[N]</CODE>; <CODE>[[N]] = [N]</CODE>.  For Modula-3, we also use the notation "((a type-reference))", defined by <CODE>((N)) = [N]</CODE> and <CODE>((I.N)) = [I]__[N]</CODE>.
<P>
A declaration of a record type <CODE>T</CODE> in interface <CODE>I</CODE> with fields <CODE>F1:TR1</CODE>, ... <CODE>Fn:TRn</CODE> is mapped to
<PRE>
TYPE [T] =  RECORD F1: [[TR1]]; ... Fn: [[TRn]]; END;
</PRE>
<P>
A declaration of a union type <CODE>T</CODE> in interface <CODE>I</CODE> of types <CODE>TR1</CODE>, ... <CODE>TRn</CODE> is mapped to
<PRE>
TYPE [T] = BRANDED OBJECT END;
TYPE [T]__((TR1)) = [T] BRANDED OBJECT v: [[TR1]] END;
...
TYPE [T]__((TRn)) = [T] BRANDED OBJECT v: [[TRn]] END;
</PRE>
<P>
A declaration of an enumerated type named <CODE>T</CODE> in interface <CODE>I</CODE> containing values <CODE>V1</CODE>, ... <CODE>Vn</CODE> is mapped to <CODE>TYPE [T] = {[V1], ... [Vn]};</CODE>
<P>
The type <CODE>Ilu.Object</CODE> has slots named <CODE>ilu_is_surrogate</CODE>, <CODE>Ilu_Get_Server</CODE>, <CODE>Ilu_Get_Type</CODE>, and <CODE>Ilu_Close_Surrogate</CODE>.  Method names <CODE>M</CODE> are translated to <CODE>[M]</CODE>.  For each object type <CODE>T</CODE>, the Modula-3 interface includes auxiliary procedures named <CODE>Ilu_Sbh_Import__[T]</CODE>, <CODE>Ilu_Name_Import__[T]</CODE>, and <CODE>Ilu_Get_Type__[T]</CODE>.
<P>
<P>Go to the <A HREF="manual_20.html">previous</A>, <A HREF="manual_22.html">next</A> section.<P>
