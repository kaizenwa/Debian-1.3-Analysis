<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Using ILU with Microsoft Windows</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_7.html">previous</A>, <A HREF="manual_9.html">next</A> section.<P>
<H1><A NAME="SEC155" HREF="manual_toc.html#SEC155">Using ILU with Microsoft Windows</A></H1>
<P>
Note:  In this document, when you see a reference to Windows NT, it also applies to Windows 95
(unless otherwise stated).
<P>
<H2><A NAME="SEC156" HREF="manual_toc.html#SEC156">Prerequisites for using ILU with Microsoft Windows</A></H2>
<P>
<H3><A NAME="SEC157" HREF="manual_toc.html#SEC157">Using ILU applications on Windows NT and Windows 95</A></H3>
<P>
Windows must be set up to use <CODE>TCP/IP</CODE>. Use the <CODE>Network Configuration
and Control</CODE> Applet under the Windows NT control panel to install and
configure your <CODE>TCP/IP</CODE> setup.  For Windows 95, use the <CODE>Network</CODE> applet. 
(See your Windows documentation for further
details.) Try all the usual <CODE>TCP/IP</CODE> applications (e.g. <CODE>ping</CODE>, <CODE>ftp</CODE>, <CODE>telnet</CODE>) 
to ensure your <CODE>TCP/IP</CODE> is working properly.
 
You will also need the redistributable Microsoft C Runtime dynamic link
library for NT (<TT>`MSVCRT20.DLL'</TT> if using Visual C++ 2.0 or <TT>`MSVCRT40.DLL'</TT> if using
Visual C++ 4.0) on the system.  The Visual C++ 
redistributable files are located in the <TT>`\MSVC20\REDIST'</TT> directory on the
Visual C++ Version 2.0 CD-ROM disc, or in the <TT>`\MSDEV\REDIST'</TT> directory on the Visual C++
4.0 CD-ROM.  Note there are different runtime DLL
files depending on whether you're on Windows NT or on Windows 3.1 with Win32s. Be sure
you use the one for Windows NT when on NT.
<P>
<STRONG>Be careful to use the right Visual C++ runtime DLL.  In particular,
Windows 95 ships with one version of the DLL in the <TT>`\WINDOWS\SYSTEM'</TT> directory,
since many of the Windows 95 system applets are written with Visual C++.</STRONG>
<P>
<H3><A NAME="SEC158" HREF="manual_toc.html#SEC158">Prerequisite software to use AND develop ILU applications on Windows NT and 95.</A></H3>
<P>
This release of ILU for Windows NT was developed with Microsoft Visual 
C++ Version 2.0, on Windows NT 3.5, and was built
 on Windows 95 and NT under Visual C++ 2.0 and 4.0.  It has not been tried with any other 
compiler or version of NT.	The ILU runtime DLLs for NT are 32 bit, and
a 32 bit compiler is needed to develop applications that use them. If
you succeed in building ILU or ILU applications for NT with a compiler other 
than Microsoft Visual C++ 2.0 or 4.0, please report your findings.  We simply haven't had
time to test ILU with other C or C++ compilers with Windows.
<P>
<H3><A NAME="SEC159" HREF="manual_toc.html#SEC159">Prerequisite software to use ILU applications on Windows 3.1</A></H3>
<P>
You must have a Winsock compliant <CODE>TCP/IP</CODE> stack  installed and operating
on your system. This release of ILU for Windows has been tested only
on Windows for Workgroups (Windows 3.11) with Microsoft <CODE>TCP/IP</CODE>.  You can
obtain Microsoft's <CODE>TCP/IP</CODE> by anonymous ftp as
<CODE>ftp://ftp.microsoft.com/Softlib/MSLFILES/WFWT32.EXE</CODE>
Follow the directions supplied within that file to install and configure 
your <CODE>TCP/IP</CODE> setup. Try all the usual <CODE>TCP/IP</CODE> applications 
(e.g. <CODE>ping</CODE>, <CODE>ftp</CODE>, <CODE>telnet</CODE>) 
to ensure your <CODE>TCP/IP</CODE> is working properly.
<P>
<H3><A NAME="SEC160" HREF="manual_toc.html#SEC160">Prerequisite software to use AND develop ILU applications on Windows 3.1</A></H3>
<P>
The ILU C and C++ stubbers are WIN32 applications.  In order to run them,
you must have Microsoft Win32s installed on your system.  Microsoft Win32s 
is available via anonymous ftp as
<CODE>ftp://ftp.microsoft.com/Softlib/MSLFILES/PW1118.EXE</CODE>.
<P>
You also need to have a Winsock header file (<TT>`winsock.h'</TT>) and export library (<TT>`winsock.lib'</TT>).
For development of ILU the same header file as supplied with Microsoft Visual 
C++ 2.0 was used.  The 
<CODE>implib</CODE> utility was run on the <TT>`WINSOCK.DLL'</TT> that came with Microsoft's <CODE>TCP/IP</CODE> to create 
the export library (<TT>`WINSOCK.LIB'</TT>).  For this release, the header file and library distributed
with Visual C++ 1.52 was also tested.
<P>
You will need the redistributable Microsoft C Runtime Dynamic Link
Library for Win32s (<TT>`MSVCRT20.DLL'</TT>) on the system in order to run the 
stubbers. All of the Visual C++ redistributable files for WIN32s are located in the 
<TT>`\WIN32S\REDIST'</TT> directory on the Visual C++ Version 2.0 CD-ROM.  Note there are 
different <TT>`MSVCRT20.DLL'</TT> files depending on whether you're on Windows NT or on
Windows 3.1 with Win32s.  Also, keep in mind that if you rebuild ILU yourself, you should use
the Runtime DLL that ships with your copy of Microsoft Visual C++.  If you recompile
ILU with Visual C++ 4.0, use the DLL from your Visual C++ 4.0 CD-ROM.
Mixing ILU and Microsoft DLLs that aren't the same version will definitely cause you problems.
Be sure you use the one for Windows Win32s when on Windows 3.1.
<P>
Finally, don't be confused by the stubber names.  While WIN32s will load the Windows NT version
of the stubbers, they won't run.  The WIN32s stubbers all end with 32W in their name, while the NT
stubbers are just called <CODE>c-stubber</CODE> and <CODE>c++-stubber</CODE>.
<P>
<H2><A NAME="SEC161" HREF="manual_toc.html#SEC161">Installation</A></H2>
<P>
ILU comes prebuilt for Windows NT and Windows 3.1. For the current release of ILU,
a single <TT>`.ZIP'</TT> file is the prebuilt version.  Since some of the files meant for NT use long file names, 
you'll see the 8.3 filename mapping of these on a Windows 3.1 machine (FAT file system).  The <TT>`.ZIP'</TT>
file is created with Nico Mak Computing's <CODE>WINZIP</CODE>, which allows long file names and is available for all versions
of Windows.  However, if you only have <CODE>PKZIP</CODE>, you should be able to extract the files from the
<TT>`.ZIP'</TT> with no problems.  Just make sure you use the <I>-d</I> when unzipping so that <CODE>PKZIP</CODE> will preserve
the directory structure contained within the <TT>`.ZIP'</TT> file.
<P>
Determine where you wish to install
ILU, e.g. <TT>`C:\ILUWIN'</TT>.  Set the environment variable <VAR>ILUHOME</VAR> to this directory (<VAR>ILUHOME</VAR> is needed
for building the examples).  Unpack the distribution into your installation directory using 
<CODE>pkzip -d iluwin20.zip</CODE>.  You should now have subdirectories in <VAR>ILUHOME</VAR> called <TT>`bin'</TT>, 
<TT>`examples'</TT>, <TT>`include'</TT>, <TT>`interfaces'</TT> 
and <TT>`lib'</TT>. 
<P>
If you'll be developing ILU apps, or building the examples, set the environment 
variable <VAR>ILUPATH</VAR> to include <TT>`<VAR>ILUHOME</VAR>\interfaces'</TT> (or <TT>`<VAR>ILUHOME</VAR>\intrface'</TT> for Windows 3.1 setups).
<VAR>ILUPATH</VAR> is the path of directories where interface (<TT>`.isl'</TT>) files can be found.  For example,
setting <VAR>ILUPATH</VAR> to <TT>`.;C:\ILUWIN\INTERFACES'</TT> will cause ILU stubbers to look for interfaces
first in the current directory, then in <TT>`C:\ILUWIN\INTERFACES'</TT>.
  
Add the <TT>`<VAR>ILUHOME</VAR>\bin'</TT> directory to your <VAR>PATH</VAR> environment variable.
<P>
Determine what common directory share will be used for your applications to publish
information about ILU objects.  This will commonly be a directory that is exported from 
a file server and shared by all the systems.  Set the environment variable 
<VAR>ILU_BINDING_DIRECTORY</VAR> to this directory e.g. <CODE><VAR>ILU_BINDING_DIRECTORY</VAR>=f:\iluwin\bindings</CODE>.  
If you do not set this, ILU will default to <TT>`\ilu\interfaces'</TT>.
<P>
<H2><A NAME="SEC162" HREF="manual_toc.html#SEC162">Building ILU</A></H2>
<P>
(For those who just *must* have and build the source! :-)
<P>
If you wish to build the ILU system from source, begin by obtaining the source distribution 
(<TT>`ilu.tar.gz'</TT>).  There is no separate source tree for the Windows version; the same source code
is used for both Unix and Windows.  Set <VAR>ILUHOME</VAR> to where you will
want ILU to be installed.
Determine where you wish to install the ILU source, and set the environment 
variable <VAR>ILUSRC</VAR> to that directory e.g. <TT>`<VAR>ILUHOME</VAR>\src'</TT>. Unpack the
distribution into that
directory.  Change to the <VAR>ILUSRC</VAR> directory.  Having previously installed Visual
C++, perform 
<P>
<PRE>
&#62; <STRONG>nmake -f ilunt35.mak</STRONG>
</PRE>
To subsequently install into <VAR>ILUHOME</VAR>, perform 
<P>
<PRE>
&#62; <STRONG>nmake -f ilunt35.mak install</STRONG>
</PRE>
Note that the default is to build a 'release' version.  If you wish to build a 
'debug' version perform 
<P>
<PRE>
&#62; <STRONG>nmake -f ilunt35.mak CFG="Win32 Debug"</STRONG>
</PRE>
To clean up after installation perform 
<P>
<PRE>
&#62; <STRONG>nmake -f ilunt35.mak clean</STRONG>
</PRE>
<P>
When bulding the debug versions of the c, c++, and kernel runtimes, the values of the environment variables,
<VAR>ILU_DEBUG_CFLAGS</VAR> and <VAR>ILU_DEBUG_CPPFLAGS</VAR> are passed to the c and c++ compiler command 
lines respectively.  This allows the builder to do things like creating source browser files, e.g. 
set ILU_DEBUG_CFLAGS=/FR"/ilu/browsefiles/", set ILU_DEBUG_CPPFLAGS=/FR"/ilu/browsefiles/".
<P>
<STRONG>Note: "make clean" does not work across all versions of Windows.  In particular, it will not work on
any other system besides Windows NT.  If you are using Windows 95, just remove all occurrences of
the <TT>`WinDebug'</TT>, <TT>`WinDebugW'</TT>, <TT>`WinRel'</TT>, and <TT>`WinRelW'</TT> directories in the source tree and examples
directories.</STRONG>
<P>
The Windows 3.1 version of ILU is also built on Windows NT.  Ensure that you've installed
Visual C++ 1.5.  Edit the file <TT>`<VAR>ILUSRC</VAR>\iluwin31.mak'</TT>	to reflect the locations of your
Visual C++ 1.5. components. Note that you must set the <VAR>WSOCKHDR</VAR> environment var
before running this makefile.  This variable should be set to the location of your 
winsock header file (typically named <TT>`WINSOCK.H'</TT>). Using the Visual C++ 1.5 <CODE>nmake</CODE>
utility, perform
<P>
<PRE>
&#62; <STRONG>nmake -f iluwin31.mak</STRONG>
</PRE>
<P>
(or 
<P>
<PRE>
&#62; <STRONG>nmake -f iluwin31.mak DEBUG=1</STRONG>
</PRE>
<P>
if you wish to build a debug version.
<P>
Note:  The stubbers are WIN32 applications and can only be built under Visual C++ 2.0 or 4.0
on Windows NT. It should be possible to rebuild the runtime under Windows 3.1 though.
<P>
To subsequently install into <VAR>ILUHOME</VAR>, perform 
<P>
<PRE>
&#62; <STRONG>nmake -f iluwin31.mak install</STRONG>
</PRE>
 
To clean up after installation perform 
<P>
<PRE>
&#62; <STRONG>nmake -f iluwin31.mak clean</STRONG>
</PRE>
<P>
Note that it is normal to see a number of compiler warnings during the ILU build process.
 
<P>
<H2><A NAME="SEC163" HREF="manual_toc.html#SEC163">Building the examples</A></H2>
<P>
To build the examples, cd to <TT>`<VAR>ILUHOME</VAR>\examples'</TT>.  Ensure that you have set <VAR>ILUPATH</VAR>
as previously discussed. 
<P>
Note:  It is important to note that the current versions of the Windows makefiles do not
execute the stubbers before compiling the actual programs.  Be sure you run the stubbers yourself before
attempting to build the examples, or you will get mysterious "don't know how to make" errors on header
files that don't exist yet because the stubbers create them.  The Windows 3.1 stubbers can be
executed via the batch file mentioned in the paragraphs below.
<P>
For Windows NT examples, perform 
<P>
<PRE>
&#62; <STRONG>nmake -f iluwinnt.mak</STRONG>
</PRE>
<P>
If you wish to build a 'debug' version perform 
<P>
<PRE>
&#62; <STRONG>nmake -f ilunt35.mak CFG="Win32 Debug"</STRONG>
</PRE>
<P>
This will create the example NT executables
in subdirectories of the <TT>`example'</TT> subdirectories, called <TT>`WinRel'</TT> and <TT>`WinRelW'</TT> (or
<TT>`WinDebug'</TT> and <TT>`WinDebugW'</TT> if you built a debug release) which correspond to the non-Windows and
Windows versions of the examples.
<P>
To build the Windows 3.1 examples, edit the makefile <TT>`<VAR>ILUHOME</VAR>\examples\iluwin31.mak'</TT>
to reflect the locations of your Visual C 1.5 components. Note that you must set <VAR>WSOCKLIB</VAR>
and <VAR>WSOCKHDR</VAR> environment vars before running this makefile.  These variables should be
set to the location of your winsock export library (<TT>`WINSOCK.LIB'</TT>) and winsock header file
(<TT>`WINSOCK.H'</TT>) respectively.
<P>
For the Windows 3.1 examples, there are two situations.  Building them on an Windows NT machine,
and building them on a Windows 3.1 machine.  Note that Windows 3.1 example executables 
appear directly in the <TT>`examples'</TT> subdirectory.
<P>
If you are building them on an NT machine,
cd to <TT>`<VAR>ILUHOME</VAR>\examples\test1'</TT> run the batch files <TT>`tstcw16.bat'</TT> and <TT>`tstcpw16.bat'</TT>.  This
uses the windowed versions of the stubbers to produce the C and C++ stubs for the 
Windows 3.1 examples. 
(Note we could have just as well used the non Windows versions of the stubbers (sans the
-batch switch you can see in the batch file.) to do this as well, since the output of the Windows 
stubbers and the WIN32 stubbers is
identical.  
<P>
If you are building on a Windows 3.1 machine, you can't run the stubbers this way since
you cannot launch Windows applications from a DOS box under Windows 3.1. There are some 
public domain (e.g. <TT>`run'</TT> by Frits Wiarda (<TT>`run18.zip'</TT>)) and shareware (e.g. <TT>`unixcorn'</TT> 
by Randall Spangler (<TT>`unixcn20.zip'</TT>) $10) utilities that will let you launch Windows apps from
a Windows 3.1 DOS box. Unixcorn is probably the better bet since it 
provides an option to wait till the Windows app actually returns.  These utilities
should allow you to run the windowed stubbers from batch and make files. Visual C++ 1.5 also comes with a program
called <TT>`WXServer'</TT> that allows you to invoke Windows apps from a DOS box.
<P>
(Since the following procedure is tedious, the Win3.1 stubs are already included with the 
distribution.)
<P>
To create the stubs, you'll have to manually run the C stubber (<TT>`cstub32w.exe'</TT>)
and C++ stubber (<TT>`cpstb32w.exe'</TT>) using the same arguments you see in the batch files, only 
omitting the -batch switch.	When the stubber window appears, you'll also see a file
selection box.  This is used to set the default drive and directory for the stubber.
Choose any file from the <TT>`<VAR>ILUHOME</VAR>\examples\test1'</TT> directory.  Next, the main window
will prompt you for arguments.  Using the batch file contents as a guide, enter the appropriate 
arguments for each of the 3 <TT>`.isl'</TT> files. For example,
<P>
<PRE>
<STRONG> -tname t1true -sname t1surrgt -hname t1hdr -cname t1comm -hdrmap test1h.map Test1.isl</STRONG>
</PRE>
<P>
So in all you'll run <TT>`cstub32w.exe'</TT>
3 times, once for each of <TT>`Test1.isl'</TT> <TT>`Test2.isl'</TT> and <TT>`Test3.isl'</TT>, and <TT>`cpstb32w.exe'</TT>
3 times, once for each of <TT>`Test1.isl'</TT> <TT>`Test2.isl'</TT> and <TT>`Test3.isl'</TT>. After doing this a few
times, you will probably <EM>want</EM> to go get <TT>`unixcorn'</TT>!
<P>
Note that it is normal to see a number of compiler warnings during the examples
build process.
<P>
<H2><A NAME="SEC164" HREF="manual_toc.html#SEC164">Running the examples</A></H2>
<P>
Ensure that you have set <VAR>ILU_BINDING_DIRECTORY</VAR> as previously discussed.
The non-Windows NT examples operate just like their
Unix counterparts.  The Windows examples are simple Windows versions of the same programs.
To execute them, launch the executables (from the Windows File Manager, a command prompt (if you
are running Windows NT or 95, or
whatever), and choose the 'Run' entry from the 'Action' menu.
<P>
<H2><A NAME="SEC165" HREF="manual_toc.html#SEC165">Developing Windows Applications with ILU</A></H2>
<P>
The basic process for using ILU in a Windows application is simple.  You either write a new
interface description or use an existing one.  You run the stubbers against the interface description
to generate stub code.  You write calls to the methods exported from the interface in your application,
or implement the object type in your application, depending on whether you're using the module,
or providing it.  Finally, you link your application code together with the generated stub code
and the ILU libraries.
<P>
<H3><A NAME="SEC166" HREF="manual_toc.html#SEC166">Running the stubbers</A></H3>
<P>
There are console and windowed versions of the stubbers and <CODE>islscan</CODE> program. The
console versions can only be used on NT. The windowed versions are meant primarily 
to be used on Windows 3.1 machines with WIN32s, although they can also be used on Windows NT.
<P>
Prior to this release, the stubbers had a number of switches as described in the ILU
reference manual.  These switches are still valid, but a number of new switches have
been added.  These new switches are primarily intended to accomodate use on a FAT
file system, where filenames are restriced to the 8.3 form. Normally, the stubbers
produce files that are based on the name of the interface being processed, appended
with some extension (e.g. <TT>`test1-common.c'</TT>).  However, this does not fit the 8.3 restriction.
<P>
The new switches for the <CODE>c-stubber</CODE> are
<P>
<UL>
<LI><CODE>-tname TRUEFILENAME</CODE>
<LI><CODE>-sname SURROGATEFILENAME</CODE>
<LI><CODE>-hname HEADERFILENAME</CODE>
<LI><CODE>-cname COMMONFILENAME</CODE>
</UL>
<P>
and the new switches for the <CODE>c++-stubber</CODE> are
<P>
<UL>
<LI><CODE>-hname HEADERFILENAME</CODE>
<LI><CODE>-sname STUBSFILENAME</CODE>
<LI><CODE>-cname CLIENTCOMMONFILENAME</CODE>
</UL>
<P>
allow you to specify exactly what the corresponding files should be named.
<P>
Because you can now specify the header filenames, there must be some means for the stubber
to know what header is associated with what interface. Both stubbers also have the new switch
<UL>
<LI><CODE>-hdrmap INTERFACEHEADERTRANSLATIONFILE</CODE>
</UL>
<P>
This switch specifies a mapping file from interface names to the header file that is
to be associated with the interface. See the files (in <TT>`<VAR>ILUHOME</VAR>\examples'</TT>) called
<TT>`tstcw16.bat'</TT> and <TT>`test1h.map'</TT> for a C based example, and <TT>`tstcpw16.bat'</TT> and <TT>`test1hh.map'</TT> for
a C++ based example of the use of these new switches.
<P>
The windowed stubbers also accept an additional switch, <I>-batch</I>, meant to facilitate
their use from a command line (as you might use in a makefile or batch file).
If this switch is used, it must be the first thing on the command line.  If there is no
<I>-batch</I> switch, the windowed stubber will pause with its window on the screen to allow
the user to view the output.  If the <I>-batch</I> switch is used and the stubber is 
successful, the window will dissappear and the stubber will exit.  If the stubber
is unsuccessful, the stubber will pause with its window on the screen to allow
the user to view the output of the unsuccessful stubbing attempt.
 
<P>
<H3><A NAME="SEC167" HREF="manual_toc.html#SEC167">Console Applications (Windows NT only)</A></H3>
<P>
Ensure that <VAR>WIN32</VAR> is defined to the preprocessor when building a 32 bit ILU application.
This is normally set by default by Visual C++, but you should verify.
<P>
Link with the non-Windows (console) versions of the libraries for Windows NT console apps.
 You need
to link with the language specific runtime, the kernel runtime, and the winsock library.
<P>
Set the Visual C++ 2.0 code generation compiler option to use the Multithreaded using DLL C 
runtime on Windows NT. This is <EM>very</EM> important.
<P>
There is NO need to call <CODE>ilu_StartWinsock</CODE> for a Windows NT ILU app.  (It is taken care of for
you internally in the runtime DLL process attach code). 
<P>
<H3><A NAME="SEC168" HREF="manual_toc.html#SEC168">Windows Applications</A></H3>
<P>
We suggest you review and understand the test1 examples before you try to build a windowed ILU application.
This section tries to highlight some of the 
<EM>important</EM> points.  Admittedly, the Windows examples are simple and crude as Windows
apps go, 
but they illustrate what you need to do in an application.
<P>
<H3><A NAME="SEC169" HREF="manual_toc.html#SEC169">WINIO</A></H3>
<P>
ILU was originally developed for Unix machines where there is always a notion of 
standard input and output.  Error and Debug messages from the ILU runtime are
sent to standard output.  With Windows NT console applications, this same model
is present.  However with Windows 3.1 applications there is no notion of a console to 
which standard input and output can be applied (although under Windows NT you can programatically
create a console; that is not addressed here). To provide a place for the ILU runtime
to write standard output, the winio library is used.  The winio library in ILU is an extension
of the original very useful utility by Dave Maxey and Andrew Schulman - discussed in the Microsoft 
Systems Journal, 1991 #4 (July-Aug). When used properly, it causes an additional window
to appear along with your application window, to which ILU runtime standard output
(and yours too if you want to use a few printf's) is sent. Try setting <VAR>ILU_DEBUG</VAR> (as
described in the ILU Reference manual) and you'll see the debug output get sent to the 
winio console window.  If you make any nifty mods to this helpful library please pass 
them on!
<P>
To use the winio library, be sure to define <CODE>_WINIO</CODE> to the preprocessor when building a 
Windows ILU application, and tell the linker to include the winio library. You'll also
likely want an icon for the console icon.  This icon should be called <VAR>WINIO_ICON</VAR>.
That is, you'll have an line in your resource file  (.rc file) like:
<P>
<PRE>
WINIO_ICON              ICON    DISCARDABLE     "clnconsl.ico"
</PRE>
<P>
Your <CODE>WinMain</CODE> function will also contain a call (probably before you do your <CODE>ShowWindow</CODE> call)
to create the console window that looks something like:
<P>
<PRE>
winio_console(hInstance, hPrevInstance, nCmdShow, 0, "clientw Console");
</PRE>
<P>
See the <TT>`WINIO.H'</TT> header file for a description of winio functionality.  For more information,
see the Microsoft Systems Journal, 1991 #4 (July-Aug), and the ILU winio source code.
<P>
<H3><A NAME="SEC170" HREF="manual_toc.html#SEC170">Windows - NT Specific</A></H3>
<P>
It is very important to set the Visual C++ code generation compiler
option to use the Multithreaded DLL C 
runtime on Windows NT.
<P>
Ensure that <VAR>WIN32</VAR> is defined to the preprocessor when building a 32 bit ILU application.
This is normally set by default by Visual C++, but you should verify.
<P>
Link with the Windows versions of the libraries for Windows NT ILU apps. You need
to link with the language specific runtime, the kernel runtime, the winio library, 
and the winsock library.
<P>
There is <EM>no</EM> need to call <CODE>ilu_StartWinsock</CODE> for a Windows NT ILU app.  (It is taken care of for
you internally in the runtime DLL process attach code).
<P>
In C++ ILU apps, you'll be including <TT>`Windows.h'</TT>.  However, <TT>`Windows.h'</TT> includes <TT>`winspool.h'</TT> 
and this file #defines <CODE>AddPort</CODE> as <CODE>AddPortA</CODE>.  This interferes with <CODE>iluServer::AddPort()</CODE>, 
so you have to undefine it (temporarily at least).  See the <TT>`examples\test1\cppsrvrw.cpp'</TT>
file for an example.
<P>
<H3><A NAME="SEC171" HREF="manual_toc.html#SEC171">Windows - 3.1	Specific</A></H3>
<P>
Windows 3.1 applications <EM>must</EM> call <CODE>ilu_StartWinsock</CODE> before performing any ILU calls.
For C based apps this is done directly by your code.  For C++ based apps, a compiler pragma
must be used to ensure <CODE>ilu_StartWinsock</CODE> is called early in the static object 
initialization phase of program startup. 
<P>
Under WIN32, you never need the call to <CODE>ilu_StartupWinsock</CODE> since ILU
is implemented as a DLL, and DLLs under Windows NT have an entry that allows 
things to happen when a process attaches to the DLL.  It is at that point under win32
that the winsock startup is taken care of for you.  Under Wdows 3.1, ILU is in static
libraries, and there is no such mechanism.  It isn't a problem with the C 
runtime, since the app can call <CODE>ilu_StartupWinsock</CODE> before it performs any ILU
functions.  With the C++ runtime however, there are some static object initializers
that make use of winsock operations (and these are run before <CODE>WinMain</CODE> is even entered).
So we have to insure that <CODE>ilu_StartupWinsock</CODE> is somehow called before these other ILU
initializers.  We do this by having a static initializer ourselves that causes
<CODE>ilu_StartupWinsock</CODE> to be called, and we ensure that this happens before the ILU
initializers by using the Microsoft pragma <CODE>init_seg(lib)</CODE> (Note that the ILU initializers
occur in the 'user' part of the startup sequence.  See Microsoft Knowledge Base
artical PSS ID Number: Q104248 for more infomation on this static initializer ordering.)
For a Windows 3.1 C++ ILU app, you use something like:
<P>
<PRE>
#pragma init_seg(lib)     
/* initialize winsock when under WIN16 */
int g_i_force_initializer_run = ILU_StartupWinsock ();
</PRE>
<P>
See the <TT>`test1'</TT> examples, files <TT>`clntw.c'</TT> and <TT>`cppclntw.cpp'</TT>.
 	  
Use Large Memory Model for compiling / linking your 16 bit Windows 3.1 ILU apps. All the
libraries for Windows 3.1 are Large Model.  Do <EM>not</EM> mix memory models!  This will cause
you more grief than you've ever encountered.
<P>
<CODE>#define</CODE> <VAR>WIN16</VAR> to the preprocessor when building a 16 bit ILU application. Note that the
compiler does not automatically define this.
<P>
Link with the static Windows versions (there are no others) of the runtime libraries,
the winio library, and the winsock library for Windows apps.
<P>
<H3><A NAME="SEC172" HREF="manual_toc.html#SEC172">Message Loop</A></H3>
<P>
See the windowed test1 server examples for a simplistic timer based means of using ILU
in the presence of a Windows message loop. (<TT>`msgalarm.c'</TT>).  You'll want to do something
about the message loop since otherwise your Windows app won't service the GUI - it'll
just be blocked in an internal call to <CODE>select()</CODE> waiting to deal with ILU activity.
This simple timer approach makes use of the ability to associate an 'alarm' function
with the ILU mainloop.  When the alarm goes off (the example uses every 500 milliseconds),
the alarm function processes any Windows messages that are waiting, then sets the
alarm for another period.
  
Note that the test1 examples were developed with Microsoft's <CODE>TCP/IP</CODE> for Windows for 
Workgroups.  Some of the behavior may be different under a different winsock implementation
(especially with respect to message dispatch during <CODE>select()</CODE> calls). If so, please let us
know.
<P>
<H2><A NAME="SEC173" HREF="manual_toc.html#SEC173">Files in the distribution</A></H2>
<P>
Note:  this list is in the process of being updated.  While there are errors in it, the distribution
.ZIP file should not be missing any files.  When ILU 2.0 becomes finalized, this list will be
corrected.
<P>
bin directory
-------------
<UL>
<LI><TT>`c++-stubber.exe'</TT> -- console C++ stubber for NT
<LI><TT>`c-stubber.exe'</TT> -- console C stubber for NT
<LI><TT>`cpstb32w.exe'</TT> -- windowed C++ stubber for NT or Windows 3.1 with Win32s
<LI><TT>`cstub32w.exe'</TT> -- windowed C stubber for NT or Windows 3.1 with Win32s
<LI><TT>`ilu32.dll'</TT> -- kernel runtime DLL for NT console apps
<LI><TT>`ilu32w.dll'</TT> -- kernel runtime DLL for NT window apps
<LI><TT>`iluc32.dll'</TT> -- C runtime DLL for NT console apps
<LI><TT>`iluc32w.dll'</TT> -- C runtime DLL for NT window apps
<LI><TT>`ilucp32w.dll'</TT> -- C++ runtime DLL for NT window apps
<LI><TT>`ilucpp32.dll'</TT> -- C++ runtime DLL for NT console apps
<LI><TT>`iscan32w.exe'</TT> -- windowed ISL scanner for NT or Windows 3.1 with Win32s
<LI><TT>`islscan.exe'</TT> -- console ISL scanner for NT
<LI><TT>`parser32.dll'</TT> -- parser DLL for NT console stubbers
<LI><TT>`parsr32w.dll'</TT> -- parser DLL for NT or Windows 3.1 with Win32s windowed stubbers
<LI><TT>`winio32w.dll'</TT> -- DLL to provide a window for stdio on NT or Windows 3.1 with Win32s
</UL>
<P>
lib directory
<P>
(Note unlabeled entries are the import export libraries for their 
counterparts in the bin directory)
<P>
<UL>
<LI><TT>`ilu16W.LIB'</TT> -- kernel runtime large model static lib for Windows 3.1 apps
<LI><TT>`ilu32.exp'</TT>
<LI><TT>`ilu32.lib'</TT>
<LI><TT>`ilu32w.exp'</TT>
<LI><TT>`ilu32w.lib'</TT>
<LI><TT>`iluC16W.LIB'</TT> -- C runtime large model static lib for Windows 3.1 apps
<LI><TT>`iluc32.exp'</TT>
<LI><TT>`iluc32.lib'</TT>
<LI><TT>`iluc32w.exp'</TT>
<LI><TT>`iluc32w.lib'</TT>
<LI><TT>`iluCP16W.LIB'</TT> -- C++ runtime large model static lib for Windows 3.1 apps
<LI><TT>`ilucp32w.exp'</TT>
<LI><TT>`ilucp32w.lib'</TT>
<LI><TT>`ilucpp32.exp'</TT>
<LI><TT>`ilucpp32.lib'</TT>
<LI><TT>`parser32.exp'</TT>
<LI><TT>`parser32.lib'</TT>
<LI><TT>`parsr32w.exp'</TT>
<LI><TT>`parsr32w.lib'</TT>
<LI><TT>`WINIO16W.LIB'</TT> -- Large model static lib to provide a window for stdio on Windows 3.1
<LI><TT>`winio32w.exp'</TT>
<LI><TT>`winio32w.lib'</TT>
</UL>
<P>
include directory  (header files need for building ILU apps)
<P>
<UL>
<LI><TT>`ilu.H'</TT>
<LI><TT>`ilubasic.h'</TT>
<LI><TT>`iluchdrs.h'</TT>
<LI><TT>`iludebug.h'</TT>
<LI><TT>`iluerror.h'</TT>
<LI><TT>`iluerrs.h'</TT>
<LI><TT>`iluhash.h'</TT>
<LI><TT>`iluntrnl.h'</TT>
<LI><TT>`iluptype.h'</TT>
<LI><TT>`iluxport.h'</TT>
<LI><TT>`winio.h'</TT>
<LI><TT>`winiodef.h'</TT>
</UL>
<P>
interfaces (or intrface on Win3.1)
<P>
<UL>
<LI><TT>`ilu.isl'</TT>
</UL>
<P>
examples/timeit (currently only as console apps for Win NT)
<P>
<UL>
<LI><TT>`client.c'</TT>
<LI><TT>`CLIENT.MAK'</TT>
<LI><TT>`iluNT35.MAK'</TT>
<LI><TT>`README'</TT>
<LI><TT>`server.c'</TT>
<LI><TT>`SERVER.MAK'</TT>
<LI><TT>`timeit.isl'</TT>
</UL>
<P>
examples/test1
<P>
<UL>
<LI><TT>`clnconsl.ico'</TT>
<LI><TT>`clnt.c'</TT>
<LI><TT>`CLNT.MAK'</TT>
<LI><TT>`clntw.c'</TT>
<LI><TT>`clntw.ico'</TT>
<LI><TT>`CLNTW.MAK'</TT>
<LI><TT>`clntw.rc'</TT>
<LI><TT>`CLNTW16.DEF'</TT>
<LI><TT>`CLNTW16.MAK'</TT>
<LI><TT>`clntw16.rc'</TT>
<LI><TT>`CPLNTW16.DEF'</TT>
<LI><TT>`CPLNTW16.MAK'</TT>
<LI><TT>`cppclnt.cpp'</TT>
<LI><TT>`CPPCLNT.MAK'</TT>
<LI><TT>`CPPCLNTW.CPP'</TT>
<LI><TT>`CPPCLNTW.MAK'</TT>
<LI><TT>`cppsrvr.cpp'</TT>
<LI><TT>`CPPSRVR.MAK'</TT>
<LI><TT>`cppsrvrw.cpp'</TT>
<LI><TT>`CPPSRVRW.MAK'</TT>
<LI><TT>`CPSVRW16.DEF'</TT>
<LI><TT>`CPSVRW16.MAK'</TT>
<LI><TT>`iluNT35.MAK'</TT>
<LI><TT>`iluWIN31.MAK'</TT>
<LI><TT>`msgalarm.c'</TT>
<LI><TT>`README'</TT>
<LI><TT>`resource.h'</TT>
<LI><TT>`srvr.c'</TT>
<LI><TT>`SRVR.MAK'</TT>
<LI><TT>`srvrw.c'</TT>
<LI><TT>`srvrw.ico'</TT>
<LI><TT>`SRVRW.MAK'</TT>
<LI><TT>`srvrw.rc'</TT>
<LI><TT>`SRVRW16.DEF'</TT>
<LI><TT>`SRVRW16.MAK'</TT>
<LI><TT>`srvrw16.rc'</TT>
<LI><TT>`svrconsl.ico'</TT>
<LI><TT>`t1clicom.cpp'</TT>
<LI><TT>`t1comm.c'</TT>
<LI><TT>`t1hdr.h'</TT>
<LI><TT>`t1hdr.hh'</TT>
<LI><TT>`t1stubs.cpp'</TT>
<LI><TT>`t1surrgt.c'</TT>
<LI><TT>`t1true.c'</TT>
<LI><TT>`t2clicom.cpp'</TT>
<LI><TT>`t2comm.c'</TT>
<LI><TT>`t2hdr.h'</TT>
<LI><TT>`t2hdr.hh'</TT>
<LI><TT>`t2stubs.cpp'</TT>
<LI><TT>`t2surrgt.c'</TT>
<LI><TT>`t2true.c'</TT>
<LI><TT>`t3clicom.cpp'</TT>
<LI><TT>`t3comm.c'</TT>
<LI><TT>`t3hdr.h'</TT>
<LI><TT>`t3hdr.hh'</TT>
<LI><TT>`t3stubs.cpp'</TT>
<LI><TT>`t3surrgt.c'</TT>
<LI><TT>`t3true.c'</TT>
<LI><TT>`Test1.isl'</TT>
<LI><TT>`test1h.map'</TT>
<LI><TT>`TEST1HH.MAP'</TT>
<LI><TT>`Test2.isl'</TT>
<LI><TT>`Test3.isl'</TT>
<LI><TT>`TSTCPW16.BAT'</TT>
<LI><TT>`TSTCW16.BAT'</TT>
</UL>
<P>
<P>Go to the <A HREF="manual_7.html">previous</A>, <A HREF="manual_9.html">next</A> section.<P>
