<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Using ILU with Common Lisp</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_2.html">previous</A>, <A HREF="manual_4.html">next</A> section.<P>
<H1><A NAME="SEC52" HREF="manual_toc.html#SEC52">Using ILU with Common Lisp</A></H1>
<P>
This document is for the Common Lisp programmer who wishes to use 
ILU.  The first section explains the mappings from the ILU Interface 
Specification Language into the Common Lisp language, the second discusses 
concepts necessary for people exporting ILU modules from Common Lisp.  In 
general, people who need only to use pre-existing ILU modules should only need 
to read the first section.  You should understand the types and concepts 
supported by ILU before reading this document.  (See section <A HREF="manual_1.html#SEC1">ILU Concepts</A>.)
<P>
<H2><A NAME="SEC53" HREF="manual_toc.html#SEC53">ILU Mappings to Common Lisp</A></H2>
<P>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>
<H3><A NAME="SEC54" HREF="manual_toc.html#SEC54">Generating Common Lisp Surrogate and True Stubs</A></H3>
The program ILU <CODE>lisp-stubber</CODE>
<A NAME="IDX50"></A>
takes a interface specification (an <TT>`.isl'</TT> file) and generates lisp 
code to provide both client-side and server-side support for the interface.
The files are generated in the current working directory.
In particular, the following files are generated:
<P>
<UL>
<LI>
<TT>`<VAR>interface-name</VAR>-sysdcl.lisp'</TT> -- tells <CODE>PDEFSYS</CODE>
<A NAME="FOOT6" HREF="manual_foot.html#FOOT6">(6)</A> how to compile and load the other files.  It defines a Common Lisp module <CODE>:<VAR>&#60;interface&#62;</VAR></CODE>, which describes the code needed to support both surrogate and true use of the interface.  This file is often called a 
<A NAME="IDX51"></A>
<I>sysdcl</I> for the module.
<LI>
<TT>`<VAR>interface-name</VAR>-basics.lisp'</TT> -- contains lisp code needed by clients of the module; and
<LI>
<TT>`<VAR>interface-name</VAR>-server-procs.lisp'</TT> -- contains lisp code needed by module implementations.
</UL>
<H3><A NAME="SEC55" HREF="manual_toc.html#SEC55">Packages &#38; Symbols</A></H3>
<P>
Runtime code is in the Common Lisp package <CODE>ilu</CODE>.
<P>
Names from interface specifications are transformed into Lisp names
(case-insensitive) by inserting hyphens at lower-to-upper case transitions.
Hyphens that are already present are maintained as is.<A NAME="FOOT7" HREF="manual_foot.html#FOOT7">(7)</A>
<P>
A separate package is defined for each interface with
<CODE>defpackage</CODE>.  The name of this package
is taken from the name of the interface.  This package uses the packages 
<CODE>common-lisp</CODE> and <CODE>ilu</CODE>.  The Common Lisp
names of all entities defined in the ISL
are exported from the package, including types, classes, constants,
accessors, type predicates,
generic functions, exceptions, etc. Such symbols are also shadowed, to avoid 
conflicts with used packages. For example, given the following interface:
<P>
<PRE>
INTERFACE MyInterface END;
EXCEPTION TotalLoser : Person;
TYPE Person = OBJECT
  METHODS
     FriendsP (someone : Person) : Boolean
       RAISES TotalLoser END
  END;
</PRE>
<P>
the stubber generates the following <CODE>defpackage</CODE>:
<P>
<PRE>
(defpackage :my-interface
  (:use :common-lisp :ilu)
  (:shadow #:total-loser #:person #:friends-p)
  (:export #:total-loser #:person #:friends-p))
</PRE>
<P>
This allows symbols defined in the <CODE>commonlisp</CODE> package
to be used by the automatically generated code in the generated package,
but it also means that the user needs to be careful about using any
generated package.  In general, we recommend that you explicitly specify
the full name of symbols from ILU interfaces.
<P>
<H3><A NAME="SEC56" HREF="manual_toc.html#SEC56">Types</A></H3>
<P>
ILU types appear in Common Lisp as follows:
<P>
<OL>
<LI>
Exceptions are represented with CL conditions, defined by <CODE>define-condition</CODE>.
All ILU conditions 
are subtypes of <CODE>ilu:rpc-exception</CODE>, which is a 
<CODE>serious-condition</CODE>. If a value is 
specified for an exception it may be accessed with
<CODE>ilu:exception-value</CODE> on the 
condition signalled.
<LI>
Constants are implemented in CL by a value of the 
appropriate type, defined with <CODE>defconstant</CODE>.
<LI>
Type aliases (one type name specified as another) are implemented 
with <CODE>deftype</CODE>.
<LI>
Sequences are implemented as <CODE>list</CODE>s, except for sequences of characters, which are implemented as <CODE>simple-string</CODE>s.
<LI>
BOOLEAN values are represented as normal Common Lisp logical
values, typically either <CODE>commonlisp:t</CODE> or <CODE>commonlisp:nil</CODE>.
<LI>
Arrays and sequences of CHARACTER (regular or SHORT) are implemented as
<CODE>simple-string</CODE>s.
<LI>
Arrays of bytes are implemented with objects of type
<CODE>(simple-array (unsigned-byte 8) (*))</CODE>.
<LI>
Other arrays are implemented as <CODE>simple-array</CODE>s.
<LI>
Unions are implemented as a cons'ed value, with the cdr containing
the union type discriminant, and the cdr containing the actual value.
<LI>
Enumerations are implemented with symbols, as in<BR>
<CODE>(deftype answer () `(member 'yes 'no 'maybe))</CODE>
<LI>
Record types are implemented with CL <CODE>defstruct</CODE>.
<LI>
Classes are implemented with CLOS <CODE>defclass</CODE>.
<P>
Private slots are created for methods which are specified as
<CODE>functional</CODE>, and the runtime caches the value of this method
in such slots after the first call to the method.
<P>
Methods always take as their first argument the object which they are a method 
on.  Subsequent arguments are those specified in the <TT>`.isl'</TT> file.
Methods that have <CODE>OUT</CODE> or <CODE>INOUT</CODE> arguments may return multiple
values.  In general, the parameters to a method are the <CODE>IN</CODE> and
<CODE>INOUT</CODE> parameters specified in the ISL interface, but not
the <CODE>OUT</CODE> parameters.  The return values from a method are the
specified return value for the ISL method, if any, followed
by the <CODE>INOUT</CODE> and <CODE>OUT</CODE> parameters for the method, if any, in
the order in which they appear in the ISL specification
of the method.
</OL>
<P>
<A NAME="IDX52"></A>
<H2><A NAME="SEC57" HREF="manual_toc.html#SEC57">Using a Module from Common Lisp</A></H2>
<P>
To use a module from Common Lisp, you must first have loaded
the PDEFSYS "system" that describes the module.  Typically,
for an ILU interface called <VAR>Foo</VAR>, the system
can be loaded by invoking <CODE>(pdefsys:load-system :foo)</CODE>.
Next, you must bind an instance of an object from that interface.
The most common way of doing this is to receive an instance
of an object from a method called on another object.  But to get the
first object exported
by that module, one can use either <CODE>ilu:sbh-&#62;instance</CODE> or
<CODE>ilu:lookup</CODE>.
<P>
<A NAME="IDX53"></A>
<U>Lisp Function:</U> <B>ilu:sbh->instance</B> <I>(<VAR>PUTATIVE-TYPE-NAME</VAR> <CODE>symbol</CODE>) (<VAR>SBH</VAR> <CODE>string</CODE>) &optional (<VAR>MOST-SPECIFIC-TYPE-ID</VAR> <CODE>simple-string</CODE> <CODE>mstid of specified PUTATIVE-TYPE</CODE>) => <CODE>ilu:rpc-object</CODE></I><P>
<P>
Accepts an ILU string binding handle and Common Lisp type name, and attempts to locally bind an instance of that type with the OID specified in the string binding handle.  If no such instance exists locally, a
surrogate instance is created and returned.  If a true instance exists
locally, that instance will be returned.
<P>
<A NAME="IDX54"></A>
<U>Lisp Function:</U> <B>ilu:lookup</B> <I>(<VAR>PUTATIVE-TYPE-NAME</VAR> <CODE>symbol</CODE>) (<VAR>OID</VAR> <CODE>simple-string</CODE>) => <CODE>(or nil ilu:rpc-object)</CODE></I><P>
<P>
This routine will find and return an object with the OID <VAR>OID</VAR>, if
such an object has been registered in the local domain via the ILU
simple binding protocol.  <A NAME="FOOT8" HREF="manual_foot.html#FOOT8">(8)</A>  See section <A HREF="manual_3.html#SEC59">Publishing</A>, for an example.
<P>
Various ILU attributes of an object type may be discovered at run time with the generic function <CODE>ilu:ilu-class-info</CODE>.
<P>
<A NAME="IDX55"></A>
<U>Lisp Function:</U> <B>ilu:ilu-class-info</B> <I>(<VAR>DISC</VAR> <CODE>(or ilu:ilu-object type-name)</CODE>) (<VAR>WHAT</VAR> <CODE>keyword</CODE>) => <CODE>(or string boolean list)</CODE></I><P>
<P>
This routine will return the specified piece of information about the ILU class
specified with <VAR>DISC</VAR>, which may be either a CLOS class name,
or an instance of the class, and with <VAR>WHAT</VAR>, which identifies which piece of information to
return.  <VAR>WHAT</VAR> may have the following values:
<UL>
<LI>
<CODE>:authentication</CODE> -- what kind of authentication, if any, is expected by the methods of this class
<LI>
<CODE>:brand</CODE> -- the brand of the object type, if any
<LI>
<CODE>:collectible-p</CODE> -- whether or not the object type participates in the ILU distributed GC
<LI>
<CODE>:doc-string</CODE> -- the doc string specified for the object type
<LI>
<CODE>:id</CODE> -- the ILU unique ID for the object type
<LI>
<CODE>:ilu-version</CODE> -- which version of ILU the stubber that generated the code for this object type came from
<LI>
<CODE>:methods</CODE> -- a list of the methods of the object type
<LI>
<CODE>:optional-p</CODE> -- whether values of this class are allowed to be <CODE>cl:nil</CODE> (a CORBA excrescence)
<LI>
<CODE>:name</CODE> -- the ILU name of the object type
</UL>
<P>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<H2><A NAME="SEC58" HREF="manual_toc.html#SEC58">Implementing a Module in Common Lisp</A></H2>
<P>
For each ILU class <CODE><VAR>interface</VAR>.<VAR>otype</VAR></CODE>,
ILU will define, in the file
<TT>`<VAR>interface</VAR>-server-procs.lisp'</TT>,
a CLOS class called <CODE><VAR>interface</VAR>:<VAR>otype</VAR>.IMPL</CODE>.
To implement a true object for <CODE><VAR>interface</VAR>.<VAR>otype</VAR></CODE>,
one should further subclass this CLOS class,
and override all of its methods.  In particular, do not let
any of the default methods for the class be called from your methods for it.
<P>
ILU supports,
in each address space, multiple instances of something called
a 
<A NAME="IDX58"></A>
<I>kernel server</I>, each of which in turn
supports some set of object instances.
A kernel server 
<A NAME="IDX59"></A>
<I>export</I>s its objects by making them available
to other modules.  It may do so via one or more 
<A NAME="IDX60"></A>
<I>port</I>s, which are
abstractly a tuple of (<VAR>rpc protocol</VAR>, <VAR>transport type</VAR>,
<VAR>transport address</VAR>).  For example, a typical port might
provide access to a kernel server's objects
via <CODE>(Sun RPC, TCP/IP, UNIX port 2076)</CODE>.  Another port on the
same kernel server might provide access to the objects via
<CODE>(Xerox Courier, XNS SPP, XNS port 1394)</CODE>.
<P>
When creating an instance of a true object, a kernel server for it,
and an instance id (the name by which the kernel server knows it) for
it must be determined.  These may be specified explicitly by use of the
keyword arguments to <CODE>commonlisp:make-instance</CODE>
<CODE>:ilu-kernel-server</CODE> and <CODE>:ilu-instance-handle</CODE>, respectively.  If they are
not specified explicitly,
the variable <CODE>ilu:*default-server*</CODE> will be bound,
and its value will be used; a default instance
handle, unique relative to the kernel server, will be generated.
<P>
A kernel server may be created by instantiating the class
<CODE>ilu:kernel-server</CODE>.  The keyword argument <CODE>:id</CODE> may
be specified to select a name for the server.  Note that ILU
object IDs, which consist of the kernel server ID, plus the instance
handle of the object on that server, must be unique "across space
and time", as the saying goes.  If no kernel server id is specified,
ILU will generate one automatically, using an algorithm
that provides a high probability of uniqueness.  If you explicitly
specify a kernel server ID, a good technique is to use a prefix or
suffix which uniquely identifies some domain in which you can assure
the uniqueness of the remaining part of the ID.  For example, when
using ILU at some project called NIFTY at some internet
site in the IP domain <CODE>department.company.com</CODE>, one might use
kernel server IDs with names like
<CODE>something.NIFTY.department.company.com</CODE>.
<P>
<PRE>
=&#62; <STRONG>(make-instance 'ilu:kernel-server :id "FOO-SERVER-1")</STRONG>
#&#60;ILU:KERNEL-SERVER "FOO-SERVER-1"&#62;
=&#62; <STRONG>(make-instance 'ilu:kernel-server)</STRONG>
#&#60;ILU:KERNEL-SERVER "121.2.100.231.1404.2c7577eb.3e5a28f"&#62;
=&#62;
</PRE>
<P>
<A NAME="IDX61"></A>
<U>{Lisp:</U> <B><CODE>cl:make-instance</CODE>}</B> <I>{ilu:kernel-server} &key {(id <CODE>string</CODE> <CODE>nil</CODE>)} {(unix-port <CODE>fixnum</CODE> <CODE>0</CODE>)} {(object-table <CODE>list of 2 elements</CODE> <CODE>nil</CODE>)} => <CODE>ilu:kernel-server</CODE></I><P>
<P>
Creates and returns an instance of <CODE>ilu:kernel-server</CODE>.  If <VAR>id</VAR> is specified, the server has that value for its server ID.  If <VAR>unix-port</VAR> is specified, the server attempts to `listen' on that UNIX port, if the notion of a UNIX port is applicable.  If <VAR>object-table</VAR> is specified, it must consist of a list of two functions.  The first function must take a string, which is the instance handle of a desired object on this kernel server, and return a value of type <CODE>ilu:ilu-true-object</CODE>.  The second funtion must free up any resources used by this object table.
<P>
To export a module for use by other modules,
simply instantiate one or more instances
of your subtypes of <CODE><VAR>interface</VAR>:<VAR>otype</VAR>.IMPL</CODE> (which
will inherit from <CODE>ilu:ilu-true-object</CODE>.
<P>
<PRE>
=&#62; <STRONG>(make-instance 'foo:my-bar.impl :ilu-kernel-server s)</STRONG>
#&#60;FOO:MY-BAR.IMPL 0x3b32e8 "1"&#62;
=&#62;
</PRE>
<P>
<A NAME="IDX62"></A>
<U>{Lisp:</U> <B><CODE>cl:make-instance</CODE>}</B> <I>{ilu:ilu-true-object} &key {(ilu-kernel-server <CODE>ilu:kernel-server</CODE> <CODE>nil</CODE>)} {(ilu-instance-handle <CODE>string</CODE> <CODE>nil</CODE>)} => <CODE>ilu:ilu-true-object</CODE></I><P>
<P>
Creates and returns an instance of <CODE>ilu:ilu-true-object</CODE>.  If <VAR>ilu-true-server</VAR> is specified, the instance is created on the specified server.  If <VAR>ilu-instance-handle</VAR> is specified, that instance handle is used.
<P>
The simplest Common Lisp "server" code would
look something like:
<P>
<PRE>
(defun start-server ()
  (make-instance 'foo:my-bar.impl))
</PRE>
<P>
which will create an instance of <CODE>FOO:MY-BAR.IMPL</CODE> and export it via
a default server.
<P>
It's also possible to find out who is making the call:
<P>
<A NAME="IDX63"></A>
<U>Lisp Variable:</U> <B>ilu:*caller-identity*</B><P>
<P>
The identity of the caller is bound to the special variable
<CODE>ilu:*caller-identity*</CODE>.  It is a string which begins with the name
of an identity scheme, followed by an identity in that scheme.  For example,
an identity in the SunRPC UNIX identity scheme would be something like
<CODE>"sunrpc-unix:2345,67@13.12.11.10"</CODE>
(i.e., <CODE>"sunrpc-unix:<VAR>&#60;uid&#62;</VAR>,<VAR>&#60;gid&#62;</VAR>@<VAR>&#60;hostname&#62;</VAR>"</CODE>).  If no
identity is furnished, a zero-length string is bound.
<P>
<H3><A NAME="SEC59" HREF="manual_toc.html#SEC59">Publishing</A></H3>
<P>
To enable users of your module find the exported objects, you may
register the string binding handle of the object or objects, along
with their type IDs, in any name service or registry that is convenient
for you.  In release 1.6 of ILU, we are supporting an experimental
simple binding method that allows you to "publish" an object,
which registers it in a domain-wide registry, and
then to withdraw the object, if necessary.  Potential clients can
find the string binding handle and type ID of the object by calling
a lookup function.  <STRONG>Note that this interface and service
is experimental, and may be supported differently in future releases
of the ILU system.</STRONG>
<P>
<A NAME="IDX64"></A>
<U>Lisp Function:</U> <B>ilu:publish</B> <I>(<VAR>OBJ</VAR> <CODE>ilu:rpc-object</CODE>) => <CODE>boolean</CODE></I><P>
<P>
Accepts an <CODE>ilu:rpc-object</CODE> instance and registers it with some
domain-wide registration service.  The object is known by its
<A NAME="IDX65"></A>
<P>
<I>object ID</I> (OID), which is composed of the ID of its kernel server, plus
a server-relative instance ID, typically composed as
<CODE><VAR>instance-ID</VAR>@<VAR>server-ID</VAR></CODE>.  Clients may find
the object by looking up the OID via the <CODE>ilu:lookup</CODE> function.
The function returns non-<CODE>cl:nil</CODE> if the publication succeeded.
<P>
<A NAME="IDX66"></A>
<U>Lisp Function:</U> <B>ilu:withdraw</B> <I>(<VAR>OBJ</VAR> <CODE>ilu:rpc-object</CODE>) => <CODE>boolean</CODE></I><P>
<P>
If <VAR>OBJ</VAR> is registered, and if it was published by the same
address space that is calling <CODE>withdraw</CODE>, its registration is
withdrawn.  The function returns non-<CODE>cl:nil</CODE> if the object
is no longer published.
<P>
If you wanted to create an instance, and publish it, the code for
starting a service might look something like this:
<P>
<PRE>
(defun start-server ()
  (let* ((ks (make-instance 'ilu:kernel-server
                ;; specify the service id
                :id "service.localdomain.company.com"))
         (si (make-instance 'foo:my-bar.impl
                ;; specify the server
                :ilu-kernel-server ks
                ;; specify the instance handle
                :ilu-instance-handle "theServer")))
    ;; the OID for "si" is now "theServer@service.localdomain.company.com"
    (ilu:publish si)
    si))
</PRE>
<P>
Someone who wanted to use this service could then find it with the following:
<P>
<PRE>
(defun find-server ()
  (ilu:lookup 'foo:bar "theServer@service.localdomain.company.com"))
</PRE>
<P>
<H3><A NAME="SEC60" HREF="manual_toc.html#SEC60">Debugging</A></H3>
<P>
To help with finding errors in your methods, the variable <CODE>*debug-uncaught-conditions*</CODE>
is provided.
<P>
<A NAME="IDX67"></A>
<U>Variable:</U> <B>ilu:*debug-uncaught-conditions*</B><P>
<P>
If <CODE>cl:t</CODE>, causes a server to invoke the debugger when an unhandled error in user code
is encountered, rather than the default action of signalling an exception back to the
caller.  The default value is <CODE>cl:nil</CODE>.
<P>
<H2><A NAME="SEC61" HREF="manual_toc.html#SEC61">Dumping an image with ILU</A></H2>
<P>
ILU has dynamic runtime state.  In particular, after it is
initialized, it uses several Common Lisp threads to maintain
part of its state, and may also keep open connections
on operating system communication interfaces.
If you wish to dump an image containing ILU,
you must dump the image before initializing the <CODE>ILU</CODE> module.
<P>
Initialization occurs automatically whenever a instance of <CODE>ilu:ilu-object</CODE>
or <CODE>ilu:rpc-server</CODE> is created.  Thus you should not create
any instances of either true or surrogate ILU objects before
dumping the image.  However, you may load all the interface code for any
interfaces that you are using, before dumping the image.
<P>
Initialization may also be accomplished by an explicit
call to <CODE>ilu:initialize-ilu</CODE>:
<P>
<A NAME="IDX68"></A>
<U>Lisp Function:</U> <B>ilu:initialize-ilu</B><P>
<P>
Initializes the <CODE>ILU</CODE> module.
<P>
You may check to see whether the system has been initialized by
examining the variable <CODE>ilu::*ilu-initialized*</CODE>, which is <CODE>t</CODE> iff
<CODE>ilu:initialize-ilu</CODE> has been invoked.
<P>
<H2><A NAME="SEC62" HREF="manual_toc.html#SEC62">The Portable DEFSYSTEM Module</A></H2>
<P>
ILU support uses a portable implementation
of <CODE>DEFSYSTEM</CODE> to specify modules to Common Lisp.
See section <A HREF="manual_18.html#SEC278">The ILU Common Lisp Portable DEFSYSTEM Module</A>,
for details of this system.
<P>
<H2><A NAME="SEC63" HREF="manual_toc.html#SEC63">ILU Common Lisp Lightweight Processes</A></H2>
<P>
ILU currently assumes the existence of lightweight process,
or thread, support in your Common Lisp implementation.
It uses these internally via a generic veneer, described
fully in section <A HREF="manual_19.html#SEC280">The ILU Common Lisp Lightweight Process System</A>.
<P>
<H2><A NAME="SEC64" HREF="manual_toc.html#SEC64">Porting ILU to a New Common Lisp Implementation</A></H2>
<P>
The Lisp support provided with ILU includes
support for the Franz Allegro Common Lisp 4.x implementation.
To use ILU with other Common Lisp implementations,
please see section <A HREF="manual_20.html#SEC305">Porting ILU to Common Lisp Implementations</A>.
<P>
<P>Go to the <A HREF="manual_2.html">previous</A>, <A HREF="manual_4.html">next</A> section.<P>
