<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Debugging ILU Programs</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_12.html">previous</A>, <A HREF="manual_14.html">next</A> section.<P>
<H1><A NAME="SEC226" HREF="manual_toc.html#SEC226">Debugging ILU Programs</A></H1>
<P>
This document describes some of the common errors that occur with the use of ILU,
and some techniques for dealing with them.
<P>
<H2><A NAME="SEC227" HREF="manual_toc.html#SEC227">C++ static instance initialization</A></H2>
<P>
Our support for C++ currently depends on having the constructors for all
static instances run before <CODE>main()</CODE> is called.  If your compiler or interpreter
doesn't support that, you will experience odd behavior.  The C++ language
does not strictly mandate that this initialization will be performed, but most compilers
seem to arrange things that way.  We'd like to see how many compilers <EM>do not</EM>;
if your's doesn't, please send a note to <CODE>ilu-bugs@parc.xerox.com</CODE> telling us
what the compiler is.
<P>
ILU uses the static-object-with-constructor trick to effect per-compilation-unit startup code.  In certain cases you'll want to ensure that a certain compilation unit's initialization is run before another's.  While C++ defines no standard way to do this, most compilers work like this: compilation units are initialized (static object construtors run) in the order in which they are given to the link-editor.  We (<CODE>ilu-bugs@parc.xerox.com</CODE>) want to hear about any exceptions to this rule.
<P>
<H2><A NAME="SEC228" HREF="manual_toc.html#SEC228">ILU trace debugging</A></H2>
<P>
ILU contains a number of trace statements that allow you to observe the progress of
certain operations within the ILU kernel.  To enable these, you can set the environment
variable <CODE>ILU_DEBUG</CODE>
<A NAME="IDX201"></A>
with the command
<CODE>setenv ILU_DEBUG "<VAR>xxx</VAR>:<VAR>yyy</VAR>:<VAR>zzz</VAR>:..."</CODE>
where <VAR>xxx</VAR>, <VAR>yyy</VAR>, and <VAR>zzz</VAR> are the names of various trace classes.
The classes are (as of December 1995) <CODE>packet</CODE>, <CODE>connection</CODE>,
<CODE>incoming</CODE>, <CODE>export</CODE>,
<CODE>authentication</CODE>,
<CODE>object</CODE>, <CODE>sunrpc</CODE>, <CODE>courier</CODE>, <CODE>dcerpc</CODE>, <CODE>call</CODE>,
<CODE>tcp</CODE>, <CODE>udp</CODE>, <CODE>xnsspp</CODE>,
<CODE>gc</CODE>, <CODE>lock</CODE>, <CODE>server</CODE>, <CODE>malloc</CODE>, <CODE>mainloop</CODE>, <CODE>iiop</CODE>, <CODE>error</CODE>, <CODE>sunrpcrm</CODE>, <CODE>inmem</CODE>, and <CODE>binding</CODE>.  The special
class <CODE>ALL</CODE> will enable all
trace statements:  <CODE>setenv ILU_DEBUG ALL</CODE>.
The function <CODE>ilu_SetDebugLevelViaString(char *trace_classes)</CODE>
<A NAME="IDX202"></A>
may also be called from
an application program or debugger, to enable tracing.  The argument <VAR>trace_classes</VAR>
should be formatted as described above.
<P>
<CODE>ILU_DEBUG</CODE> may also be set to an unsigned integer value, where each bit set in the binary
version of the number corresponds to one of the above trace classes.  For a list of the
various bit values, see the file <TT>`<VAR>ILUHOME</VAR>/include/iludebug.h'</TT>.  Again, you can
also enable the tracing from a program or from a debugger, by calling the
routine <CODE>ilu_SetDebugLevel(unsigned long trace_bits)</CODE>
<A NAME="IDX203"></A>
with an unsigned integer argument.
<P>
The routine <CODE>ilu_SetDebugMessageHandler</CODE> allows
an application to specify an alternate routine to be called when an error
or debugging message is to be printed.
<P>
<A NAME="IDX204"></A>
<U>[ILU kernel]:</U> void <B>ilu_SetDebugMessageHandler</B> <I>(void (*<VAR>handler</VAR>) (char *formatSpec, va_list args))</I><P>
<P>
Locking:  unconstrained
<P>
Registers <VAR>handler</VAR> with the ILU kernel to be called
whenever a debugging or error message is output via <CODE><CODE>ilu_DebugPrintf</CODE></CODE>, instead
of the default handler, which simply prints the message to <CODE>stderr</CODE>, using <CODE><CODE>vfprintf</CODE></CODE>.
Two special constant values for <VAR>handler</VAR> are defined, <CODE><CODE>ILU_DEFAULT_DEBUG_MESSAGE_HANDLER</CODE></CODE>,
which will cause the default behavior to be resumed, and
<CODE><CODE>ILU_NIL_DEBUG_MESSAGE_HANDLER</CODE></CODE>, which will cause debugging and
error messages to be simply, silently, discarded.
<P>
<H2><A NAME="SEC229" HREF="manual_toc.html#SEC229">Debugging ISL</A></H2>
<P>
<H3><A NAME="SEC230" HREF="manual_toc.html#SEC230">Use of <CODE>islscan</CODE></A></H3>
<A NAME="IDX205"></A>
<P>
The <CODE>islscan</CODE> program is supplied as part of the ILU
release.  It runs the ISL parser against a file containing an
interface, and prints a "report" on the interface to standard output.
It can therefor be used to check the syntax of an interface before
running any language stubbers.
<P>
<H3><A NAME="SEC231" HREF="manual_toc.html#SEC231">The ISLDEBUG environment variable</A></H3>
<A NAME="IDX206"></A>
<P>
Setting the environment variable <CODE>ISLDEBUG</CODE> to any value (say, "t"),
before running any ILU stubber or the program <CODE>islscan</CODE>,
will cause ILU's parser to print out its state transitions as
it parses the ISL file.  If you're having a serious problem finding
a bug in your ISL file, this might help.
<P>
<H2><A NAME="SEC232" HREF="manual_toc.html#SEC232">Bug Reporting and Comments</A></H2>
<P>
Report bugs (nah! -- couldn't be!) to the Internet address
<CODE>ilu-bugs.parc@xerox.com</CODE>, or to the XNS address
<CODE>ILU-bugs:PARC:Xerox</CODE>.  Bug reports are more helpful with some
information about the activity.  General comments and suggestions can be
sent to either <CODE>ILU@parc.xerox.com</CODE> or <CODE>ILU-bugs</CODE>.
<P>
Often the our first reply to a bug report is a request for a typescript that shows
the bug occurring, with all trace debugging turned on.  If that doesn't make it
clear to us, our second reply may be a request for a stack trace, with printouts of
relevant variables and data strutures.  Including these things in your bug report
may speed the cycle of interactions.
<P>
<H2><A NAME="SEC233" HREF="manual_toc.html#SEC233">Use of <CODE>gdb</CODE></A></H2>
<P>
When using ILU with C++ or C or even Common Lisp,
running under the GNU debugger <CODE>gdb</CODE> can be helpful for
finding segmentation violations and other system errors.
<P>
ILU provides a debugging trace
feature which can be set from <CODE>gdb</CODE>
<A NAME="IDX207"></A>
with the following command:
<P>
<PRE>
(gdb) <STRONG>p ilu_SetDebugLevel(0x<VAR>XXX</VAR>)</STRONG>
ilu_SetDebugLevel:  setting debug mask from 0x0 to 0x<VAR>XXX</VAR>
$1 = void
(gdb) 
</PRE>
<P>
The value <VAR>XXX</VAR> is an unsigned integer as discussed in section 3.
The debugger <CODE>dbx</CODE>
<A NAME="IDX208"></A>
should also work.
<P>
We are in the midst of installing a consistent new way of handling rutime failures into the ILU runtime kernel.  This new way involves the kernel reporting the failure to its caller; the old way involves combinations of panicking, reporting to the user (not the caller) via a printed message, and fragmentary reporting to the caller.  Every time a runtime failure is noted the new way, the procedure <CODE>_ilu_NoteRaise</CODE> in <TT>`<VAR>ILUSRC</VAR>/runtime/kernel/error.c'</TT> is called; this procedure thus makes a good place to set a breakpoint when debugging.  Most runtime failures occur due to genuine problems; some occur during normal processing (e.g., end-of-file detection).
<P>
<H2><A NAME="SEC234" HREF="manual_toc.html#SEC234">Error handling</A></H2>
<P>
Ideally, the ILU runtime would report all failures
to the application, in the way most appropriate for the application's
programming language.  Sadly, this is not yet the case.
<P>
The ILU runtime kernel has three kinds of runtime failures:
<OL>
<LI>
memory allocation failures from which the kernel cannot proceed;
<LI>
internal consistency check failures, from which the kernel cannot proceed; and
<LI>
internal consistency check failures, which the kernel is prepared to report
to the ILU language-specific runtime veneer (which, hopefully,
would in turn report the failure to the applicaiton).
</OL>
<P>
The second kind is being eliminated.  The first kind is being reduced, and might also be eliminated.
<P>
The application can specify how each of these three kinds of runtime failures is to be handled.  The choices are:
<OL>
<LI>
Print an explanatory message and then explicitly trigger a <CODE>SEGV</CODE> signal by attempting to write to protected memory.  This
is useful for generating core dumps for later study of the error.
<LI>
Print an explanatory message and then exit the program with an application-specified exit code.
<LI>
Print an explanatory message and then enter an endless loop, which calls <CODE>sleep(3)</CODE> repeatedly.  This option is useful
for keeping the process alive but dormant, so that a debugger can attach to it
and examine its "live" state.  This is the default action for all three kinds of failures.
<LI>
Invoke an application-supplied procedure (without printing anything first).
<LI>
Report the failure out of the kernel, without printing anything first (this option is available only for the third kind of failure).
</OL>
<P>
An application can change the action taken on memory failures by
calling <CODE>ilu_SetMemFailureAction</CODE> or <CODE>ilu_SetMemFailureConsumer</CODE>.
<P>
<A NAME="IDX209"></A>
<U>[ILU kernel]:</U> void <B>ilu_SetMemFailureAction</B> <I>( int <VAR>mfa</VAR> )</I><P>
<P>
Locking:  unconstrained
<P>
Calling this tells the ILU kernel which drastic action is to be
performed when <CODE>ilu_must_malloc</CODE> fails.  -2 means to print an explanatory message on stderr and then coredump;
-1 means to print an explanatory message on stderr and then loop forever in repeated calls to <CODE>sleep(3)</CODE>; positive numbers mean to print an explanatory message on stderr and then <CODE>exit(<VAR>mfa</VAR>)</CODE>.
The default is -1.
<P>
<A NAME="IDX210"></A>
<U>[ILU kernel]:</U> typedef void (*) (const char *file, int line) <B>ilu_FailureConsumer</B><P>
A procedure that is called when the ILU kernel can't proceed.  This procedure must not return.
<P>
<A NAME="IDX211"></A>
<U>[ILU kernel]:</U> void <B>ilu_SetMemFailureConsumer</B> <I>( ilu_FailureConsumer <VAR>mfc</VAR> )</I><P>
<P>
Locking:  unconstrained
<P>
An alternative to <CODE>ilu_SetMemFailureAction</CODE>: this causes <VAR>mfc</VAR> to be called when <CODE>ilu_must_malloc fails</CODE>.
<P>
Similarly, an application specifies how unrecoverable runtime consistency check failures are to be handled by calling <CODE>ilu_SetAssertionFailureAction</CODE> or <CODE>ilu_SetAssertionFailConsumer</CODE>, which are exactly analogous to the procedures for memory failure handling.  For recoverable consistency check failures, an application can call <CODE>ilu_SetCheckFailureAction</CODE> or <CODE>ilu_SetCheckFailureConsumer</CODE>.
<P>
<A NAME="IDX212"></A>
<U>[ILU kernel]:</U> void <B>ilu_SetCheckFailureAction</B> <I>( int <VAR>cfa</VAR> )</I><P>
<P>
Locking:  unconstrained
<P>
Calling this tells the runtime which action is to be performed
 when an internal consistency check fails.  -3 means to raise an
 error from the kernel (without necessarily printing anything); -2
 means to print an explanatory message to stderr and then
 coredump; -1 means to print and then loop forever; non-negative
 numbers mean to print and then <CODE>exit(<VAR>cfa</VAR>)</CODE>; others number reserved.
 The default is -1.
<P>
<A NAME="IDX213"></A>
<U>[ILU kernel]:</U> typedef void (*) (const char *file, int line) <B>ilu_CheckFailureConsumer</B><P>
A procedure for handling an internal consistency check failure.
 If this procedure returns, the consistency check failure will be
 raised as an error from the kernel.
 @end deftypevr
<P>
<A NAME="IDX214"></A>
<U>[ILU kernel]:</U> void <B>ilu_SetCheckFailureConsumer</B> <I>( ilu_CheckFailureConsumer <VAR>cfc</VAR> )</I><P>
<P>
Locking:  unconstrained
<P>
An alternative to <CODE>ilu_SetCheckFailureAction</CODE>: this causes <VAR>cfc</VAR> to
 be called (and no printing); if <VAR>cfc</VAR> returns, an error will be
 raised from the kernel.
<P>
<H3><A NAME="SEC235" HREF="manual_toc.html#SEC235">Decoding reportable consistency check failures</A></H3>
<P>
For language mappings consistent with CORBA,
the third kind of failure is reported as an occurrence of the CORBA system exception <CODE>internal</CODE>,
with a minor code that encodes the filename and line number where the consistency check occurs.
The coding is this: 10,000*hash(filename, 32771) + linenum + 1,000.
The directory part, if any, is stripped from the filename before hashing.
To aid in decoding these minor codes, ILU includes the program <CODE>decoderr</CODE>, which is used like this:
<PRE>
% decoderr 269211234
269211234 = line 234, file $ILUSRC/runtime/kernel/call.c
</PRE>
<P>
If a reportable consistency check failure occurs in a file not anticipated in the construction of <CODE>decoderr</CODE>, you'll see something like this:
<PRE>
% decoderr 60612345
60612345 = line 1345 in unknown file (that hashes to 6061)
</PRE>
<P>
The program <CODE>iluhashm</CODE> can be used to hash given filenames, so you can search a set of candidates for the mysterious hash code:
<PRE>
% iluhashm 32771 ../cpp/foobar.cpp ../cpp/barfoo.cpp
/* Generated at Mon Dec 11 22:44:47 1995
   with modulus 32771 */
{      6061, "../cpp/foobar.cpp"},
{     13273, "../cpp/barfoo.cpp"},
</PRE>
<P>
<P>Go to the <A HREF="manual_12.html">previous</A>, <A HREF="manual_14.html">next</A> section.<P>
