@setfilename mappings.info
@settitle Possible ISL Name Mappings for Target Languages
@ifclear largerdoc
@titlepage
@title Possible ISL Name Mappings for Target Languages
@author Mike Spreitzer
@sp
@today{}
@end titlepage
@end ifclear

This note outlines a proposal for name mappings and restrictions; this
proposal is not yet accepted.  (Thanks to external standards such as
@system{CORBA}, this proposal cannot be implemented for some languages,
such as @language{ANSI C}.)  @strong{The mappings outlined here are not
necessarily the ones used in the current @system{ILU} release.}

This proposal is about how to name things in the various programming
languages, in a way that avoids name clashes.  It imposes no
restrictions on the @language{ISL} source.  However, the mappings will
be more straightforward if the @language{ISL} source avoids two things:
(1) two or more concsecutive hyphens in a name, and (2) starting an
interface or type name with ``ilu-'' (in any casing).

The first step in mapping an @language{ISL} to a programming language is
to scan type and interface names for the substring ``ilu-'' (in any
casing); wherever it occurs, we insert a trailing digit zero.

In a similar way, we next scan the name for sequences of hyphens.
Wherever two or more hyphens appear consecutively, the digit zero (`0')
is inserted after every other one, starting with inserting a zero after
the second hyphen.

The following steps assume the first two steps have already been done.

Where tuples <N1, N2, ... Nk> of @language{ISL} names must be mapped into a flat programming namespace, we concatenate the @language{ISL} names, with a double hyphen (``--'') inserted between each.

Where @language{ISL} names (or tuples thereof) must be mapped, together with @system{ILU}-chosen names derived from the @language{ISL} names, into a flat programming namespace, the derived names begin with fixed strings specific to the derivation, where the fixed strings begin with ``ilu-'' (with any case), and a double hyphen is inserted between the fixed string and the @language{ISL} name.

Where @language{ISL} names (or tuples thereof), and possibly @system{ILU}-chosen names derived from the @language{ISL} names, must be mapped, together with a fixed set of @system{ILU}-chosen names, into a flat programming namespace, the fixed @system{ILU}-chosen names begin with ``ilu-'' (with any case) and do not include a double hyphen.

The final step is to translate hyphens to underscores, for programming languages that accept underscores but not hyphens in names.

Following is a specification of how names are mapped in each language.  The notation "[N]" is used to denote the application of the first two steps and the last step.  Examples of "[..]" are:
@codeexample
[Foo] => Foo
[foo-bar] => foo-bar
[wait----for---it-] => wait--0--0for--0-it-
[iluminate] => iluminate
[ilu---uli] => ilu-0--0uli
@end codeexample
The mappings also use the notation "[[..]]" to denote the mapping of a type-reference.

@section C mapping

[ This mapping, while clean, will never be adopted because of the more problematic mapping specified by the OMG's CORBA document. ]

Item @code{N} from interface @code{I} is mapped to @code{[I]__[N]}.  @code{[[I.N]] = [I]__[N]}; @code{[[N]] = [I]__[N]}, where @code{I} is the current interface.

An enumerated value named @code{V}, of type @code{T} in interface @code{I} is mapped to @code{[I]__[T]__[V]}.

A declaration of a record type @code{T} in interface @code{I} with fields @code{F1:TR1}, ... @code{Fn:TRn} is mapped to
@codeexample
typedef struct @{[[TR1]] F1; ... [[TRn]] Fn@} [I]__[T];
@end codeexample

A declaration of a union type @code{T} in interface @code{I} of types @code{TR1}, ... @code{TRn} is mapped to
@codeexample
typedef enum @{[[I.T]]__[[TR1]], ... [[I.T]]__[[TRn]]@} ilu_tags__[[I.T]];
typedef struct @{ilu_tags__[[I.T]] tag;
    union @{
        [[TR1]] [[TR1]];
        ...
        [[TRn]] [[TRn]];
    @} val;
@} [[I.T]];
@end codeexample

For passing exceptions through the method calls in interface @code{I}, the following auxiliary declaration is generated (supposing exceptions @code{ER1:TR1}, ... @code{ER2:TR2} are raised):
@codeexample
typedef struct @{
    ilu_Exception returnCode;
    union @{
        [[TR1]] [[ER1]];
        ...
        [[TRn]] [[ERn]];
    @} val;
@} ilu_Status__[I];
@end codeexample

An object type named @code{T} in interface @code{I} with methods @code{M1}, ... @code{Mn} maps to
@codeexample
typedef ilu_Ojbect [[I.T]];
[result-type-1] [I]__[T]__[M1]([[I.T]] ilu_self,
    [[arg-type-1-1]] [arg-name-1-1], ...
    [[arg-type-1-k]] [arg-name-1-k]);
...
@end codeexample

@section C++ mapping

Item @code{N} from interface @code{I} is mapped to @code{[I]__[N]}.  @code{[[I.N]] = [I]__[N]}; @code{[[N]] = [I]__[N]}, where @code{I} is the current interface.

A declaration of an enumerated type named @code{T} in interface @code{I} containing values @code{V1}, ... @code{Vn} is mapped to @code{typedef enum @{[V1], ... [Vn]@} [I]__[T]}.

Record and union declarations are mapped as for C.  The exception status declaration is as for C.

@section Modula-3 mapping

@system{ILU} interface @code{I} is mapped to @language{Modula-3} interface @code{[I]}; within an interface, item @code{N} is mapped to item @code{[N]}.  @code{[[I.N]] = [I].[N]}; @code{[[N]] = [N]}.  For @language{Modula-3}, we also use the notation "((a type-reference))", defined by @code{((N)) = [N]} and @code{((I.N)) = [I]__[N]}.

A declaration of a record type @code{T} in interface @code{I} with fields @code{F1:TR1}, ... @code{Fn:TRn} is mapped to
@codeexample
TYPE [T] =  RECORD F1: [[TR1]]; ... Fn: [[TRn]]; END;
@end codeexample

A declaration of a union type @code{T} in interface @code{I} of types @code{TR1}, ... @code{TRn} is mapped to
@codeexample
TYPE [T] = BRANDED OBJECT END;
TYPE [T]__((TR1)) = [T] BRANDED OBJECT v: [[TR1]] END;
...
TYPE [T]__((TRn)) = [T] BRANDED OBJECT v: [[TRn]] END;
@end codeexample

A declaration of an enumerated type named @code{T} in interface @code{I} containing values @code{V1}, ... @code{Vn} is mapped to @code{TYPE [T] = @{[V1], ... [Vn]@};}

The type @code{Ilu.Object} has slots named @code{ilu_is_surrogate}, @code{Ilu_Get_Server}, @code{Ilu_Get_Type}, and @code{Ilu_Close_Surrogate}.  Method names @code{M} are translated to @code{[M]}.  For each object type @code{T}, the @language{Modula-3} interface includes auxiliary procedures named @code{Ilu_Sbh_Import__[T]}, @code{Ilu_Name_Import__[T]}, and @code{Ilu_Get_Type__[T]}.


