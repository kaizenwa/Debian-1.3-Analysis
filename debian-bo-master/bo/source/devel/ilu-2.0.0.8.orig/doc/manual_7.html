<!-- This HTML file has been created by texi2html 1.29
     from manual.texinfo on 17 July 1996 -->

<TITLE>ILU Reference Manual - Using ILU with Python</TITLE>
<BODY TEXT=#000000 BGCOLOR=#ffffff>
<P>Go to the <A HREF="manual_6.html">previous</A>, <A HREF="manual_8.html">next</A> section.<P>
<H1><A NAME="SEC126" HREF="manual_toc.html#SEC126">Using ILU with Python</A></H1>
<P>
<A NAME="IDX181"></A>
<H2><A NAME="SEC127" HREF="manual_toc.html#SEC127">Introduction</A></H2>
This document is for the Python programmer who wishes to use 
ILU. The following sections will show how ILU is
mapped into Python constructs and how both Python
clients and servers are generated and built.
<P>
<H2><A NAME="SEC128" HREF="manual_toc.html#SEC128">The ISL Mapping to Python</A></H2>
<P>
<A NAME="IDX182"></A>
<H3><A NAME="SEC129" HREF="manual_toc.html#SEC129">Names</A></H3>
In general, ILU constructs Python symbols from
ISL names by replacing hyphens with underscores.
For example, an ISL object type <CODE>T-1</CODE> would correspond to
the Python class <CODE>T_1</CODE>.
Any place an ISL name appears as part or all of a Python
identifier, this translation occurs.
<P>
<H3><A NAME="SEC130" HREF="manual_toc.html#SEC130">Interface</A></H3>
Each ISL <CODE>interface</CODE> <CODE><VAR>I</VAR></CODE>
generates two Python modules:
one named <CODE><VAR>I</VAR></CODE> containing common definitions,
and another named <CODE><VAR>I</VAR>__skel</CODE> containing skeletons (server stubs).
For example,
<CODE>INTERFACE map-test;</CODE> generates the Python modules
<CODE>map_test</CODE> and <CODE>map_test__skel</CODE>, contained in the files
<TT>`map_test.py'</TT> and <TT>`map_test__skel.py'</TT>, respectively.
<P>
<H3><A NAME="SEC131" HREF="manual_toc.html#SEC131">Constant</A></H3>
ISL constants translate to
Python variables initialized to the specified value.
For example,
<PRE>
CONSTANT pi : real = 3.14159265358979323846;
</PRE>
maps to
<PRE>
pi = 3.14159265358979323846e0
</PRE>
<P>
<H3><A NAME="SEC132" HREF="manual_toc.html#SEC132">Exception</A></H3>
An ISL exception translates to a Python variable
initialized with a string representing the exception.
These variables are used in Python <CODE>raise</CODE> statements
in object implementation code, and in <CODE>try ... except</CODE> statements
in client code.
For example, the declaration
<PRE>
EXCEPTION division-by-zero;
</PRE>
in the interface <CODE>map-test</CODE> maps to the following statement in
<TT>`map_test.py'</TT>:
<PRE>
division = 'map-test: division-by-zero'
</PRE>
<P>
<H3><A NAME="SEC133" HREF="manual_toc.html#SEC133">Types</A></H3>
<P>
<H4><A NAME="SEC134" HREF="manual_toc.html#SEC134">Basic Types</A></H4>
The basic ISL types have the following mapping to Python
types:
<P>
<OL>
<LI>
BYTE,
BOOLEAN,
SHORT CHARACTER,
CHARACTER,
SHORT INTEGER,
INTEGER,
and SHORT CARDINAL
all map to Python int.
<LI>
LONG INTEGER,
CARDINAL,
and LONG CARDINAL
all map to Python long int.
<LI>
SHORT REAL
and REAL
map to Python float.
<LI>
LONG REAL
maps to the Python type ilu_longreal, a type implemented by the
ILU Python runtime.
This type has limited functionality, but can be passed around without loss of
precision, converted to float or int, and compared.
A value of this type may be constructed by calling <CODE>ilu.LongReal()</CODE>.
</OL>
<P>
<H4><A NAME="SEC135" HREF="manual_toc.html#SEC135">Enumeration</A></H4>
Enumerations are mapped to a method-less class object which
contains an attribute of the correct type and value for each
value in the enumeration.
The class also contains a dictionary, called "__image__", for each enumeration type
that maps an enumeration value to a
string corresponding to its Python enumeration value name.
<P>
For example,
<PRE>
TYPE color = ENUMERATION red, dark-blue END;
</PRE>
maps to
<PRE>
class color:
    red = 0;
    dark_blue = 1;
    __image__ = {
       red: 'red',
       dark_blue: 'dark_blue'};
</PRE>
<P>
<H4><A NAME="SEC136" HREF="manual_toc.html#SEC136">Array</A></H4>
An ISL array maps into a Python list with the
specified number of elements.
Tuples as well as lists are accepted as input, but lists are always
produced as output from ILU.
Arrays of BYTE or SHORT CHARACTER are represented with Python strings.
<P>
<H4><A NAME="SEC137" HREF="manual_toc.html#SEC137">Sequence</A></H4>
An ISL sequence of short character maps into a Python
string.
<P>
All other ISL sequence types map into Python lists.
Tuples as well as lists are accepted as input, but lists are always
produced as output from ILU.
Sequences of BYTE or SHORT CHARACTER are represented as Python strings.
<P>
<H4><A NAME="SEC138" HREF="manual_toc.html#SEC138">Record</A></H4>
ISL records map into generated Python classes with
the same name, with the record's field names as attributes.  The name
of the record becomes a constructor function which accepts exactly the
same number of arguments as the record has fields, in the same order.
<P>
For example, a record value of the ISL type
<PRE>
TYPE segment = RECORD left-limit : integer, right-limit : integer END;
</PRE>
with a left-limit of -3 and a right-limit of 7 would map to
<PRE>
segment(-3, 7) =&#62; &#60;segment:{'left-limit' : -3, 'right-limit' : 7}&#62;
</PRE>
<P>
<H4><A NAME="SEC139" HREF="manual_toc.html#SEC139">Union</A></H4>
An ISL union maps into a Python tuple with two
components:
an integer discriminator, and the discriminated value.
There are three possibilities:
<OL>
<LI>
If the discriminator matches one of the union case values of an arm,
the second component is of the type specified by that arm.
<LI>
If the discriminator matches no union case values and there is a default arm,
the second component is of the type specified by the default arm.
<LI>
If the discriminator matches no union case values and there is no default arm
but the union has the <CODE>OTHERS</CODE> attribute,
the second component is <CODE>None</CODE>.
</OL>
<P>
<H4><A NAME="SEC140" HREF="manual_toc.html#SEC140">Object</A></H4>
Each ISL object type is mapped into a Python class.
These classes have the methods specified in the ISL, as well as
some built-ins.
<P>
<H4><A NAME="SEC141" HREF="manual_toc.html#SEC141">Optional</A></H4>
A value corresponding to the ISL type <CODE>OPTIONAL <VAR>T</VAR></CODE>
may be <CODE>None</CODE> (indicating the null case) in addition to the values of the
type <VAR>T</VAR>.
<P>
<H3><A NAME="SEC142" HREF="manual_toc.html#SEC142">Methods and Parameters</A></H3>
ISL methods of an object type map to Python methods
of the corresponding class.
<CODE>IN</CODE> and <CODE>INOUT</CODE> parameters appear in the Python method
signature in the same order as they do in ISL.
<P>
Let us define a <EM>result</EM> value to be either
a return value (corresponding to a method's return type) or
an <CODE>INOUT</CODE> or <CODE>OUT</CODE> parameter.
Result values are returned by the Python method as a tuple,
with the return value (if present) appearing before any parameters.
If the method has only one result value, then it is simply returned
(i.e., a tuple of length one is <EM>not</EM> constructed to hold this value).
If the method has no result values, then <CODE>None</CODE> is returned.
<P>
<H3><A NAME="SEC143" HREF="manual_toc.html#SEC143">Threads</A></H3>
<P>
To use threads, you must have configured both ILU and Python with thread
support when building them.  If you have done this, your ILU/Python runtime support
will be thread-capable.  To have ILU begin using threads, place a call to the
function <CODE>ilu.ThreadedOperation()</CODE> in your Python program before any other
ILU calls are made.
<P>
<H3><A NAME="SEC144" HREF="manual_toc.html#SEC144">Identities</A></H3>
<P>
An ILU passport (see See section <A HREF="manual_10.html#SEC195">Security</A>) is represented in
Python by a dictionary.  Each entry has one of the following
keys:
<UL>
<LI><CODE>"connection"</CODE> -- this key is used for a value which is a string containing an identity
of type <CODE>ilu_ConnectionIdentity</CODE>.
<LI><CODE>"sunrpc-unix"</CODE> -- this key is used for a value which is itself a dictionary, containing the fields <CODE>"uid"</CODE>, <CODE>"gid"</CODE>, <CODE>"hostname"</CODE>, and <CODE>"groups"</CODE>.
<LI><CODE>"GSS"</CODE> -- this key is used for a value which is a Python GSS object.
</UL>
<P>
The passport may be obtained in the true method by calling the ILU runtime routine <CODE>ilu.CallerIdentity()</CODE>.
<P>
<H2><A NAME="SEC145" HREF="manual_toc.html#SEC145">Using an ILU module from Python</A></H2>
The ILU runtime interface is in the Python module
<CODE>ilu</CODE>.
Python definitions for ISL
<CODE>INTERFACE <VAR>I</VAR></CODE> are in the Python module
<CODE><VAR>I</VAR></CODE>.
As with any other modules in Python, these modules are imported
using the <CODE>import</CODE> statement.
<P>
A client program may create an ILU object in one of three ways:
<OL>
<LI>
Knowing the string binding handle <CODE>sbh</CODE> and class <CODE>cl</CODE> of an
object,
call <CODE>ilu.ObjectOfSBH(cl, sbh)</CODE> which returns an instance of that class.
For example, to obtain an instance of ISL type <CODE>square</CODE> from
<CODE>INTERFACE shapes</CODE>
whose string binding handle is <CODE>sbh</CODE>,
one would call <CODE>ilu.ObjectOfSBH(shapes.square, sbh)</CODE>.
<LI>
Knowing the object ID <CODE>(sid, ih)</CODE> and class <CODE>cl</CODE> of an object that
has been published using the simple binding service,
call <CODE>ilu.Lookup(sid, ih, cl)</CODE> which returns an instance of that class
(or <CODE>None</CODE> if the lookup fails).
<LI>
Receive an instance as a result value from a method call that returns an
object type or has an object type as an <CODE>INOUT</CODE> or <CODE>OUT</CODE> parameter.
</OL>
<P>
<H2><A NAME="SEC146" HREF="manual_toc.html#SEC146">Implementing an ILU module in Python</A></H2>
A Python module that implements ILU objects of types
defined in <CODE>INTERFACE <VAR>I</VAR></CODE>
also imports from <CODE><VAR>I</VAR>__skel</CODE>.
This gives access to the skeleton classes from which implementation classes
inherit.
<P>
<H3><A NAME="SEC147" HREF="manual_toc.html#SEC147">Implementation Inheritance</A></H3>
An implementation of object type <VAR>T</VAR> from interface <VAR>I</VAR>
needs to inherit from the class <CODE><VAR>I</VAR>__skel.<VAR>T</VAR></CODE>.
If there is inheritance in the ISL, and an implementation of a
subtype wants to inherit from an implementation of a supertype,
the skeleton class must be appear in the list of base types
before the implementation class.
<P>
For example, objects for the ISL
<PRE>
INTERFACE j;

TYPE c1 = OBJECT METHODS one() END;
TYPE c2 = OBJECT METHODS two() END;
TYPE c3 = OBJECT SUPERTYPES c1, c2 END METHODS three() END;
</PRE>
could be implemented in Python by
<PRE>
import ilu, j, j__skel

class c1(j__skel.c1):
    def one(self):
        ...

class c2(j__skel.c2):
    def two(self):
        ...

class c3(j__skel.c3, c1, c2):
    def three(self):
        ...
</PRE>
In this case <CODE>c3</CODE>'s method <CODE>one</CODE> is implemented by <CODE>c1.one</CODE>
and 
<CODE>c3</CODE>'s method <CODE>two</CODE> is implemented by <CODE>c2.two</CODE>.
<P>
<H3><A NAME="SEC148" HREF="manual_toc.html#SEC148">True Servers</A></H3>
Each object exported by an implementation must belong to a true server,
an instance of the Python type <CODE>ilu_Server</CODE> which is
implemented by the ILU runtime.
An <CODE>ilu_Server</CODE> can be created by calling the function
<CODE>ilu.CreateServer([serverID [, transport [, protocol [, objectTable]]]])</CODE>,
which returns a value of type <CODE>ilu_Server</CODE>.
If <VAR>serverID</VAR> is a string, it specifies the server ID;
if it is <CODE>None</CODE>, one will be invented automatically.
The <VAR>transport</VAR> and <VAR>protocol</VAR> arguments are strings to choose a specific
transport or protocol, or <CODE>None</CODE> to let them default.
The <VAR>objectTable</VAR> argument allows specification of a callback
function for creating true instances on demand.  The callback function
should take one argument, a string, which is the object ID of the
instance to be created, and return a true instance.
<P>
The first time a true server is created, it becomes the default server.
The default server is used for an exported object if a server is not
otherwise specified.
If an object is exported before any servers have been created,
one will be created automatically using default parameters and a message
to that effect will be written to stderr.
<P>
An object of type <CODE>ilu_Server</CODE> has a method <CODE>id()</CODE> that returns
its server ID.
<P>
<H3><A NAME="SEC149" HREF="manual_toc.html#SEC149">Exporting Objects</A></H3>
An object can be exported in one of three ways:
<OL>
<LI>
The object's string binding handle may be obtained by calling its
method <CODE>IluSBH()</CODE> and communicating this somehow to a client,
who then turns the handle back into an object by calling
<CODE>ilu.ObjectOfSBH(cl, sbh)</CODE>.
<LI>
The object may be published using the simple binding service
by calling its method <CODE>IluPublish()</CODE>.
In order for this to be effective, the object must have a well-known
object ID, or the object ID must be communicated to clients, so clients can
know what to pass to <CODE>ilu.Lookup</CODE>.
The object ID is a function of the object's instance handle and
its server's server ID.
<LI>
The object may be returned by a method or passed back in a method's
<CODE>INOUT</CODE> or <CODE>OUT</CODE> parameter.
</OL>
<P>
An object's instance handle can be controlled by setting the
instance variable <CODE>IluInstHandle</CODE> before the object is first exported.
If this instance variable is not set, and instance handle will be
invented automatically.
<P>
An object's server can be controlled by setting the instance or class variable
<CODE>IluServer</CODE> to a value of type <CODE>ilu_Server</CODE>.
The value of this variable at the time an object is first exported will be
used as the server for that object.
If such a variable is not set, the default server is used.
<P>
<H3><A NAME="SEC150" HREF="manual_toc.html#SEC150">Animating Servers</A></H3>
Running the ILU main loop
by calling <CODE>ilu.RunMainLoop()</CODE>
brings the true servers to life.
This function does not return until <CODE>ilu.ExitMainLoop()</CODE> is called.
If you are using ILU with <CODE>Tkinter</CODE>,
run the main loop by calling <CODE><CODE>ilu_tk.RunMainLoop()</CODE></CODE>, rather
than using either the ILU or <CODE>Tkinter</CODE> main loops.
<CODE><CODE>ilu_tk.RunMainLoop</CODE></CODE> sets things up so that both Tk
and ILU events are handled.
<P>
<H3><A NAME="SEC151" HREF="manual_toc.html#SEC151">Using Alarms</A></H3>
In order to schedule a Python function to be called at a certain
time in the future when executing the ILU main loop,
an <CODE>ilu_Alarm</CODE> may be used.
Objects of this type are created by calling <CODE>ilu.CreateAlarm()</CODE>.
An <CODE>ilu_Alarm</CODE> must be set to have any effect.
<P>
The alarm's method <CODE>set(time, proc, args)</CODE> is used to set the alarm.
The <CODE>int</CODE>, <CODE>float</CODE>, or <CODE>ilu_FineTime</CODE> <CODE>time</CODE> argument
is the time at which the alarm will fire;
the <CODE>proc</CODE> argument is the Python function that will be
called when the alarm fires;
and
the <CODE>args</CODE> argument is a tuple of arguments to be passed to <CODE>proc</CODE>.
The tuple <CODE>args</CODE> must match <CODE>proc</CODE>'s signature.
For example, if <CODE>proc</CODE>
is declared <CODE>def P(a, b):</CODE> then <CODE>args</CODE> must be a two-tuple.
Likewise, if <CODE>proc</CODE> takes only one argument then <CODE>args</CODE> must be
a one-tuple,
or if no arguments then a zero-tuple.
<P>
The function <CODE>ilu.FineTime_Now()</CODE> may be called to obtain ILU's
idea of the current time.
A value <CODE>sec</CODE> of type <CODE>int</CODE> or <CODE>float</CODE> in units of seconds
may be converted to type <CODE>ilu_FineTime</CODE> by calling
<CODE>ilu.FineTime(sec)</CODE>.
Values of type <CODE>ilu_FineTime</CODE> may be compared, added, and subtracted.
These operations may be used to construct values representing any relative
time (subject to precision and range limitations), which is what is needed
by an alarm's <CODE>set</CODE> method.
<P>
The alarm may be set multiple times with different arguments, in which
case the parameters of the most recent call to <CODE>set</CODE> are in effect.
Thus, once an alarm fires, it may be reused by calling <CODE>set</CODE> again.
<P>
An alarm may be unset by calling its method <CODE>unset()</CODE>.
<P>
<H2><A NAME="SEC152" HREF="manual_toc.html#SEC152">Using the Simple Binding Service</A></H2>
An object may be published using the simple binding service by calling its
method <CODE>IluPublish()</CODE>.
An object may be unpublished by calling its method <CODE>IluWithdraw()</CODE>.
<P>
A published ILU object may be obtained by calling
<CODE>ilu.Lookup(sid, ih, cl)</CODE>,
where <CODE>sid</CODE> is object's server's server ID, <CODE>ih</CODE>
is the object's instance handle, and <CODE>cl</CODE> is its class.
<P>
<H2><A NAME="SEC153" HREF="manual_toc.html#SEC153">Summary of the ILU Python Runtime</A></H2>
Exported from module <CODE>ilu</CODE>:
<P>
<UL>
<P>
<LI>
<CODE>def CallerIdentity():</CODE>
<P>
Returns the passport containing identities of the caller.  This routine is only valid inside the code of a true method.
<LI>
<CODE>def CreateAlarm():</CODE>
<P>
Creates an object of type <CODE>ilu_Alarm</CODE>.
<LI>
<CODE>def CreateLoopHandle():</CODE>
<P>
Creates and returns an instance of a "loop handle" object, which can
be passed to <CODE>ilu.RunMainLoop</CODE> and <CODE>ilu.ExitMainLoop()</CODE>.
<LI>
<CODE>def CreateServer([serverID [, transport [, protocol [, objtable]]]]):</CODE>
<P>
Used to create an <CODE>ilu_Server</CODE> object with the specified
serverID, transport, and protocol.
If <VAR>serverID</VAR> is unspecified or <CODE>None</CODE>, an identifier will be invented automatically.
If transport or protocol are unspecified or <CODE>None</CODE>, they will default to
<CODE>'sunrpcrm|tcp_localhost_0'</CODE> and <CODE>'sunrpc_'</CODE>, respectively.
The first time <CODE><CODE>CreateServer</CODE></CODE> is called, the server so created becomes
the default server.
If there is no default server when one is required, one will be created
using default parameters and a message will be issued on stderr.
The <VAR>objtable</VAR> argument allows specification of a callback
function for creating true instances on demand.  The callback function
should take one argument, a string, which is the object ID of the
instance to be created, and return a true instance.
<P>
An <CODE>ilu_Server</CODE> object has an <CODE>id</CODE> method which returns the
string identifier of that server.
<LI>
<CODE>def DefaultServer():</CODE>
<P>
Returns the default server.
<LI>
<CODE>def Delete(obj):</CODE>
<P>
Puts the specified object on a list to schedule it for eventual deletion.
Actually, the deletion routine simply decrements the reference count increment
used by ILU to hold onto an object, so if other references to the object exist,
the object will continue to exist.
<LI>
<CODE>def ExitMainLoop(loophandle):</CODE>
<P>
Exits the ILU main loop, assuming it is running.  The <VAR>loophandle</VAR>
is created by a call to <CODE>ilu.CreateLoopHandle()</CODE>, and must have been
previously used as an argument to a call to <CODE>ilu.RunMainLoop()</CODE>.
<LI>
<CODE>FALSE = 0</CODE>
<LI>
<CODE>def FineTime(sec):</CODE>
<P>
Converts its <CODE>int</CODE> or <CODE>float</CODE> argument <VAR>sec</VAR> in units of seconds
to type <CODE>ilu_FineTime</CODE>.
Objects of this type can be compared, added, subtracted, and converted to
<CODE>int</CODE> or <CODE>float</CODE>.
The main use of objects of this type is in setting alarms.
<LI>
<CODE>FineTimeRate = ...</CODE>
<P>
The precision of type <CODE>ilu_FineTime</CODE> in seconds is the reciprocal of
this constant.
<LI>
<CODE>def FineTime_Now():</CODE>
<P>
Returns the current time as an <CODE>ilu_FineTime</CODE> object.
<LI>
<CODE>def FormSBH(objectID, contactInfo):</CODE>
<P>
Returns the string binding handle corresponding to the
object id <VAR>objectID</VAR>
and contact info <VAR>contactInfo</VAR>.
This is the inverse of <CODE><CODE>ParseSBH</CODE></CODE>.
<LI>
<CODE>IluGeneralError</CODE>,
<CODE>IluProtocolError</CODE>,
and
<CODE>IluUnimplementedMethodError</CODE>
are all strings that may occur as exceptions from the ILU runtime.
<LI>
<CODE>def LongReal(v):</CODE>
<P>
Converts its <CODE>int</CODE>, <CODE>float</CODE>, or sixteen-integer <CODE>list</CODE> or
<CODE>tuple</CODE> argument to type <CODE>ilu_LongReal</CODE>.
In case of a list or tuple, the elements encode the bytes of the
IEEE long real value, from most significant to least.
<LI>
<CODE>def LookupObject(sid, ih, cl):</CODE>
<P>
Returns the object with object server ID <VAR>sid</VAR>, object instance handle <VAR>ih</VAR>,
and Python class <CODE>cl</CODE>,
assuming it was previously published using the simple binding service.
If the lookup fails, <CODE>None</CODE> is returned.
<LI>
<CODE>def ObjectOfSBH(cl, sbh):</CODE>
<P>
Returns the object corresponding to the Python class <VAR>cl</VAR>
and string binding handle <VAR>sbh</VAR>.
<LI>
<CODE>def ParseSBH(sbh):</CODE>
<P>
Returns the pair (object id, contact info) corresponding to the string
binding handle <VAR>sbh</VAR>.
<LI>
<CODE>def IOROfObject(obj):</CODE>
<P>
If the <CODE>IIOP</CODE> protocol has been configured in, returns the string IOR
of the object, as specified in the CORBA 2 IIOP specification.  If
the <CODE>IIOP</CODE> protocol has not been configured in, throws an
error.
<LI>
<CODE>def RegisterInputHandler (file, handler_fn):</CODE>
<P>
Sets up an association between the <VAR>file</VAR> (which must be a file object
opened for reading), and the <VAR>handler_fn</VAR> (which must be a callable function
with no arguments) so that <VAR>handler_fn</VAR> is called whenever input is available
on <VAR>file</VAR>.  This is useful for implementing a server that also responds
to commands typed to its standard input, for example.  Passing a value of
<CODE>None</CODE> for the <VAR>handler_fn</VAR> removes the association.
<P>
<LI>
<CODE>def RunMainLoop(loophandle):</CODE>
<P>
Runs the ILU main loop.  The argument is a "handle" on that loop invocation,
created by a call to <CODE>ilu.CreateLoopHandle()</CODE>.
<LI>
<CODE>def SetMainLoop(DoEvent, RegisterInput, CancelInput, RegisterOutput, CancelOutput, CreateAlarm, SetAlarm, CancelAlarm)</CODE>
<P>
The purpose of this function is to be able to use a foreign main loop
(such as for a user interface toolkit)
with an ILU server.
The details will not be described here.
Look at the runtime module <CODE><CODE>ilu_tk</CODE></CODE> for an example of its use.
<P>
<LI>
<CODE>def SetDebugLevel(bits):</CODE> or <CODE>def SetDebugLevel(string):</CODE>
<P>
Sets the ILU kernel debugging flags according to its <CODE>int</CODE>
argument, if an int is specified, or via the colon-separated list of
debug switches, if a string is specified.  See the Debugging section of the
ILU Manual for more information on these switches.
<P>
<LI>
<CODE>def ThreadedOperation():</CODE>
<P>
Enables thread use in both the ILU kernel and the ILU/Python runtime.  This routine should be called
before any other ILU calls are made.
<P>
<LI>
<CODE>TRUE = 1</CODE>
<LI>
<CODE>def TypeID(cl):</CODE>
<P>
Returns the ILU unique type identifier
corresponding to the Python class <VAR>cl</VAR>.
<LI>
<CODE>def TypeName(cl):</CODE>
<P>
Returns the ILU type name
corresponding to the Python class <VAR>cl</VAR>.
<LI>
<CODE>Version = ...</CODE> is the ILU version string.
</UL>
<P>
Built-in methods of ILU objects:
<P>
<UL>
<LI>
<CODE>IluObjectID()</CODE> returns the object ID of the object.
<LI>
<CODE>IluPublish()</CODE> publishes the object using the simple binding service.
<LI>
<CODE>IluSBH()</CODE> returns the object's string binding handle.
<LI>
<CODE>IluTypeID()</CODE> returns the unique type identifier of the
object's ILU type.
<LI>
<CODE>IluTypeName()</CODE> returns the type name of the object's ILU type.
<LI>
<CODE>IluWithdraw()</CODE> undoes the effect of IluPublish().
</UL>
<P>
Special attributes of ILU true objects:
One or more of the following attributes may be set in a
true (implementation) object of an ISL object type
to control certain aspects of that object.
<P>
<UL>
<LI>
<CODE>IluInstHandle</CODE>, a string instance variable,
gives the object's instance handle.
If not present, an instance handle is invented automatically.
<LI>
<CODE>IluServer</CODE>, a variable of type <CODE>ilu_Server</CODE>,
determines the object's server.
This can be an instance or a class variable.
If not present, the default server is used.
</UL>
<P>
<H2><A NAME="SEC154" HREF="manual_toc.html#SEC154">Stub Generation</A></H2>
To generate Python stubs from an ISL file,
use the program <CODE>python-stubber</CODE>.
Two files are generated from each ISL
<CODE>INTERFACE <VAR>name</VAR></CODE>:
<UL>
<LI>
<TT>`<VAR>name</VAR>.py'</TT> containing code for constants, exceptions,
and types defined in the interface,
and
<LI>
<TT>`<VAR>name</VAR>__skel.py'</TT> containing code for the skeletons
(server stubs) for object types defined in the interface.
</UL>
<P>
<P>Go to the <A HREF="manual_6.html">previous</A>, <A HREF="manual_8.html">next</A> section.<P>
