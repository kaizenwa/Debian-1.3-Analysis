*-----------------------------------------------------------------------------
*-                                                                          --
*-                                 G N A T                                  --
*-                                                                          --
*-                            COMPILER UTILITIES                            --
*-                                                                          --
*-                               X N M A K E                                --
*-                                                                          --
*-                            $Revision: 1.22 $                             --
*-                                                                          --
*-     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --
*-                                                                          --
*- GNAT is free software;  you can  redistribute it  and/or modify it under --
*- terms of the  GNU General Public License as published  by the Free Soft- --
*- ware  Foundation;  either version 2,  or (at your option) any later ver- --
*- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
*- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
*- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
*- for  more details.  You should have  received  a copy of the GNU General --
*- Public License  distributed with GNAT;  see file COPYING.  If not, write --
*- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
*- MA 02111-1307, USA.                                                      --
*-                                                                          --
*- GNAT was originally developed  by the GNAT team at  New York University. --
*- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --
*-                                                                          --
*-----------------------------------------------------------------------------

* Program to construct the spec and body of the Nmake package
*
*   Input files:
*
*      sinfo.ads     Spec of Sinfo package
*      nmake.adt     Template for Nmake package
*
*   Output files:
*
*      nmake.ads     Spec of Nmake package
*      nmake.adb     Body of Nmake package
*
* Note: this program assumes that sinfo.ads has passed the error checks which
* are carried out by the csinfo utility, so it does not duplicate these checks
*
*  In the absence of any switches, both the ads and adb files are constructed.
*  The switch -s or /s indicates that only the ads file is to be constructed.
*  The switch -b or /b indicates that only the adb file is to be constructed.
*
*  If a file name argument is given, then the output is written to this file
*  rather than to nmake.ads or nmake.adb. A file name can only be given if
*  exactly one of the -s or -b options is present.

        "$Revision: 1.22 $" "$Rev" "ision: " break(' ') $ xnmakerev

        terminal =
        lineno = 0
        &stlimit = -1
        nwidth = 28
        &anchor = 1

        files = 'nmake.ads'
        fileb = 'nmake.adb'

        args = trim(host(1))
        args = ident(args, "0") trim(host(0))

        args breakx('-/') $ a len(1) any('bB') (span(' ') | '') = a :f(o1)
        files =

o1      args breakx('-/') $ a len(1) any('sS') (span(' ') | '') = a :f(o2)
        fileb =

o2      args span(' ') =
        args break(' ') $ a span(' ') rpos(0) = a
        args break(' ')                                       :f(o3)

bado    terminal = "invalid arguments"                        :(end)

o3      ident(args)                                           :s(o4)
        ident(files)    :s(o5)
        ident(fileb)    :s(o6)
        terminal = "if file name given, must use -b or -s"    :(end)

o5      fileb = args                                          :(o4)
o6      files = args                                          :(o4)
o4
        input(.ins,1,'sinfo.ads')
        input(.int,2,'nmake.adt')

        (differ(files) output(.outs,3,files))
        (differ(fileb) output(.outb,4,fileb))

        &anchor = 1
        wsp = span(' ' char(9))
        digits = '0123456789'
        digit = any(digits)

* Get sinfo rev

slp     line = ins
        line breakx('$') '$Rev' 'ision: ' break(' ') $ sinforev :f(slp)


* Copy initial part of template to spec and body

lp1     line = int                              :f(err)

        line breakx('$') '$Rev' 'ision: ' break(' ') $ temprev :f(lp1a)

        outb = outs =
.        '--                 Generated by xnmake revision '
.        xnmakerev ' using'
.        '                   --'

        outb = outs =
.        '--                         sinfo.ads revision ' sinforev
.        '                          --'

        outb = outs =
.        '--                         nmake.adt revision ' temprev
.        '                          --'    :(lp1)

* Skip lines describing the template

lp1a    line '--  This file is a template'      :f(lp1c)
lp1b    line = trim(int)                        :f(err)
        differ(line)                            :s(lp1b)

lp1c    line 'package'                          :s(p1)
        line breakx(' ') $ x span(' ') '--  body only' = x :s(lpbb)
        line breakx(' ') $ x span(' ') '--  spec only' = x :s(lpss)
        line breakx('T') $ a 'T e m p l a t e' =
.            a '    S p e c    '
        outs = line
        line breakx('S') $ a 'S p e c' = a 'B o d y'
        outb = line                             :(lp1)

lpbb    outb = line                             :(lp1)
lpss    outs = line                             :(lp1)

* Package line reached

p1      outs = 'package Nmake is'
        outb = 'package body Nmake is'
        outb =

* Copy rest of lines up to template insert point to spec only

lp2     line = int                              :f(err)
        line '!!TEMPLATE INSERTION POINT'       :s(lp3)
        outs = line                             :(lp2)

* Here we are doing the actual insertions

lp3     line = trim(ins)                        :f(err)
        line wsp '--  N_' rem $ node            :f(lp3)
        node breakx(' .,')                      :s(lp3)
        ident(node,'Unused')                    :s(lp3)
        ident(node,'Empty')                     :s(done)

        prevl = '   function Make_' node ' (Sloc : Source_Ptr'
        arg_list =

lp4     line = trim(ins)                        :f(err)
        ident(line)                             :s(ef)

        line wsp '--  plus fields for binary operator'    :s(cb)
        line wsp '--  plus fields for unary operator'     :s(cu)

        line wsp '--  ' break(' ') $ synonym ' (' break(')') $ field
.                 rem $ comment                 :f(lp4)

        ident(synonym, "Prev_Ids")              :s(lp4)
        ident(synonym, "More_Ids")              :s(lp4)
        ident(synonym, "Comes_From_Source")     :s(lp4)
        ident(synonym, "Paren_Count")           :s(lp4)
        field breakx('-') '-Sem'                :s(lp4)
        field breakx('-') '-Lib'                :s(lp4)

        type =

        field breakx(digits) $ field

        field = ident(field, 'Str')      'String_Id'
        field = ident(field, 'Node')     'Node_Id'
        field = ident(field, 'Name')     'Name_Id'
        field = ident(field, 'List')     'List_Id'
        field = ident(field, 'Elist')    'Elist_Id'
        field = ident(field, 'Flag')     'Boolean'

        default =
        default = ident(field, 'Boolean') 'False'
        comment breakx('(') '(set to ' break(' ') $ default ' if'

        outb = outs = prevl ';'

        arg_list = arg_list synonym ','
        synonym = rpad(synonym,nwidth)

        prevl = ident(default) "      " synonym ' : ' field  :s(lp4)
        prevl = "      " synonym ' : ' field ' := ' default :(lp4)

cu      outb = outs = prevl ';'
        arg_list = arg_list 'Right_Opnd,'
        prevl =       "      " rpad('Right_Opnd',nwidth) ' : Node_Id' :(lp4)

cb      outb = outs = prevl ';'
        arg_list = arg_list 'Left_Opnd,Right_Opnd,'
        outb = outs = "      " rpad('Left_Opnd',nwidth) ' : Node_Id;'
        prevl =       "      " rpad('Right_Opnd',nwidth) ' : Node_Id' :(lp4)

ef      outb = outs = prevl ')'
        outs = '      return Node_Id;'
        outs = '   pragma Inline (Make_' node ');'
        outb = '      return Node_Id'
        outb = '   is'
        outb =
.       '      N : constant Node_Id :='

        node 'Defining_Identifier'   :s(extend)
        node 'Defining_Character'    :s(extend)
        node 'Defining_Operator'     :s(extend)
        outb =
.       '            New_Node (N_' node ', Sloc);' :(merge)

extend  outb =
.       '            New_Entity (N_' node ', Sloc);'

merge   outb = '   begin'

efl     arg_list  break(',') $ arg ',' =                :f(efe)
        outb = lt(size(arg),28) '      Set_' arg ' (N, ' arg ');'    :s(efl)
        outb = '      Set_' arg
        outb = '        (N, ' arg ');'    :(efl)

efe     node 'Op_' rem $ Op_Name        :f(efx)

        outb = ident(node,'Op_Plus')
.              '      Set_Chars (N, Name_Op_Add);'       :s(eff1)

        outb = ident(node,'Op_Minus')
.              '      Set_Chars (N, Name_Op_Subtract);'  :s(eff1)

        Op_Name ('Shift_' | 'Rotate_')                   :f(eff)

        outb = '      Set_Chars (N, Name_' Op_Name ');'  :(eff2)

eff     outb = '      Set_Chars (N, Name_' node ');'

eff1    Op_Name ('Or_Else' | 'And_Then' | 'In' | 'Not_In')  :s(efx)
eff2    outb = '      Set_Entity (N, Standard_' node ');'

efx     outb = '      return N;'
        outb = '   end Make_' node ';'
        outs =
        outb =                                  :(lp3)

done    outs = outb = 'end Nmake;'
end
