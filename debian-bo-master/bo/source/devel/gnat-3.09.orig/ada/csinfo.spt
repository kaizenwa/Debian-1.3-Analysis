*-----------------------------------------------------------------------------
*-                                                                          --
*-                                 G N A T                                  --
*-                                                                          --
*-                            COMPILER UTILITIES                            --
*-                                                                          --
*-                               C S I N F O                                --
*-                                                                          --
*-                            $Revision: 1.32 $                             --
*-                                                                          --
*-     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --
*-                                                                          --
*- GNAT is free software;  you can  redistribute it  and/or modify it under --
*- terms of the  GNU General Public License as published  by the Free Soft- --
*- ware  Foundation;  either version 2,  or (at your option) any later ver- --
*- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
*- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
*- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
*- for  more details.  You should have  received  a copy of the GNU General --
*- Public License  distributed with GNAT;  see file COPYING.  If not, write --
*- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
*- MA 02111-1307, USA.                                                      --
*-                                                                          --
*- GNAT was originally developed  by the GNAT team at  New York University. --
*- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --
*-                                                                          --
*-----------------------------------------------------------------------------

* Program to check consistency of Syntax_Info spec (sinfo.ads) and
* Syntax_Info body (sinfo.adb). Checks that field name usage is consistent
* and that debugging cross-reference lists are correct, as well as making
* sure that all the comments on field name usage are consistent.

        terminal =
        lineno = 0
        &stlimit = -1
        input(.in,1,'sinfo.ads')
        &anchor = 1
        wsp = span(' ' char(9))
        fields = table(300)
        refs = table(300)
        terminal = 'Check for field name consistency'
        digit = '0123456789'

* Special fields table. The following fields are not recorded or checked by
* csinfo, since they are specially handled. This means that the both the
* field definitions, and the corresponding subprograms are completely ignored.

        special = table(20)
        special<'Analyzed'> = 1
        special<'Assignment_OK'> = 1
        special<'Cannot_Be_Constant'> = 1
        special<'Chars'> = 1
        special<'Comes_From_Source'> = 1
        special<'Do_Overflow_Check'> = 1
        special<'Do_Range_Check'> = 1
        special<'Entity'> = 1
        special<'Error_Posted'> = 1
        special<'Etype'> = 1
        special<'Evaluate_Once'> = 1
        special<'First_Itype'> = 1
        special<'Has_Dynamic_Itype'> = 1
        special<'Has_Dynamic_Range_Check'> = 1
        special<'Has_Dynamic_Length_Check'> = 1
        special<'Has_Private_View'> = 1
        special<'Is_Controlling_Actual'> = 1
        special<'Is_Overloaded'> = 1
        special<'Is_Static_Expression'> = 1
        special<'Left_Opnd'> = 1
        special<'Must_Not_Freeze'> = 1
        special<'Parens'> = 1
        special<'Raises_Constraint_Error'> = 1
        special<'Right_Opnd'> = 1

* The following define the standard fields used for binary operator, unary
* operator, and other expression nodes. Numbers in the range 1-5 refer to
* the Fieldn fields. Letters D-R refer to flags:
*
*     D = Flag4
*     E = Flag5
*     F = Flag6
*     G = Flag7
*     H = Flag8
*     I = Flag9
*     J = Flag10
*     K = Flag11
*     L = Flag12
*     M = Flag13
*     N = Flag14
*     O = Flag15
*     P = Flag16
*     Q = Flag17
*     R = Flag18

        n_fields = breakx("JL")
        e_fields = breakx("5EFGHIJLOP")
        u_fields = breakx("1345EFGHIJKLOPQ")
        b_fields = breakx("12345EFGHIJKLOPQ")

* Loop to acquire information from node definitions in sinfo.ads, checking
* for consistency in Op/Flag assignments to each synonym

lp      line = trim(in)         :f(err)
        lineno = lineno + 1
        line '   -- Node Access Functions'    :s(nxt1)

        line wsp '--  N_' rem $ node          :f(n0)
        node break(' .,')                     :s(n0)
        fieldsused =                          :(lp)

n0      ident(node)    :s(lp)
        node = ident(line)      :s(lp)

        line wsp '--  plus fields for binary operator'    :s(cb)
        line wsp '--  plus fields for unary operator'     :s(cu)
        line wsp '--  plus fields for expression'         :s(ce)

        line wsp '--  ' break(' ') $ synonym ' (' break(')') $ field
.                                       :f(lp)
        synonym 'plus' :s(lp)
        field breakx('-') $ field
        differ(special<synonym>)                       :s(lp)
        fields<synonym> = ident(fields<synonym>) field :s(n1)
        terminal = differ(field, fields<synonym>)
.       'Inconsistent field reference at line ' lineno ' for ' synonym :s(end)

n1      refs<synonym> = node ',' refs<synonym>
        field breakx(digit) span(digit) $ whichfield
        field 'Flag'                    :f(n1a)
        whichfield = substr(&alphabet,whichfield + 65,1)

n1a     fieldsused break(whichfield)            :f(n1c)
        terminal = 'Overlapping field at line ' lineno ' for ' synonym :s(end)
n1c     fieldsused = fieldsused whichfield
        fieldsused n_fields                     :f(lp)s(bad)

cb      fieldsused b_fields                     :f(lp)s(bad)
cu      fieldsused u_fields                     :f(lp)s(bad)
ce      fieldsused e_fields                     :f(lp)s(bad)
bad     terminal = 'fields conflict with standard fields for node ' node :(lp)

* Loop through field function definitions to make sure they are OK

nxt1    terminal = '     OK'
        terminal =
        terminal = 'Check for function consistency'

        fields1 = copy(fields)

lp2     line = trim(in)         :f(err)
        lineno = lineno + 1

        line '   -- Node Update' :s(nxt2)

        line wsp 'function ' rem $ synonym        :f(lp2)
        differ(special<synonym>)                  :s(lp2)

        terminal = ident(fields1<synonym>) 'function on line ' lineno
.       ' is for unused synonym' :s(end)

        line = trim(in)         :f(err)
        lineno = lineno + 1

        line breakx('-') '-- ' rem $ field    :f(err)

        fields1<synonym> = ident(field,fields1<synonym>) :s(lp2)
        terminal = 'Wrong field in function ' synonym :(end)

* Check no field function definitions were omitted

nxt2    terminal = '     OK'
        terminal =
        terminal = 'Check for missing functions'

        list = convert(fields1,'ARRAY')
        ident(list)  :s(nxt3)
        terminal = 'No function for field synonym ' list<1,1> :s(end)

* Check field set procedures

nxt3    terminal = '     OK'
        terminal =
        terminal = 'Check for set procedure consistency'
        fields1 = copy(fields)

lp3     line = trim(in)         :f(err)
        lineno = lineno + 1

        line '   -- Inline Pragmas' :s(nxt3a)

        line wsp 'procedure Set_' rem $ synonym :f(lp3)
        differ(special<synonym>)                :s(lp3)

        terminal = ident(fields1<synonym>) 'procedure on line ' lineno
.       ' is for unused synonym' :s(end)

        line = trim(in)         :f(err)
        lineno = lineno + 1

        line breakx('-') '-- ' rem $ field    :f(err)

        fields1<synonym> = ident(field,fields1<synonym>) :s(lp3)

        terminal = 'Wrong field in procedure Set_' synonym :(end)

* Check no field set procedure definitions were omitted

nxt3a   terminal = '     OK'
        terminal =
        terminal = 'Check for missing set procedures'
        list = convert(fields1,'ARRAY')
        ident(list)  :s(nxt4)
        terminal = 'No procedure for field synonym Set_' list<1,1> :(end)

*  Check pragma Inlines are all for existing fields

nxt4    terminal = '     OK'
        terminal =
        fields1 =
        terminal = 'Check pragma Inlines are all for existing subprograms'
        inlines = table(100)

lp4     line = trim(in)   :f(nxt5)
        lineno = lineno + 1

        line wsp 'pragma Inline (' break(')') $ name :f(lp4)
        differ(special<name>)                        :s(lp4)
        name 'Set_' rem $ name    :s(nxt5)

lp4m    terminal = ident(fields<name>) 'Pragma Inline on line ' lineno
.         ' does not correspond to synonym'
.               :s(end)
        inlines<name> = inlines<name> 'r' :(lp4)

* Check no pragma Inlines were omitted

nxt5    terminal = '     OK'
        terminal =
        terminal = 'Check no pragma Inlines were omitted'

        list = convert(fields,'ARRAY')
        m = 0

nxt5l   m = m + 1
        nxt = list<m,1>         :f(nxt7)

        ident(inlines<nxt>,'r') :s(nxt5l)
nxt6e   terminal = 'Incorrect pragma Inlines for ' nxt :(end)

nxt7    terminal = '     OK'
        terminal =
        inlines =

* Check consistency of functions in the body

        endfile(1)
        input(.in,1,'sinfo.adb')
        lineno = 0
        terminal = 'Check references in functions in body'
        refscopy = copy(refs)

lp7     line = trim(in)         :f(err)
        lineno = lineno + 1
        line '   -- Field Access Functions --' :f(lp7)

lp8     line = trim(in)         :f(err)
        lineno = lineno + 1

        line '   -- Field Set Procedures --' :s(nxt9)

        line '   function ' rem $ synonym  :f(lp8)
        differ(special<synonym>)           :s(lp8)

        ref = refs<synonym>
        refs<synonym> =
        terminal = ident(ref) 'Function on line ' lineno
.               ' is for unknown synonym' :s(end)

* alpha sort of references for this entry

        refa = array(100)
        n = 0
sort1   ref break(',') $ nxtref ',' =   :f(sort2)
        refa<n = n + 1> = nxtref  :(sort1)


sort2   m = 1

sort3   ge(m,n)         :s(sort4)
        m = llt(refa<m>, refa<m + 1>) m + 1 :s(sort3)
        temp = refa<m>
        refa<m> = refa<m + 1>
        refa<m + 1> = temp      :(sort2)

sort4   line = trim(in)         :f(err)
        lineno = lineno + 1
        line = trim(in)         :f(err)
        lineno = lineno + 1
        line = trim(in)         :f(err)
        lineno = lineno + 1

        m = 0

* checking references for one entry

checkr  line = trim(in)         :f(err)
        lineno = lineno + 1
        m = m + 1
        line break('=') '= N_' (break(' ,)') | rem)  $ next :f(checke)
        next breakx(',') $ next
        differ(next,refa<m>) :s(checke)
        lt(m,n) :s(checkr)f(checkf1)

checke  terminal = 'Expecting N_' refa<m> ' at line ' lineno    :(end)

checkf1 line = trim(in) :f(err)
        lineno = lineno + 1

        line wsp 'return ' break(' ') $ field
        ident(field, fields<synonym>) :s(lp8)
        terminal = 'Wrong field for function ' synonym ' at line ' lineno
.               ' should be ' fields<synonym>   :(end)

* check missing functions in body

nxt9    terminal = '     OK'
        terminal =
        terminal = 'Check for missing functions in body'

        list = convert(refs,'ARRAY')      :f(nxt10)

        ident(list)   :s(nxt10)

        terminal = 'Missing function ' list<1,1> ' in body' :(end)

* check consistency of Set procedures in body

nxt10   terminal = '     OK'
        terminal =
        terminal = 'Check Set procedures in body'
        fields1 = copy(fields)
        refs = refscopy

lp10    line = trim(in)         :f(err)
        lineno = lineno + 1

        line 'end'                      :s(nxt12)

        line '   procedure Set_' rem $ synonym :f(lp10)
        differ(special<synonym>)               :s(lp10)

        ref = refs<synonym>
        refs<synonym> =

        terminal = ident(fields1<synonym>) 'Procedure on line ' lineno
.               ' is for unknown synonym' :s(end)
* alpha sort of references for this entry

        refa = array(100)
        n = 0
sortx1  ref break(',') $ nxtref ',' =   :f(sortx2)
        refa<n = n + 1> = nxtref  :(sortx1)


sortx2  m = 1

sortx3  ge(m,n)         :s(sortx4)
        m = llt(refa<m>, refa<m + 1>) m + 1 :s(sortx3)
        temp = refa<m>
        refa<m> = refa<m + 1>
        refa<m + 1> = temp      :(sortx2)

sortx4  line = trim(in)         :f(err)
        lineno = lineno + 1
        line = trim(in)         :f(err)
        lineno = lineno + 1
        line = trim(in)         :f(err)
        lineno = lineno + 1

        m = 0

* checking references for one entry

checkxr line = trim(in)         :f(err)
        lineno = lineno + 1
        m = m + 1
        line break('=') '= N_' (break(' ,)') | rem) $ next :f(checke)
        differ(next,refa<m>) :s(checke)
        lt(m,n) :s(checkxr)f(checkf2)

checkxe terminal = 'Expecting N_' refa<m> ' at line ' lineno    :(end)

checkf2 line = trim(in) :f(err)
        lineno = lineno + 1

        line wsp 'Set_' break(' ') $ field ' (N, Val)' :f(checkf2)
        field break('_') . field '_With_Parent'

        ident(field, fields<synonym>) :s(mxt11)
        terminal = 'Wrong field for procedure Set_' synonym ' at line ' lineno
.               ' should be ' fields<synonym>   :(end)

mxt11   fields1<synonym> =      :(lp10)

* check missing procedures in body

nxt12   terminal = '     OK'
        terminal =
        terminal = 'Check for missing set procedures in body'

        list = convert(fields1,'ARRAY')   :f(nxt13)

        ident(list)   :s(nxt13)

        terminal = 'Missing procedure Set_' list<1,1> ' in body' :(end)

nxt13   terminal = '     OK'
        terminal =
        terminal = 'All tests completed successfully, no errors detected'
end
