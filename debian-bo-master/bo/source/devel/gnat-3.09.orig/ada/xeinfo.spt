*-----------------------------------------------------------------------------
*-                                                                          --
*-                                 G N A T                                  --
*-                                                                          --
*-                            COMPILER UTILITIES                            --
*-                                                                          --
*-                               X E I N F O                                --
*-                                                                          --
*-                            $Revision: 1.23 $                             --
*-                                                                          --
*-   Copyright (C) 1992,1993,1994,1995,1996 Free Software Foundation, Inc.  --
*-                                                                          --
*- GNAT is free software;  you can  redistribute it  and/or modify it under --
*- terms of the  GNU General Public License as published  by the Free Soft- --
*- ware  Foundation;  either version 2,  or (at your option) any later ver- --
*- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
*- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
*- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
*- for  more details.  You should have  received  a copy of the GNU General --
*- Public License  distributed with GNAT;  see file COPYING.  If not, write --
*- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --
*- MA 02111-1307, USA.                                                      --
*-                                                                          --
*- GNAT was originally developed  by the GNAT team at  New York University. --
*- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --
*-                                                                          --
*-----------------------------------------------------------------------------

* Program to construct C header file a-einfo.h (C version of einfo.ads spec,
* for use by Gigi, contains all definitions and access functions, but does not
* contain set procedures, since Gigi is not allowed to modify the GNAT tree)
*
*   Input files:
*
*      einfo.ads     spec of Einfo package
*      einfo.adb     body of Einfo package
*
*   Output files:
*
*      a-einfo.h     Corresponding c header file
*
* Note: It is assumed that the input files have been compiled without errors
*
* An optional argument allows the specification of an output file name to
* override the default a-einfo.h file name for the generated output file.
*
* Most, but not all of the functions in Einfo can be inlined in the C header.
* Those functions which cannot be inlined are identified in the header and
* in terminal output when this utility program is run.

        "$Revision: 1.23 $" "$Rev" "ision: " break(' ') $ xeinforev

        arg = trim(host(1))
        arg = ident(arg, "0") trim(host(0))
        ofile = ident(arg) 'a-einfo.h'
        ofile = differ(arg) arg

        lineno = 0
        &stlimit = -1
        input(.in,1,'einfo.ads')
        input(.inb,5,'einfo.adb')
        output(.out,2,ofile)
        &anchor = 1
        wsp = span(' ' char(9)) | ''

* Get einfo revs and write header to output file

slp1    line = inb
        ident(line)   :s(err)
        line breakx('$') '$Rev' 'ision: ' break(' ') $ einfobrev
.                                                     :f(slp1)

slp     line = in
        ident(line)    :s(start)
        line breakx('$') '$Rev' 'ision: ' break(' ') $ einforev :s(vsn)
        line '--                                 S p e c       ' =
.            '--                              C Header File    '

        line '--' = '/*'
        line rtab(2) $ a '--' = a '*/'
        out = line                :(slp)

vsn     out = '/*                 Generated by xeinfo revision ' xeinforev
.             ' using                  */'
        out = '/*                         einfo.ads revision ' einforev
.             '                         */'
        out = '/*                         einfo.adb revision ' einfobrev
.             '                         */'           :(slp)

start   lc = 'abcdefghijklmnopqrstuvwxyz'
        uc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        out =

* status<N> = 'I' for inlined function, null otherwise

        status = table(200)

*  Get non-comment line (comment lines skipped, also skips FOR rep clauses)

        define('getlins()a,b')                  :(fd2)

getlins getlins = trim(in)                      :f(freturn)
        lineno = lineno + 1
        ident(getlins)                          :s(getlins)
        getlins wsp 'for '                      :s(getlins)
        getlins wsp $ a '--' =                  :f(return)s(getlins)

*  Process function header into C form and output it

fd2     define('sethead(line,term)a,args,formal,formaltype,filler,i') :(fd3)

sethead line wsp $ a
.       'function' wsp break(' ') $ Name =      :s(sh5)f(err)

sh5     args =
        line wsp $ filler '(' =                 :f(sh8)
        args = filler '('

sh6     line break(' :') $ formal wsp ':' wsp
.            breakx(' );') $ formaltype =       :f(err)
        args = args formaltype ' ' formal
        line wsp '; ' =                         :f(sh7)
        args = args ','                         :(sh6)

sh7     line wsp ')' =
        args = args ')'

sh8     line wsp 'return' wsp breakx(' ;') $ rtn :s(sh10)f(err)

sh10    i =
        i = ident(status<Name>,'I') "INLINE "
        out = a i rtn ' ' Name args term
.                                               :(return)

fd3

* find pragma inlines

i0      lineno = 0

i1      line = getlins()                        :f(n0)
        line wsp 'pragma Inline (' break(')') $ name  :f(i1)
        status<name> = 'I'                      :(i1)

* process specification

n0      input(.in,4,'einfo.ads')
        lineno = 0

n1      line = getlins()
        line wsp 'package '                     :s(n2)f(n1)

n2      V = 0
        line = getlins()
        line wsp 'type Entity_Kind'             :f(err)

n3      line = getlins()
        line wsp break(',') $ N ','             :f(n4)
        out = '   #define ' rpad(N,32) ' ' V
        V = V + 1                               :(n3)

n4      line wsp rem $ N                        :f(err)
        out = '   #define ' rpad(N,32) ' ' V
        getlins() wsp ");"                      :f(err)

        out =

* Loop through subtype and type declarations

n5      line = getlins()                        :f(err)
        line wsp 'function'                     :s(funcs)
        line wsp $ a 'subtype ' break(' ') $ N  :s(subtype)
        line wsp $ a 'type ' break(' ') $ N ' is (' :f(err)

* Process type declaration (must be enumeration type)

type    ctr = 0
        out = a 'typedef int ' N ';'

typelp  line = getlins()                             :f(err)
        line wsp $ a break(',)') $ nam len(1) $ term :f(err)
        out = a "#define " rpad(nam,25) ctr
        ctr = ctr + 1
        ident(term,',') :s(typelp)
        out =

*  Processing a subtype declaration, see if it is simply an abbrevation
*  of the form subtype x is y, and if so generate the appropriate typedef

subtype line wsp 'subtype' wsp break(' ') $ new wsp 'is'
.         wsp break(' ;') $ old wsp ';' wsp rtab(0)  :f(n8)
        out = a 'typedef ' old ' ' new ';'      :(n5)

*  Otherwise the subtype must be declaring a subrange of Entity_Id

n8      line wsp $ a 'subtype ' break(' ') $ N  :f(n5)
        getlins() wsp break(' ') $ N1           :f(err)

n8a     line = trim(in)                         :f(err)
        lineno = lineno + 1
        line wsp '-- ' rem $ N2                 :s(n8a)

        line wsp break(';') $ N3                :f(err)
        out = a 'SUBTYPE (' N ', Entity_Kind, '
        out = a '   ' N1 ', ' N3 ')'            
        out =                                   :(n5)

* process function declarations (note laststatus used to control blank lines)

funcs   out =
        laststatus = 'I'

* loop through function declarations

n9      line wsp $ aa 'function' wsp break(' (') $ FN   :f(rbody)

        ident(status<FN>,'I')                           :s(n9a)

* case of non-lined function

        out =
        out = '   #define ' FN ' einfo__' replace(FN,uc,lc) :s(n9b)

* case of inlined function

n9a     out = ident(laststatus)

* merge here to output spec

n9b     sethead(line,';')
        laststatus = status<FN>
        line = getlins()                        :(n9)


* Read body to find inlined functions

rbody   out =
        input(.in,3,'einfo.adb')
        lineno = 1

* Loop through input lines to find bodies of inlined functions

n10     fline = getlins()                        :f(n13)
        fline wsp $ aa 'function' wsp break(' (') $ FN :f(n10)
        ident(status<FN>,'I')                   :f(n10)

* Here we have an inlined function

        fline breakx('r') 'return'              :f(badfunc)
        getlins() wsp 'begin'                   :f(badfunc)

* Skip past pragma Asserts

n10b    line = getlins()
        line wsp "pragma Assert"                :f(n11)

* pragma Assert found, get its continuation lines

n10c    line breakx(';')                        :s(n10b)
        line = getlins()                        :(n10c)

* process return statement

n11     line breakx('-') $ a '--' = a

* get continuations of return statement

n11a    line breakx(';')                        :s(n11c)
        nextlin = getlins()
        nextlin span(' ') = ' '
        line = line nextlin                     :(n11a)

n11c    line wsp 'return ' break(';') $ expr    :f(badfunc)
        getlins() wsp 'end' breakx(';') ';'     :f(badfunc)

        expr breakx(' ') $ a " in " rem $ b = "IN (" a ', ' b ")"
        expr breakx(' ') $ a " = " rem $ b = a ' == ' b
        out =
        sethead(fline,'')

        out = aa '   { return ' expr '; }'      :(n10)

n13     out =
        out =
.         '/* End of einfo.h (C version of Einfo package specification)'
.               ' */'    :(end)

badfunc terminal = "Body for function " FN " does not meet requirements"
.                         :(err)

err    terminal = lineno '.  ' line
       terminal = "**** fatal error ****"  :(fatal_error)

end
