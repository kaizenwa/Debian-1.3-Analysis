#!/bin/sh
if test "$1" = ""
then
   echo "Usage : gnatchop [-krsw] filename [directory]"
   echo " "
   echo "  k         limit filenames to 8 characters"
   echo "  r         generate Source_Reference pragmas"
   echo "  s         generate a compilation script"
   echo "  w         overwrite existing filenames"
   echo "  filename  source file"
   echo "  directory directory to place split files (default is ./)"
   exit 1;
fi
parms=
k8option=
#
# Scan through the options, checking for validity and especially looking for
# the 'k' option since this will be used for the call to gcc to get the offset
# information.
#
# modified by AS, 1994/06/06: use of getopts replaced by getopt since it
# seems more common.
#
if (getopt a a) >/dev/null 2>&1
then
   for c in `getopt krsw $*`
   do
      case $c in
         -k)       k8option="-k8"; shift;;
         -r | -s | -w)  parms="$parms $c"; shift;;
         --)       break;;
         -\?)      echo "Usage : gnatchop [-krsw] filename [directory]"; exit 1;;
      esac
   done
else
   while getopts krsw c
   do
      case $c in
         k)      k8option="-k8";;
         r | s | w)  parms="$parms -$c";;
         \?)     echo "Usage : gnatchop [-krsw] filename [directory]"; exit 1;;
      esac
   done
   shift `expr $OPTIND - 1`
fi

#
# Check that there is a filename argument after the option list, and that the
# file actually exists.
#
if test "$1" = ""
then
   echo "missing filename"
   echo "Usage : gnatchop [-krsw] filename [directory]"; exit 1
   exit 1
elif test ! -r $1
then
    echo "$1 not found"; exit 1
fi
# Call gnatf on the source filename argument with special options to generate
# offset information. Then call the gnatchp program to actuall split the
# source file in one file per compilation unit in the optional directory if
# given otherwise in the current directory.
#
gnatf -s -u $k8option $1 >tmpfile$$
if [ $? -ne 0 ] ; then
   echo ""
   echo "Warning: parse errors detected, chop might not be succesful"
fi
gnatchp $parms $1 $2 <tmpfile$$
rm tmpfile$$
