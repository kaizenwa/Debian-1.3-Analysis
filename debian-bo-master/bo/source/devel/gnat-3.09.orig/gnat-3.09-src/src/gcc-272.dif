This file consists of patches to the GCC base compiler that are needed
to patch bugs in GCC that affect GNAT.

Each of these patches is currently present in the master GCC sources
at the FSF (or is a variant of such, adapted to GCC 2.7.2) and will be
present in the next GCC release, unless superceded.

Sun Jan 19 08:58:47 1997  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* alpha.h (MINIMUM_ATOMIC_ALIGNMENT): New macro.

	* function.c (instantiate_virtual_regs_1, case USE, case CLOBBER):
	Properly handle case of shared MEM whose replacement is not valid.

Sat Jan 18 13:11:44 1997  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.c (get_unwidened): Don't crash if FIELD_DECL not layed out.

	* varasm.c (const_hash): Treat NON_LVALUE_EXPR like CONVERT_EXPR.
	(compare_constant_1, copy_constant, bc_assemble_integer): Likewise.

Mon Jan  6 08:07:27 1997  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* dwarfout.c (type_attribute): Ignore any subtype for now.

	* fold-const.c (operand_equal_p): Rework to consider two
	expressions that have embedded identical SAVE_EXPRs as
	equivalent; also handle some more cases.

Sat Jan  4 18:50:24 1997  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (get_inner_reference): Fix type error.
	(expand_expr, case COMPONENT_REF): Don't convert if modifier
	is EXPAND_CONST_ADDRESS, EXPAND_SUM, or EXPAND_INITIALIZER.
	* tree.c (staticp, case COMPONENT_REF, BIT_FIELD_REF): Not
	static if bitfield.

Sun Nov 24 10:59:08 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* gcc.c (give_switch): Add new arg, INCLUDE_BLANKS.
	(handle_braces): All callers changed.
	Add support for new construct: %{S*^}.

Sun Nov 17 20:29:18 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (get_inner_reference): Fix error in previous change.

Sat Nov 16 06:20:45 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (get_inner_reference): Add new arg PALIGNMENT and compute it.
	(expand_assignment, do_jump): Pass new arg to get_inner_reference.
	(expand_expr, case COMPONENT_REF): Likewise.
	* fold-const.c (optimize_bit_field_compare, decode_field_reference):
	Likewise.
	* tree.h (get_inner_reference): Add new arg.

Fri Nov  8 17:42:56 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* emit-rtl.c (change_address): If MEMREF isn't changing,
	return the old one.

	* expr.c (expand_assignment): Remove bogus resetting of alignment
	to inner alignment.
	(expand_expr, case COMPONENT_REF): Likewise.

Thu Nov  7 07:31:42 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* stor-layout.c (layout_record): Treat constant size as variable if
	it overflows.
	* fold-const.c (const_binop, case *_DIV_EXPR): Don't do special
	sizetype case if a constant overflows.
	(size_binop): Use integer_{zero,one}p instead of explicit test.
	* tree.c (integer_{zero,one,all_ones,pow2}p, real_{zero,one,two}p):
	Return 0 if TREE_CONSTANT_OVERFLOW.

Mon Oct 21 08:05:20 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (store_expr): Disable optimization of using convert
	if exp's type is a subtype.

Fri Oct  4 06:59:22 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* stor-layout.c (layout_decl): Don't turn off DECL_BIT_FIELD
	if DECL's alignment is less than its type.

	* reload1.c (reload): Ignore REG_EQUAL if (const (minus ...)).
	Needed only in GCC 2.7.2.

Sun Sep 29 11:24:07 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.c (build_complex): Add new argument, TYPE.
	* tree.h (build_complex): Likewise.
	* c-lex.c (yylex): Add new arg, TYPE, to call to build_complex.
	* fold-const.c (const_binop): Likewise.
	(fold, case CONJ_EXPR, COMPLEX_EXPR): Likewise.
	* varasm.c (copy_constant, case COMPLEX_CST): Likweise.
	* expr.c (expand_expr, case COMPONENT_REF): Don't try to directly
	load a complex.
	* recog.c (register_operand): Don't reject subreg of complex mode.
	* emit-rtl.c (mark_user_reg): New function.
	* function.c (assign_parms): Use it.
	* stmt.c (expand_decl): Likewise, and simplify code.

	* tree.c (contains_placeholder): Return 1 for PLACEHOLDER_EXPR.

	* reload1.c (gen_reload): Handle SUBREG in PLUS specially too.
	Change calls to emit_move_insn to recursive calls.

	* stmt.c (fixup_gotos): When running undefined labels, if no cleanup
	actions for this block, don't clear BEFORE_JUMP.

Tue Sep 24 14:20:14 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* loop.c (scan_loop): Don't use constant REG_EQUAL as source if
	not LEGITIMATE_CONSTANT_P.
	* mips.h (LEGITIMATE_CONSTANT_P): A CONST of a MINUS is not valid.

Sat Sep  7 22:12:29 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (store_field): If storing a record on big endian targets,
	set up so we store the high-order bits.
	(expand_expr, case COMPONENT_REF): Likewise for loads.

Sun Aug 25 22:33:02 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* function.c (mark_all_temps_used): New function.

Mon Aug 12 07:48:54 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (expand_builtin, case BUILT_IN_SETJMP): Add test
	and call for nonlocal_goto_receiver pattern.
	* stmt.c (expand_end_bindings): Likewise.

Wed Jul 24 21:52:18 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* cse.c (canon_hash, cse_insn): MEM is not unchanging if it is
	in the frame (since the temp slot might be reused).

Tue Jul 23 23:11:57 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.h (struct tree_int_cst): Add field for TREE_CST_RTL.
	* varasm.c (decode_addr_const, output_constant_def): Allow INTEGER_CST.

Sat Jul 20 09:34:09 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* dwarfout.c (output_bound_representation): Treat default case
	as variable bounds, then look inside for SAVE_EXPR.

	* mips.h (INITIALIZE_TRAMPOLINE): Use `_flush_cache'; flush data
	cache too.

Sat Jul 20 09:20:06 1996  Marco Walther  (Marco.Walther@mch.sni.de).

	* configure (mips-sni-sysv4): New target.
	* mips/sni-gas.h, mips/sni-svr4.h, mips/x-sni-svr4: New files.

Thu Jul  4 11:46:38 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (get_inner_reference): Delete using alternate mode for
	bitfield; we don't make bitfields anymore if not needed.

Sat Jun 29 05:48:40 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* explow.c (convert_memory_address, case PLUS): Fix error in
	last change.

Tue Jun 18 06:14:37 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* integrate.c (expand_inline_function): Add missing call to
	force_operand when getting structure_value_addr into reg.

	* expr.c (expand_builtin, case BUILT_IN_{SET,LONG}JMP): Properly
	handle case when ptr_mode != Pmode.

	* c-typeck.c (pointer_int_sum): Convert integer to both signedness
	and precision of sizetype.
	* explow.c (convert_memory_address, case PLUS, MULT): Don't commute
	operation with extension if not adding small integer.

	* configure (Makefile): Set target to the canonical form of target.

Wed Jun  5 13:47:17 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sparc.md (*call_{address,symbolic}_struct_value_sp32): Allow
	operand 2 to be the const0_rtx.

Mon Jun  3 07:55:12 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sparc.md (call): Mask unimp operand to 12 bits, just like Sun.

	* expr.c (store_field): Fix typo in last change; update TARGET addr.

	* c-decl.c (start_struct): Set TYPE_PACKED from flag_pack_struct.
	(start_enum): Likewise but from flag_short_enums.
	(finish_enum): Test TYPE_PACKED, not flag_short_enums.
	* stor-layout.c (layout_decl): Test DECL_PACKED and TYPE_PACKED
	instead of flag_pack_struct.

Mon May 27 06:40:32 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (expand_builtin, case BUILT_IN_{LONG,SET}JMP):
	Convert block address from ptr_mode to Pmode.

Fri May 17 15:20:39 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expmed.c (store_split_bit_field): Don't assume the alignment
	of VALUE is the same as the record.

Fri May 17 08:04:18 1996  Doug Rupp  (rupp@gnat.com)

	* msdos/configur.bat: If Ada subdirectory present, adjust Makefile.

Sat May 11 07:42:08 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (store_field): Support BLKmode bitfield if aligned on
	byte boundary using emit_block_move.
	(expand_expr, case COMPONENT_REF): Likewise.

Mon May  6 15:44:11 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* stmt.c (expand_decl): Don't deduce alignment of SIZE from
	DECL_ALIGN; use TYPE_ALIGN instead.

	* function.c (assign_parms): Set RTX_UNCHANGING_P in stack_parm
	if parm is read-only.

Mon May  6 13:14:45 1996  Jim Wilson  <wilson@cygnus.com>

	* expr.c (expand_expr, case INDIRECT_REF): Delete obsolete code
	to special case a SAVE_EXPR operand.

Fri Apr 26 06:37:57 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* stor-layout.c (layout_decl): Turn off DECL_BIT_FIELD for BLKmode
	that's properly aligned and a multiple of a byte.

Thu Apr 25 14:06:36 1996  Richard Kenner  (kennervlsi1.ultra.nyu.edu)

	* calls.c (expand_call): In inlining case, if BEFORE_CALLS is
	zero, start looking at first insn (one more place).

Thu Apr 11 07:24:00 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (preexpand_calls, case CALL_EXPR): Rework to properly
	avoid expanding functions returning variable size objects.

	* calls.c (expand_call): In inlining case, if BEFORE_CALLS is
	zero, start looking at first insn.

Tue Apr  9 07:12:05 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.c (substitute_in_expr): Don't return new expression if
	nothing changed.
	(substitute_in_type): Deleted, not used.
	* tree.h (substitute_in_type): Delete declaration.

Mon Apr  1 16:16:28 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expr.c (get_inner_reference): When finding mode to access bitfield
	that ends up properly aligned, use mode class of its type unless
	type's mode was BLKmode.

Sun Mar 31 05:11:56 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sched.c (schedule_block): CALL_INSNs don't affect fixed regs.

	* stor-layout.c (layout_decl): Don't make a bitfield an integral mode
	if the mode of the field type is not MODE_INT.

	* flow.c (propagate_block): CALL_INSNs don't kill fixed regs.

Thu Mar 28 08:35:19 1996  Doug Evans  <dje@canuck.cygnus.com>

	* sparc.h (FUNCTION_PROFILER): Save/restore %g2 around call to mcount.

Fri Mar 22 08:58:59 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* local-alloc.c (optimize_reg_copy_1): Only update reg_live_length
	if it is non-negative.

Sat Mar 16 18:58:08 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.c (substitute_in_expr, case COMPONENT_REF): Ignore
	if inner PLACEHOLDER_EXPR has not yet been initialized.

	* i386.c (standard_80386_constant_p): -0.0 is not 0.0.

Sat Mar  2 07:46:45 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* calls.c (expand_call): If passing by invisible ref, not const.

	* expr.c (do_jump, case COMPOUND_EXPR): Call preserve_temp_slots.

	* sparc.c (SKIP_CALLERS_UNIMP_P): Make agree with test used in call.

	* fold-const.c (fold, case *_DIV_EXPR): Ignore SAVE_EXPR if has RTL.

Wed Feb 21 08:02:45 1996  Richard Kenner  (kenner at vlsi1)

	* expr.c (expand_builtin, case BUILT_IN_SETJMP): Set CONST_CALL_P
	on NOTE_INSN_SETJMP instead of emitting USE insns for call-saved regs.
	* reload1.c (reload): For special CONST_CALL_P NOTE_INSN_SETJMP,
	mark all call-saved regs as used.
	* sched.c (sched_analyze): Record NOTE_INSN_SETJMP if no 
	CALL_INSN as prev; preserve CONST_CALL_P bit.
	(reemit_notes): Restore CONST_CALL_P.

Mon Feb 19 07:19:07 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sparc.md (nonlocal_goto): No longer need USE of %o0.
	(goto_handler_and_restore): Show uses %o0.

Sat Feb  3 14:48:39 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* reload1.c (eliminate_regs, case USE): If USE of source of
	replacement, show can't make replacement.

Fri Feb  2 08:26:54 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* flow.c (jmp_uses_reg_or_mem): Renamed from uses_reg_or_mem.
	Don't look into condition of an IF_THEN_ELSE; also make faster.
	(find_basic_blocks): Use new name.

Sat Jan 27 07:50:11 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* tree.h (enum built_in_function): Add BUILT_IN_{SET,LONG}JMP.
	* expr.c: Include hard-reg-set.h.
	(arg_pointer_save_area): New declaration.
	(expand_builtin, case BUILT_IN_{SET,LONG}JMP): New cases.
	* Makefile.in (expr.o): Includes hard-reg-set.h.
	* c-decl.c (init_decl_processing): Add definitions for
	__builtin_setjmp and __builtin_longjmp.
	* cccp.c (initialize_builtins): Add def of __HAVE_BUILTIN_SETJMP__.

	* expr.c (expand_expr, case COMPONENT_REF): Pass EXPAND_INITIALIZER
	to recursive call.

Wed Jan 24 18:00:12 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>

	* alpha.c (alpha_write_verstamp): Only emit MS_STAMP and LS_STAMP,
	not the extra numbers.

Thu Jan 18 08:46:56 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sched.c (flush_pending_lists): Add new arg, ONLY_WRITE.
	(sched_analyze_{1,2,insn}): Add new arg to flush_pending_lists.
	(sched_analyze): Always flush pending write list for call, even const.

Tue Jan 16 08:08:17 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expmed.c (extract_bit_field): Don't abort if not MEM_IN_STRUCT_P.

Sun Jan 14 17:59:09 1996  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* stupid.c (stupid_find_reg): Don't try to allocate reg if live
	over more than 5,000 insns.

Sat Dec 30 07:59:05 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* sdbout.c (plain_type_1, case ARRAY_TYPE): Subtract lower bound
	when writing dimension.

Tue Dec 26 21:52:27 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* fold-const.c (fold_convert): When converting a NaN to 
	another type, change the type of the node before returning it.

Fri Dec 22 17:30:44 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* mips.c (expand_block_move): Preserve MEM flags in call to
	movstrsi_internal.

	* reload.c (find_valid_class): New function.
	(push_reload): Use it in cases where a SUBREG and its contents
	both need to be reloaded.

	* toplev.c (rest_of_compilation): Never defer functions that
	contain nested functions.

Fri Dec 15 08:06:50 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expmed.c (store_bit_field): Don't use insv for BLKmode value.
	(store_split_bit_field): Set total_bits to BITS_PER_FOR for
	BLKmode value.

	* function.c (init_temp_slots): New function.
	(init_function_start): Code moved to new function and called here.
	* toplev.c (rest_of_compilation): Call init_temp_slots.

Wed Dec 13 15:35:34 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)

	* expmed.c (expand_divmod): Don't use TARGET if it's the wrong mode.

*** cse.old	Thu Nov 16 15:49:11 1995
--- cse.c	Sun Nov 26 22:37:16 1995
*************** cse_basic_block (from, to, next_branch, 
*** 8405,8408 ****
--- 8405,8409 ----
    int to_usage = 0;
    int in_libcall_block = 0;
+   int num_insns = 0;
  
    /* Each of these arrays is undefined before max_reg, so only allocate
*************** cse_basic_block (from, to, next_branch, 
*** 8437,8440 ****
--- 8438,8461 ----
      {
        register enum rtx_code code;
+       int i;
+       struct table_elt *p, *next;
+ 
+       /* If we have processed 1,000 insns, flush the hash table to avoid
+ 	 extreme quadratic behavior.  */
+       if (num_insns++ > 1000)
+ 	{
+ 	  for (i = 0; i < NBUCKETS; i++)
+ 	    for (p = table[i]; p; p = next)
+ 	      {
+ 		next = p->next_same_hash;
+ 
+ 		if (GET_CODE (p->exp) == REG)
+ 		  invalidate (p->exp, p->mode);
+ 		else
+ 		  remove_from_table (p, i);
+ 	      }
+ 
+ 	  num_insns = 0;
+ 	}
  
        /* See if this is a branch that is part of the path.  If so, and it is
*** expmed.c.old	Fri Jul 14 16:40:47 1995
--- expmed.c	Wed Dec 13 12:55:11 1995
*************** expand_divmod (rem_flag, code, mode, op0
*** 3189,3193 ****
  	   Notice that we compute also the final remainder value here,
  	   and return the result right away.  */
! 	if (target == 0)
  	  target = gen_reg_rtx (compute_mode);
  
--- 3189,3193 ----
  	   Notice that we compute also the final remainder value here,
  	   and return the result right away.  */
! 	if (target == 0 || GET_MODE (target) != compute_mode)
  	  target = gen_reg_rtx (compute_mode);
  
*************** expand_divmod (rem_flag, code, mode, op0
*** 3316,3320 ****
  	       remainder.  Notice that we compute also the final remainder
  	       value here, and return the result right away.  */
! 	    if (target == 0)
  	      target = gen_reg_rtx (compute_mode);
  
--- 3316,3320 ----
  	       remainder.  Notice that we compute also the final remainder
  	       value here, and return the result right away.  */
! 	    if (target == 0 || GET_MODE (target) != compute_mode)
  	      target = gen_reg_rtx (compute_mode);
  
*************** expand_divmod (rem_flag, code, mode, op0
*** 3418,3422 ****
  	       remainder.  Notice that we compute also the final remainder
  	       value here, and return the result right away.  */
! 	    if (target == 0)
  	      target = gen_reg_rtx (compute_mode);
  	    if (rem_flag)
--- 3418,3422 ----
  	       remainder.  Notice that we compute also the final remainder
  	       value here, and return the result right away.  */
! 	    if (target == 0 || GET_MODE (target) != compute_mode)
  	      target = gen_reg_rtx (compute_mode);
  	    if (rem_flag)
*************** expand_divmod (rem_flag, code, mode, op0
*** 3602,3605 ****
--- 3602,3608 ----
    if (quotient == 0)
      {
+       if (target && GET_MODE (target) != compute_mode)
+ 	target = 0;
+ 
        if (rem_flag)
  	{
*************** expand_divmod (rem_flag, code, mode, op0
*** 3653,3656 ****
--- 3656,3662 ----
    if (rem_flag)
      {
+       if (target && GET_MODE (target) != compute_mode)
+ 	target = 0;
+ 
        if (quotient == 0)
  	/* No divide instruction either.  Use library for remainder.  */
*** function.c.old	Wed Nov 15 17:24:40 1995
--- function.c	Thu Dec 14 18:06:16 1995
*************** pop_temp_slots ()
*** 1208,1211 ****
--- 1208,1222 ----
    temp_slot_level--;
  }
+ 
+ /* Initialize temporary slots.  */
+ 
+ void
+ init_temp_slots ()
+ {
+   /* We have not allocated any temporaries yet.  */
+   temp_slots = 0;
+   temp_slot_level = 0;
+   target_temp_slot_level = 0;
+ }
  
  /* Retroactively move an auto variable from a register to a stack slot.
*************** init_function_start (subr, filename, lin
*** 4814,4821 ****
    rtl_expr_chain = 0;
  
!   /* We have not allocated any temporaries yet.  */
!   temp_slots = 0;
!   temp_slot_level = 0;
!   target_temp_slot_level = 0;
  
    /* Within function body, compute a type's size as soon it is laid out.  */
--- 4825,4830 ----
    rtl_expr_chain = 0;
  
!   /* Set up to allocate temporaries.  */
!   init_temp_slots ();
  
    /* Within function body, compute a type's size as soon it is laid out.  */
*** toplev.c.old	Sun Dec 10 09:41:06 1995
--- toplev.c	Thu Dec 14 18:00:37 1995
*************** rest_of_compilation (decl)
*** 3274,3277 ****
--- 3274,3281 ----
    resume_temporary_allocation ();
  
+   /* Show no temporary slots allocated.  */
+ 
+   init_temp_slots ();
+ 
    /* The parsing time is all the time spent in yyparse
       *except* what is spent in this function.  */
*** expmed.c.old	Fri Dec 15 08:00:03 1995
--- expmed.c	Fri Dec 15 08:01:41 1995
*************** store_bit_field (str_rtx, bitsize, bitnu
*** 399,402 ****
--- 399,403 ----
  #ifdef HAVE_insv
    if (HAVE_insv
+       && GET_MODE (value) != BLKmode
        && !(bitsize == 1 && GET_CODE (value) == CONST_INT)
        /* Ensure insv's size is wide enough for this field.  */
*************** store_split_bit_field (op0, bitsize, bit
*** 777,781 ****
  	     done in extract_bit_field, so that the two calls to
  	     extract_fixed_bit_field will have comparable arguments.  */
! 	  if (GET_CODE (value) != MEM)
  	    total_bits = BITS_PER_WORD;
  	  else
--- 778,782 ----
  	     done in extract_bit_field, so that the two calls to
  	     extract_fixed_bit_field will have comparable arguments.  */
! 	  if (GET_CODE (value) != MEM || GET_MODE (value) == BLKmode)
  	    total_bits = BITS_PER_WORD;
  	  else
*** toplev.c.old	Mon Dec 18 08:00:54 1995
--- toplev.c	Tue Dec 19 18:37:00 1995
*************** rest_of_compilation (decl)
*** 2715,2725 ****
  	 finish_compilation will call rest_of_compilation again
  	 for those functions that need to be output.  Also defer those
! 	 functions that we are supposed to defer.  */
  
!       if (DECL_DEFER_OUTPUT (decl)
! 	  || ((specd || DECL_INLINE (decl))
! 	      && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)
! 		   && ! flag_keep_inline_functions)
! 		  || DECL_EXTERNAL (decl))))
  	{
  	  DECL_DEFER_OUTPUT (decl) = 1;
--- 2715,2728 ----
  	 finish_compilation will call rest_of_compilation again
  	 for those functions that need to be output.  Also defer those
! 	 functions that we are supposed to defer.  We cannot defer
! 	 functions containing nested functions since the nested function
! 	 data is in our non-saved obstack.  */
  
!       if (! current_function_contains_functions
! 	  && (DECL_DEFER_OUTPUT (decl)
! 	      || ((specd || DECL_INLINE (decl))
! 		  && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)
! 		       && ! flag_keep_inline_functions)
! 		      || DECL_EXTERNAL (decl)))))
  	{
  	  DECL_DEFER_OUTPUT (decl) = 1;
*** reload.c.old	Sun Dec 17 06:32:13 1995
--- reload.c	Wed Dec 20 08:10:45 1995
*************** static int push_secondary_reload PROTO((
*** 292,295 ****
--- 292,296 ----
  					enum machine_mode, enum reload_type,
  					enum insn_code *));
+ static enum reg_class find_valid_class PROTO((enum machine_mode, int));
  static int push_reload		PROTO((rtx, rtx, rtx *, rtx *, enum reg_class,
  				       enum machine_mode, enum machine_mode,
*************** clear_secondary_mem ()
*** 692,695 ****
--- 693,728 ----
  #endif /* SECONDARY_MEMORY_NEEDED */
  
+ /* Find the largest class for which every register number plus N is valid in
+    M1 (if in range).  Abort if no such class exists.  */
+ 
+ static enum reg_class
+ find_valid_class (m1, n)
+      enum machine_mode  m1;
+      int n;
+ {
+   int class;
+   int regno;
+   enum reg_class best_class;
+   int best_size = 0;
+ 
+   for (class = 1; class < N_REG_CLASSES; class++)
+     {
+       int bad = 0;
+       for (regno = 0; regno < FIRST_PSEUDO_REGISTER && ! bad; regno++)
+ 	if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)
+ 	    && TEST_HARD_REG_BIT (reg_class_contents[class], regno + n)
+ 	    && ! HARD_REGNO_MODE_OK (regno + n, m1))
+ 	  bad = 1;
+ 
+       if (! bad && reg_class_size[class] > best_size)
+ 	best_class = class, best_size = reg_class_size[class];
+     }
+ 
+   if (best_size == 0)
+     abort ();
+ 
+   return best_class;
+ }
+ 
  /* Record one reload that needs to be performed.
     IN is an rtx saying where the data are to be found before this instruction.
*************** push_reload (in, out, inloc, outloc, cla
*** 897,901 ****
        && GET_CODE (SUBREG_REG (in)) == REG
        && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER
!       && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)), inmode)
  	  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD
  	      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))
--- 930,935 ----
        && GET_CODE (SUBREG_REG (in)) == REG
        && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER
!       && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)) + SUBREG_WORD (in),
! 				inmode)
  	  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD
  	      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))
*************** push_reload (in, out, inloc, outloc, cla
*** 912,916 ****
  	 output before the outer reload.  */
        push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,
! 		   GENERAL_REGS, VOIDmode, VOIDmode, 0, 0, opnum, type);
        dont_remove_subreg = 1;
      }
--- 946,951 ----
  	 output before the outer reload.  */
        push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,
! 		   find_valid_class (inmode, SUBREG_WORD (in)),
! 		   VOIDmode, VOIDmode, 0, 0, opnum, type);
        dont_remove_subreg = 1;
      }
*************** push_reload (in, out, inloc, outloc, cla
*** 985,989 ****
        && GET_CODE (SUBREG_REG (out)) == REG
        && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER
!       && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)), outmode)
  	  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD
  	      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))
--- 1020,1025 ----
        && GET_CODE (SUBREG_REG (out)) == REG
        && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER
!       && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)) + SUBREG_WORD (out),
! 				outmode)
  	  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD
  	      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))
*************** push_reload (in, out, inloc, outloc, cla
*** 1001,1005 ****
        dont_remove_subreg = 1;
        push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),
! 		   &SUBREG_REG (out), ALL_REGS, VOIDmode, VOIDmode, 0, 0,
  		   opnum, RELOAD_OTHER);
      }
--- 1037,1043 ----
        dont_remove_subreg = 1;
        push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),
! 		   &SUBREG_REG (out),
! 		   find_valid_class (outmode, SUBREG_WORD (out)),
! 		   VOIDmode, VOIDmode, 0, 0,
  		   opnum, RELOAD_OTHER);
      }
*** mips.c.old	Sun Dec 10 09:41:56 1995
--- config/mips/mips.c	Wed Dec 20 12:45:10 1995
*************** expand_block_move (operands)
*** 2360,2365 ****
  
    else if (constp && bytes <= 2*MAX_MOVE_BYTES)
!     emit_insn (gen_movstrsi_internal (gen_rtx (MEM, BLKmode, dest_reg),
! 				      gen_rtx (MEM, BLKmode, src_reg),
  				      bytes_rtx, align_rtx));
  
--- 2360,2367 ----
  
    else if (constp && bytes <= 2*MAX_MOVE_BYTES)
!     emit_insn (gen_movstrsi_internal (change_address (operands[0],
! 						      BLKmode, dest_reg),
! 				      change_address (orig_src, BLKmode,
! 						      src_reg),
  				      bytes_rtx, align_rtx));
  
*** pa.c.old	Fri Dec 22 18:08:22 1995
--- config/pa/pa.c	Sat Dec 23 12:34:19 1995
*************** output_move_double (operands)
*** 1374,1389 ****
       do them in the other order.
  
!      RMS says "This happens only for registers;
!      such overlap can't happen in memory unless the user explicitly
!      sets it up, and that is an undefined circumstance."
  
!      but it happens on the HP-PA when loading parameter registers,
!      so I am going to define that circumstance, and make it work
!      as expected.  */
  
!   if (optype0 == REGOP && (optype1 == MEMOP || optype1 == OFFSOP)
! 	   && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))
      {
-       /* XXX THIS PROBABLY DOESN'T WORK.  */
        /* Do the late half first.  */
        if (addreg1)
--- 1374,1395 ----
       do them in the other order.
  
!      This can happen in two cases:
  
! 	mem -> register where the first half of the destination register
!  	is the same register used in the memory's address.  Reload
! 	can create such insns.
  
! 	mem in this case will be either register indirect or register
! 	indirect plus a valid offset. 
! 
! 	register -> register move where REGNO(dst) == REGNO(src + 1)
! 	someone (Tim/Tege?) claimed this can happen for parameter loads. 
! 
!      Handle mem -> register case first.  */
!   if (optype0 == REGOP
!       && (optype1 == MEMOP || optype1 == OFFSOP)
!       && refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,
! 			    operands[1], 0))
      {
        /* Do the late half first.  */
        if (addreg1)
*************** output_move_double (operands)
*** 1390,1399 ****
  	output_asm_insn ("ldo 4(%0),%0", &addreg1);
        output_asm_insn (singlemove_string (latehalf), latehalf);
        if (addreg1)
  	output_asm_insn ("ldo -4(%0),%0", &addreg1);
-       /* Then clobber.  */
        return singlemove_string (operands);
      }
  
    if (optype0 == REGOP && optype1 == REGOP
        && REGNO (operands[0]) == REGNO (operands[1]) + 1)
--- 1396,1407 ----
  	output_asm_insn ("ldo 4(%0),%0", &addreg1);
        output_asm_insn (singlemove_string (latehalf), latehalf);
+ 
+       /* Then clobber.  */
        if (addreg1)
  	output_asm_insn ("ldo -4(%0),%0", &addreg1);
        return singlemove_string (operands);
      }
  
+   /* Now handle register -> register case.  */
    if (optype0 == REGOP && optype1 == REGOP
        && REGNO (operands[0]) == REGNO (operands[1]) + 1)
*** pa.md.old	Fri Dec 22 18:12:39 1995
--- config/pa/pa.md	Sat Dec 23 12:34:26 1995
***************
*** 2147,2151 ****
  (define_insn ""
    [(set (match_operand:DF 0 "reg_or_nonsymb_mem_operand"
! 			  "=f,*r,Q,?o,?Q,f,*&r,*&r")
  	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
  			  "fG,*rG,f,*r,*r,Q,o,Q"))]
--- 2147,2151 ----
  (define_insn ""
    [(set (match_operand:DF 0 "reg_or_nonsymb_mem_operand"
! 			  "=f,*r,Q,?o,?Q,f,*r,*r")
  	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
  			  "fG,*rG,f,*r,*r,Q,o,Q"))]
***************
*** 2165,2169 ****
  (define_insn ""
    [(set (match_operand:DF 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,?o,?Q,&r,&r")
  	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
  			  "rG,r,r,o,Q"))]
--- 2165,2169 ----
  (define_insn ""
    [(set (match_operand:DF 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,?o,?Q,r,r")
  	(match_operand:DF 1 "reg_or_0_or_nonsymb_mem_operand"
  			  "rG,r,r,o,Q"))]
***************
*** 2376,2380 ****
  (define_insn ""
    [(set (match_operand:DI 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,o,Q,&r,&r,&r,f,f,*T")
  	(match_operand:DI 1 "general_operand"
  			  "rM,r,r,o,Q,i,fM,*T,f"))]
--- 2376,2380 ----
  (define_insn ""
    [(set (match_operand:DI 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,o,Q,r,r,r,f,f,*T")
  	(match_operand:DI 1 "general_operand"
  			  "rM,r,r,o,Q,i,fM,*T,f"))]
***************
*** 2394,2398 ****
  (define_insn ""
    [(set (match_operand:DI 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,o,Q,&r,&r,&r")
  	(match_operand:DI 1 "general_operand"
  			  "rM,r,r,o,Q,i"))]
--- 2394,2398 ----
  (define_insn ""
    [(set (match_operand:DI 0 "reg_or_nonsymb_mem_operand"
! 			  "=r,o,Q,r,r,r")
  	(match_operand:DI 1 "general_operand"
  			  "rM,r,r,o,Q,i"))]
*** fold-const.c.old	Sun Dec 17 08:08:23 1995
--- fold-const.c	Tue Dec 26 21:44:54 1995
*************** fold_convert (t, arg1)
*** 1482,1486 ****
  	{
  	  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))
! 	    return arg1;
  	  else if (setjmp (float_error))
  	    {
--- 1482,1490 ----
  	{
  	  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))
! 	    {
! 	      t = arg1;
! 	      TREE_TYPE (arg1) = type;
! 	      return t;
! 	    }
  	  else if (setjmp (float_error))
  	    {
*** sdbout.c.old	Fri Dec 22 18:11:45 1995
--- sdbout.c	Sat Dec 30 07:47:22 1995
*************** plain_type_1 (type, level)
*** 539,543 ****
  	  sdb_dims[sdb_n_dims++]
  	    = (TYPE_DOMAIN (type)
! 	       ? TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) + 1
  	       : 0);
  	return PUSH_DERIVED_LEVEL (DT_ARY, m);
--- 539,544 ----
  	  sdb_dims[sdb_n_dims++]
  	    = (TYPE_DOMAIN (type)
! 	       ? (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
! 		  - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1)
  	       : 0);
  	return PUSH_DERIVED_LEVEL (DT_ARY, m);
*** stupid.c.old	Sun Dec 10 09:41:29 1995
--- stupid.c	Sun Jan 14 17:42:45 1996
*************** stupid_reg_compare (r1p, r2p)
*** 309,314 ****
     that can hold a value of machine-mode MODE
       (but actually we test only the first of the block for holding MODE)
!    currently free from after insn whose suid is BIRTH
!    through the insn whose suid is DEATH,
     and return the number of the first of them.
     Return -1 if such a block cannot be found.
--- 309,314 ----
     that can hold a value of machine-mode MODE
       (but actually we test only the first of the block for holding MODE)
!    currently free from after insn whose suid is BORN_INSN
!    through the insn whose suid is DEAD_INSN,
     and return the number of the first of them.
     Return -1 if such a block cannot be found.
*************** stupid_find_reg (call_preserved, class, 
*** 337,340 ****
--- 337,347 ----
    static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;
  #endif
+ 
+   /* If this register's life is more than 5,000 insns, we probably
+      can't allocate it, so don't waste the time trying.  This avoid
+      quadratic behavior on programs that have regularly-occurring
+      SAVE_EXPRs.  */
+   if (dead_insn > born_insn + 5000)
+     return -1;
  
    COPY_HARD_REG_SET (used,
*** sched.c.old	Wed Jan 17 07:23:09 1996
--- sched.c	Thu Jan 18 08:39:50 1996
*************** static int priority			PROTO((rtx));
*** 314,318 ****
  static void free_pending_lists		PROTO((void));
  static void add_insn_mem_dependence	PROTO((rtx *, rtx *, rtx, rtx));
! static void flush_pending_lists		PROTO((rtx));
  static void sched_analyze_1		PROTO((rtx, rtx));
  static void sched_analyze_2		PROTO((rtx, rtx));
--- 314,318 ----
  static void free_pending_lists		PROTO((void));
  static void add_insn_mem_dependence	PROTO((rtx *, rtx *, rtx, rtx));
! static void flush_pending_lists		PROTO((rtx, int));
  static void sched_analyze_1		PROTO((rtx, rtx));
  static void sched_analyze_2		PROTO((rtx, rtx));
*************** add_insn_mem_dependence (insn_list, mem_
*** 1628,1640 ****
  
  /* Make a dependency between every memory reference on the pending lists
!    and INSN, thus flushing the pending lists.  */
  
  static void
! flush_pending_lists (insn)
       rtx insn;
  {
    rtx link;
  
!   while (pending_read_insns)
      {
        add_dependence (insn, XEXP (pending_read_insns, 0), REG_DEP_ANTI);
--- 1628,1642 ----
  
  /* Make a dependency between every memory reference on the pending lists
!    and INSN, thus flushing the pending lists.  If ONLY_WRITE, don't flush
!    the read list.  */
  
  static void
! flush_pending_lists (insn, only_write)
       rtx insn;
+      int only_write;
  {
    rtx link;
  
!   while (pending_read_insns && ! only_write)
      {
        add_dependence (insn, XEXP (pending_read_insns, 0), REG_DEP_ANTI);
*************** sched_analyze_1 (x, insn)
*** 1765,1769 ****
  	     this flush occurs 8 times for sparc, and 10 times for m88k using
  	     the number 32.  */
! 	  flush_pending_lists (insn);
  	}
        else
--- 1767,1771 ----
  	     this flush occurs 8 times for sparc, and 10 times for m88k using
  	     the number 32.  */
! 	  flush_pending_lists (insn, 0);
  	}
        else
*************** sched_analyze_2 (x, insn)
*** 1984,1988 ****
  	    reg_pending_sets_all = 1;
  
! 	    flush_pending_lists (insn);
  	  }
  
--- 1986,1990 ----
  	    reg_pending_sets_all = 1;
  
! 	    flush_pending_lists (insn, 0);
  	  }
  
*************** sched_analyze_insn (x, insn, loop_notes)
*** 2088,2092 ****
        reg_pending_sets_all = 1;
  
!       flush_pending_lists (insn);
  
        link = loop_notes;
--- 2090,2094 ----
        reg_pending_sets_all = 1;
  
!       flush_pending_lists (insn, 0);
  
        link = loop_notes;
*************** sched_analyze (head, tail)
*** 2263,2275 ****
  	  loop_notes = 0;
  
! 	  /* We don't need to flush memory for a function call which does
! 	     not involve memory.  */
! 	  if (! CONST_CALL_P (insn))
! 	    {
! 	      /* In the absence of interprocedural alias analysis,
! 		 we must flush all pending reads and writes, and
! 		 start new dependencies starting from here.  */
! 	      flush_pending_lists (insn);
! 	    }
  
  	  /* Depend this function call (actually, the user of this
--- 2265,2273 ----
  	  loop_notes = 0;
  
! 	  /* In the absence of interprocedural alias analysis, we must flush
! 	     all pending reads and writes, and start new dependencies starting
! 	     from here.  But only flush writes for constant calls (which may
! 	     be passed a pointer to something we haven't written yet).  */
! 	  flush_pending_lists (insn, CONST_CALL_P (insn));
  
  	  /* Depend this function call (actually, the user of this
*** tree.h.old	Sun Jan 21 12:23:49 1996
--- tree.h	Sun Jan 21 12:25:01 1996
***************
*** 98,101 ****
--- 98,103 ----
    BUILT_IN_APPLY,
    BUILT_IN_RETURN,
+   BUILT_IN_SETJMP,
+   BUILT_IN_LONGJMP,
  
    /* C++ extensions */
*** Makefile.in.old	Wed Jan 17 07:21:12 1996
--- Makefile.in	Mon Jan 22 07:11:12 1996
***************
*** 1189,1193 ****
     insn-flags.h insn-codes.h expr.h insn-config.h recog.h output.h \
     typeclass.h bytecode.h bc-opcode.h bc-typecd.h bc-typecd.def bc-optab.h \
!    bc-emit.h modemap.def
  calls.o : calls.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h expr.h insn-codes.h \
     insn-flags.h
--- 1189,1193 ----
     insn-flags.h insn-codes.h expr.h insn-config.h recog.h output.h \
     typeclass.h bytecode.h bc-opcode.h bc-typecd.h bc-typecd.def bc-optab.h \
!    bc-emit.h modemap.def hard-reg-set.h
  calls.o : calls.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h expr.h insn-codes.h \
     insn-flags.h
*** c-decl.c.old	Sun Jan 21 12:23:55 1996
--- c-decl.c	Sun Jan 21 12:30:29 1996
*************** init_decl_processing ()
*** 3225,3228 ****
--- 3225,3241 ----
    builtin_function ("__builtin_cosl", ldouble_ftype_ldouble, 
  		    BUILT_IN_COS, "cosl");
+   builtin_function ("__builtin_setjmp",
+ 		    build_function_type (integer_type_node,
+ 					 tree_cons (NULL_TREE,
+ 						    ptr_type_node, endlink)),
+ 		    BUILT_IN_SETJMP, NULL_PTR);
+   builtin_function ("__builtin_longjmp",
+ 		    build_function_type
+ 		    (void_type_node,
+ 		     tree_cons (NULL, ptr_type_node,
+ 				tree_cons (NULL_TREE,
+ 					   integer_type_node,
+ 					   endlink))),
+ 		    BUILT_IN_LONGJMP, NULL_PTR);
  
    /* In an ANSI C program, it is okay to supply built-in meanings
*** cccp.c.old	Fri Jan 26 21:19:51 1996
--- cccp.c	Fri Jan 26 22:44:05 1996
*************** initialize_builtins (inp, outp)
*** 9506,9509 ****
--- 9506,9510 ----
      so that it is present only when truly compiling with GNU C.  */
  /*  install ((U_CHAR *) "__GNUC__", -1, T_CONST, "2", -1);  */
+   install ((U_CHAR *) "__HAVE_BUILTIN_SETJMP__", -1, T_CONST, "1", -1);
  
    if (debug_output)
*** sol2.h.old	Wed Jan 31 17:34:56 1996
--- config/sparc/sol2.h	Wed Jan 31 17:58:58 1996
***************
*** 165,168 ****
     Instead, it is enabled here, because it does work under Solaris.  */
  /* Define for support of TFmode long double and REAL_ARITHMETIC.
     Sparc ABI says that long double is 4 words.  */
! #define LONG_DOUBLE_TYPE_SIZE 128
--- 165,168 ----
     Instead, it is enabled here, because it does work under Solaris.  */
  /* Define for support of TFmode long double and REAL_ARITHMETIC.
     Sparc ABI says that long double is 4 words.  */
! #define LONG_DOUBLE_TYPE_SIZE 64
*** flow.c.old	Sat May 13 06:50:26 1995
--- flow.c	Fri Feb  2 08:19:53 1996
*************** static HARD_REG_SET elim_reg_set;
*** 287,291 ****
  /* Forward declarations */
  static void find_basic_blocks		PROTO((rtx, rtx));
! static int uses_reg_or_mem		PROTO((rtx));
  static void mark_label_ref		PROTO((rtx, rtx, int));
  static void life_analysis		PROTO((rtx, int));
--- 287,291 ----
  /* Forward declarations */
  static void find_basic_blocks		PROTO((rtx, rtx));
! static int jmp_uses_reg_or_mem		PROTO((rtx));
  static void mark_label_ref		PROTO((rtx, rtx, int));
  static void life_analysis		PROTO((rtx, int));
*************** find_basic_blocks (f, nonlocal_label_lis
*** 553,557 ****
  		    if (GET_CODE (XVECEXP (pat, 0, i)) == SET
  			&& SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx
! 			&& uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))
  		      computed_jump = 1;
  	      }
--- 553,557 ----
  		    if (GET_CODE (XVECEXP (pat, 0, i)) == SET
  			&& SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx
! 			&& jmp_uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))
  		      computed_jump = 1;
  	      }
*************** find_basic_blocks (f, nonlocal_label_lis
*** 558,562 ****
  	    else if (GET_CODE (pat) == SET
  		     && SET_DEST (pat) == pc_rtx
! 		     && uses_reg_or_mem (SET_SRC (pat)))
  	      computed_jump = 1;
  		    
--- 558,562 ----
  	    else if (GET_CODE (pat) == SET
  		     && SET_DEST (pat) == pc_rtx
! 		     && jmp_uses_reg_or_mem (SET_SRC (pat)))
  	      computed_jump = 1;
  		    
*************** find_basic_blocks (f, nonlocal_label_lis
*** 759,766 ****
  /* Subroutines of find_basic_blocks.  */
  
! /* Return 1 if X contain a REG or MEM that is not in the constant pool.  */
  
  static int
! uses_reg_or_mem (x)
       rtx x;
  {
--- 759,767 ----
  /* Subroutines of find_basic_blocks.  */
  
! /* Return 1 if X, the SRC_SRC of  SET of (pc) contain a REG or MEM that is
!    not in the constant pool and not in the condition of an IF_THEN_ELSE.  */
  
  static int
! jmp_uses_reg_or_mem (x)
       rtx x;
  {
*************** uses_reg_or_mem (x)
*** 769,777 ****
    char *fmt;
  
!   if (code == REG
!       || (code == MEM
! 	  && ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF
! 		&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))))
!     return 1;
  
    fmt = GET_RTX_FORMAT (code);
--- 770,795 ----
    char *fmt;
  
!   switch (code)
!     {
!     case CONST:
!     case LABEL_REF:
!     case PC:
!       return 0;
! 
!     case REG:
!       return 1;
! 
!     case MEM:
!       return ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF
! 		&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));
! 
!     case IF_THEN_ELSE:
!       return (jmp_uses_reg_or_mem (XEXP (x, 1))
! 	      || jmp_uses_reg_or_mem (XEXP (x, 2)));
! 
!     case PLUS:  case MINUS:  case MULT:
!       return (jmp_uses_reg_or_mem (XEXP (x, 0))
! 	      || jmp_uses_reg_or_mem (XEXP (x, 1)));
!     }
  
    fmt = GET_RTX_FORMAT (code);
*************** uses_reg_or_mem (x)
*** 779,783 ****
      {
        if (fmt[i] == 'e'
! 	  && uses_reg_or_mem (XEXP (x, i)))
  	return 1;
  
--- 797,801 ----
      {
        if (fmt[i] == 'e'
! 	  && jmp_uses_reg_or_mem (XEXP (x, i)))
  	return 1;
  
*************** uses_reg_or_mem (x)
*** 784,788 ****
        if (fmt[i] == 'E')
  	for (j = 0; j < XVECLEN (x, i); j++)
! 	  if (uses_reg_or_mem (XVECEXP (x, i, j)))
  	    return 1;
      }
--- 802,806 ----
        if (fmt[i] == 'E')
  	for (j = 0; j < XVECLEN (x, i); j++)
! 	  if (jmp_uses_reg_or_mem (XVECEXP (x, i, j)))
  	    return 1;
      }
*** reload1.c.old	Sat Jan 27 08:14:17 1996
--- reload1.c	Sat Feb  3 14:42:48 1996
*************** eliminate_regs (x, mem_mode, insn)
*** 2900,2904 ****
  
        /* Fall through to generic unary operation case.  */
-     case USE:
      case STRICT_LOW_PART:
      case NEG:          case NOT:
--- 2900,2903 ----
*************** eliminate_regs (x, mem_mode, insn)
*** 2987,2990 ****
--- 2986,3002 ----
  	}
  
+       return x;
+ 
+     case USE:
+       /* If using a register that is the source of an eliminate we still
+ 	 think can be performed, note it cannot be performed since we don't
+ 	 know how this register is used.  */
+       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)
+ 	if (ep->from_rtx == XEXP (x, 0))
+ 	  ep->can_eliminate = 0;
+ 
+       new = eliminate_regs (XEXP (x, 0), mem_mode, insn);
+       if (new != XEXP (x, 0))
+ 	return gen_rtx (code, GET_MODE (x), new);
        return x;
  
*** expmed.c.old	Fri Dec 22 18:12:47 1995
--- expmed.c	Tue Jan 16 09:07:22 1996
*************** extract_bit_field (str_rtx, bitsize, bit
*** 877,883 ****
    rtx spec_target_subreg = 0;
  
-   if (GET_CODE (str_rtx) == MEM && ! MEM_IN_STRUCT_P (str_rtx))
-     abort ();
- 
    /* Discount the part of the structure before the desired byte.
       We need to know how many bytes are safe to reference after it.  */
--- 877,880 ----
*** sparc.md.old	Mon Feb 19 18:40:32 1996
--- config/sparc/sparc.md	Mon Feb 19 18:41:17 1996
***************
*** 5178,5182 ****
    emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));
    emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));
-   emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, Pmode, 8)));
    /* Return, restoring reg window and jumping to goto handler.  */
    emit_insn (gen_goto_handler_and_restore ());
--- 5178,5181 ----
***************
*** 5192,5196 ****
  
  (define_insn "goto_handler_and_restore"
!   [(unspec_volatile [(const_int 0)] 2)]
    ""
    "jmp %%o0+0\;restore"
--- 5191,5196 ----
  
  (define_insn "goto_handler_and_restore"
!   [(unspec_volatile [(const_int 0)] 2)
!    (use (reg:SI 8))]
    ""
    "jmp %%o0+0\;restore"
*** reload1.c.old	Thu Feb 15 07:28:06 1996
--- reload1.c	Wed Feb 21 07:40:09 1996
*************** reload (first, global, dumpfile)
*** 552,556 ****
       Also find all paradoxical subregs and find largest such for each pseudo.
       On machines with small register classes, record hard registers that
!      are used for user variables.  These can never be used for spills.  */
  
    for (insn = first; insn; insn = NEXT_INSN (insn))
--- 552,558 ----
       Also find all paradoxical subregs and find largest such for each pseudo.
       On machines with small register classes, record hard registers that
!      are used for user variables.  These can never be used for spills. 
!      Also look for a "constant" NOTE_INSN_SETJMP.  This means that all
!      caller-saved registers must be marked live.  */
  
    for (insn = first; insn; insn = NEXT_INSN (insn))
*************** reload (first, global, dumpfile)
*** 557,560 ****
--- 559,568 ----
      {
        rtx set = single_set (insn);
+ 
+       if (GET_CODE (insn) == NOTE && CONST_CALL_P (insn)
+ 	  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)
+ 	for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+ 	  if (! call_used_regs[i])
+ 	    regs_ever_live[i] = 1;
  
        if (set != 0 && GET_CODE (SET_DEST (set)) == REG)
*** sched.c.old	Thu Feb 15 07:18:51 1996
--- sched.c	Wed Feb 21 07:55:10 1996
*************** sched_analyze (head, tail)
*** 2279,2285 ****
        else if (GET_CODE (insn) == NOTE
  	       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG
! 		   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END))
! 	loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,
! 			      GEN_INT (NOTE_LINE_NUMBER (insn)), loop_notes);
  
        if (insn == tail)
--- 2279,2290 ----
        else if (GET_CODE (insn) == NOTE
  	       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG
! 		   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END
! 		   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP
! 		       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))
! 	{
! 	  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,
! 				GEN_INT (NOTE_LINE_NUMBER (insn)), loop_notes);
! 	  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);
! 	}
  
        if (insn == tail)
*************** reemit_notes (insn, last)
*** 3148,3152 ****
  	{
  	  if (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)
! 	    emit_note_after (INTVAL (XEXP (note, 0)), insn);
  	  else
  	    last = emit_note_before (INTVAL (XEXP (note, 0)), last);
--- 3153,3158 ----
  	{
  	  if (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)
! 	    CONST_CALL_P (emit_note_after (INTVAL (XEXP (note, 0)), insn))
! 	      = CONST_CALL_P (note);
  	  else
  	    last = emit_note_before (INTVAL (XEXP (note, 0)), last);
*** stupid.c.old	Mon Jan 15 06:30:46 1996
--- stupid.c	Sat Feb 24 10:39:32 1996
*************** static int *uid_suid;
*** 66,69 ****
--- 66,74 ----
  static int last_call_suid;
  
+ /* Record the suid of the last NOTE_INSN_SETJMP
+    so we can tell whether a pseudo reg crosses any setjmp.  */
+ 
+ static int last_setjmp_suid;
+ 
  /* Element N is suid of insn where life span of pseudo reg N ends.
     Element is  0 if register N has not been seen yet on backward scan.  */
*************** static char *regs_live;
*** 89,92 ****
--- 94,101 ----
  static char *regs_change_size;
  
+ /* Indexed by reg number, nonzero if reg crosses a setjmp.  */
+ 
+ static char *regs_crosses_setjmp;
+ 
  /* Indexed by insn's suid, the set of hard regs live after that insn.  */
  
*************** stupid_life_analysis (f, nregs, file)
*** 149,152 ****
--- 158,162 ----
  
    last_call_suid = i + 1;
+   last_setjmp_suid = i + 1;
    max_suid = i + 1;
  
*************** stupid_life_analysis (f, nregs, file)
*** 167,170 ****
--- 177,183 ----
    bzero ((char *) regs_change_size, nregs * sizeof (char));
  
+   regs_crosses_setjmp = (char *) alloca (nregs * sizeof (char));
+   bzero ((char *) regs_crosses_setjmp, nregs * sizeof (char));
+ 
    reg_renumber = (short *) oballoc (nregs * sizeof (short));
    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
*************** stupid_life_analysis (f, nregs, file)
*** 216,219 ****
--- 229,236 ----
  	stupid_mark_refs (PATTERN (insn), insn);
  
+       if (GET_CODE (insn) == NOTE
+ 	  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)
+ 	last_setjmp_suid = INSN_SUID (insn);
+ 
        /* Mark all call-clobbered regs as live after each call insn
  	 so that a pseudo whose life span includes this insn
*************** stupid_life_analysis (f, nregs, file)
*** 254,259 ****
        register int r = reg_order[i];
  
!       /* Some regnos disappear from the rtl.  Ignore them to avoid crash.  */
!       if (regno_reg_rtx[r] == 0)
  	continue;
  
--- 271,277 ----
        register int r = reg_order[i];
  
!       /* Some regnos disappear from the rtl.  Ignore them to avoid crash. 
! 	 Also don't allocate registers that cross a setjmp.  */
!       if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r])
  	continue;
  
*************** stupid_mark_refs (x, insn)
*** 495,498 ****
--- 513,519 ----
  	      if (last_call_suid < reg_where_dead[regno])
  		reg_n_calls_crossed[regno] += 1;
+ 
+ 	      if (last_setjmp_suid < reg_where_dead[regno])
+ 		regs_crosses_setjmp[regno] = 1;
  	    }
  	}
*** fold-const.c.old	Wed Jan 17 07:20:26 1996
--- fold-const.c	Sat Mar  2 07:38:51 1996
*************** fold (expr) 
*** 4052,4056 ****
  	  tree xarg0 = arg0;
  
! 	  if (TREE_CODE (xarg0) == SAVE_EXPR)
  	    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);
  
--- 4052,4056 ----
  	  tree xarg0 = arg0;
  
! 	  if (TREE_CODE (xarg0) == SAVE_EXPR && SAVE_EXPR_RTL (xarg0) == 0)
  	    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);
  
*************** fold (expr) 
*** 4070,4074 ****
  	    }
  
! 	  if (TREE_CODE (xarg0) == SAVE_EXPR)
  	    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);
  
--- 4070,4074 ----
  	    }
  
! 	  if (TREE_CODE (xarg0) == SAVE_EXPR && SAVE_EXPR_RTL (xarg0) == 0)
  	    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);
  
*** config/sparc/sparc.c.old	Fri Feb 23 08:07:58 1996
--- config/sparc/sparc.c	Sat Mar  2 12:03:59 1996
*************** Boston, MA 02111-1307, USA.  */
*** 40,46 ****
  /* 1 if the caller has placed an "unimp" insn immediately after the call.
     This is used in v8 code when calling a function that returns a structure.
!    v9 doesn't have this.  */
  
! #define SKIP_CALLERS_UNIMP_P (!TARGET_V9 && current_function_returns_struct)
  
  /* Global variables for machine-dependent things.  */
--- 40,51 ----
  /* 1 if the caller has placed an "unimp" insn immediately after the call.
     This is used in v8 code when calling a function that returns a structure.
!    v9 doesn't have this.  Be careful to have this test be the same as that
!    used on the call.  */
  
! #define SKIP_CALLERS_UNIMP_P  \
! (!TARGET_V9 && current_function_returns_struct			\
!  && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)))	\
!  && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))	\
!      == INTEGER_CST))
  
  /* Global variables for machine-dependent things.  */
*** calls.c.old	Mon Feb 19 07:03:20 1996
--- calls.c	Sat Mar  2 14:24:46 1996
*************** expand_call (exp, target, ignore)
*** 1087,1090 ****
--- 1087,1091 ----
  
  	      store_expr (args[i].tree_value, copy, 0);
+ 	      is_const = 0;
  
  	      args[i].tree_value = build1 (ADDR_EXPR,
*** config/sparc/sparc.md.orig	Fri Mar  8 02:07:05 1996
--- config/sparc/sparc.md	Fri Mar  8 08:50:25 1996
***************
*** 5198,5201 ****
--- 5198,5231 ----
     (set_attr "length" "2")])
  
+ ;; Pattern for use after a setjmp to store FP and the return register
+ ;; into the stack area.
+ 
+ (define_expand "setjmp"
+   [(const_int 0)]
+   ""
+   "
+ {
+   if (TARGET_V9)
+     emit_insn (gen_setjmp_64 ());
+   else
+     emit_insn (gen_setjmp_32 ());
+ 
+   DONE;
+ }")
+ 
+ (define_expand "setjmp_32"
+   [(set (mem:SI (plus:SI (reg:SI 14) (const_int 56))) (match_dup 0))
+    (set (mem:SI (plus:SI (reg:SI 14) (const_int 60))) (reg:SI 31))]
+   ""
+   "
+ { operands[0] = frame_pointer_rtx; }")
+ 
+ (define_expand "setjmp_64"
+   [(set (mem:DI (plus:DI (reg:DI 14) (const_int 112))) (match_dup 0))
+    (set (mem:DI (plus:DI (reg:DI 14) (const_int 120))) (reg:DI 31))]
+   ""
+   "
+ { operands[0] = frame_pointer_rtx; }")
+ 
  ;; Special pattern for the FLUSH instruction.
  
*** Makefile.in.old	Thu Feb 15 07:16:50 1996
--- Makefile.in	Sun Feb 18 14:18:18 1996
***************
*** 574,578 ****
      _fixxfdi _fixunsxfdi _floatdixf _fixunsxfsi \
      _fixtfdi _fixunstfdi _floatditf \
!     __gcc_bcmp _varargs _eprintf _op_new _op_vnew _new_handler _op_delete \
      _op_vdel _bb _shtab _clear_cache _trampoline __main _exit _ctors _eh \
      _pure
--- 574,579 ----
      _fixxfdi _fixunsxfdi _floatdixf _fixunsxfsi \
      _fixtfdi _fixunstfdi _floatditf \
!     __gcc_bcmp _varargs __dummy _eprintf \
!     _op_new _op_vnew _new_handler _op_delete \
      _op_vdel _bb _shtab _clear_cache _trampoline __main _exit _ctors _eh \
      _pure
*** libgcc2.c.old	Sun Feb 18 14:16:34 1996
--- libgcc2.c	Sun Feb 18 14:19:09 1996
***************
*** 1193,1196 ****
--- 1193,1201 ----
  #endif
  
+ #ifdef L__dummy
+ void
+ __dummy () {}
+ #endif
+ 
  #ifdef L_varargs
  #ifdef __i860__
*** config/sparc/sparc.md.old	Tue Mar 12 07:17:40 1996
--- config/sparc/sparc.md	Tue Mar 12 13:03:38 1996
***************
*** 5180,5183 ****
--- 5180,5184 ----
    /* Return, restoring reg window and jumping to goto handler.  */
    emit_insn (gen_goto_handler_and_restore ());
+   emit_barrier ();
    DONE;
  }")
*** config/i386/i386.c.old	Sat Mar  2 06:12:51 1996
--- config/i386/i386.c	Sat Mar 16 19:12:55 1996
*************** standard_80387_constant_p (x)
*** 1369,1373 ****
    set_float_handler (handler);
    REAL_VALUE_FROM_CONST_DOUBLE (d, x);
!   is0 = REAL_VALUES_EQUAL (d, dconst0);
    is1 = REAL_VALUES_EQUAL (d, dconst1);
    set_float_handler (NULL_PTR);
--- 1369,1373 ----
    set_float_handler (handler);
    REAL_VALUE_FROM_CONST_DOUBLE (d, x);
!   is0 = REAL_VALUES_EQUAL (d, dconst0) && !REAL_VALUE_MINUS_ZERO (d);
    is1 = REAL_VALUES_EQUAL (d, dconst1);
    set_float_handler (NULL_PTR);
*** tree.c.old	Fri Feb 23 08:08:34 1996
--- tree.c	Fri Mar 15 09:18:32 1996
*************** substitute_in_expr (exp, f, r)
*** 2287,2290 ****
--- 2287,2296 ----
  	    return r;
  
+ 	  /* If this expression hasn't been completed let, leave it 
+ 	     alone.  */
+ 	  if (TREE_CODE (inner) == PLACEHOLDER_EXPR
+ 	      && TREE_TYPE (inner) == 0)
+ 	    return exp;
+ 
  	  new = fold (build (code, TREE_TYPE (exp),
  			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
*** local-alloc.c.old	Thu Mar 21 16:19:41 1996
--- local-alloc.c	Thu Mar 21 16:21:12 1996
***************
*** 817,834 ****
  	    {
  	      if (sregno >= FIRST_PSEUDO_REGISTER)
  		{
! 		  reg_live_length[sregno] -= length;
! 		  /* reg_live_length is only an approximation after combine
! 		     if sched is not run, so make sure that we still have
! 		     a reasonable value.  */
! 		  if (reg_live_length[sregno] < 2)
! 		    reg_live_length[sregno] = 2;
  		  reg_n_calls_crossed[sregno] -= n_calls;
  		}
  
  	      if (dregno >= FIRST_PSEUDO_REGISTER)
  		{
! 		  reg_live_length[dregno] += d_length;
  		  reg_n_calls_crossed[dregno] += d_n_calls;
  		}
  
--- 817,840 ----
  	    {
  	      if (sregno >= FIRST_PSEUDO_REGISTER)
  		{
! 		  if (reg_live_length[sregno] >= 0)
! 		    {
! 		      reg_live_length[sregno] -= length;
! 		      /* reg_live_length is only an approximation after
! 			 combine if sched is not run, so make sure that we
! 			 still have a reasonable value.  */
! 		      if (reg_live_length[sregno] < 2)
! 			reg_live_length[sregno] = 2;
! 		    }
! 
  		  reg_n_calls_crossed[sregno] -= n_calls;
  		}
  
  	      if (dregno >= FIRST_PSEUDO_REGISTER)
  		{
! 		  if (reg_live_length[dregno] >= 0)
! 		    reg_live_length[dregno] += d_length;
! 
  		  reg_n_calls_crossed[dregno] += d_n_calls;
  		}
  
*** flow.c.old	Thu Feb 15 07:21:23 1996
--- flow.c	Sat Mar 30 20:26:47 1996
*************** propagate_block (old, first, last, final
*** 1623,1627 ****
  
  		  /* Each call clobbers all call-clobbered regs that are not
! 		     global.  Note that the function-value reg is a
  		     call-clobbered reg, and mark_set_regs has already had
  		     a chance to handle it.  */
--- 1623,1627 ----
  
  		  /* Each call clobbers all call-clobbered regs that are not
! 		     global or fixed.  Note that the function-value reg is a
  		     call-clobbered reg, and mark_set_regs has already had
  		     a chance to handle it.  */
*************** propagate_block (old, first, last, final
*** 1628,1632 ****
  
  		  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
! 		    if (call_used_regs[i] && ! global_regs[i])
  		      dead[i / REGSET_ELT_BITS]
  			|= ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS));
--- 1628,1633 ----
  
  		  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
! 		    if (call_used_regs[i] && ! global_regs[i]
! 			&& ! fixed_regs[i])
  		      dead[i / REGSET_ELT_BITS]
  			|= ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS));
*** stor-layout.c.old	Thu Feb 15 07:19:39 1996
--- stor-layout.c	Sun Mar 31 05:38:49 1996
*************** layout_decl (decl, known_align)
*** 261,265 ****
    if (DECL_BIT_FIELD (decl)
        && TYPE_SIZE (type) != 0
!       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)
      {
        register enum machine_mode xmode
--- 261,266 ----
    if (DECL_BIT_FIELD (decl)
        && TYPE_SIZE (type) != 0
!       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
!       && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT)
      {
        register enum machine_mode xmode
*** sparc.h	1996/03/20 22:12:36	1.55
--- config/sparc/sparc.h	1996/03/28 16:35:48
***************
*** 1650,1659 ****
     : output_function_prologue (FILE, SIZE, leaf_function))
  
  /* Output assembler code to FILE to increment profiler label # LABELNO
!    for profiling a function entry.  */
  
  #define FUNCTION_PROFILER(FILE, LABELNO)  			\
    do {								\
      fputs ("\tsethi %hi(", (FILE));				\
      ASM_OUTPUT_INTERNAL_LABELREF (FILE, "LP", LABELNO);		\
      fputs ("),%o0\n", (FILE));					\
--- 1650,1666 ----
     : output_function_prologue (FILE, SIZE, leaf_function))
  
  /* Output assembler code to FILE to increment profiler label # LABELNO
!    for profiling a function entry.
! 
!    32 bit sparc uses %g2 as the STATIC_CHAIN_REGNUM which gets clobbered
!    during profiling so we need to save/restore it around the call to mcount.
!    We're guaranteed that a save has just been done, and we use the space
!    allocated for intreg/fpreg value passing.  */
  
  #define FUNCTION_PROFILER(FILE, LABELNO)  			\
    do {								\
+     if (! TARGET_V9)					\
+       fputs ("\tst %g2,[%fp-4]\n", FILE);			\
      fputs ("\tsethi %hi(", (FILE));				\
      ASM_OUTPUT_INTERNAL_LABELREF (FILE, "LP", LABELNO);		\
      fputs ("),%o0\n", (FILE));					\
***************
*** 1663,1669 ****
      fputs ("\tcall mcount\n\tadd %lo(", (FILE));		\
      ASM_OUTPUT_INTERNAL_LABELREF (FILE, "LP", LABELNO);		\
      fputs ("),%o0,%o0\n", (FILE));				\
    } while (0)
  
  /* Output assembler code to FILE to initialize this source file's
     basic block profiling info, if that has not already been done.  */
--- 1670,1678 ----
      fputs ("\tcall mcount\n\tadd %lo(", (FILE));		\
      ASM_OUTPUT_INTERNAL_LABELREF (FILE, "LP", LABELNO);		\
      fputs ("),%o0,%o0\n", (FILE));				\
+     if (! TARGET_V9)					\
+       fputs ("\tld [%fp-4],%g2\n", FILE);			\
    } while (0)
  
  /* Output assembler code to FILE to initialize this source file's
     basic block profiling info, if that has not already been done.  */
*** sched.c.old	Wed Feb 21 07:55:10 1996
--- sched.c	Sun Mar 31 17:53:17 1996
*************** schedule_block (b, file)
*** 3824,3828 ****
  		     made live again later.  */
  		  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
! 		    if (call_used_regs[i] || global_regs[i])
  		      {
  			register int offset = i / REGSET_ELT_BITS;
--- 3824,3829 ----
  		     made live again later.  */
  		  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
! 		    if ((call_used_regs[i] && ! fixed_regs[i])
! 			|| global_regs[i])
  		      {
  			register int offset = i / REGSET_ELT_BITS;
*** tree.c.old	Wed Mar 20 07:16:23 1996
--- tree.c	Thu Apr  4 09:01:07 1996
*************** substitute_in_expr (exp, f, r)
*** 2215,2218 ****
--- 2215,2219 ----
  {
    enum tree_code code = TREE_CODE (exp);
+   tree op0, op1, op2;
    tree new = 0;
    tree inner;
*************** substitute_in_expr (exp, f, r)
*** 2236,2242 ****
  	{
  	case 1:
! 	  new = fold (build1 (code, TREE_TYPE (exp),
! 			      substitute_in_expr (TREE_OPERAND (exp, 0),
! 						  f, r)));
  	  break;
  
--- 2237,2245 ----
  	{
  	case 1:
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0))
! 	    return exp;
! 	  
! 	  new = fold (build1 (code, TREE_TYPE (exp), op0));
  	  break;
  
*************** substitute_in_expr (exp, f, r)
*** 2249,2256 ****
  	    abort ();
  
! 	  new = fold (build (code, TREE_TYPE (exp),
! 			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 1),
! 						 f, r)));
  	  break;
  
--- 2252,2261 ----
  	    abort ();
  
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
! 	    return exp;
! 
! 	  new = fold (build (code, TREE_TYPE (exp), op0, op1));
  	  break;
  
*************** substitute_in_expr (exp, f, r)
*** 2264,2272 ****
  	    abort ();
  
! 	  new = fold (build (code, TREE_TYPE (exp),
! 			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 1), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 2),
! 						 f, r)));
  	}
  
--- 2269,2280 ----
  	    abort ();
  
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);
! 	  op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
! 	      && op2 == TREE_OPERAND (exp, 2))
! 	    return exp;
! 
! 	  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));
  	}
  
*************** substitute_in_expr (exp, f, r)
*** 2293,2298 ****
  	    return exp;
  
! 	  new = fold (build (code, TREE_TYPE (exp),
! 			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
  			     TREE_OPERAND (exp, 1)));
  	  break;
--- 2301,2309 ----
  	    return exp;
  
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0))
! 	    return exp;
! 
! 	  new = fold (build (code, TREE_TYPE (exp), op0,
  			     TREE_OPERAND (exp, 1)));
  	  break;
*************** substitute_in_expr (exp, f, r)
*** 2299,2306 ****
  
  	case BIT_FIELD_REF:
! 	  new = fold (build (code, TREE_TYPE (exp),
! 			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 1), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 2), f, r)));
  	  break;
  
--- 2310,2321 ----
  
  	case BIT_FIELD_REF:
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);
! 	  op2 = substitute_in_expr (TREE_OPERAND (exp, 2), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)
! 	      && op2 == TREE_OPERAND (exp, 2))
! 	    return exp;
! 
! 	  new = fold (build (code, TREE_TYPE (exp), op0, op1, op2));
  	  break;
  
*************** substitute_in_expr (exp, f, r)
*** 2307,2319 ****
  	case INDIRECT_REF:
  	case BUFFER_REF:
! 	  new = fold (build1 (code, TREE_TYPE (exp),
! 			      substitute_in_expr (TREE_OPERAND (exp, 0),
! 						  f, r)));
  	  break;
  
  	case OFFSET_REF:
! 	  new = fold (build (code, TREE_TYPE (exp),
! 			     substitute_in_expr (TREE_OPERAND (exp, 0), f, r),
! 			     substitute_in_expr (TREE_OPERAND (exp, 1), f, r)));
  	  break;
  	}
--- 2322,2339 ----
  	case INDIRECT_REF:
  	case BUFFER_REF:
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0))
! 	    return exp;
! 
! 	  new = fold (build1 (code, TREE_TYPE (exp), op0));
  	  break;
  
  	case OFFSET_REF:
! 	  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);
! 	  op1 = substitute_in_expr (TREE_OPERAND (exp, 1), f, r);
! 	  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))
! 	    return exp;
! 
! 	  new = fold (build (code, TREE_TYPE (exp), op0, op1));
  	  break;
  	}
*************** substitute_in_expr (exp, f, r)
*** 2326,2469 ****
    TREE_READONLY (new) = TREE_READONLY (exp);
    return new;
- }
- 
- /* Given a type T, a FIELD_DECL F, and a replacement value R,
-    return a new type with all size expressions that contain F
-    updated by replacing F with R.  */
- 
- tree
- substitute_in_type (t, f, r)
-      tree t, f, r;
- {
-   switch (TREE_CODE (t))
-     {
-     case POINTER_TYPE:
-     case VOID_TYPE:
-       return t;
-     case INTEGER_TYPE:
-     case ENUMERAL_TYPE:
-     case BOOLEAN_TYPE:
-     case CHAR_TYPE:
-       if ((TREE_CODE (TYPE_MIN_VALUE (t)) != INTEGER_CST
- 	   && contains_placeholder_p (TYPE_MIN_VALUE (t)))
- 	  || (TREE_CODE (TYPE_MAX_VALUE (t)) != INTEGER_CST
- 	      && contains_placeholder_p (TYPE_MAX_VALUE (t))))
- 	return build_range_type (t,
- 				 substitute_in_expr (TYPE_MIN_VALUE (t), f, r),
- 				 substitute_in_expr (TYPE_MAX_VALUE (t), f, r));
-       return t;
- 
-     case REAL_TYPE:
-       if ((TYPE_MIN_VALUE (t) != 0
- 	   && TREE_CODE (TYPE_MIN_VALUE (t)) != REAL_CST
- 	   && contains_placeholder_p (TYPE_MIN_VALUE (t)))
- 	  || (TYPE_MAX_VALUE (t) != 0
- 	      && TREE_CODE (TYPE_MAX_VALUE (t)) != REAL_CST
- 	      && contains_placeholder_p (TYPE_MAX_VALUE (t))))
- 	{
- 	  t = build_type_copy (t);
- 
- 	  if (TYPE_MIN_VALUE (t))
- 	    TYPE_MIN_VALUE (t) = substitute_in_expr (TYPE_MIN_VALUE (t), f, r);
- 	  if (TYPE_MAX_VALUE (t))
- 	    TYPE_MAX_VALUE (t) = substitute_in_expr (TYPE_MAX_VALUE (t), f, r);
- 	}
-       return t;
- 
-     case COMPLEX_TYPE:
-       return build_complex_type (substitute_in_type (TREE_TYPE (t), f, r));
- 
-     case OFFSET_TYPE:
-     case METHOD_TYPE:
-     case REFERENCE_TYPE:
-     case FILE_TYPE:
-     case SET_TYPE:
-     case FUNCTION_TYPE:
-     case LANG_TYPE:
-       /* Don't know how to do these yet.  */
-       abort ();
- 
-     case ARRAY_TYPE:
-       t = build_array_type (substitute_in_type (TREE_TYPE (t), f, r),
- 			    substitute_in_type (TYPE_DOMAIN (t), f, r));
-       TYPE_SIZE (t) = 0;
-       layout_type (t);
-       return t;
- 
-     case RECORD_TYPE:
-     case UNION_TYPE:
-     case QUAL_UNION_TYPE:
-       {
- 	tree new = copy_node (t);
- 	tree field;
- 	tree last_field = 0;
- 
- 	/* Start out with no fields, make new fields, and chain them
- 	   in.  */
- 
- 	TYPE_FIELDS (new) = 0;
- 	TYPE_SIZE (new) = 0;
- 
- 	for (field = TYPE_FIELDS (t); field;
- 	     field = TREE_CHAIN (field))
- 	  {
- 	    tree new_field = copy_node (field);
- 
- 	    TREE_TYPE (new_field)
- 	      = substitute_in_type (TREE_TYPE (new_field), f, r);
- 
- 	    /* If this is an anonymous field and the type of this field is
- 	       a UNION_TYPE or RECORD_TYPE with no elements, ignore it.  If
- 	       the type just has one element, treat that as the field. 
- 	       But don't do this if we are processing a QUAL_UNION_TYPE.  */
- 	    if (TREE_CODE (t) != QUAL_UNION_TYPE && DECL_NAME (new_field) == 0
- 		&& (TREE_CODE (TREE_TYPE (new_field)) == UNION_TYPE
- 		    || TREE_CODE (TREE_TYPE (new_field)) == RECORD_TYPE))
- 	      {
- 		if (TYPE_FIELDS (TREE_TYPE (new_field)) == 0)
- 		  continue;
- 
- 		if (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (new_field))) == 0)
- 		  new_field = TYPE_FIELDS (TREE_TYPE (new_field));
- 	      }
- 
- 	    DECL_CONTEXT (new_field) = new;
- 	    DECL_SIZE (new_field) = 0;
- 
- 	    if (TREE_CODE (t) == QUAL_UNION_TYPE)
- 	      {
- 		/* Do the substitution inside the qualifier and if we find
- 		   that this field will not be present, omit it.  */
- 		DECL_QUALIFIER (new_field)
- 		  = substitute_in_expr (DECL_QUALIFIER (field), f, r);
- 		if (integer_zerop (DECL_QUALIFIER (new_field)))
- 		  continue;
- 	      }
- 
- 	    if (last_field == 0)
- 	      TYPE_FIELDS (new) = new_field;
- 	    else
- 	      TREE_CHAIN (last_field) = new_field;
- 
- 	    last_field = new_field;
- 
- 	    /* If this is a qualified type and this field will always be
- 	       present, we are done.  */
- 	    if (TREE_CODE (t) == QUAL_UNION_TYPE
- 		&& integer_onep (DECL_QUALIFIER (new_field)))
- 	      break;
- 	  }
- 
- 	/* If this used to be a qualified union type, but we now know what
- 	   field will be present, make this a normal union.  */
- 	if (TREE_CODE (new) == QUAL_UNION_TYPE
- 	    && (TYPE_FIELDS (new) == 0
- 		|| integer_onep (DECL_QUALIFIER (TYPE_FIELDS (new)))))
- 	  TREE_SET_CODE (new, UNION_TYPE);
- 
- 	layout_type (new);
- 	return new;
-       }
-     }
  }
  
--- 2346,2349 ----
*** tree.h.old	Wed Mar 20 07:28:01 1996
--- tree.h	Tue Apr  9 07:06:42 1996
***************
*** 1497,1506 ****
  extern tree substitute_in_expr		PROTO((tree, tree, tree));
  
- /* Given a type T, a FIELD_DECL F, and a replacement value R,
-    return a new type with all size expressions that contain F
-    updated by replacing the reference to F with R.  */
- 
- extern tree substitute_in_type		PROTO((tree, tree, tree));
- 
  /* variable_size (EXP) is like save_expr (EXP) except that it
     is for the special case of something that is part of a
--- 1497,1500 ----
*** calls.c.old	1996/04/01 06:02:12	1.131
--- calls.c	1996/04/25 19:23:59
***************
*** 740,744 ****
  	  if (stack_arg_under_construction || i >= 0)
  	    {
! 	      rtx insn = NEXT_INSN (before_call), seq;
  
  	      /* Look for a call in the inline function code.
--- 740,746 ----
  	  if (stack_arg_under_construction || i >= 0)
  	    {
! 	      rtx first_insn
! 		= before_call ? NEXT_INSN (before_call) : get_insns ();
! 	      rtx insn, seq;
  
  	      /* Look for a call in the inline function code.
***************
*** 748,752 ****
  
  	      if (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) == 0)
! 		for (; insn; insn = NEXT_INSN (insn))
  		  if (GET_CODE (insn) == CALL_INSN)
  		    break;
--- 750,754 ----
  
  	      if (OUTGOING_ARGS_SIZE (DECL_SAVED_INSNS (fndecl)) == 0)
! 		for (insn = first_insn; insn; insn = NEXT_INSN (insn))
  		  if (GET_CODE (insn) == CALL_INSN)
  		    break;
***************
*** 780,784 ****
  		  seq = get_insns ();
  		  end_sequence ();
! 		  emit_insns_before (seq, NEXT_INSN (before_call));
  		  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);
  		}
--- 782,786 ----
  		  seq = get_insns ();
  		  end_sequence ();
! 		  emit_insns_before (seq, first_insn);
  		  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);
  		}
*** stor-layout.c.old	Sun Apr 21 08:24:11 1996
--- stor-layout.c	Thu Apr 25 19:03:21 1996
*************** layout_decl (decl, known_align)
*** 279,282 ****
--- 279,290 ----
      }
  
+   /* Turn off DECL_BIT_FIELD if we won't need it set.  */
+   if (DECL_BIT_FIELD (decl) && TYPE_MODE (type) == BLKmode
+       && known_align % TYPE_ALIGN (type) == 0
+       && DECL_SIZE (decl) != 0
+       && (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST
+ 	  || (TREE_INT_CST_LOW (DECL_SIZE (decl)) % BITS_PER_UNIT) == 0))
+     DECL_BIT_FIELD (decl) = 0;
+ 
    /* Evaluate nonconstant size only once, either now or as soon as safe.  */
    if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)
*** function.c.old	Tue Apr 16 18:22:19 1996
--- function.c	Mon May  6 18:37:25 1996
*************** assign_parms (fndecl, second_time)
*** 3464,3469 ****
  
  	  /* If this is a memory ref that contains aggregate components,
! 	     mark it as such for cse and loop optimize.  */
  	  MEM_IN_STRUCT_P (stack_parm) = aggregate;
  	}
  
--- 3464,3471 ----
  
  	  /* If this is a memory ref that contains aggregate components,
! 	     mark it as such for cse and loop optimize.  Likewise if it
! 	     is readonly.  */
  	  MEM_IN_STRUCT_P (stack_parm) = aggregate;
+ 	  RTX_UNCHANGING_P (stack_parm) = TREE_READONLY (parm);
  	}
  
*** stmt.c.old	Sun Apr 21 08:24:20 1996
--- stmt.c	Mon May  6 21:59:11 1996
*************** expand_decl (decl)
*** 3464,3470 ****
        free_temp_slots ();
  
!       /* Allocate space on the stack for the variable.  */
        address = allocate_dynamic_stack_space (size, NULL_RTX,
! 					      DECL_ALIGN (decl));
  
        /* Reference the variable indirect through that rtx.  */
--- 3464,3473 ----
        free_temp_slots ();
  
!       /* Allocate space on the stack for the variable.  Note that
! 	 DECL_ALIGN says how the variable is to be aligned and we 
! 	 cannot use it to conclude anything about the alignment of
! 	 the size.  */
        address = allocate_dynamic_stack_space (size, NULL_RTX,
! 					      TYPE_ALIGN (TREE_TYPE (decl)));
  
        /* Reference the variable indirect through that rtx.  */
*** expr.c.old	Thu Jul  4 11:47:36 1996
--- expr.c	Thu Jul  4 11:48:21 1996
*************** Boston, MA 02111-1307, USA.  */
*** 27,30 ****
--- 27,31 ----
  #include "flags.h"
  #include "regs.h"
+ #include "hard-reg-set.h"
  #include "function.h"
  #include "insn-flags.h"
*************** extern int stack_depth;
*** 139,144 ****
  extern int max_stack_depth;
  extern struct obstack permanent_obstack;
  
- 
  static rtx enqueue_insn		PROTO((rtx, rtx));
  static int queued_subexp_p	PROTO((rtx));
--- 140,145 ----
  extern int max_stack_depth;
  extern struct obstack permanent_obstack;
+ extern rtx arg_pointer_save_area;
  
  static rtx enqueue_insn		PROTO((rtx, rtx));
  static int queued_subexp_p	PROTO((rtx));
*************** store_constructor (exp, target)
*** 3071,3074 ****
--- 3072,3083 ----
  	    }
  
+ 	  if (TREE_READONLY (field))
+ 	    {
+ 	      if (GET_CODE (to_rtx) == MEM)
+ 		to_rtx = change_address (to_rtx, GET_MODE (to_rtx),
+ 					 XEXP (to_rtx, 0));
+ 	      RTX_UNCHANGING_P (to_rtx) = 1;
+ 	    }
+ 
  	  store_field (to_rtx, bitsize, bitpos, mode, TREE_VALUE (elt),
  		       /* The alignment of TARGET is
*************** store_field (target, bitsize, bitpos, mo
*** 3420,3423 ****
--- 3429,3453 ----
  	temp = convert_modes (mode, TYPE_MODE (TREE_TYPE (exp)), temp, 1);
  
+       /* If the modes of TARGET and TEMP are both BLKmode, both
+ 	 must be in memory and BITPOS must be aligned on a byte
+ 	 boundary.  If so, we simply do a block copy.  */
+       if (GET_MODE (target) == BLKmode && GET_MODE (temp) == BLKmode)
+ 	{
+ 	  if (GET_CODE (target) != MEM || GET_CODE (temp) != MEM
+ 	      || bitpos % BITS_PER_UNIT != 0)
+ 	    abort ();
+ 
+ 	  target = change_address (target, VOIDmode,
+ 				   plus_constant (XEXP (target, 0),
+ 						  bitpos / BITS_PER_UNIT));
+ 
+ 	  emit_block_move (target, temp,
+ 			   GEN_INT ((bitsize + BITS_PER_UNIT - 1)
+ 				    / BITS_PER_UNIT),
+ 			   1);
+ 
+ 	  return value_mode == VOIDmode ? const0_rtx : target;
+ 	}
+ 
        /* Store the value in the bitfield.  */
        store_bit_field (target, bitsize, bitpos, mode, temp, align, total_size);
*************** get_inner_reference (exp, pbitsize, pbit
*** 3599,3607 ****
  
  	  *pbitpos += TREE_INT_CST_LOW (constant);
! 
! 	  if (var)
! 	    offset = size_binop (PLUS_EXPR, offset,
! 				 size_binop (EXACT_DIV_EXPR, var,
! 					     size_int (BITS_PER_UNIT)));
  	}
  
--- 3629,3635 ----
  
  	  *pbitpos += TREE_INT_CST_LOW (constant);
! 	  offset = size_binop (PLUS_EXPR, offset,
! 			       size_binop (EXACT_DIV_EXPR, var,
! 					   size_int (BITS_PER_UNIT)));
  	}
  
*************** get_inner_reference (exp, pbitsize, pbit
*** 3655,3667 ****
      }
  
-   /* If this was a bit-field, see if there is a mode that allows direct
-      access in case EXP is in memory.  */
-   if (mode == VOIDmode && *pbitsize != 0 && *pbitpos % *pbitsize == 0)
-     {
-       mode = mode_for_size (*pbitsize, MODE_INT, 0);
-       if (mode == BLKmode)
- 	mode = VOIDmode;
-     }
- 
    if (integer_zerop (offset))
      offset = 0;
--- 3683,3686 ----
*************** expand_expr (exp, target, tmode, modifie
*** 4534,4537 ****
--- 4553,4565 ----
  		}
  	    }
+ 
+ 	  if (TREE_READONLY (exp))
+ 	    {
+ 	      if (GET_CODE (target) == MEM)
+ 		target = change_address (target, GET_MODE (target),
+ 					 XEXP (target, 0));
+ 	      RTX_UNCHANGING_P (target) = 1;
+ 	    }
+ 
  	  store_constructor (exp, target);
  	  return target;
*************** expand_expr (exp, target, tmode, modifie
*** 4793,4797 ****
  				!= INTEGER_CST)
  			    ? target : NULL_RTX),
! 			   VOIDmode, EXPAND_SUM);
  
  	/* If this is a constant, put it into a register if it is a
--- 4821,4826 ----
  				!= INTEGER_CST)
  			    ? target : NULL_RTX),
! 			   VOIDmode,
! 			   modifier == EXPAND_INITIALIZER ? modifier : 0);
  
  	/* If this is a constant, put it into a register if it is a
*************** expand_expr (exp, target, tmode, modifie
*** 4857,4861 ****
  
  	    if (ext_mode == BLKmode)
! 	      abort ();
  
  	    op0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,
--- 4886,4914 ----
  
  	    if (ext_mode == BLKmode)
! 	      {
! 		/* In this case, BITPOS must start at a byte boundary and
! 		   TARGET, if specified, must be a MEM.  */
! 		if (GET_CODE (op0) != MEM
! 		    || (target != 0 && GET_CODE (target) != MEM)
! 		    || bitpos % BITS_PER_UNIT != 0)
! 		  abort ();
! 
! 		op0 = change_address (op0, VOIDmode,
! 				      plus_constant (XEXP (op0, 0),
! 						     bitpos / BITS_PER_UNIT));
! 		if (target == 0)
! 		  {
! 		    target
! 		      = assign_stack_temp (mode, int_size_in_bytes (type), 0);
! 		    MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (type);
! 		  }
! 
! 		emit_block_move (target, op0,
! 				 GEN_INT ((bitsize + BITS_PER_UNIT - 1)
! 					  / BITS_PER_UNIT),
! 				 1);
! 		
! 		return target;
! 	      }
  
  	    op0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,
*************** expand_expr (exp, target, tmode, modifie
*** 4877,4880 ****
--- 4930,4938 ----
  	  }
  
+ 	/* If the result is BLKmode, use that to access the object
+ 	   now as well.  */
+ 	if (mode == BLKmode)
+ 	  mode1 = BLKmode;
+ 
  	/* Get a reference to just this component.  */
  	if (modifier == EXPAND_CONST_ADDRESS
*************** expand_builtin (exp, target, subtarget, 
*** 7986,7989 ****
--- 8044,8283 ----
  #endif
  
+       /* __builtin_setjmp is passed a pointer to an array of five words
+ 	 (not all will be used on all machines).  It operates similarly to
+ 	 the C library function of the same name, but is more efficient.
+ 	 Much of the code below (and for longjmp) is copied from the handling
+ 	 of non-local gotos.
+ 
+ 	 NOTE: This is intended for use by GNAT and will only work in
+ 	 the method used by it.  This code will likely NOT survive to 
+ 	 the GCC 2.8.0 release.  */
+     case BUILT_IN_SETJMP:
+       if (arglist == 0
+ 	  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
+ 	break;
+ 
+       {
+ 	rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,
+ 				    VOIDmode, 0);
+ 	rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();
+ 	enum machine_mode sa_mode = Pmode;
+ 	rtx stack_save;
+ 	int old_inhibit_defer_pop = inhibit_defer_pop;
+ 	int return_pops = RETURN_POPS_ARGS (get_identifier ("__dummy"),
+ 					    get_identifier ("__dummy"), 0);
+ 	rtx next_arg_reg;
+ 	CUMULATIVE_ARGS args_so_far;
+ 	int current_call_is_indirect = 1;
+ 	int i;
+ 
+ #ifdef POINTERS_EXTEND_UNSIGNED
+ 	buf_addr = convert_memory_address (Pmode, buf_addr);
+ #endif
+ 
+ 	buf_addr = force_reg (Pmode, buf_addr);
+ 
+ 	if (target == 0 || GET_CODE (target) != REG
+ 	    || REGNO (target) < FIRST_PSEUDO_REGISTER)
+ 	  target = gen_reg_rtx (value_mode);
+ 
+ 	emit_queue ();
+ 
+ 	CONST_CALL_P (emit_note (NULL_PTR, NOTE_INSN_SETJMP)) = 1;
+ 	current_function_calls_setjmp = 1;
+ 
+ 	/* We store the frame pointer and the address of lab1 in the buffer
+ 	   and use the rest of it for the stack save area, which is
+ 	   machine-dependent.  */
+ 	emit_move_insn (gen_rtx (MEM, Pmode, buf_addr),
+ 			virtual_stack_vars_rtx);
+ 	emit_move_insn
+ 	  (validize_mem (gen_rtx (MEM, Pmode,
+ 				  plus_constant (buf_addr,
+ 						 GET_MODE_SIZE (Pmode)))),
+ 	   gen_rtx (LABEL_REF, Pmode, lab1));
+ 
+ #ifdef HAVE_save_stack_nonlocal
+ 	if (HAVE_save_stack_nonlocal)
+ 	  sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];
+ #endif
+ 
+ 	current_function_has_nonlocal_goto = 1;
+ 
+ 	stack_save = gen_rtx (MEM, sa_mode,
+ 			      plus_constant (buf_addr,
+ 					     2 * GET_MODE_SIZE (Pmode)));
+ 	emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);
+ 
+ #ifdef HAVE_setjmp
+ 	if (HAVE_setjmp)
+ 	  emit_insn (gen_setjmp ());
+ #endif
+ 
+ 	/* Set TARGET to zero and branch around the other case.  */
+ 	emit_move_insn (target, const0_rtx);
+ 	emit_jump_insn (gen_jump (lab2));
+ 	emit_barrier ();
+ 	emit_label (lab1);
+ 
+ 	/* Note that setjmp clobbers FP when we get here, so we have to
+ 	   make sure it's marked as used by this function. */
+ 	emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));
+ 
+ 	/* Mark the static chain as clobbered here so life information
+ 	   doesn't get messed up for it.  */
+ 	emit_insn (gen_rtx (CLOBBER, VOIDmode, static_chain_rtx));
+ 
+ 	/* Now put in the code to restore the frame pointer, and argument
+ 	   pointer, if needed.  The code below is from expand_end_bindings
+ 	   in stmt.c; see detailed documentation there.  */
+ #ifdef HAVE_nonlocal_goto
+ 	if (! HAVE_nonlocal_goto)
+ #endif
+ 	  emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);
+ 
+ #if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM
+ 	if (fixed_regs[ARG_POINTER_REGNUM])
+ 	  {
+ #ifdef ELIMINABLE_REGS
+ 	    static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;
+ 
+ 	    for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)
+ 	      if (elim_regs[i].from == ARG_POINTER_REGNUM
+ 		  && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)
+ 		break;
+ 
+ 	    if (i == sizeof elim_regs / sizeof elim_regs [0])
+ #endif
+ 	      {
+ 		/* Now restore our arg pointer from the address at which it
+ 		   was saved in our stack frame.
+ 		   If there hasn't be space allocated for it yet, make
+ 		   some now.  */
+ 		if (arg_pointer_save_area == 0)
+ 		  arg_pointer_save_area
+ 		    = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);
+ 		emit_move_insn (virtual_incoming_args_rtx,
+ 				copy_to_reg (arg_pointer_save_area));
+ 	      }
+ 	  }
+ #endif
+ 
+ #ifdef HAVE_nonlocal_goto_receiver
+ 	if (HAVE_nonlocal_goto_receiver)
+ 	  emit_insn (gen_nonlocal_goto_receiver ());
+ #endif
+
+ 	/* The static chain pointer contains the address of dummy function.
+ 	   We need to call it here to handle some PIC cases of restoring
+ 	   a global pointer.  Then return 1.  */
+ 	op0 = copy_to_mode_reg (Pmode, static_chain_rtx);
+ 
+ 	/* We can't actually call emit_library_call here, so do everything
+ 	   it does, which isn't much for a libfunc with no args.  */
+ 	op0 = memory_address (FUNCTION_MODE, op0);
+ 
+ 	INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,
+ 			      gen_rtx (SYMBOL_REF, Pmode, "__dummy"));
+ 	next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);
+ 
+ #ifndef ACCUMULATE_OUTGOING_ARGS
+ #ifdef HAVE_call_pop
+ 	if (HAVE_call_pop)
+ 	  emit_call_insn (gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, op0),
+ 					const0_rtx, next_arg_reg,
+ 					GEN_INT (return_pops)));
+ 	else
+ #endif
+ #endif
+ 
+ #ifdef HAVE_call
+ 	if (HAVE_call)
+ 	  emit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, op0),
+ 				    const0_rtx, next_arg_reg, const0_rtx));
+ 	else
+ #endif
+ 	    abort ();
+ 
+ 	emit_move_insn (target, const1_rtx);
+ 	emit_label (lab2);
+ 	return target;
+       }
+ 
+       /* __builtin_longjmp is passed a pointer to an array of five words
+ 	 and a value, which is a dummy.  It's similar to the C library longjmp
+ 	 function but works with __builtin_setjmp above.  */
+     case BUILT_IN_LONGJMP:
+       if (arglist == 0 || TREE_CHAIN (arglist) == 0
+ 	  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)
+ 	break;
+ 
+       {
+ 	tree dummy_id = get_identifier ("__dummy");
+ 	tree dummy_type = build_function_type (void_type_node, NULL_TREE);
+ 	tree dummy_decl = build_decl (FUNCTION_DECL, dummy_id, dummy_type); 
+ #ifdef POINTERS_EXTEND_UNSIGNED
+ 	rtx buf_addr
+ 	  = force_reg (Pmode,
+ 		       convert_memory_address
+ 		       (Pmode,
+ 			expand_expr (TREE_VALUE (arglist),
+ 				     NULL_RTX, VOIDmode, 0)));
+ #else
+ 	rtx buf_addr
+ 	  = force_reg (Pmode, expand_expr (TREE_VALUE (arglist),
+ 					   NULL_RTX,
+ 					   VOIDmode, 0));
+ #endif
+ 	rtx fp = gen_rtx (MEM, Pmode, buf_addr);
+ 	rtx lab = gen_rtx (MEM, Pmode,
+ 			   plus_constant (buf_addr, GET_MODE_SIZE (Pmode)));
+ 	enum machine_mode sa_mode
+ #ifdef HAVE_save_stack_nonlocal
+ 	  = (HAVE_save_stack_nonlocal
+ 	     ? insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0]
+ 	     : Pmode);
+ #else
+ 	= Pmode;
+ #endif
+ 	rtx stack = gen_rtx (MEM, sa_mode,
+ 			     plus_constant (buf_addr,
+ 					    2 * GET_MODE_SIZE (Pmode)));
+ 
+ 	DECL_EXTERNAL (dummy_decl) = 1;
+ 	TREE_PUBLIC (dummy_decl) = 1;
+ 	make_decl_rtl (dummy_decl, NULL_PTR, 1);
+ 
+ 	/* Expand the second expression just for side-effects.  */
+ 	expand_expr (TREE_VALUE (TREE_CHAIN (arglist)),
+ 		     const0_rtx, VOIDmode, 0);
+ 
+ 	assemble_external (dummy_decl);
+ 
+ 	/* Pick up FP, label, and SP from the block and jump.  This code is
+ 	   from expand_goto in stmt.c; see there for detailed comments.  */
+ #if HAVE_nonlocal_goto
+ 	if (HAVE_nonlocal_goto)
+ 	  emit_insn (gen_nonlocal_goto (fp, lab, stack,
+ 					XEXP (DECL_RTL (dummy_decl), 0)));
+       else
+ #endif
+ 	{
+ 	  lab = copy_to_reg (lab);
+ 	  emit_move_insn (hard_frame_pointer_rtx, fp);
+ 	  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);
+ 
+ 	  /* Put in the static chain register the address of the dummy
+ 	     function.  */
+ 	  emit_move_insn (static_chain_rtx, XEXP (DECL_RTL (dummy_decl), 0));
+ 	  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));
+ 	  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));
+ 	  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));
+ 	  emit_indirect_jump (lab);
+ 	}
+ 
+ 	return const0_rtx;
+       }
+ 
      default:			/* just do library call, if unknown builtin */
        error ("built-in function `%s' not currently supported",
*************** preexpand_calls (exp)
*** 8688,8701 ****
      case CALL_EXPR:
        /* Do nothing if already expanded.  */
!       if (CALL_EXPR_RTL (exp) != 0)
  	return;
  
!       /* Do nothing to built-in functions.  */
!       if (TREE_CODE (TREE_OPERAND (exp, 0)) != ADDR_EXPR
! 	  || TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) != FUNCTION_DECL
! 	  || ! DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))
! 	  /* Do nothing if the call returns a variable-sized object.  */
! 	  || TREE_CODE (TYPE_SIZE (TREE_TYPE(exp))) != INTEGER_CST)
! 	CALL_EXPR_RTL (exp) = expand_call (exp, NULL_RTX, 0);
        return;
  
--- 8977,8991 ----
      case CALL_EXPR:
        /* Do nothing if already expanded.  */
!       if (CALL_EXPR_RTL (exp) != 0
! 	  /* Do nothing if the call returns a variable-sized object.  */
! 	  || TREE_CODE (TYPE_SIZE (TREE_TYPE(exp))) != INTEGER_CST
! 	  /* Do nothing to built-in functions.  */
! 	  || (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR
! 	      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))
! 		  == FUNCTION_DECL)
! 	      && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))))
  	return;
  
!       CALL_EXPR_RTL (exp) = expand_call (exp, NULL_RTX, 0);
        return;
  
*************** do_jump (exp, if_false_label, if_true_la
*** 9087,9090 ****
--- 9377,9381 ----
        push_temp_slots ();
        expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);
+       preserve_temp_slots (NULL_RTX);
        free_temp_slots ();
        pop_temp_slots ();
*** configur.bat.old	Mon Aug 28 05:55:47 1995
--- config/msdos/configur.bat	Tue May  7 12:10:40 1996
***************
*** 18,21 ****
--- 18,27 ----
  set LANG=
  
+ if not exist ada\make-lang.in goto no_ada
+ sed -f config/msdos/top.sed ada\make-lang.in >> Makefile
+ sed -f config/msdos/top.sed ada\makefile.in > ada\Makefile
+ set LANG=%LANG% ada.&	
+ :no_ada
+ 
  if not exist cp\make-lang.in goto no_cp
  sed -f config/msdos/top.sed cp\make-lang.in >> Makefile
*** expmed.c.old	Wed Apr  3 06:33:59 1996
--- expmed.c	Fri May 17 17:16:05 1996
*************** store_split_bit_field (op0, bitsize, bit
*** 782,789 ****
  	    /* The args are chosen so that the last part includes the
  	       lsb.  Give extract_bit_field the value it needs (with
! 	       endianness compensation) to fetch the piece we want.  */
! 	    part = extract_fixed_bit_field (word_mode, value, 0, thissize,
! 					    total_bits - bitsize + bitsdone,
! 					    NULL_RTX, 1, align);
  	}
        else
--- 782,798 ----
  	    /* The args are chosen so that the last part includes the
  	       lsb.  Give extract_bit_field the value it needs (with
! 	       endianness compensation) to fetch the piece we want.
! 
! 	       ??? We have no idea what the alignment of VALUE is, so
! 	       we have to use a guess.  */
! 	    part
! 	      = extract_fixed_bit_field
! 		(word_mode, value, 0, thissize,
! 		 total_bits - bitsize + bitsdone, NULL_RTX, 1,
! 		 GET_MODE (value) == VOIDmode
! 		 ? UNITS_PER_WORD
! 		 : (GET_MODE (value) == BLKmode
! 		    ? 1
! 		    : GET_MODE_ALIGNMENT (GET_MODE (value)) / BITS_PER_UNIT));
  	}
        else
*************** store_split_bit_field (op0, bitsize, bit
*** 795,800 ****
  			    & (((HOST_WIDE_INT) 1 << thissize) - 1));
  	  else
! 	    part = extract_fixed_bit_field (word_mode, value, 0, thissize,
! 					    bitsdone, NULL_RTX, 1, align);
  	}
  
--- 804,815 ----
  			    & (((HOST_WIDE_INT) 1 << thissize) - 1));
  	  else
! 	    part
! 	      = extract_fixed_bit_field
! 		(word_mode, value, 0, thissize, bitsdone, NULL_RTX, 1,
! 		 GET_MODE (value) == VOIDmode
! 		 ? UNITS_PER_WORD
! 		 : (GET_MODE (value) == BLKmode
! 		    ? 1
! 		    : GET_MODE_ALIGNMENT (GET_MODE (value)) / BITS_PER_UNIT));
  	}
  
*** c-decl.c.orig	Mon May 27 06:44:03 1996
--- c-decl.c	Mon Jun  3 07:58:28 1996
*************** start_struct (code, name)
*** 5378,5381 ****
--- 5378,5382 ----
    pushtag (name, ref);
    C_TYPE_BEING_DEFINED (ref) = 1;
+   TYPE_PACKED (ref) = flag_pack_struct;
    return ref;
  }
*************** start_enum (name)
*** 5819,5822 ****
--- 5820,5826 ----
    enum_overflow = 0;
  
+   if (flag_short_enums)
+     TYPE_PACKED (enumtype) = 1;
+ 
    return enumtype;
  }
*************** finish_enum (enumtype, values, attribute
*** 5875,5880 ****
    precision = MAX (lowprec, highprec);
  
!   if (flag_short_enums || TYPE_PACKED (enumtype)
!       || precision > TYPE_PRECISION (integer_type_node))
      /* Use the width of the narrowest normal C type which is wide enough.  */
      TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size (precision, 1));
--- 5879,5883 ----
    precision = MAX (lowprec, highprec);
  
!   if (TYPE_PACKED (enumtype) || precision > TYPE_PRECISION (integer_type_node))
      /* Use the width of the narrowest normal C type which is wide enough.  */
      TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size (precision, 1));
*** stor-layout.c.orig	Mon May 27 06:44:12 1996
--- stor-layout.c	Mon Jun  3 07:58:29 1996
*************** layout_decl (decl, known_align)
*** 255,259 ****
        if (maximum_field_alignment != 0)
  	DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);
!       else if (flag_pack_struct)
  	DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);
      }
--- 255,259 ----
        if (maximum_field_alignment != 0)
  	DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);
!       else if (DECL_PACKED (decl))
  	DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);
      }
*************** layout_record (rec)
*** 389,393 ****
  	      if (maximum_field_alignment != 0)
  		type_align = MIN (type_align, maximum_field_alignment);
! 	      else if (flag_pack_struct)
  		type_align = MIN (type_align, BITS_PER_UNIT);
  
--- 389,393 ----
  	      if (maximum_field_alignment != 0)
  		type_align = MIN (type_align, maximum_field_alignment);
! 	      else if (TYPE_PACKED (rec))
  		type_align = MIN (type_align, BITS_PER_UNIT);
  
*************** layout_record (rec)
*** 431,437 ****
  	  && DECL_BIT_FIELD_TYPE (field)
  	  && !DECL_PACKED (field)
- 	  /* If #pragma pack is in effect, turn off this feature.  */
  	  && maximum_field_alignment == 0
- 	  && !flag_pack_struct
  	  && !integer_zerop (DECL_SIZE (field)))
  	{
--- 431,435 ----
*************** layout_record (rec)
*** 468,472 ****
  	  if (maximum_field_alignment != 0)
  	    type_align = MIN (type_align, maximum_field_alignment);
! 	  else if (flag_pack_struct)
  	    type_align = MIN (type_align, BITS_PER_UNIT);
  
--- 466,470 ----
  	  if (maximum_field_alignment != 0)
  	    type_align = MIN (type_align, maximum_field_alignment);
! 	  else if (TYPE_PACKED (rec))
  	    type_align = MIN (type_align, BITS_PER_UNIT);
  
*** sparc.md.orig	Tue Sep 12 18:57:35 1995
--- config/sparc/sparc.md	Mon Jun  3 08:18:56 1996
***************
*** 4799,4803 ****
      abort ();
  
!  if (GET_CODE (XEXP (operands[0], 0)) == LABEL_REF)
      {
        /* This is really a PIC sequence.  We want to represent
--- 4799,4803 ----
      abort ();
  
!   if (GET_CODE (XEXP (operands[0], 0)) == LABEL_REF)
      {
        /* This is really a PIC sequence.  We want to represent
***************
*** 4809,4824 ****
  
        if (! TARGET_V9 && INTVAL (operands[3]) != 0)
! 	emit_jump_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,
! 				 gen_rtx (SET, VOIDmode, pc_rtx,
! 					  XEXP (operands[0], 0)),
! 				 operands[3],
! 				 gen_rtx (CLOBBER, VOIDmode,
! 					  gen_rtx (REG, Pmode, 15)))));
        else
! 	emit_jump_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,
! 				 gen_rtx (SET, VOIDmode, pc_rtx,
! 					  XEXP (operands[0], 0)),
! 				 gen_rtx (CLOBBER, VOIDmode,
! 					  gen_rtx (REG, Pmode, 15)))));
        goto finish_call;
      }
--- 4809,4828 ----
  
        if (! TARGET_V9 && INTVAL (operands[3]) != 0)
! 	emit_jump_insn
! 	  (gen_rtx (PARALLEL, VOIDmode,
! 		    gen_rtvec (3,
! 			       gen_rtx (SET, VOIDmode, pc_rtx,
! 					XEXP (operands[0], 0)),
! 			       GEN_INT (INTVAL (operands[3]) & 0xfff),
! 			       gen_rtx (CLOBBER, VOIDmode,
! 					gen_rtx (REG, Pmode, 15)))));
        else
! 	emit_jump_insn
! 	  (gen_rtx (PARALLEL, VOIDmode,
! 		    gen_rtvec (2,
! 			       gen_rtx (SET, VOIDmode, pc_rtx,
! 					XEXP (operands[0], 0)),
! 			       gen_rtx (CLOBBER, VOIDmode,
! 					gen_rtx (REG, Pmode, 15)))));
        goto finish_call;
      }
***************
*** 4839,4852 ****
  
    if (! TARGET_V9 && INTVAL (operands[3]) != 0)
!     emit_call_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (3,
! 			     gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),
! 			     operands[3],
! 			     gen_rtx (CLOBBER, VOIDmode,
! 					       gen_rtx (REG, Pmode, 15)))));
    else
!     emit_call_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,
! 			     gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),
! 			     gen_rtx (CLOBBER, VOIDmode,
! 					       gen_rtx (REG, Pmode, 15)))));
  
   finish_call:
--- 4843,4858 ----
  
    if (! TARGET_V9 && INTVAL (operands[3]) != 0)
!     emit_call_insn
!       (gen_rtx (PARALLEL, VOIDmode,
! 		gen_rtvec (3, gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),
! 			   GEN_INT (INTVAL (operands[3]) & 0xfff),
! 			   gen_rtx (CLOBBER, VOIDmode,
! 				    gen_rtx (REG, Pmode, 15)))));
    else
!     emit_call_insn
!       (gen_rtx (PARALLEL, VOIDmode,
! 		gen_rtvec (2, gen_rtx (CALL, VOIDmode, fn_rtx, nregs_rtx),
! 			   gen_rtx (CLOBBER, VOIDmode,
! 				    gen_rtx (REG, Pmode, 15)))));
  
   finish_call:
*** config/sparc/sparc.md.old	Mon Jun 03 08:29:45 1996
--- config/sparc/sparc.md	Wed Jun 05 13:37:54 1996
***************
*** 4917,4921 ****
     (clobber (reg:SI 15))]
    ;;- Do not use operand 1 for most machines.
!   "! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 0"
    "call %a0,%1\;nop\;unimp %2"
    [(set_attr "type" "call_no_delay_slot")])
--- 4917,4921 ----
     (clobber (reg:SI 15))]
    ;;- Do not use operand 1 for most machines.
!   "! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0"
    "call %a0,%1\;nop\;unimp %2"
    [(set_attr "type" "call_no_delay_slot")])
***************
*** 4929,4933 ****
     (clobber (reg:SI 15))]
    ;;- Do not use operand 1 for most machines.
!   "! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) > 0"
    "call %a0,%1\;nop\;unimp %2"
    [(set_attr "type" "call_no_delay_slot")])
--- 4929,4933 ----
     (clobber (reg:SI 15))]
    ;;- Do not use operand 1 for most machines.
!   "! TARGET_V9 && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 0"
    "call %a0,%1\;nop\;unimp %2"
    [(set_attr "type" "call_no_delay_slot")])
*** configure.old	Tue Jun 11 07:04:42 1996
--- configure	Tue Jun 18 06:03:16 1996
***************
*** 3144,3148 ****
  	rm Makefile.sed
  	echo 's|||' > Makefile.sed
! 	echo "s|^target=.*$|target=${target}|" >> Makefile.sed
  	echo "s|^xmake_file=.*$|xmake_file=${dep_host_xmake_file}|" >> Makefile.sed
  	echo "s|^tmake_file=.*$|tmake_file=${dep_tmake_file}|" >> Makefile.sed
--- 3156,3160 ----
  	rm Makefile.sed
  	echo 's|||' > Makefile.sed
! 	echo "s|^target=.*$|target=${canon_target}|" >> Makefile.sed
  	echo "s|^xmake_file=.*$|xmake_file=${dep_host_xmake_file}|" >> Makefile.sed
  	echo "s|^tmake_file=.*$|tmake_file=${dep_tmake_file}|" >> Makefile.sed
*** c-typeck.c.old	Wed Oct 18 17:54:55 1995
--- c-typeck.c	Tue Jun 18 06:59:55 1996
*************** pointer_int_sum (resultcode, ptrop, into
*** 2681,2686 ****
       so the multiply won't overflow spuriously.  */
  
!   if (TYPE_PRECISION (TREE_TYPE (intop)) != POINTER_SIZE)
!     intop = convert (type_for_size (POINTER_SIZE, 0), intop);
  
    /* Replace the integer argument with a suitable product by the object size.
--- 2681,2688 ----
       so the multiply won't overflow spuriously.  */
  
!   if (TYPE_PRECISION (TREE_TYPE (intop)) != TYPE_PRECISION (sizetype)
!       || TREE_UNSIGNED (TREE_TYPE (intop)) != TREE_UNSIGNED (sizetype))
!     intop = convert (type_for_size (TYPE_PRECISION (sizetype), 
! 				    TREE_UNSIGNED (sizetype)), intop);
  
    /* Replace the integer argument with a suitable product by the object size.
*** explow.c.old	Wed Dec 27 16:19:46 1995
--- explow.c	Fri Jun 14 11:43:19 1996
*************** convert_memory_address (to_mode, x)
*** 305,310 ****
--- 305,313 ----
       rtx x;
  {
+   enum machine_mode from_mode = to_mode == ptr_mode ? Pmode : ptr_mode;
    rtx temp;
  
+   /* Here we handle some special cases.  If none of them apply, fall through
+      to the default case.  */
    switch (GET_CODE (x))
      {
*************** convert_memory_address (to_mode, x)
*** 321,330 ****
        return temp;
  
-     case PLUS:
-     case MULT:
-       return gen_rtx (GET_CODE (x), to_mode, 
- 		      convert_memory_address (to_mode, XEXP (x, 0)),
- 		      convert_memory_address (to_mode, XEXP (x, 1)));
- 
      case CONST:
        return gen_rtx (CONST, to_mode, 
--- 324,327 ----
*************** convert_memory_address (to_mode, x)
*** 331,339 ****
  		      convert_memory_address (to_mode, XEXP (x, 0)));
  
!     default:
!       return convert_modes (to_mode,
! 			    to_mode == ptr_mode ? Pmode : ptr_mode,
! 			    x, POINTERS_EXTEND_UNSIGNED);
      }
  }
  #endif
--- 328,348 ----
  		      convert_memory_address (to_mode, XEXP (x, 0)));
  
!     case PLUS:
!     case MULT:
!       /* For addition the second operand is a small constant, we can safely
! 	 permute the converstion and addition operation.  We can always safely
! 	 permute them if we are making the address narrower.  In addition,
! 	 always permute the operations if this is a constant.  */
!       if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)
! 	  || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT
! 	      && (INTVAL (XEXP (x, 1)) + 20000 < 40000
! 		  || CONSTANT_P (XEXP (x, 0)))))
! 	return gen_rtx (GET_CODE (x), to_mode, 
! 			convert_memory_address (to_mode, XEXP (x, 0)),
! 			convert_memory_address (to_mode, XEXP (x, 1)));
      }
+ 
+   return convert_modes (to_mode, from_mode,
+ 			x, POINTERS_EXTEND_UNSIGNED);
  }
  #endif
*** integrate.c.old	Thu Apr 11 07:17:14 1996
--- integrate.c	Tue Jun 18 13:46:01 1996
*************** expand_inline_function (fndecl, parms, t
*** 1600,1604 ****
        if (GET_CODE (XEXP (loc, 0)) == REG)
  	{
! 	  temp = force_reg (Pmode, structure_value_addr);
  	  map->reg_map[REGNO (XEXP (loc, 0))] = temp;
  	  if ((CONSTANT_P (structure_value_addr)
--- 1600,1605 ----
        if (GET_CODE (XEXP (loc, 0)) == REG)
  	{
! 	  temp = force_reg (Pmode,
! 			    force_operand (structure_value_addr, NULL_RTX));
  	  map->reg_map[REGNO (XEXP (loc, 0))] = temp;
  	  if ((CONSTANT_P (structure_value_addr)
*** configure.old	Sat Jul 20 09:03:26 1996
--- configure	Thu Jul 18 17:55:32 1996
***************
*** 1693,1696 ****
--- 1693,1717 ----
  		use_collect2=yes
  		;;
+         mips-sni-sysv4)
+ 		if [ x$gas = xyes ]
+ 		then
+ 			if [ x$stabs = xyes ]
+ 			then
+ 				tm_file=mips/iris5gdb.h
+ 			else
+ 				tm_file=mips/sni-gas.h
+ 			fi
+ 		else
+ 			tm_file=mips/sni-svr4.h
+ 		fi
+                 xm_file=mips/xm-sysv.h
+                 xmake_file=mips/x-sni-svr4
+                 tmake_file=mips/t-mips-gas
+                 if [ x$gnu_ld != xyes ]
+                 then
+                         use_collect2=yes
+                 fi
+                 broken_install=yes
+                 ;;
  	mips-sgi-irix5*)		# SGI System V.4., IRIX 5
  		if [ x$gas = xyes ]
*** mips.h.old	Fri Jun 28 09:50:37 1996
--- config/mips/mips.h	Sun Jun 30 20:37:11 1996
***************
*** 2219,2229 ****
      }									    \
  									    \
!   /* Flush the instruction cache.  */					    \
-   /* ??? Are the modes right? Maybe they should depend on -mint64/-mlong64? */\
    /* ??? Should check the return value for errors.  */			    \
!   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, "cacheflush"),		    \
  		     0, VOIDmode, 3, addr, Pmode,			    \
  		     GEN_INT (TRAMPOLINE_SIZE), SImode,  		    \
! 		     GEN_INT (1), SImode);				    \
  }
  
--- 2219,2229 ----
      }									    \
  									    \
!   /* Flush both caches.  We need to flush the data cache in case	    \
!      the system has a write-back cache.  */				    \
    /* ??? Should check the return value for errors.  */			    \
!   emit_library_call (gen_rtx (SYMBOL_REF, Pmode, "_flush_cache"),	    \
  		     0, VOIDmode, 3, addr, Pmode,			    \
  		     GEN_INT (TRAMPOLINE_SIZE), TYPE_MODE (integer_type_node),\
! 		     GEN_INT (3), TYPE_MODE (integer_type_node));	    \
  }
  
*** /dev/null	Thu Aug 17 14:25:05 1995
--- config/mips/sni-gas.h	Wed Jun 26 05:16:20 1996
***************
*** 0 ****
--- 1,43 ----
+ #include "mips/sni-svr4.h"
+ 
+ /* Enable debugging.  */
+ #define DBX_DEBUGGING_INFO
+ #define SDB_DEBUGGING_INFO
+ #define MIPS_DEBUGGING_INFO
+ 
+ #define DWARF_DEBUGGING_INFO
+ #undef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG
+ 
+ /* We need to use .esize and .etype instead of .size and .type to
+    avoid conflicting with ELF directives.  These are only recognized
+    by gas, anyhow, not the native assembler.  */
+ #undef PUT_SDB_SIZE
+ #define PUT_SDB_SIZE(a)                                       \
+ do {                                                  \
+   extern FILE *asm_out_text_file;                     \
+   fprintf (asm_out_text_file, "\t.esize\t%d;", (a));  \
+ } while (0)
+ 
+ #undef PUT_SDB_TYPE
+ #define PUT_SDB_TYPE(a)                                       \
+ do {                                                  \
+   extern FILE *asm_out_text_file;                     \
+   fprintf (asm_out_text_file, "\t.etype\t0x%x;", (a));        \
+ } while (0)
+ 
+ 
+ /* This is how to equate one symbol to another symbol.  The syntax used is
+    `SYM1=SYM2'.  Note that this is different from the way equates are done
+    with most svr4 assemblers, where the syntax is `.set SYM1,SYM2'.  */
+ 
+ #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)				\
+  do {	fprintf ((FILE), "\t");						\
+ 	assemble_name (FILE, LABEL1);					\
+ 	fprintf (FILE, " = ");						\
+ 	assemble_name (FILE, LABEL2);					\
+ 	fprintf (FILE, "\n");						\
+   } while (0)
+ 
+ 
+ 
*** /dev/null	Thu Aug 17 14:25:05 1995
--- config/mips/sni-svr4.h	Wed Jun 26 06:23:20 1996
***************
*** 0 ****
--- 1,103 ----
+ /* Definitions of target machine for GNU compiler.  SNI SINIX version.
+    Copyright (C) 1996 Free Software Foundation, Inc.
+    Contributed by Marco Walther (Marco.Walther@mch.sni.de).
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ 
+ #define MIPS_SVR4
+ 
+ #define CPP_PREDEFINES "\
+ -Dmips -Dunix -Dhost_mips -DMIPSEB -DR3000 -DSYSTYPE_SVR4 \
+ -D_mips -D_unix -D_host_mips -D_MIPSEB -D_R3000 -D_SYSTYPE_SVR4 \
+ -Asystem(unix) -Asystem(svr4) -Acpu(mips) -Amachine(mips)"
+ 
+ #define CPP_SPEC "\
+ %{.cc:	-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \
+ %{.cxx:	-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \
+ %{.C:	-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \
+ %{.m:	-D__LANGUAGE_OBJECTIVE_C -D_LANGUAGE_OBJECTIVE_C} \
+ %{.S:	-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \
+ %{.s:	-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \
+ %{!.S:%{!.s:	-D__LANGUAGE_C -D_LANGUAGE_C %{!ansi:-DLANGUAGE_C}}} \
+ -D__SIZE_TYPE__=unsigned\\ int -D__PTRDIFF_TYPE__=int"
+ 
+ #define LINK_SPEC "\
+ %{G*} \
+ %{!mgas: \
+ 	%{dy} %{dn}}"
+ 		    
+ #define LIB_SPEC "\
+ 	%{p:-lprof1} \
+ 	%{!p:%{pg:-lprof1} \
+ 	     %{!pg:-L/usr/ccs/lib/ -lc /usr/ccs/lib/crtn.o%s}}"
+ 
+ #define STARTFILE_SPEC "\
+ 	%{pg:gcrt0.o%s} \
+ 	%{!pg:%{p:mcrt0.o%s} \
+ 	       %{!p:/usr/ccs/lib/crt1.o /usr/ccs/lib/crti.o /usr/ccs/lib/values-Xt.o%s}}"
+ 
+ /* Mips System V.4 doesn't have a getpagesize() function needed by the
+    trampoline code, so use the POSIX sysconf function to get it.
+    This is only done when compiling the trampoline code.  */
+ 
+ #ifdef  L_trampoline
+ #include <unistd.h>
+ 
+ #define getpagesize()	sysconf(_SC_PAGE_SIZE)
+ #endif /*  L_trampoline */
+ 
+ /* Use atexit for static constructors/destructors, instead of defining
+    our own exit function.  */
+ #define HAVE_ATEXIT
+ 
+ /* Generate calls to memcpy, etc., not bcopy, etc.  */
+ #define TARGET_MEM_FUNCTIONS
+ 
+ #define OBJECT_FORMAT_ELF
+ 
+ #define	TARGET_DEFAULT	MASK_ABICALLS
+ #define ABICALLS_ASM_OP ".option pic2"
+ 
+ #define MACHINE_TYPE "SNI running SINIX 5.42"
+ 
+ #define MIPS_DEFAULT_GVALUE	0
+ 
+ #define NM_FLAGS	"-p"
+ 
+ /* wir haben ein Problem, wenn in einem Assembler-File keine .text-section
+    erzeugt wird. Dann landen diese Pseudo-Labels in irgendeiner anderen
+    section, z.B. .reginfo. Das macht den ld sehr ungluecklich. */
+ 
+ #define ASM_IDENTIFY_GCC(mw_stream) \
+ 	fprintf(mw_stream, "\t.ident \"gcc2_compiled.\"\n");
+ 
+ #define ASM_IDENTIFY_LANGUAGE(STREAM)
+ 
+ #define ASM_LONG	".word\t"
+ #define ASM_GLOBAL	".rdata\n\t\t.globl\t"
+ 
+ #include "mips/mips.h"
+ 
+ /* We do not want to run mips-tfile!  */
+ #undef ASM_FINAL_SPEC
+ 
+ #undef OBJECT_FORMAT_COFF
+ 
+ /* We don't support debugging info for now. */
+ #undef DBX_DEBUGGING_INFO
+ #undef SDB_DEBUGGING_INFO
+ #undef MIPS_DEBUGGING_INFO
*** /dev/null	Thu Aug 17 14:25:05 1995
--- config/mips/x-sni-svr4	Wed Jun 26 05:16:21 1996
***************
*** 0 ****
--- 1,18 ----
+ # Define CC and OLDCC as the same, so that the tests:
+ #	if [ x"$(OLDCC)" = x"$(CC)" ] ...
+ #
+ # will succeed (if OLDCC != CC, it is assumed that GCC is
+ # being used in secondary stage builds).
+ # -Olimit is so the user can use -O2.  Down with fixed
+ # size tables!
+ 
+ CC		= $(OLDCC)
+ OPT		=
+ OLDCC		= cc -Olimit 3000 $(OPT)
+ 
+ X_CFLAGS	= -DNO_SYS_SIGLIST
+ 
+ # Show we need to use the C version of ALLOCA
+ # The SVR3 configurations have it, but the SVR4 configurations don't.
+ # For now, just try using it for all SVR* configurations.
+ ALLOCA		= alloca.o
*** dwarfout.c.old	Sat Jul 20 09:02:52 1996
--- dwarfout.c	Sat Jul 20 09:06:27 1996
*************** output_bound_representation (bound, dim_
*** 1723,1799 ****
      {
  
!       case ERROR_MARK:
! 	return;
  
        /* All fixed-bounds are represented by INTEGER_CST nodes.	 */
  
!       case INTEGER_CST:
! 	ASM_OUTPUT_DWARF_DATA4 (asm_out_file,
! 				(unsigned) TREE_INT_CST_LOW (bound));
! 	break;
  
!       /* Dynamic bounds may be represented by NOP_EXPR nodes containing
! 	 SAVE_EXPR nodes.  */
! 
!       case NOP_EXPR:
! 	bound = TREE_OPERAND (bound, 0);
! 	/* ... fall thru... */
  
!       case SAVE_EXPR:
! 	{
! 	  char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];
! 	  char end_label[MAX_ARTIFICIAL_LABEL_BYTES];
! 
! 	  sprintf (begin_label, BOUND_BEGIN_LABEL_FMT,
! 				current_dienum, dim_num, u_or_l);
  
! 	  sprintf (end_label,	BOUND_END_LABEL_FMT,
! 				current_dienum, dim_num, u_or_l);
  
! 	  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);
! 	  ASM_OUTPUT_LABEL (asm_out_file, begin_label);
  
! 	  /* If we are working on a bound for a dynamic dimension in C,
! 	     the dynamic dimension in question had better have a static
! 	     (zero) lower bound and a dynamic *upper* bound.  */
  
! 	  if (u_or_l != 'u')
! 	    abort ();
  
! 	  /* If optimization is turned on, the SAVE_EXPRs that describe
! 	     how to access the upper bound values are essentially bogus.
! 	     They only describe (at best) how to get at these values at
! 	     the points in the generated code right after they have just
! 	     been computed.  Worse yet, in the typical case, the upper
! 	     bound values will not even *be* computed in the optimized
! 	     code, so these SAVE_EXPRs are entirely bogus.
  
! 	     In order to compensate for this fact, we check here to see
! 	     if optimization is enabled, and if so, we effectively create
! 	     an empty location description for the (unknown and unknowable)
! 	     upper bound.
  
! 	     This should not cause too much trouble for existing (stupid?)
! 	     debuggers because they have to deal with empty upper bounds
! 	     location descriptions anyway in order to be able to deal with
! 	     incomplete array types.
  
! 	     Of course an intelligent debugger (GDB?) should be able to
! 	     comprehend that a missing upper bound specification in a
! 	     array type used for a storage class `auto' local array variable
! 	     indicates that the upper bound is both unknown (at compile-
! 	     time) and unknowable (at run-time) due to optimization.
! 	  */
  
! 	  if (! optimize)
! 	    output_loc_descriptor
! 	      (eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));
  
! 	  ASM_OUTPUT_LABEL (asm_out_file, end_label);
! 	}
! 	break;
  
-       default:
- 	abort ();
      }
  }
--- 1723,1793 ----
      {
  
!     case ERROR_MARK:
!       return;
  
        /* All fixed-bounds are represented by INTEGER_CST nodes.	 */
  
!     case INTEGER_CST:
!       ASM_OUTPUT_DWARF_DATA4 (asm_out_file,
! 			      (unsigned) TREE_INT_CST_LOW (bound));
!       break;
  
!     default:
  
!       /* Dynamic bounds may be represented by NOP_EXPR nodes containing
! 	 SAVE_EXPR nodes, in which case we can do something, or as
! 	 an expression, which we cannot represent.  */
!       {
! 	char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];
! 	char end_label[MAX_ARTIFICIAL_LABEL_BYTES];
  
! 	sprintf (begin_label, BOUND_BEGIN_LABEL_FMT,
! 		 current_dienum, dim_num, u_or_l);
  
! 	sprintf (end_label, BOUND_END_LABEL_FMT,
! 		 current_dienum, dim_num, u_or_l);
  
! 	ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);
! 	ASM_OUTPUT_LABEL (asm_out_file, begin_label);
  
! 	/* If optimization is turned on, the SAVE_EXPRs that describe
! 	   how to access the upper bound values are essentially bogus.
! 	   They only describe (at best) how to get at these values at
! 	   the points in the generated code right after they have just
! 	   been computed.  Worse yet, in the typical case, the upper
! 	   bound values will not even *be* computed in the optimized
! 	   code, so these SAVE_EXPRs are entirely bogus.
  
! 	   In order to compensate for this fact, we check here to see
! 	   if optimization is enabled, and if so, we effectively create
! 	   an empty location description for the (unknown and unknowable)
! 	   upper bound.
  
! 	   This should not cause too much trouble for existing (stupid?)
! 	   debuggers because they have to deal with empty upper bounds
! 	   location descriptions anyway in order to be able to deal with
! 	   incomplete array types.
  
! 	   Of course an intelligent debugger (GDB?) should be able to
! 	   comprehend that a missing upper bound specification in a
! 	   array type used for a storage class `auto' local array variable
! 	   indicates that the upper bound is both unknown (at compile-
! 	   time) and unknowable (at run-time) due to optimization. */
  
! 	if (! optimize)
! 	  {
! 	    while (TREE_CODE (bound) == NOP_EXPR
! 		   || TREE_CODE (bound) == CONVERT_EXPR)
! 	      bound = TREE_OPERAND (bound, 0);
  
! 	    if (TREE_CODE (bound) == SAVE_EXPR)
! 	      output_loc_descriptor
! 		(eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));
! 	  }
  
! 	ASM_OUTPUT_LABEL (asm_out_file, end_label);
!       }
!       break;
  
      }
  }
*** tree.h.old	Sat Jun 15 06:38:05 1996
--- tree.h	Tue Jul 23 18:51:34 1996
***************
*** 511,514 ****
--- 511,516 ----
  {
    char common[sizeof (struct tree_common)];
+   struct rtx_def *rtl;	/* acts as link to register transfer language
+ 			   (rtl) info */
    HOST_WIDE_INT int_cst_low;
    HOST_WIDE_INT int_cst_high;
*** varasm.c.old	Sat Jul 20 09:09:22 1996
--- varasm.c	Tue Jul 23 18:55:08 1996
*************** decode_addr_const (exp, value)
*** 2264,2267 ****
--- 2264,2268 ----
      case COMPLEX_CST:
      case CONSTRUCTOR:
+     case INTEGER_CST:
        x = TREE_CST_RTL (target);
        break;
*************** output_constant_def (exp)
*** 2825,2831 ****
    int reloc;
    register rtx def;
- 
-   if (TREE_CODE (exp) == INTEGER_CST)
-     abort ();			/* No TREE_CST_RTL slot in these.  */
  
    if (TREE_CST_RTL (exp))
--- 2826,2829 ----
*** cse.c.jul24	Wed Jul 10 06:09:22 1996
--- cse.c	Wed Jul 24 21:32:41 1996
*************** canon_hash (x, mode)
*** 1946,1950 ****
  	  return 0;
  	}
!       if (! RTX_UNCHANGING_P (x))
  	{
  	  hash_arg_in_memory = 1;
--- 1946,1950 ----
  	  return 0;
  	}
!       if (! RTX_UNCHANGING_P (x) || FIXED_BASE_PLUS_P (XEXP (x, 0)))
  	{
  	  hash_arg_in_memory = 1;
*************** cse_insn (insn, in_libcall_block)
*** 7378,7382 ****
  		      sets[i].dest_hash, GET_MODE (dest));
  	elt->in_memory = (GET_CODE (sets[i].inner_dest) == MEM
! 			  && ! RTX_UNCHANGING_P (sets[i].inner_dest));
  
  	if (elt->in_memory)
--- 7378,7384 ----
  		      sets[i].dest_hash, GET_MODE (dest));
  	elt->in_memory = (GET_CODE (sets[i].inner_dest) == MEM
! 			  && (! RTX_UNCHANGING_P (sets[i].inner_dest)
! 			      || FIXED_BASE_PLUS_P (XEXP (sets[i].inner_dest,
! 							  0))));
  
  	if (elt->in_memory)
*** stmt.c.old	Tue Jun 11 06:57:46 1996
--- stmt.c	Tue Aug  6 23:15:23 1996
*************** expand_end_bindings (vars, mark_ends, do
*** 3173,3176 ****
--- 3173,3181 ----
  	    }
  	}
+ #endif
+ 
+ #ifdef HAVE_nonlocal_goto_receiver
+       if (HAVE_nonlocal_goto_receiver)
+ 	emit_insn (gen_nonlocal_goto_receiver ());
  #endif
  
*** function.c.old	Wed Jul 10 06:06:03 1996
--- function.c	Sun Aug 25 22:22:15 1996
*************** free_temps_for_rtl_expr (t)
*** 1227,1230 ****
--- 1227,1245 ----
  }
  
+ /* Mark all temporaries ever allocated in this functon as not suitable
+    for reuse until the current level is exited.  */
+ 
+ void
+ mark_all_temps_used ()
+ {
+   struct temp_slot *p;
+ 
+   for (p = temp_slots; p; p = p->next)
+     {
+       p->in_use = 1;
+       p->level = MIN (p->level, temp_slot_level);
+     }
+ }
+ 
  /* Push deeper into the nesting level for stack temporaries.  */
  
*** expr.c.old	Tue Aug  6 22:14:16 1996
--- expr.c	Sat Sep  7 13:33:24 1996
*************** store_field (target, bitsize, bitpos, mo
*** 4035,4038 ****
--- 4035,4050 ----
        rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);
  
+       /* If BITSIZE is narrower than the size of the type of EXP
+ 	 we will be narrowing TEMP.  Normally, what's wanted are the
+ 	 low-order bits.  However, if EXP's type is a record and this is
+ 	 big-endian machine, we want the upper BITSIZE bits.  */
+       if (BYTES_BIG_ENDIAN && GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT
+ 	  && bitsize < GET_MODE_BITSIZE (GET_MODE (temp))
+ 	  && TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)
+ 	temp = expand_shift (RSHIFT_EXPR, GET_MODE (temp), temp,
+ 			     size_int (GET_MODE_BITSIZE (GET_MODE (temp))
+ 				       - bitsize),
+ 			     temp, 1);
+ 
        /* Unless MODE is VOIDmode or BLKmode, convert TEMP to
  	 MODE.  */
*************** expand_expr (exp, target, tmode, modifie
*** 5525,5528 ****
--- 5537,5552 ----
  				     alignment,
  				     int_size_in_bytes (TREE_TYPE (tem)));
+ 
+ 	    /* If the result is a record type and BITSIZE is narrower than
+ 	       the mode of OP0, an integral mode, and this is a big endian
+ 	       machine, we must put the field into the high-order bits.  */
+ 	    if (TREE_CODE (type) == RECORD_TYPE && BYTES_BIG_ENDIAN
+ 		&& GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT
+ 		&& bitsize < GET_MODE_BITSIZE (GET_MODE (op0)))
+ 	      op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,
+ 				  size_int (GET_MODE_BITSIZE (GET_MODE (op0))
+ 					    - bitsize),
+ 				  op0, 1);
+ 
  	    if (mode == BLKmode)
  	      {
*** loop.c.old	Tue Oct  3 12:17:16 1995
--- loop.c	Tue Sep 24 14:09:28 1996
*************** scan_loop (loop_start, end, nregs)
*** 669,673 ****
  	    {
  	      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);
! 	      if (temp && CONSTANT_P (XEXP (temp, 0)))
  		src = XEXP (temp, 0), move_insn = 1;
  	      if (temp && find_reg_note (p, REG_RETVAL, NULL_RTX))
--- 669,674 ----
  	    {
  	      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);
! 	      if (temp && CONSTANT_P (XEXP (temp, 0))
! 		  && LEGITIMATE_CONSTANT_P (XEXP (temp, 0)))
  		src = XEXP (temp, 0), move_insn = 1;
  	      if (temp && find_reg_note (p, REG_RETVAL, NULL_RTX))
*** config/mips/mips.h.old	Fri Aug 30 08:03:37 1996
--- config/mips/mips.h	Tue Sep 24 14:00:05 1996
***************
*** 2388,2392 ****
    ((GET_CODE (X) != CONST_DOUBLE					\
      || mips_const_double_ok (X, GET_MODE (X)))				\
!    && ! (GET_CODE (X) == CONST && ABI_64BIT))
  
  /* A C compound statement that attempts to replace X with a valid
--- 2388,2393 ----
    ((GET_CODE (X) != CONST_DOUBLE					\
      || mips_const_double_ok (X, GET_MODE (X)))				\
!    && ! (GET_CODE (X) == CONST						\
! 	 && (ABI_64BIT || GET_CODE (XEXP (X, 0)) == MINUS)))
  
  /* A C compound statement that attempts to replace X with a valid
*** stmt.c.old	Tue Sep 10 18:23:04 1996
--- stmt.c	Sun Sep 29 11:06:46 1996
*************** fixup_gotos (thisblock, stack_level, cle
*** 1245,1250 ****
  	      poplevel (1, 0, 0);
  	      end_sequence ();
! 	      f->before_jump
! 		= emit_insns_after (cleanup_insns, f->before_jump);
  
  	      f->cleanup_list_list = TREE_CHAIN (lists);
--- 1245,1251 ----
  	      poplevel (1, 0, 0);
  	      end_sequence ();
! 	      if (cleanup_insns != 0)
! 		f->before_jump
! 		  = emit_insns_after (cleanup_insns, f->before_jump);
  
  	      f->cleanup_list_list = TREE_CHAIN (lists);
*** reload1.c.old	Sat Jun 29 05:34:29 1996
--- reload1.c	Sun Sep 29 14:19:12 1996
*************** gen_reload (out, in, opnum, type)
*** 6810,6815 ****
--- 6802,6809 ----
    if (GET_CODE (in) == PLUS
        && (GET_CODE (XEXP (in, 0)) == REG
+ 	  || GET_CODE (XEXP (in, 0)) == SUBREG
  	  || GET_CODE (XEXP (in, 0)) == MEM)
        && (GET_CODE (XEXP (in, 1)) == REG
+ 	  || GET_CODE (XEXP (in, 1)) == SUBREG
  	  || CONSTANT_P (XEXP (in, 1))
  	  || GET_CODE (XEXP (in, 1)) == MEM))
*************** gen_reload (out, in, opnum, type)
*** 6872,6876 ****
  	 we emit below.  */
  
!       if (CONSTANT_P (op1) || GET_CODE (op1) == MEM
  	  || (GET_CODE (op1) == REG
  	      && REGNO (op1) >= FIRST_PSEUDO_REGISTER))
--- 6866,6870 ----
  	 we emit below.  */
  
!       if (CONSTANT_P (op1) || GET_CODE (op1) == MEM || GET_CODE (op1) == SUBREG
  	  || (GET_CODE (op1) == REG
  	      && REGNO (op1) >= FIRST_PSEUDO_REGISTER))
*************** gen_reload (out, in, opnum, type)
*** 6877,6881 ****
  	tem = op0, op0 = op1, op1 = tem;
  
!       emit_insn (gen_move_insn (out, op0));
  
        /* If OP0 and OP1 are the same, we can use OUT for OP1.
--- 6871,6875 ----
  	tem = op0, op0 = op1, op1 = tem;
  
!       gen_reload (out, op0, opnum, type);
  
        /* If OP0 and OP1 are the same, we can use OUT for OP1.
*************** gen_reload (out, in, opnum, type)
*** 6905,6909 ****
        delete_insns_since (last);
  
!       emit_insn (gen_move_insn (out, op1));
        emit_insn (gen_add2_insn (out, op0));
      }
--- 6899,6903 ----
        delete_insns_since (last);
  
!       gen_reload (out, op1, opnum, type);
        emit_insn (gen_add2_insn (out, op0));
      }
*************** gen_reload (out, in, opnum, type)
*** 6926,6931 ****
  	in = gen_rtx (REG, GET_MODE (loc), REGNO (in));
  
!       emit_insn (gen_move_insn (loc, in));
!       emit_insn (gen_move_insn (out, loc));
      }
  #endif
--- 6920,6925 ----
  	in = gen_rtx (REG, GET_MODE (loc), REGNO (in));
  
!       gen_reload (loc, in, opnum, type);
!       gen_reload (out, loc, opnum, type);
      }
  #endif
*** tree.c.old	Sun Sep 29 16:41:57 1996
--- tree.c	Sun Sep 29 17:34:48 1996
*************** contains_placeholder_p (exp)
*** 2264,2267 ****
--- 2265,2270 ----
    if (code == WITH_RECORD_EXPR)
      return 0;
+   else if (code == PLACEHOLDER_EXPR)
+     return 1;
  
    switch (TREE_CODE_CLASS (code))
*** c-lex.c.old	Tue May  7 07:55:06 1996
--- c-lex.c	Sat Sep 14 19:26:19 1996
*************** yylex ()
*** 1466,1470 ****
  	    /* Create a node with determined type and value.  */
  	    if (imag)
! 	      yylval.ttype = build_complex (convert (type, integer_zero_node),
  					    build_real (type, value));
  	    else
--- 1466,1471 ----
  	    /* Create a node with determined type and value.  */
  	    if (imag)
! 	      yylval.ttype = build_complex (NULL_TREE,
! 					    convert (type, integer_zero_node),
  					    build_real (type, value));
  	    else
*************** yylex ()
*** 1635,1640 ****
  		    <= TYPE_PRECISION (integer_type_node))
  		  yylval.ttype
! 		    = build_complex (integer_zero_node,
! 				     convert (integer_type_node, yylval.ttype));
  		else
  		  error ("complex integer constant is too wide for `complex int'");
--- 1636,1642 ----
  		    <= TYPE_PRECISION (integer_type_node))
  		  yylval.ttype
! 		    = build_complex (NULL_TREE, integer_zero_node,
! 				     convert (integer_type_node,
! 					      yylval.ttype));
  		else
  		  error ("complex integer constant is too wide for `complex int'");
*** emit-rtl.c.old	Tue Sep 10 19:20:58 1996
--- emit-rtl.c	Sun Sep 15 20:29:27 1996
***************
*** 544,549 ****
--- 544,566 ----
    return label_num;
  }
  
+ /* Identify REG (which may be a CONCAT) as a user register.  */
+ 
+ void
+ mark_user_reg (reg)
+      rtx reg;
+ {
+   if (GET_CODE (reg) == CONCAT)
+     {
+       REG_USERVAR_P (XEXP (reg, 0)) = 1;
+       REG_USERVAR_P (XEXP (reg, 1)) = 1;
+     }
+   else if (GET_CODE (reg) == REG)
+     REG_USERVAR_P (reg) = 1;
+   else
+     abort ();
+ }
+ 
  /* Return first label number used in this function (if any were used).  */
  
  int
*** expr.c.old	Sun Sep 29 16:41:18 1996
--- expr.c	Sun Sep 29 17:32:46 1996
*************** expand_expr (exp, target, tmode, modifie
*** 5519,5523 ****
  	    || (modifier != EXPAND_CONST_ADDRESS
  		&& modifier != EXPAND_INITIALIZER
! 		&& ((mode1 != BLKmode && ! direct_load[(int) mode1])
  		    /* If the field isn't aligned enough to fetch as a memref,
  		       fetch it as a bit field.  */
--- 5519,5525 ----
  	    || (modifier != EXPAND_CONST_ADDRESS
  		&& modifier != EXPAND_INITIALIZER
! 		&& ((mode1 != BLKmode && ! direct_load[(int) mode1]
! 		     && GET_MODE_CLASS (mode) != MODE_COMPLEX_INT
! 		     && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)
  		    /* If the field isn't aligned enough to fetch as a memref,
  		       fetch it as a bit field.  */
*** fold-const.c.old	Thu Jun  6 18:18:16 1996
--- fold-const.c	Sat Sep 14 08:39:31 1996
*************** const_binop (code, arg1, arg2, notrunc)
*** 1229,1232 ****
--- 1229,1233 ----
    if (TREE_CODE (arg1) == COMPLEX_CST)
      {
+       register tree type = TREE_TYPE (arg1);
        register tree r1 = TREE_REALPART (arg1);
        register tree i1 = TREE_IMAGPART (arg1);
*************** const_binop (code, arg1, arg2, notrunc)
*** 1238,1242 ****
  	{
  	case PLUS_EXPR:
! 	  t = build_complex (const_binop (PLUS_EXPR, r1, r2, notrunc),
  			     const_binop (PLUS_EXPR, i1, i2, notrunc));
  	  break;
--- 1239,1244 ----
  	{
  	case PLUS_EXPR:
! 	  t = build_complex (type,
! 			     const_binop (PLUS_EXPR, r1, r2, notrunc),
  			     const_binop (PLUS_EXPR, i1, i2, notrunc));
  	  break;
*************** const_binop (code, arg1, arg2, notrunc)
*** 1243,1247 ****
  
  	case MINUS_EXPR:
! 	  t = build_complex (const_binop (MINUS_EXPR, r1, r2, notrunc),
  			     const_binop (MINUS_EXPR, i1, i2, notrunc));
  	  break;
--- 1245,1250 ----
  
  	case MINUS_EXPR:
! 	  t = build_complex (type,
! 			     const_binop (MINUS_EXPR, r1, r2, notrunc),
  			     const_binop (MINUS_EXPR, i1, i2, notrunc));
  	  break;
*************** const_binop (code, arg1, arg2, notrunc)
*** 1248,1252 ****
  
  	case MULT_EXPR:
! 	  t = build_complex (const_binop (MINUS_EXPR,
  					  const_binop (MULT_EXPR,
  						       r1, r2, notrunc),
--- 1251,1256 ----
  
  	case MULT_EXPR:
! 	  t = build_complex (type,
! 			     const_binop (MINUS_EXPR,
  					  const_binop (MULT_EXPR,
  						       r1, r2, notrunc),
*************** const_binop (code, arg1, arg2, notrunc)
*** 1270,1292 ****
  			     notrunc);
  
! 	    t = build_complex
! 	      (const_binop (INTEGRAL_TYPE_P (TREE_TYPE (r1))
! 			    ? TRUNC_DIV_EXPR : RDIV_EXPR,
! 			    const_binop (PLUS_EXPR,
! 					 const_binop (MULT_EXPR, r1, r2,
! 						      notrunc),
! 					 const_binop (MULT_EXPR, i1, i2,
! 						      notrunc),
! 					 notrunc),
! 			    magsquared, notrunc),
! 	       const_binop (INTEGRAL_TYPE_P (TREE_TYPE (r1))
! 			    ? TRUNC_DIV_EXPR : RDIV_EXPR,
! 			    const_binop (MINUS_EXPR,
! 					 const_binop (MULT_EXPR, i1, r2,
! 						      notrunc),
! 					 const_binop (MULT_EXPR, r1, i2,
! 						      notrunc),
! 					 notrunc),
! 			    magsquared, notrunc));
  	  }
  	  break;
--- 1274,1298 ----
  			     notrunc);
  
! 	    t = build_complex (type,
! 			       const_binop
! 			       (INTEGRAL_TYPE_P (TREE_TYPE (r1))
! 				? TRUNC_DIV_EXPR : RDIV_EXPR,
! 				const_binop (PLUS_EXPR,
! 					     const_binop (MULT_EXPR, r1, r2,
! 							  notrunc),
! 					     const_binop (MULT_EXPR, i1, i2,
! 							  notrunc),
! 					     notrunc),
! 				magsquared, notrunc),
! 			       const_binop
! 			       (INTEGRAL_TYPE_P (TREE_TYPE (r1))
! 				? TRUNC_DIV_EXPR : RDIV_EXPR,
! 				const_binop (MINUS_EXPR,
! 					     const_binop (MULT_EXPR, i1, r2,
! 							  notrunc),
! 					     const_binop (MULT_EXPR, r1, i2,
! 							  notrunc),
! 					     notrunc),
! 				magsquared, notrunc));
  	  }
  	  break;
*************** const_binop (code, arg1, arg2, notrunc)
*** 1295,1299 ****
  	  abort ();
  	}
-       TREE_TYPE (t) = TREE_TYPE (arg1);
        return t;
      }
--- 1301,1304 ----
*************** fold (expr) 
*** 3622,3626 ****
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (TREE_OPERAND (arg0, 0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
--- 3627,3631 ----
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (type, TREE_OPERAND (arg0, 0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
*************** fold (expr) 
*** 5124,5128 ****
      case COMPLEX_EXPR:
        if (wins)
! 	return build_complex (arg0, arg1);
        return t;
  
--- 5129,5133 ----
      case COMPLEX_EXPR:
        if (wins)
! 	return build_complex (type, arg0, arg1);
        return t;
  
*** function.c.old	Sun Sep 29 16:38:22 1996
--- function.c	Sun Sep 29 17:26:40 1996
*************** assign_parms (fndecl, second_time)
*** 3752,3756 ****
  
  	  parmreg = gen_reg_rtx (promoted_nominal_mode);
! 	  REG_USERVAR_P (parmreg) = 1;
  
  	  /* If this was an item that we received a pointer to, set DECL_RTL
--- 3752,3756 ----
  
  	  parmreg = gen_reg_rtx (promoted_nominal_mode);
! 	  mark_user_reg (parmreg);
  
  	  /* If this was an item that we received a pointer to, set DECL_RTL
*************** assign_parms (fndecl, second_time)
*** 3820,3824 ****
  		 Pmode above.  We must use the actual mode of the parm.  */
  	      parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));
! 	      REG_USERVAR_P (parmreg) = 1;
  	      emit_move_insn (parmreg, DECL_RTL (parm));
  	      DECL_RTL (parm) = parmreg;
--- 3820,3824 ----
  		 Pmode above.  We must use the actual mode of the parm.  */
  	      parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));
! 	      mark_user_reg (parmreg);
  	      emit_move_insn (parmreg, DECL_RTL (parm));
  	      DECL_RTL (parm) = parmreg;
*** recog.c.old	Sun Sep 29 16:51:06 1996
--- recog.c	Sun Sep 29 17:51:22 1996
*************** register_operand (op, mode)
*** 872,876 ****
  				REGNO (SUBREG_REG (op)))
  	  && (GET_MODE_SIZE (mode)
! 	      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (op)))))
  	return 0;
  #endif
--- 872,878 ----
  				REGNO (SUBREG_REG (op)))
  	  && (GET_MODE_SIZE (mode)
! 	      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))
! 	  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) != MODE_COMPLEX_INT
! 	  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) != MODE_COMPLEX_FLOAT)
  	return 0;
  #endif
*** stmt.c.old	Sun Sep 29 17:13:57 1996
--- stmt.c	Sun Sep 29 17:15:24 1996
*************** expand_decl (decl)
*** 3449,3473 ****
  	= promote_mode (type, DECL_MODE (decl), &unsignedp, 0);
  
!       if (TREE_CODE (type) == COMPLEX_TYPE)
! 	{
! 	  rtx realpart, imagpart;
! 	  enum machine_mode partmode = TYPE_MODE (TREE_TYPE (type));
  
! 	  /* For a complex type variable, make a CONCAT of two pseudos
! 	     so that the real and imaginary parts
! 	     can be allocated separately.  */
! 	  realpart = gen_reg_rtx (partmode);
! 	  REG_USERVAR_P (realpart) = 1;
! 	  imagpart = gen_reg_rtx (partmode);
! 	  REG_USERVAR_P (imagpart) = 1;
! 	  DECL_RTL (decl) = gen_rtx (CONCAT, reg_mode, realpart, imagpart);
! 	}
!       else
! 	{
! 	  DECL_RTL (decl) = gen_reg_rtx (reg_mode);
! 	  if (TREE_CODE (type) == POINTER_TYPE)
! 	    mark_reg_pointer (DECL_RTL (decl));
! 	  REG_USERVAR_P (DECL_RTL (decl)) = 1;
! 	}
      }
    else if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)
--- 3449,3457 ----
  	= promote_mode (type, DECL_MODE (decl), &unsignedp, 0);
  
!       DECL_RTL (decl) = gen_reg_rtx (reg_mode);
!       mark_user_reg (DECL_RTL (decl));
  
!       if (TREE_CODE (type) == POINTER_TYPE)
! 	mark_reg_pointer (DECL_RTL (decl));
      }
    else if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)
*** tree.c.old	Sun Sep 29 16:41:57 1996
--- tree.c	Sun Sep 29 17:34:48 1996
*************** build_string (len, str)
*** 1445,1453 ****
  /* Return a newly constructed COMPLEX_CST node whose value is
     specified by the real and imaginary parts REAL and IMAG.
!    Both REAL and IMAG should be constant nodes.
!    The TREE_TYPE is not initialized.  */
  
  tree
! build_complex (real, imag)
       tree real, imag;
  {
--- 1445,1454 ----
  /* Return a newly constructed COMPLEX_CST node whose value is
     specified by the real and imaginary parts REAL and IMAG.
!    Both REAL and IMAG should be constant nodes.  TYPE, if specified,
!    will be the type of the COMPLEX_CST; otherwise a new type will be made.  */
  
  tree
! build_complex (type, real, imag)
!      tree type;
       tree real, imag;
  {
*************** build_complex (real, imag)
*** 1456,1460 ****
    TREE_REALPART (t) = real;
    TREE_IMAGPART (t) = imag;
!   TREE_TYPE (t) = build_complex_type (TREE_TYPE (real));
    TREE_OVERFLOW (t) = TREE_OVERFLOW (real) | TREE_OVERFLOW (imag);
    TREE_CONSTANT_OVERFLOW (t)
--- 1457,1461 ----
    TREE_REALPART (t) = real;
    TREE_IMAGPART (t) = imag;
!   TREE_TYPE (t) = type ? type : build_complex_type (TREE_TYPE (real));
    TREE_OVERFLOW (t) = TREE_OVERFLOW (real) | TREE_OVERFLOW (imag);
    TREE_CONSTANT_OVERFLOW (t)
*************** build_type_variant (type, constp, volati
*** 3163,3167 ****
       preserve the TYPE_NAME, since there is code that depends on this.  */
  
!   for (t = TYPE_MAIN_VARIANT(type); t; t = TYPE_NEXT_VARIANT (t))
      if (constp == TYPE_READONLY (t) && volatilep == TYPE_VOLATILE (t)
  	&& TYPE_NAME (t) == TYPE_NAME (type))
--- 3166,3170 ----
       preserve the TYPE_NAME, since there is code that depends on this.  */
  
!   for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))
      if (constp == TYPE_READONLY (t) && volatilep == TYPE_VOLATILE (t)
  	&& TYPE_NAME (t) == TYPE_NAME (type))
*** tree.h.old	Wed Sep 18 15:55:30 1996
--- tree.h	Wed Sep 18 16:04:41 1996
***************
*** 1252,1256 ****
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
! extern tree build_complex		PROTO((tree, tree));
  extern tree build_string		PROTO((int, char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
--- 1252,1256 ----
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
! extern tree build_complex		PROTO((tree, tree, tree));
  extern tree build_string		PROTO((int, char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
*** varasm.c.old	Wed Sep 18 15:55:10 1996
--- varasm.c	Wed Sep 18 16:03:09 1996
*************** copy_constant (exp)
*** 2797,2801 ****
  
      case COMPLEX_CST:
!       return build_complex (copy_constant (TREE_REALPART (exp)),
  			    copy_constant (TREE_IMAGPART (exp)));
  
--- 2797,2802 ----
  
      case COMPLEX_CST:
!       return build_complex (TREE_TYPE (exp),
! 			    copy_constant (TREE_REALPART (exp)),
  			    copy_constant (TREE_IMAGPART (exp)));
  
*** reload1.c.old	Tue Oct  1 12:45:05 1996
--- reload1.c	Tue Oct  1 13:12:19 1996
*************** reload (first, global, dumpfile)
*** 572,576 ****
  		  if (GET_CODE (x) == MEM)
  		    reg_equiv_memory_loc[i] = x;
! 		  else if (CONSTANT_P (x))
  		    {
  		      if (LEGITIMATE_CONSTANT_P (x))
--- 572,578 ----
  		  if (GET_CODE (x) == MEM)
  		    reg_equiv_memory_loc[i] = x;
! 		  else if (CONSTANT_P (x)
! 			   && ! (GET_CODE (x) == CONST
! 				 && GET_CODE (XEXP (x, 0)) == MINUS))
  		    {
  		      if (LEGITIMATE_CONSTANT_P (x))
*** stor-layout.c.old	Tue Oct  1 12:49:01 1996
--- stor-layout.c	Tue Oct  1 19:09:54 1996
*************** layout_decl (decl, known_align)
*** 284,288 ****
        && DECL_SIZE (decl) != 0
        && (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST
! 	  || (TREE_INT_CST_LOW (DECL_SIZE (decl)) % BITS_PER_UNIT) == 0))
      DECL_BIT_FIELD (decl) = 0;
  
--- 284,289 ----
        && DECL_SIZE (decl) != 0
        && (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST
! 	  || (TREE_INT_CST_LOW (DECL_SIZE (decl)) % BITS_PER_UNIT) == 0)
!       && DECL_ALIGN (decl) >= TYPE_ALIGN (type))
      DECL_BIT_FIELD (decl) = 0;
  
*** expr.c.old	Sun Oct 13 07:59:22 1996
--- expr.c	Mon Oct 21 19:00:56 1996
*************** store_expr (exp, target, want_value)
*** 3126,3131 ****
  	 which will often result in some optimizations.  Do the conversion
  	 in two steps: first change the signedness, if needed, then
! 	 the extend.  */
!       if (! want_value)
  	{
  	  if (TREE_UNSIGNED (TREE_TYPE (exp))
--- 3126,3134 ----
  	 which will often result in some optimizations.  Do the conversion
  	 in two steps: first change the signedness, if needed, then
! 	 the extend.  But don't do this if the type of EXP is a subtype
! 	 of something else since then the conversion might involve
! 	 more than just converting modes.  */
!       if (! want_value && INTEGRAL_TYPE_P (TREE_TYPE (exp))
! 	  && TREE_TYPE (TREE_TYPE (exp)) == 0)
  	{
  	  if (TREE_UNSIGNED (TREE_TYPE (exp))
*** stor-layout.c.old	Fri Oct 25 15:33:36 1996
--- stor-layout.c	Thu Nov  7 06:44:55 1996
*************** layout_record (rec)
*** 508,511 ****
--- 508,512 ----
  	  /* Do nothing.  */;
  	else if (TREE_CODE (dsize) == INTEGER_CST
+ 		 && ! TREE_CONSTANT_OVERFLOW (dsize)
  		 && TREE_INT_CST_HIGH (dsize) == 0
  		 && TREE_INT_CST_LOW (dsize) + const_size >= const_size)
*** fold-const.c.old	Fri Nov  1 08:36:53 1996
--- fold-const.c	Thu Nov  7 07:02:26 1996
*************** const_binop (code, arg1, arg2, notrunc)
*** 1172,1175 ****
--- 1172,1177 ----
  	  if (int2h == 0 && int2l > 0
  	      && TREE_TYPE (arg1) == sizetype
+ 	      && ! TREE_CONSTANT_OVERFLOW (arg1)
+ 	      && ! TREE_CONSTANT_OVERFLOW (arg2)
  	      && int1h == 0 && int1l >= 0)
  	    {
*************** size_binop (code, arg0, arg1)
*** 1446,1461 ****
      {
        /* And some specific cases even faster than that.  */
!       if (code == PLUS_EXPR
! 	  && TREE_INT_CST_LOW (arg0) == 0
! 	  && TREE_INT_CST_HIGH (arg0) == 0)
  	return arg1;
!       if (code == MINUS_EXPR
! 	  && TREE_INT_CST_LOW (arg1) == 0
! 	  && TREE_INT_CST_HIGH (arg1) == 0)
  	return arg0;
!       if (code == MULT_EXPR
! 	  && TREE_INT_CST_LOW (arg0) == 1
! 	  && TREE_INT_CST_HIGH (arg0) == 0)
  	return arg1;
        /* Handle general case of two integer constants.  */
        return const_binop (code, arg0, arg1, 0);
--- 1448,1459 ----
      {
        /* And some specific cases even faster than that.  */
!       if (code == PLUS_EXPR && integer_zerop (arg0))
  	return arg1;
!       else if ((code == MINUS_EXPR || code == PLUS_EXPR)
! 	       && integer_zerop (arg1))
  	return arg0;
!       else if (code == MULT_EXPR && integer_onep (arg0))
  	return arg1;
+ 
        /* Handle general case of two integer constants.  */
        return const_binop (code, arg0, arg1, 0);
*** tree.c.old	Thu Oct 31 18:45:40 1996
--- tree.c	Thu Nov  7 07:04:20 1996
*************** integer_zerop (expr)
*** 1503,1506 ****
--- 1503,1507 ----
  
    return ((TREE_CODE (expr) == INTEGER_CST
+ 	   && ! TREE_CONSTANT_OVERFLOW (expr)
  	   && TREE_INT_CST_LOW (expr) == 0
  	   && TREE_INT_CST_HIGH (expr) == 0)
*************** integer_onep (expr)
*** 1520,1523 ****
--- 1521,1525 ----
  
    return ((TREE_CODE (expr) == INTEGER_CST
+ 	   && ! TREE_CONSTANT_OVERFLOW (expr)
  	   && TREE_INT_CST_LOW (expr) == 1
  	   && TREE_INT_CST_HIGH (expr) == 0)
*************** integer_all_onesp (expr)
*** 1544,1548 ****
      return 1;
  
!   else if (TREE_CODE (expr) != INTEGER_CST)
      return 0;
  
--- 1546,1551 ----
      return 1;
  
!   else if (TREE_CODE (expr) != INTEGER_CST
! 	   || TREE_CONSTANT_OVERFLOW (expr))
      return 0;
  
*************** integer_pow2p (expr)
*** 1593,1597 ****
      return 1;
  
!   if (TREE_CODE (expr) != INTEGER_CST)
      return 0;
  
--- 1596,1600 ----
      return 1;
  
!   if (TREE_CODE (expr) != INTEGER_CST || TREE_CONSTANT_OVERFLOW (expr))
      return 0;
  
*************** real_zerop (expr)
*** 1615,1618 ****
--- 1618,1622 ----
  
    return ((TREE_CODE (expr) == REAL_CST
+ 	   && ! TREE_CONSTANT_OVERFLOW (expr)
  	   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst0))
  	  || (TREE_CODE (expr) == COMPLEX_CST
*************** real_onep (expr)
*** 1630,1633 ****
--- 1634,1638 ----
  
    return ((TREE_CODE (expr) == REAL_CST
+ 	   && ! TREE_CONSTANT_OVERFLOW (expr)
  	   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst1))
  	  || (TREE_CODE (expr) == COMPLEX_CST
*************** real_twop (expr)
*** 1645,1648 ****
--- 1650,1654 ----
  
    return ((TREE_CODE (expr) == REAL_CST
+ 	   && ! TREE_CONSTANT_OVERFLOW (expr)
  	   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst2))
  	  || (TREE_CODE (expr) == COMPLEX_CST
*** expr.c.old	Tue Oct 29 06:36:42 1996
--- expr.c	Fri Nov  8 17:29:31 1996
*************** expand_assignment (to, from, want_value,
*** 2808,2819 ****
  				   gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),
  					    force_reg (ptr_mode, offset_rtx)));
- 	  /* If we have a variable offset, the known alignment
- 	     is only that of the innermost structure containing the field.
- 	     (Actually, we could sometimes do better by using the
- 	     align of an element of the innermost array, but no need.)  */
- 	  if (TREE_CODE (to) == COMPONENT_REF
- 	      || TREE_CODE (to) == BIT_FIELD_REF)
- 	    alignment
- 	      = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (to, 0))) / BITS_PER_UNIT;
  	}
        if (volatilep)
--- 2808,2811 ----
*************** expand_expr (exp, target, tmode, modifie
*** 5506,5517 ****
  				  gen_rtx (PLUS, ptr_mode, XEXP (op0, 0),
  					   force_reg (ptr_mode, offset_rtx)));
- 	  /* If we have a variable offset, the known alignment
- 	     is only that of the innermost structure containing the field.
- 	     (Actually, we could sometimes do better by using the
- 	     size of an element of the innermost array, but no need.)  */
- 	  if (TREE_CODE (exp) == COMPONENT_REF
- 	      || TREE_CODE (exp) == BIT_FIELD_REF)
- 	    alignment = (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))
- 			 / BITS_PER_UNIT);
  	  }
  
--- 5498,5501 ----
*** emit-rtl.c.old	Tue Oct 29 06:39:14 1996
--- emit-rtl.c	Fri Nov  8 10:00:21 1996
*************** change_address (memref, mode, addr)
*** 1377,1380 ****
--- 1377,1383 ----
      addr = memory_address (mode, addr);
  	
+   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))
+     return memref;
+ 
    new = gen_rtx (MEM, mode, addr);
    MEM_VOLATILE_P (new) = MEM_VOLATILE_P (memref);
*** tree.h.old	Wed Sep 18 16:04:41 1996
--- tree.h	Fri Nov 15 15:04:29 1996
***************
*** 1541,1545 ****
     and find the ultimate containing object, which is returned.  */
  
! extern tree get_inner_reference		PROTO((tree, int *, int *, tree *, enum machine_mode *, int *, int *));
  
  /* Return the FUNCTION_DECL which provides this _DECL with its context,
--- 1541,1547 ----
     and find the ultimate containing object, which is returned.  */
  
! extern tree get_inner_reference		PROTO((tree, int *, int *, tree *,
! 					       enum machine_mode *, int *,
! 					       int *, int *));
  
  /* Return the FUNCTION_DECL which provides this _DECL with its context,
*** fold-const.c.old	Thu Nov 14 12:48:39 1996
--- fold-const.c	Fri Nov 15 15:06:26 1996
*************** optimize_bit_field_compare (code, compar
*** 2313,2316 ****
--- 2313,2317 ----
    int lunsignedp, runsignedp;
    int lvolatilep = 0, rvolatilep = 0;
+   int alignment;
    tree linner, rinner;
    tree mask;
*************** optimize_bit_field_compare (code, compar
*** 2321,2325 ****
       extraction at all and so can do nothing.  */
    linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,
! 				&lunsignedp, &lvolatilep);
    if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0
        || offset != 0)
--- 2322,2326 ----
       extraction at all and so can do nothing.  */
    linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,
! 				&lunsignedp, &lvolatilep, &alignment);
    if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0
        || offset != 0)
*************** optimize_bit_field_compare (code, compar
*** 2330,2335 ****
       /* If this is not a constant, we can only do something if bit positions,
  	sizes, and signedness are the same.   */
!      rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset,
! 				   &rmode, &runsignedp, &rvolatilep);
  
       if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize
--- 2331,2336 ----
       /* If this is not a constant, we can only do something if bit positions,
  	sizes, and signedness are the same.   */
!      rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,
! 				   &runsignedp, &rvolatilep, &alignment);
  
       if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize
*************** decode_field_reference (exp, pbitsize, p
*** 2504,2507 ****
--- 2505,2509 ----
    tree unsigned_type;
    int precision;
+   int alignment;
  
    /* All the optimizations using this function assume integer fields.  
*************** decode_field_reference (exp, pbitsize, p
*** 2524,2528 ****
  
    inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,
! 			       punsignedp, pvolatilep);
    if ((inner == exp && and_mask == 0)
        || *pbitsize < 0 || offset != 0)
--- 2526,2530 ----
  
    inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,
! 			       punsignedp, pvolatilep, &alignment);
    if ((inner == exp && and_mask == 0)
        || *pbitsize < 0 || offset != 0)
*** expr.c.old	Fri Nov  8 20:09:32 1996
--- expr.c	Fri Nov 15 15:21:06 1996
*************** expand_assignment (to, from, want_value,
*** 2788,2793 ****
  
        push_temp_slots ();
!       tem = get_inner_reference (to, &bitsize, &bitpos, &offset,
! 				      &mode1, &unsignedp, &volatilep);
  
        /* If we are going to use store_bit_field and extract_bit_field,
--- 2788,2793 ----
  
        push_temp_slots ();
!       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,
! 				 &unsignedp, &volatilep, &alignment);
  
        /* If we are going to use store_bit_field and extract_bit_field,
*************** expand_assignment (to, from, want_value,
*** 2797,2801 ****
  	tem = stabilize_reference (tem);
  
-       alignment = TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT;
        to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);
        if (offset != 0)
--- 2797,2800 ----
*************** get_inner_unaligned_p (exp)
*** 4185,4188 ****
--- 4184,4190 ----
     This offset is in addition to the bit position.
     If the position is not variable, we store 0 in *POFFSET.
+    We set *PALIGNMENT to the alignment in bytes of the address that will be
+    computed.  This is the alignment of the thing we return if *POFFSET
+    is zero, but can be more less strictly aligned if *POFFSET is nonzero.
  
     If any of the extraction expressions is volatile,
*************** get_inner_unaligned_p (exp)
*** 4195,4203 ****
     If the field describes a variable-sized object, *PMODE is set to
     VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in
!    this case, but the address of the object can be found.  */
  
  tree
  get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,
! 		     punsignedp, pvolatilep)
       tree exp;
       int *pbitsize;
--- 4197,4205 ----
     If the field describes a variable-sized object, *PMODE is set to
     VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in
!    this case, but the address of the object can be found.   */
  
  tree
  get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,
! 		     punsignedp, pvolatilep, palignment)
       tree exp;
       int *pbitsize;
*************** get_inner_reference (exp, pbitsize, pbit
*** 4207,4210 ****
--- 4209,4213 ----
       int *punsignedp;
       int *pvolatilep;
+      int *palignment;
  {
    tree orig_exp = exp;
*************** get_inner_reference (exp, pbitsize, pbit
*** 4212,4215 ****
--- 4215,4219 ----
    enum machine_mode mode = VOIDmode;
    tree offset = integer_zero_node;
+   int alignment = BIGGEST_ALIGNMENT;
  
    if (TREE_CODE (exp) == COMPONENT_REF)
*************** get_inner_reference (exp, pbitsize, pbit
*** 4320,4326 ****
--- 4324,4341 ----
        if (TREE_THIS_VOLATILE (exp))
  	*pvolatilep = 1;
+ 
+       /* If the offset is non-constant already, then we can't assume any
+ 	 alignment more than the alignment here.  */
+       if (! integer_zerop (offset))
+ 	alignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));
+ 
        exp = TREE_OPERAND (exp, 0);
      }
  
+   if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')
+     alignment = MIN (alignment, DECL_ALIGN (exp));
+   else if (TREE_TYPE (exp) != 0)
+     alignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));
+ 
    if (integer_zerop (offset))
      offset = 0;
*************** get_inner_reference (exp, pbitsize, pbit
*** 4331,4334 ****
--- 4346,4350 ----
    *pmode = mode;
    *poffset = offset;
+   *palignment = alignment / BITS_PER_UNIT;
    return exp;
  }
*************** expand_expr (exp, target, tmode, modifie
*** 5458,5464 ****
  	tree offset;
  	int volatilep = 0;
- 	tree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,
- 					&mode1, &unsignedp, &volatilep);
  	int alignment;
  
  	/* If we got back the original object, something is wrong.  Perhaps
--- 5474,5481 ----
  	tree offset;
  	int volatilep = 0;
  	int alignment;
+ 	tree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,
+ 					&mode1, &unsignedp, &volatilep,
+ 					&alignment);
  
  	/* If we got back the original object, something is wrong.  Perhaps
*************** expand_expr (exp, target, tmode, modifie
*** 5491,5495 ****
  	  }
  
- 	alignment = TYPE_ALIGN (TREE_TYPE (tem)) / BITS_PER_UNIT;
  	if (offset != 0)
  	  {
--- 5508,5511 ----
*************** do_jump (exp, if_false_label, if_true_la
*** 10151,10154 ****
--- 10167,10171 ----
  	tree offset;
  	int volatilep = 0;
+ 	int alignment;
  
  	/* Get description of this reference.  We don't actually care
*************** do_jump (exp, if_false_label, if_true_la
*** 10155,10159 ****
  	   about the underlying object here.  */
  	get_inner_reference (exp, &bitsize, &bitpos, &offset,
! 			     &mode, &unsignedp, &volatilep);
  
  	type = type_for_size (bitsize, unsignedp);
--- 10172,10177 ----
  	   about the underlying object here.  */
  	get_inner_reference (exp, &bitsize, &bitpos, &offset,
! 			     &mode, &unsignedp, &volatilep,
! 			     &alignment);
  
  	type = type_for_size (bitsize, unsignedp);
*** gcc.c.old	Tue Nov 12 18:25:28 1996
--- gcc.c	Mon Nov 25 14:56:51 1996
*************** static int is_directory		PROTO((char *, 
*** 254,258 ****
  static void validate_switches	PROTO((char *));
  static void validate_all_switches PROTO((void));
! static void give_switch		PROTO((int, int));
  static int used_arg		PROTO((char *, int));
  static int default_arg		PROTO((char *, int));
--- 254,258 ----
  static void validate_switches	PROTO((char *));
  static void validate_all_switches PROTO((void));
! static void give_switch		PROTO((int, int, int));
  static int used_arg		PROTO((char *, int));
  static int default_arg		PROTO((char *, int));
*************** or with constant text in a single argume
*** 363,366 ****
--- 363,367 ----
  	name starts with `o'.  %{o*} would substitute this text,
  	including the space; thus, two arguments would be generated.
+  %{^S*} likewise, but don't put a blank between a switch and any args.
   %{S*:X} substitutes X if one or more switches whose names start with -S are
  	specified to CC.  Note that the tail part of the -S option
*************** handle_braces (p)
*** 3744,3748 ****
--- 3745,3754 ----
    int negate = 0;
    int suffix = 0;
+   int include_blanks = 1;
  
+   if (*p == '^')
+     /* A '^' after the open-brace means to not give blanks before args.  */
+     include_blanks = 0, ++p;
+ 
    if (*p == '|')
      /* A `|' after the open-brace means,
*************** handle_braces (p)
*** 3809,3813 ****
  	if (!strncmp (switches[i].part1, filter, p - filter)
  	    && check_live_switch (i, p - filter))
! 	  give_switch (i, 0);
      }
    else
--- 3815,3819 ----
  	if (!strncmp (switches[i].part1, filter, p - filter)
  	    && check_live_switch (i, p - filter))
! 	  give_switch (i, 0, include_blanks);
      }
    else
*************** handle_braces (p)
*** 3848,3852 ****
  		    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);
  		    /* Pass any arguments this switch has.  */
! 		    give_switch (i, 1);
  		  }
  
--- 3854,3858 ----
  		    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);
  		    /* Pass any arguments this switch has.  */
! 		    give_switch (i, 1, 1);
  		  }
  
*************** handle_braces (p)
*** 3892,3896 ****
  	  if (*p == '}')
  	    {
! 	      give_switch (i, 0);
  	    }
  	  else
--- 3898,3902 ----
  	  if (*p == '}')
  	    {
! 	      give_switch (i, 0, include_blanks);
  	    }
  	  else
*************** check_live_switch (switchnum, prefix_len
*** 3993,4002 ****
     This cannot fail since it never finishes a command line.
  
!    If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */
  
  static void
! give_switch (switchnum, omit_first_word)
       int switchnum;
       int omit_first_word;
  {
    if (!omit_first_word)
--- 3999,4012 ----
     This cannot fail since it never finishes a command line.
  
!    If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.
! 
!    If INCLUDE_BLANKS is nonzero, then we include blanks before each argument
!    of the switch.  */
  
  static void
! give_switch (switchnum, omit_first_word, include_blanks)
       int switchnum;
       int omit_first_word;
+      int include_blanks;
  {
    if (!omit_first_word)
*************** give_switch (switchnum, omit_first_word)
*** 4005,4009 ****
        do_spec_1 (switches[switchnum].part1, 1, NULL_PTR);
      }
!   do_spec_1 (" ", 0, NULL_PTR);
    if (switches[switchnum].args != 0)
      {
--- 4015,4019 ----
        do_spec_1 (switches[switchnum].part1, 1, NULL_PTR);
      }
! 
    if (switches[switchnum].args != 0)
      {
*************** give_switch (switchnum, omit_first_word)
*** 4011,4018 ****
        for (p = switches[switchnum].args; *p; p++)
  	{
  	  do_spec_1 (*p, 1, NULL_PTR);
- 	  do_spec_1 (" ", 0, NULL_PTR);
  	}
      }
    switches[switchnum].valid = 1;
  }
--- 4021,4031 ----
        for (p = switches[switchnum].args; *p; p++)
  	{
+ 	  if (include_blanks)
+ 	    do_spec_1 (" ", 0, NULL_PTR);
  	  do_spec_1 (*p, 1, NULL_PTR);
  	}
      }
+ 
+   do_spec_1 (" ", 0, NULL_PTR);
    switches[switchnum].valid = 1;
  }
*** alpha.c	Mon May  6 15:47:28 1996
--- config/alpha/alpha.c	Mon May  6 15:47:22 1996
*************** alpha_write_verstamp (file)
*** 1254,1263 ****
  {
  #ifdef MS_STAMP
!   char *p;
! 
!   fprintf (file, "\t.verstamp %d %d ", MS_STAMP, LS_STAMP);
!   for (p = version_string; *p != ' ' && *p != 0; p++)
!     fprintf (file, "%c", *p == '.' ? ' ' : *p);
!   fprintf (file, "\n");
  #endif
  }
--- 1254,1258 ----
  {
  #ifdef MS_STAMP
!   fprintf (file, "\t.verstamp %d %d\n", MS_STAMP, LS_STAMP);
  #endif
  }
*** expr.c.old	Tue Nov 26 16:03:54 1996
--- expr.c	Sat Jan  4 19:06:20 1997
*************** get_inner_reference (exp, pbitsize, pbit
*** 4305,4309 ****
  
  	  index = fold (build (MULT_EXPR, index_type, index,
! 			       TYPE_SIZE (TREE_TYPE (exp))));
  
  	  if (TREE_CODE (index) == INTEGER_CST
--- 4305,4310 ----
  
  	  index = fold (build (MULT_EXPR, index_type, index,
! 			       convert (index_type,
! 					TYPE_SIZE (TREE_TYPE (exp)))));
  
  	  if (TREE_CODE (index) == INTEGER_CST
*************** expand_expr (exp, target, tmode, modifie
*** 5633,5640 ****
  	MEM_IN_STRUCT_P (op0) = 1;
  	MEM_VOLATILE_P (op0) |= volatilep;
! 	if (mode == mode1 || mode1 == BLKmode || mode1 == tmode)
  	  return op0;
! 	if (target == 0)
  	  target = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);
  	convert_move (target, op0, unsignedp);
  	return target;
--- 5672,5682 ----
  	MEM_IN_STRUCT_P (op0) = 1;
  	MEM_VOLATILE_P (op0) |= volatilep;
! 	if (mode == mode1 || mode1 == BLKmode || mode1 == tmode
! 	    || modifier == EXPAND_CONST_ADDRESS
! 	    || modifier == EXPAND_INITIALIZER)
  	  return op0;
! 	else if (target == 0)
  	  target = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);
+ 
  	convert_move (target, op0, unsignedp);
  	return target;
*** tree.c.old	Thu Dec 12 08:14:34 1996
--- tree.c	Thu Jan  2 07:13:08 1997
*************** staticp (arg)
*** 2119,2125 ****
        return 1;
  
      case COMPONENT_REF:
      case BIT_FIELD_REF:
!       return staticp (TREE_OPERAND (arg, 0));
  
  #if 0
--- 2175,2186 ----
        return 1;
  
+       /* If we are referencing a bitfield, we can't evaluate an
+ 	 ADDR_EXPR at compile time and so it isn't a constant.  */
      case COMPONENT_REF:
+       return (! DECL_BIT_FIELD (TREE_OPERAND (arg, 1))
+ 	      && staticp (TREE_OPERAND (arg, 0)));
+ 
      case BIT_FIELD_REF:
!       return 0;
  
  #if 0
*** fold-const.c.old	Sun Jan  5 07:56:54 1997
--- fold-const.c	Sun Jan  5 20:49:33 1997
*************** operand_equal_p (arg0, arg1, only_const)
*** 1736,1777 ****
    STRIP_NOPS (arg1);
  
!   /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.
!      We don't care about side effects in that case because the SAVE_EXPR
!      takes care of that for us.  */
!   if (TREE_CODE (arg0) == SAVE_EXPR && arg0 == arg1)
!     return ! only_const;
! 
!   if (TREE_SIDE_EFFECTS (arg0) || TREE_SIDE_EFFECTS (arg1))
      return 0;
  
!   if (TREE_CODE (arg0) == TREE_CODE (arg1)
!       && TREE_CODE (arg0) == ADDR_EXPR
!       && TREE_OPERAND (arg0, 0) == TREE_OPERAND (arg1, 0))
      return 1;
  
!   if (TREE_CODE (arg0) == TREE_CODE (arg1)
!       && TREE_CODE (arg0) == INTEGER_CST
!       && TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)
!       && TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1))
!     return 1;
  
!   /* Detect when real constants are equal.  */
!   if (TREE_CODE (arg0) == TREE_CODE (arg1)
!       && TREE_CODE (arg0) == REAL_CST)
!     return !bcmp ((char *) &TREE_REAL_CST (arg0),
! 		  (char *) &TREE_REAL_CST (arg1),
! 		  sizeof (REAL_VALUE_TYPE));
  
!   if (only_const)
!     return 0;
  
!   if (arg0 == arg1)
!     return 1;
  
!   if (TREE_CODE (arg0) != TREE_CODE (arg1))
!     return 0;
!   /* This is needed for conversions and for COMPONENT_REF.
!      Might as well play it safe and always test this.  */
!   if (TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))
      return 0;
  
--- 1736,1787 ----
    STRIP_NOPS (arg1);
  
!   if (TREE_CODE (arg0) != TREE_CODE (arg1)
!       /* This is needed for conversions and for COMPONENT_REF.
! 	 Might as well play it safe and always test this.  */
!       || TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))
      return 0;
  
!   /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.
!      We don't care about side effects in that case because the SAVE_EXPR
!      takes care of that for us. In all other cases, two expressions are
!      equal if they have no side effects.  If we have two identical
!      expressions with side effects that should be treated the same due
!      to the only side effects being identical SAVE_EXPR's, that will
!      be detected in the recursive calls below.  */
!   if (arg0 == arg1 && ! only_const
!       && (TREE_CODE (arg0) == SAVE_EXPR
! 	  || (! TREE_SIDE_EFFECTS (arg0) && ! TREE_SIDE_EFFECTS (arg1))))
      return 1;
  
!   /* Next handle constant cases, those for which we can return 1 even
!      if ONLY_CONST is set.  */
!   if (TREE_CONSTANT (arg0) && TREE_CONSTANT (arg1))
!     switch (TREE_CODE (arg0))
!       {
!       case INTEGER_CST:
! 	return (TREE_INT_CST_LOW (arg0) == TREE_INT_CST_LOW (arg1)
! 		&& TREE_INT_CST_HIGH (arg0) == TREE_INT_CST_HIGH (arg1));
  
!       case REAL_CST:
! 	return REAL_VALUES_EQUAL (TREE_REAL_CST (arg0), TREE_REAL_CST (arg1));
  
!       case COMPLEX_CST:
! 	return (operand_equal_p (TREE_REALPART (arg0), TREE_REALPART (arg1),
! 				 only_const)
! 		&& operand_equal_p (TREE_IMAGPART (arg0), TREE_IMAGPART (arg1),
! 				    only_const));
  
!       case STRING_CST:
! 	return (TREE_STRING_LENGTH (arg0) == TREE_STRING_LENGTH (arg1)
! 		&& ! strncmp (TREE_STRING_POINTER (arg0),
! 			      TREE_STRING_POINTER (arg1),
! 			      TREE_STRING_LENGTH (arg0)));
  
!       case ADDR_EXPR:
! 	return operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0),
! 				0);
!       }
! 
!   if (only_const)
      return 0;
  
*************** operand_equal_p (arg0, arg1, only_const)
*** 1788,1795 ****
      case '<':
      case '2':
!       return (operand_equal_p (TREE_OPERAND (arg0, 0),
! 			       TREE_OPERAND (arg1, 0), 0)
  	      && operand_equal_p (TREE_OPERAND (arg0, 1),
! 				  TREE_OPERAND (arg1, 1), 0));
  
      case 'r':
--- 1800,1819 ----
      case '<':
      case '2':
!       if (operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0), 0)
! 	  && operand_equal_p (TREE_OPERAND (arg0, 1), TREE_OPERAND (arg1, 1),
! 			      0))
! 	return 1;
! 
!       /* For commutative ops, allow the other order.  */
!       return ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MULT_EXPR
! 	       || TREE_CODE (arg0) == MIN_EXPR || TREE_CODE (arg0) == MAX_EXPR
! 	       || TREE_CODE (arg0) == BIT_IOR_EXPR
! 	       || TREE_CODE (arg0) == BIT_XOR_EXPR
! 	       || TREE_CODE (arg0) == BIT_AND_EXPR
! 	       || TREE_CODE (arg0) == NE_EXPR || TREE_CODE (arg0) == EQ_EXPR)
! 	      && operand_equal_p (TREE_OPERAND (arg0, 0),
! 				  TREE_OPERAND (arg1, 1), 0)
  	      && operand_equal_p (TREE_OPERAND (arg0, 1),
! 				  TREE_OPERAND (arg1, 0), 0));
  
      case 'r':
*** dwarfout.c.old	Sun Jan  5 08:00:27 1997
--- dwarfout.c	Mon Jan  6 07:10:49 1997
*************** type_attribute (type, decl_const, decl_v
*** 3003,3007 ****
    register int root_type_modified;
  
!   if (TREE_CODE (type) == ERROR_MARK)
      return;
  
--- 3003,3007 ----
    register int root_type_modified;
  
!   if (code == ERROR_MARK)
      return;
  
*************** type_attribute (type, decl_const, decl_v
*** 3010,3015 ****
       type `void', so this only applies to function return types.  */
  
!   if (TREE_CODE (type) == VOID_TYPE)
      return;
  
    root_type_modified = (code == POINTER_TYPE || code == REFERENCE_TYPE
--- 3010,3021 ----
       type `void', so this only applies to function return types.  */
  
!   if (code == VOID_TYPE)
      return;
+ 
+   /* If this is a subtype, find the underlying type.  Eventually,
+      this should write out the appropriate subtype info.  */
+   while ((code == INTEGER_TYPE || code == REAL_TYPE)
+ 	 && TREE_TYPE (type) != 0)
+     type = TREE_TYPE (type), code = TREE_CODE (type);
  
    root_type_modified = (code == POINTER_TYPE || code == REFERENCE_TYPE
*** expr.c.368  Thu Jan 16 14:43:46 1997
--- expr.c  Thu Jan 16 14:44:23 1997
***************
*** 5058,5082 ****
  	tree exp2;
  
! 	/* A SAVE_EXPR as the address in an INDIRECT_EXPR is generated
! 	   for  *PTR += ANYTHING  where PTR is put inside the SAVE_EXPR.
! 	   This code has the same general effect as simply doing
! 	   expand_expr on the save expr, except that the expression PTR
! 	   is computed for use as a memory address.  This means different
! 	   code, suitable for indexing, may be generated.  */
! 	if (TREE_CODE (exp1) == SAVE_EXPR
! 	    && SAVE_EXPR_RTL (exp1) == 0
! 	    && TYPE_MODE (TREE_TYPE (exp1)) == ptr_mode)
! 	  {
! 	    temp = expand_expr (TREE_OPERAND (exp1, 0), NULL_RTX,
! 				VOIDmode, EXPAND_SUM);
! 	    op0 = memory_address (mode, temp);
! 	    op0 = copy_all_regs (op0);
! 	    SAVE_EXPR_RTL (exp1) = op0;
! 	  }
! 	else
! 	  {
! 	    op0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);
! 	    op0 = memory_address (mode, op0);
! 	  }
  
  	temp = gen_rtx (MEM, mode, op0);
--- 5058,5063 ----
 	tree exp2;
  
! 	op0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);
! 	op0 = memory_address (mode, op0);
  
  	temp = gen_rtx (MEM, mode, op0);
*** varasm.c.old	Sun Jan  5 08:00:34 1997
--- varasm.c	Sat Jan 18 06:55:45 1997
*************** const_hash (exp)
*** 2408,2412 ****
      return const_hash (TREE_OPERAND (exp, 0)) * 9
        +  const_hash (TREE_OPERAND (exp, 1));
!   else if (code == NOP_EXPR || code == CONVERT_EXPR)
      return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;
  
--- 2408,2412 ----
      return const_hash (TREE_OPERAND (exp, 0)) * 9
        +  const_hash (TREE_OPERAND (exp, 1));
!   else if (code == NOP_EXPR || code == CONVERT_EXPR || code == NON_LVALUE_EXPR)
      return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;
  
*************** compare_constant_1 (exp, p)
*** 2565,2569 ****
        return p;
      }
!   else if (code == NOP_EXPR || code == CONVERT_EXPR)
      {
        p = compare_constant_1 (TREE_OPERAND (exp, 0), p);
--- 2565,2569 ----
        return p;
      }
!   else if (code == NOP_EXPR || code == CONVERT_EXPR || code == NON_LVALUE_EXPR)
      {
        p = compare_constant_1 (TREE_OPERAND (exp, 0), p);
*************** copy_constant (exp)
*** 2810,2813 ****
--- 2810,2814 ----
      case NOP_EXPR:
      case CONVERT_EXPR:
+     case NON_LVALUE_EXPR:
        return build1 (TREE_CODE (exp), TREE_TYPE (exp),
  		     copy_constant (TREE_OPERAND (exp, 0)));
*************** bc_assemble_integer (exp, size)
*** 3787,3791 ****
    exp = fold (exp);
    
!   while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR)
      exp = TREE_OPERAND (exp, 0);
    if (TREE_CODE (exp) == INTEGER_CST)
--- 3788,3793 ----
    exp = fold (exp);
    
!   while (TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR
! 	 || TREE_CODE (exp) == NON_LVALUE_EXPR)
      exp = TREE_OPERAND (exp, 0);
    if (TREE_CODE (exp) == INTEGER_CST)
*************** bc_assemble_integer (exp, size)
*** 3798,3806 ****
        const_part = TREE_OPERAND (exp, 0);
        while (TREE_CODE (const_part) == NOP_EXPR
! 	     || TREE_CODE (const_part) == CONVERT_EXPR)
  	const_part = TREE_OPERAND (const_part, 0);
        addr_part = TREE_OPERAND (exp, 1);
        while (TREE_CODE (addr_part) == NOP_EXPR
! 	     || TREE_CODE (addr_part) == CONVERT_EXPR)
  	addr_part = TREE_OPERAND (addr_part, 0);
        if (TREE_CODE (const_part) != INTEGER_CST)
--- 3800,3810 ----
        const_part = TREE_OPERAND (exp, 0);
        while (TREE_CODE (const_part) == NOP_EXPR
! 	     || TREE_CODE (const_part) == CONVERT_EXPR
! 	     || TREE_CODE (const_part) == NON_LVALUE_EXPR)
  	const_part = TREE_OPERAND (const_part, 0);
        addr_part = TREE_OPERAND (exp, 1);
        while (TREE_CODE (addr_part) == NOP_EXPR
! 	     || TREE_CODE (addr_part) == CONVERT_EXPR
! 	     || TREE_CODE (addr_part) == NON_LVALUE_EXPR)
  	addr_part = TREE_OPERAND (addr_part, 0);
        if (TREE_CODE (const_part) != INTEGER_CST)
*** tree.c.old	Sun Jan  5 07:57:02 1997
--- tree.c	Sat Jan 18 15:53:54 1997
*************** get_unwidened (op, for_type)
*** 4182,4186 ****
    if (TREE_CODE (op) == COMPONENT_REF
        /* Since type_for_size always gives an integer type.  */
!       && TREE_CODE (type) != REAL_TYPE)
      {
        unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));
--- 4182,4188 ----
    if (TREE_CODE (op) == COMPONENT_REF
        /* Since type_for_size always gives an integer type.  */
!       && TREE_CODE (type) != REAL_TYPE
!       /* Don't crash if field not layed out yet.  */
!       && DECL_SIZE (TREE_OPERAND (op, 1)) != 0)
      {
        unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));
*** function.c.old	Sun Jan  5 07:58:14 1997
--- function.c	Sun Jan 19 08:31:22 1997
*************** instantiate_virtual_regs_1 (loc, object,
*** 2943,2947 ****
      case MEM:
        /* Most cases of MEM that convert to valid addresses have already been
! 	 handled by our scan of regno_reg_rtx.  The only special handling we
  	 need here is to make a copy of the rtx to ensure it isn't being
  	 shared if we have to change it to a pseudo. 
--- 2943,2947 ----
      case MEM:
        /* Most cases of MEM that convert to valid addresses have already been
! 	 handled by our scan of decls.  The only special handling we
  	 need here is to make a copy of the rtx to ensure it isn't being
  	 shared if we have to change it to a pseudo. 
*************** instantiate_virtual_regs_1 (loc, object,
*** 3001,3005 ****
  	     has less restrictions on an address that some other insn.
  	     In that case, we will modify the shared address.  This case
! 	     doesn't seem very likely, though.  */
  
  	  if (instantiate_virtual_regs_1 (&XEXP (x, 0),
--- 3001,3007 ----
  	     has less restrictions on an address that some other insn.
  	     In that case, we will modify the shared address.  This case
! 	     doesn't seem very likely, though.  One case where this could
! 	     happen is in the case of a USE or CLOBBER reference, but we
! 	     take care of that below.  */
  
  	  if (instantiate_virtual_regs_1 (&XEXP (x, 0),
*************** instantiate_virtual_regs_1 (loc, object,
*** 3014,3019 ****
  
        /* Fall through to generic unary operation case.  */
-     case USE:
-     case CLOBBER:
      case SUBREG:
      case STRICT_LOW_PART:
--- 3016,3019 ----
*************** instantiate_virtual_regs_1 (loc, object,
*** 3029,3032 ****
--- 3029,3049 ----
        /* These case either have just one operand or we know that we need not
  	 check the rest of the operands.  */
+       loc = &XEXP (x, 0);
+       goto restart;
+ 
+     case USE:
+     case CLOBBER:
+       /* If the operand is a MEM, see if the change is a valid MEM.  If not,
+ 	 go ahead and make the invalid one, but do it to a copy.  For a REG,
+ 	 just make the recursive call, since there's no chance of a problem. */
+ 
+       if ((GET_CODE (XEXP (x, 0)) == MEM
+ 	   && instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 0), XEXP (x, 0),
+ 					  0))
+ 	  || (GET_CODE (XEXP (x, 0)) == REG
+ 	      && instantiate_virtual_regs_1 (&XEXP (x, 0), 0, 0)))
+ 	return 1;
+ 
+       XEXP (x, 0) = copy_rtx (XEXP (x, 0));
        loc = &XEXP (x, 0);
        goto restart;
*** config/alpha/alpha.h.old	Sat Nov 16 06:50:12 1996
--- config/alpha/alpha.h	Sat Jan 18 18:06:31 1997
***************
*** 380,383 ****
--- 380,386 ----
  #define BIGGEST_ALIGNMENT 64
  
+ /* For atomic access to objects, must have at least 32-bit alignment.  */
+ #define MINIMUM_ATOMIC_ALIGNMENT 32
+ 
  /* Align all constants and variables to at least a word boundary so
     we can pick up pieces of them faster.  */
