diff -rc2P ld.so.old/example/README.preload ld.so/example/README.preload
*** ld.so.old/example/README.preload	Tue Sep 27 03:45:45 1994
--- ld.so/example/README.preload	Sat Nov 26 19:41:35 1994
***************
*** 134,135 ****
--- 134,157 ----
  Mitch
  m.dsouza@mrc-apu.cam.ac.uk
+ 
+ NOTE:
+ If the module preloaded contains a function called _preload_main_ (in fact
+ __preload_main_), this function is called at preloading time.
+ 
+ prototype: void callmefunc(int ver, int nlibs, char **libs,
+ 		 int nmod, char **mods, char *argv0, char **environ);
+ 
+ VER is the version (actually 1). It is used to be sure about the next
+ arguments:
+ VER: version number
+ NLIBS: number of libraries
+ LIBS: array of the linked libraries path
+ NMOD: number of modules (preloaded binaries)
+ MODS: array of the modules name
+ ARGV0: argv[0] of the program
+ ENVIRON: n.c.
+ 
+ For an example, see dispinfo.c
+ 
+ Tristan.
diff -rc2P ld.so.old/example/dispinfo.c ld.so/example/dispinfo.c
*** ld.so.old/example/dispinfo.c	Thu Jan  1 02:00:00 1970
--- ld.so/example/dispinfo.c	Sat Nov 26 19:57:03 1994
***************
*** 0 ****
--- 1,43 ----
+ #define DISP(c) write(1, c, strlen(c))
+ 
+ void
+ _preload_main_(int ver, int nlibs, char **libs,
+ 		 int nmod, char **mods, char *argv0, char **environ)
+ {
+  int i;
+  char *p;
+  char *p1;
+  if (ver != 1)
+    {
+      DISP("Bad version of ld.so\n");
+      return;
+    }
+  DISP("disinfo: an example of the PRELOAD feature\n");
+  DISP("Program name: ");
+  if (argv0 && *argv0)
+    DISP(argv0);
+  else
+    DISP("*unknown* (called by ldd?)");
+  DISP("\nShared libraries loaded:\n");
+  for (i = 0; i < nlibs; i++)
+    {
+      DISP(libs[i]);
+      DISP("\n");
+    }
+  DISP("Environ:\n");
+  for (i = 0; environ[i]; i++)
+    {
+      DISP(environ[i]);
+      DISP("\n");
+    }
+  DISP("Program arguments:\n");
+  /* Well, this is not really beautiful ! */
+  for (p = argv0; p != environ[0]; p++)
+    {
+      DISP(p);
+      DISP(" ");
+      while (*p) p++;	/* Next arg */
+    }
+  DISP("\n*** End of dispinfo ***\n");
+  return;
+ }
diff -rc2P ld.so.old/fixups.h ld.so/fixups.h
*** ld.so.old/fixups.h	Tue Sep 27 03:45:45 1994
--- ld.so/fixups.h	Sat Nov 26 19:37:26 1994
***************
*** 126,130 ****
  int __dynamic_resolve(struct fixuplist * xpnt);
  
! void ldpreload (char *name, int ldd, char **libs, int num);
  
  #endif /* _FIXUPS_H */
--- 126,130 ----
  int __dynamic_resolve(struct fixuplist * xpnt);
  
! void ldpreload (char *name, int ldd, char **libs, int num, char *argv0);
  
  #endif /* _FIXUPS_H */
diff -rc2P ld.so.old/ld.so.c ld.so/ld.so.c
*** ld.so.old/ld.so.c	Tue Sep 27 03:45:48 1994
--- ld.so/ld.so.c	Sat Nov 26 19:34:25 1994
***************
*** 432,436 ****
      }
  	if (preload)
! 	    ldpreload(preload, ldd, libs, nlibs);
  }
  
--- 432,436 ----
      }
  	if (preload)
! 	    ldpreload(preload, ldd, libs, nlibs, argv0);
  }
  
diff -rc2P ld.so.old/preload.c ld.so/preload.c
*** ld.so.old/preload.c	Tue Sep 27 03:45:48 1994
--- ld.so/preload.c	Sat Nov 26 19:39:54 1994
***************
*** 2,5 ****
--- 2,8 ----
   *  Shamelessly stolen/adapted from nm.c - binutils-1.9.
   *  Mitch DSouza - m.dsouza@mrc-apu.cam.ac.uk 
+  * 
+  *  1994-11-26: 'preload_main' feature added.
+  *  Tristan Gingold
   */
  
***************
*** 39,53 ****
  /* Always use the GNU version of debugging symbol type codes, if possible.  */
  #include "stab.h"
- 
  struct exec hdr;
  
  /* Current file's name.  */
- 
  char *input_name;
  
  static void do_one_rel_file ();
  
  /* Like malloc but get fatal error if memory is exhausted.  */
! 
  static char *
  xmalloc (size)
--- 42,74 ----
  /* Always use the GNU version of debugging symbol type codes, if possible.  */
  #include "stab.h"
  struct exec hdr;
  
  /* Current file's name.  */
  char *input_name;
  
+ /* The __environ array is declared in ld.so.c */
+ extern char **__environ;
+ 
+ /* Function to call when the file has just been linked */
+ /* Arguments:	VER: version number
+  *		NLIBS: number of libraries
+  *	     	LIBS: array of the linked libraries path
+  *		NMOD: number of modules (preloaded binaries)
+  *		MODS: array of the modules name
+  *		ARGV0: argv[0] of the program
+  *		ENVIRON: n.c.
+  */
+ typedef void (*callmefunc)(int ver, int nlibs, char **libs,
+ 		 int nmod, char **mods, char *argv0, char **environ);
+ callmefunc call_me;
+ #define CALL_ME_VER 1	/* The argument version */
+ 
+ /* Name of the function */
+ #define CALL_ME_NAME "__preload_main_"
+ 
  static void do_one_rel_file ();
  
  /* Like malloc but get fatal error if memory is exhausted.  */
! #if 0
  static char *
  xmalloc (size)
***************
*** 61,64 ****
--- 82,88 ----
    return result;
  }
+ #else
+ #define xmalloc(size) alloca(size)
+ #endif
  
  typedef struct {
***************
*** 70,74 ****
  
  void
! ldpreload (char *name, int ldd, char **libs, int num)
  {
    int desc, nchars, err, fd, i;
--- 94,98 ----
  
  void
! ldpreload (char *name, int ldd, char **libs, int num, char *argv0)
  {
    int desc, nchars, err, fd, i;
***************
*** 88,91 ****
--- 112,116 ----
  
    input_name = name;
+   call_me = (callmefunc)0;
  
    nchars = read (desc, &hdr, sizeof(struct exec));
***************
*** 112,120 ****
  #ifdef DEBUG
    for (i=0; i<nlibs; i++)
! 	fdprintf(2,"%2d: 0x%x - 0x%x\n",i,libn[i].txtoff,libn[i].txtend);
  #endif
     if (ldd)
! 	fdprintf(2, "\t%s\n", name);
!     do_one_rel_file (desc, ldd);
    }
    close (desc);
--- 137,147 ----
  #ifdef DEBUG
    for (i=0; i<nlibs; i++)
! 	fdprintf(2,"%2d: 0x%x - 0x%x (%s)\n",i,libn[i].txtoff,libn[i].txtend,libs[i]);
  #endif
     if (ldd)
!      fdprintf(2, "\t%s\n", name);
!    do_one_rel_file (desc, ldd);
!    if (call_me)
!      (*call_me)(CALL_ME_VER, num, libs, 1, &name, argv0, __environ);
    }
    close (desc);
***************
*** 236,244 ****
    /* Print the symbols in the order they are now in.  */
  
!   for (i = 0; i < symcount; i++) {
! 
!     if (symbols_and_strings[i].n_type == (N_TEXT|N_EXT))
! 	lookup_symbol (&symbols_and_strings[i],ldd);
!   }
  #if 0
    free (symbols_and_strings);
--- 263,276 ----
    /* Print the symbols in the order they are now in.  */
  
!   for (i = 0; i < symcount; i++)
!     {
!       if (symbols_and_strings[i].n_type == (N_TEXT|N_EXT))
!         {
! 	  lookup_symbol (&symbols_and_strings[i],ldd);
! 	  /* Is it the CALL_ME function ? */
! 	  if (strcmp(symbols_and_strings[i].n_un.n_name, CALL_ME_NAME) == 0)
! 	    call_me = (callmefunc)(symbols_and_strings[i].n_value);
!         }
!     }
  #if 0
    free (symbols_and_strings);
