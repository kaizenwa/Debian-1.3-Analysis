Notes on the Implementation of Checker in GCC
---------------------------------------------
[ This file was written by Tristan Gingold.  You are welcome to correct
  English mistakes, ask questions...]
[ Last update: Tue Jan  2 13:00:24 MET 1996]

Everything you want to/must know to implement Checker in GCC.
Checker can work with GCC through the option `-fcheck-memory-usage'.

Concept:
Checker is a memory accesses detector: it maintains bitmap for the memory and
has to check memory accesses with this bitmap.  A state (kept in the bitmap)
is defined for each byte of memory:
UN (0): no right, cannot be read or written (red-zone).
RO (1): read-only.
RW (3): read-write.
WO (2): write-only.  A written write-only byte becomes RW.
See expr.h(memory_use_mode)

Checker in GCC:
When -fcheck-memory-usage is enabled, GCC will insert code before each memory
access.  The code must check this access.  Memory access can be done through
a symbol reference or through a pointer.
a) Symbol reference.
 These accesses are never checked since we are sure they are correct: a
static variable is always readable (since initialized) and writable.
b) Pointer (INDIRECT_REF).
 They are always checked.  Checker needs the address, the size and the
right.  With RTL, we know the address and the size (GET_MODE_SIZE).  However
the right (ie the memory can be read, written or both) is not known.  Since
INDIRECT_REF occurs only in expressions (* is it true ? *), I added a fifth
args to expand_expr: the right, which is (see expr.h):
MEMORY_USE_RO: memory will be read
MEMORY_USE_WO: memory will be written
MEMORY_USE_RW: memory will be modified (ie read and written)
MEMORY_USE_BAD: the access is unknown.  Will abort if a pointer is used.
Examples:
  *ptr = 5;	/* *ptr is written */
  foo = *ptr;	/* *ptr is read */
  (*ptr)++;	/* *ptr is modified */
  *(*ptr) = 1;	/* *ptr is read and **ptr is written */
The Checker function to call is:
void chkr_check_addr (void *addr, int size, int right);
 handles this memory range: (us) [addr, addr + size) 
 or (fr) [addr, addr + size[
Example: (assume ptr is a initialized pointer to an integer)
  *ptr = 5;
will be transformed into:
  chkr_check_addr (ptr, sizeof(int), MEMORY_USE_WO);
  *ptr = 5;

GCC also inserts code to check code at an address is executable.  This is
done for computed gotos and call to a function through a pointer.  Use
void chkr_check_exec (void *addr);

Structures are a bit annoying because they can contains several unitialized
bytes (implicit or explicit pads).  As a consequence, if a structure is
copied, I think the bitmap must also be copied.  You can use
void chkr_copy_bitmap (void *dest, void *src, int size);
Example: (struct foo *bar1, *bar2)
  *bar1 = *bar2;
can be translated into:
  chkr_copy_bitmap (bar1, bar2, sizeof (struct foo));
  *bar1 = *bar2;
Note: this behavior could be changed, since it is an innovation.

Sometime, you need to initialise memory (memset ...).  The best way is to
use chkr_check_addr.
Example:
  memset (ptr, len);
can be silently translated into:
  chkr_check_addr (ptr, len, MEMORY_USE_WO);
  memset (ptr, len);
The call to chkr_check_addr will check the zone is writable and will mark it
readable and writable.

If you want to set directly rights, you can use:
void chkr_set_right (void *addr, int size, int right);
This can be used to create red-zone if right is MEMORY_USE_BAD.

If you want to check memory is writable without updating it to RW, you can
use:
void chkr_check_addr (void *addr, int size, MEMORY_USE_TW);
Note the difference with MEMORY_USE_WO: bytes checked with MEMORY_USE_WO
becomes MEMORY_USE_RW.

For strings, the size is unknown, so you can use:
void chkr_check_str (void *addr, int right);
which roughly does the same thing as:
chkr_check_addr (addr, strlen (addr) + 1, right);


New Options of GCC:
-fcheck-memory-usage: Enable Checker.  Roughly speaking, GCC will insert
code before each memory access to check it.  -fcheck-memory-usage disables
-fomit-frame-pointer if this option prevents from debugging.

-Wcheck-memory-usage: Enable warnings that should be used with Checker.  You 
should take care of these warnings if you use Checker.  Warnings are:
  -Wimplicit
  -Wuninitialized
  -Wstrict-prototypes
  -Wformat


Features of -fcheck-memory-usage:
a) Static and global function names are prefixed with "chkr$".  External
functions (defined in libc, libX...) will be called through a stub, which
checks arguments and set rights).  Only nested functions are not prefixed.
b) Code insertion to check each memory access.

Optimization:
A lost of check can be avoided because of the structure of the program.
Example:
  *ptr = foo (4);
  b += *ptr;	/* I am sure that ptr is readable */
However, if -O is not enable, do not remove checks because of the debugger.

Stack:
GCC must inform Checker about the value of the stack pointer, with this
function:
void chkr_stack_pointer (void *addr);
This function must be called when the stack pointer is changing (eg before
arguments are pushed and after they are pushed, alloca ...).
It can be a good idea to regroup operation when arguments are pushed.  This
is not done yet.
It can be a good idea to create red-zones between the frames.  Saved pc and
frame pointer can be included in the red-zone, since they are not read by
the user (they can be read by builtin_*_address).  This is not done yet.
BTW: Incoming arguments of a function are not checked.  Use the prototypes
for that.

Alloca:
It could be easy to create red-zones around alloca-ed zones.

Static data:
Currently, there is no bitmap for the static data (.data segment), since
they are considered are RW.  A good idea is to (optionaly) separate static
data by red-zones to detect more bound violations (of course, in this case a
bitmap should be created).

Asm insn:
Currently asm() is disabled: GCC will emit an error if you try to use asm()
when -fcheck-memory-usage is enabled.  asm() are a hot point: GCC can only
check incoming and outcoming arguments but not the behavior of asm().
Example:
Imagine this macro:
#define memset(s, c, n) ({ asm (... s, c, n); s; })
How to tell GCC that memset is initializing N bytes at S ?

TODO:
* static data
* asm
* stack
* What about G++, g77, objc and the stubs ?
