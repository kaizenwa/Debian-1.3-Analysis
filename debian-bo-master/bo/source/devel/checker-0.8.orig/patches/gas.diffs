diff -rcp binutils-2.5.2l.17.orig/gas/app.c binutils-2.5.2l.17/gas/app.c
*** binutils-2.5.2l.17.orig/gas/app.c	Wed Feb 22 03:59:35 1995
--- binutils-2.5.2l.17/gas/app.c	Wed Jul  5 13:47:37 1995
*************** recycle:
*** 652,664 ****
--- 652,697 ----
  	    }
  	  if (ch < '0' || ch > '9' || not_cpp_line)
  	    {
+ #ifdef CHECKER
+ 	      char comment[10];
+ 	      int i = 0;
  	      /* Non-numerics:  Eat whole comment line */
  	      while (ch != EOF && !IS_NEWLINE (ch))
+ 	        {
+ 	          if (i < 10)
+ 	            comment[i++] = ch;
+ 		  ch = (*get) ();
+ 		}
+ 	      if (ch == EOF)
+ 		as_warn ("EOF in Comment: Newline inserted");
+               if (i == 6 && strncmp(comment, "NO_APP", 6) == 0)
+                 {
+                   old_state = 0;
+                   state = -1;
+                   out_string = "\t.appoff\n";
+                   return *out_string++;
+                 }
+               else if (i == 3 && strncmp(comment, "APP", 3) == 0)
+                 {
+                   old_state = 0;
+                   state = -1;
+                   out_string = "\t.appon\n";
+                   return *out_string++;
+                 }
+               else
+                 {
+ 	          state = 0;
+ 	          return '\n';
+ 	        }
+ #else
+ 	      /* Non-numerics:  Eat whole comment line */
+ 	      while (ch != EOF && !IS_NEWLINE (ch))
  		ch = GET ();
  	      if (ch == EOF)
  		as_warn ("EOF in Comment: Newline inserted");
  	      state = 0;
  	      return '\n';
+ #endif
  	    }
  	  /* Numerics begin comment.  Perhaps CPP `# 123 "filename"' */
  	  (*unget) (ch);
diff -rcp binutils-2.5.2l.17.orig/gas/config/tc-i386.c binutils-2.5.2l.17/gas/config/tc-i386.c
*** binutils-2.5.2l.17.orig/gas/config/tc-i386.c	Tue May 23 04:04:22 1995
--- binutils-2.5.2l.17/gas/config/tc-i386.c	Mon Nov 27 22:51:50 1995
*************** const relax_typeS md_relax_table[] =
*** 240,245 ****
--- 240,264 ----
  
  };
  
+ #ifdef CHECKER
+ /* option flags */
+ int checkerflag;	/* bits: 0-1 set to enable checker
+ 		         2   set to enable check on stack
+ 		         3   set to enable verbose
+ 		         4   set to enable special case for pushl/popl %ebp 
+ 		         5   set to enable check on call
+ 		         6   print statistics at the end
+ 		         7   fnstcw */
+ static int postchecker;	/* 1 if we must insert code *after* the code */
+ static int nbr_instructions;
+ static int nbr_chkr_instr;
+ #define FNSTCW_REAL 1
+ #define FNSTCW_FORCE 2
+ #define FNSTCW_AUTO 4
+ static int fnstcw_mode = FNSTCW_AUTO;
+ static void s_app PARAMS((int arg));
+ #endif
+ 
  static char *output_invalid PARAMS ((int c));
  static int i386_operand PARAMS ((char *operand_string));
  static reg_entry *parse_register PARAMS ((char *reg_string));
*************** mode_from_disp_size (t)
*** 256,262 ****
    return (t & Disp8) ? 1 : (t & Disp32) ? 2 : 0;
  }
  
! #if 0
  /* Not used.  */
  /* convert opcode suffix ('b' 'w' 'l' typically) into type specifier */
  
--- 275,281 ----
    return (t & Disp8) ? 1 : (t & Disp32) ? 2 : 0;
  }
  
! #ifdef CHECKER
  /* Not used.  */
  /* convert opcode suffix ('b' 'w' 'l' typically) into type specifier */
  
*************** const pseudo_typeS md_pseudo_table[] =
*** 345,350 ****
--- 364,373 ----
    {"optim", s_ignore, 0},
    {"code16", set_16bit_code_flag, 1},
    {"code32", set_16bit_code_flag, 0},
+ #ifdef CHECKER
+   {"appon", s_app, 1},
+   {"appoff", s_app, 0},
+ #endif
    {0, 0, 0}
  };
  
*************** md_begin ()
*** 491,496 ****
--- 514,532 ----
    record_alignment (bss_section, 2);
  #endif
  }
+ 
+ void
+ md_end ()
+ {
+ #ifdef CHECKER
+   if (checkerflag & CHKR_STATS)
+     {
+       fprintf(stdout, "Number of instructions: %d\n", nbr_instructions);
+       fprintf(stdout, "Number of cheker calls: %d\n", nbr_chkr_instr);
+       fprintf(stdout, "Pourcentage: %f\n", (float)(100*nbr_chkr_instr)/nbr_instructions);
+     }
+ #endif
+ }				/* not much to do here. */
  
  
  #ifdef DEBUG386
*************** reloc (size, pcrel, other)
*** 681,686 ****
--- 717,1177 ----
  #define BFD_RELOC_386_GOTOFF	0
  #endif
  
+ #ifdef CHECKER
+ static void
+ set_fnstcw_mode()
+ {
+  if (symbol_find("gcc2_compiled.") == NULL)
+    fnstcw_mode = FNSTCW_FORCE | FNSTCW_REAL;	/* A real .s file */
+  else
+    fnstcw_mode = 0;	/* An .s file produced by GCC */
+  if (checkerflag & CHKR_VERBOSE)
+    if (!fnstcw_mode)
+      as_tsktsk("Checker thinks this file was produced by GCC V2");
+    else
+      as_tsktsk("Checker thinks this file was NOT produced by GCC");
+ }
+ 
+ static void
+ do_chkr_emit_call(char *func, int verbose)
+ {
+   symbolS *symbolP;	/* points to symbol */
+   expressionS expressionP;
+   char *p;
+   
+   if ((checkerflag & CHKR_VERBOSE) && verbose == 1)
+     as_tsktsk("Checker pre adds \tcall %s", func);
+   if ((checkerflag & CHKR_VERBOSE) && verbose == 2)
+     as_tsktsk("Checker post adds \tcall %s", func);
+     
+   /* insertion of code */
+   /* Taken from gas/expr.c at line ~600 */
+   symbolP = symbol_find_or_make (func);
+   p = frag_more (1 + 4);
+   p[0] = CALL_PC_RELATIVE;	/* Call opcode */
+   expressionP.X_op = O_symbol;
+   expressionP.X_add_symbol = symbolP;
+   expressionP.X_add_number = 0;
+   fix_new_exp (frag_now, &p[1] - frag_now->fr_literal, 4,
+ 		&expressionP, 1, reloc (4,1,BFD_RELOC_32_PCREL));
+   nbr_chkr_instr++;	/* do the stats */
+ }
+ 
+ static void
+ do_postchecker()
+ {
+   /* clear the flag */
+   postchecker = 0;
+   
+   do_chkr_emit_call("chkr_0_5_0_0_chkr",2); 
+ }
+ 
+ void static
+ do_checker(int reverse, char *line)
+ {
+   static int instr_to_skipf = 0;
+   int j, useful;
+   /* description of the function to call */
+   int size;		/* number of bytes to check */
+   int addrmod;		/* disp or ModRm */
+   int accmod;		/* type of check: R, W or R&W */
+   int skipf = -1;	/* bytes to skipf to access to the address */
+   char name[20];
+   symbolS *symbolP;	/* points to symbol */
+   expressionS expressionP;
+   char *p;
+   
+   nbr_instructions++;	/* stats */
+   if (instr_to_skipf > 0)
+   {
+     instr_to_skipf--;	/* skipf one instruction */
+     return;
+   }
+   if (checkerflag & CHKR_VERBOSE)  
+     fprintf(stderr,"Line: '%s' Right:%x\n",line, i.tm.opcode_des);
+     
+   if (i.tm.opcode_des & ErrOp)
+     as_fatal("instruction not supported by Checker");
+     
+   /* Strings and Int */
+   if ((i.tm.opcode_des & ODMASK) == StrOp)
+   {
+    addrmod = 3;	/* special case */
+    size = 0;		
+    switch(i.tm.base_opcode)
+    {
+      case REPNE:
+  	accmod = 1;
+ 	instr_to_skipf++;
+ 	break;
+      case REPE:
+ 	accmod = 2;
+ 	instr_to_skipf++;
+ 	break;
+      default:
+ 	j = opcode_suffix_to_type(i.suffix);
+ 	size = (j==Byte)?1: (j==Word)?2:4;
+ 	accmod = 0;
+    }
+   }
+   else if ((i.tm.opcode_des & ODMASK) == IntOp)
+   {
+     addrmod = 4;	/* IntOp */
+     switch (i.tm.base_opcode)
+     {
+       case 0xce: /* into */
+ 	accmod = 0;
+ 	size = 0;	/* special interruption */
+ 	break;
+       case INT3_OPCODE:
+ 	accmod = 0;
+ 	size = 3;
+ 	break;
+       case INT_OPCODE:
+ 	accmod = (i.imms[0]->X_add_number & 0xf0) >> 4;
+ 	size = i.imms[0]->X_add_number & 0x0f;
+ 	break;
+       default:
+ 	as_fatal("Internal err at do_check(IntOp).");
+     }
+   }
+   else if ((i.tm.opcode_des & ODMASK) == StackOp &&
+   	    !( i.operands > 0 && i.types[0] & BaseIndex))
+   {
+     if(!(checkerflag & CHKR_ON_STACK))
+       return;
+     addrmod = 5;
+     size = 4;	/* store/load only words */
+     if (i.tm.opcode_des == PushOp || i.tm.opcode_des == PopOp)
+     {
+       accmod = (i.tm.opcode_des == PushOp) ? WriteMem : ReadMem;
+       /* test for pusha or popa */
+       switch (i.tm.base_opcode)
+       {
+         case 0x60: /* pusha */
+         case 0x61: /* popa */
+        	  size = 1;	/* 1 means 4*8 ! */
+        	  break;
+        	case 0x9c: /* pushf */
+        	case 0x9d: /* popf */
+        	  skipf = 0;
+        	  break; /* nothing to add */
+        	default:
+           if (i.operands != 1)
+             as_fatal("Internal error in do_checker");
+           else
+             if ((checkerflag & CHKR_FRAME_P) &&
+                  (i.types[i.operands - 1] & Reg32) && 
+                  i.regs[i.operands - 1]->reg_num == EBP_REG_NUM)
+               {
+                 if (i.tm.opcode_des == PopOp)
+                   {
+                     size = 0;	/* popl %ebp: frame pointer */
+                     accmod = 0;
+                   }
+                 else
+                   {
+                     do_chkr_emit_call("chkr_0_5_0_4_chkr",1);
+                     return;
+                   }
+               }
+           skipf = 0;
+       }
+     }
+     else if (i.tm.opcode_des == StackOp)
+     {
+       accmod = 0;
+       switch (i.tm.base_opcode)
+       {
+         case 0xc3: /* ret */
+  	  size = 4;
+           break;
+         case 0xc2: /* ret xx */
+  	  size = 0;
+ 	  break;
+ 	default:
+ 	  return; /* nothing to do */
+       }
+     }
+     else if (i.tm.base_opcode == 0xc9)	/* leave */
+       {
+         postchecker = 1;
+         return;
+       }
+     else
+       return;
+   }
+   else if (i.tm.opcode_des == CallOp)
+   {
+     if (checkerflag & CHKR_ON_CALL)	/* call. BUG: lcall is not tested */
+       do_chkr_emit_call("chkr_0_7_0_4_chkr", 1);
+     return;
+   }
+   else
+   { 
+     /* test of postcheck */
+     if (i.tm.opcode_des & StOp)
+     {
+       /* I assume i.operands is the destination */
+       if ((i.types[i.operands - 1] & Reg32) && 
+          i.regs[i.operands - 1]->reg_num == ESP_REG_NUM)
+       postchecker = 1;
+     }  	
+     if ((i.tm.opcode_des & RWField) == NoMemAcc)
+       return;
+     if ((i.tm.opcode_des & CallOp) && (checkerflag & CHKR_ON_CALL))
+       addrmod = 7;
+     else if (i.tm.opcode_des & JmpOp)
+       addrmod = 8;
+     else
+       addrmod = 6;
+     useful = 0;
+     /* find the operand which holds the address */
+     for (j = 0; j < i.operands; j++)
+       if (i.types[j] & (Disp|Mem))
+       {
+          useful = 1 + j;	/* which field is useful */
+          break;
+       }
+     if (!useful--)
+       if (addrmod == 6)
+         return;
+       else
+         {
+           /* This is for 'jmp *reg' and 'call *reg' */
+           p = frag_more(1);
+           p[0] = 0x50 | (i.rm.regmem & 0x07);	/* push reg */
+           sprintf(name,"chkr_%1x_%1x_%1x_%1x_chkr", 3, addrmod, 0, 4);
+           do_chkr_emit_call(name,1);
+           return;
+         }
+     if (i.types[useful] & BaseIndex)
+       skipf = 1;	/* by %eax */
+     else
+       skipf = 0;	/* by stack */
+     if (i.tm.opcode_des & CvOp)
+       switch (i.tm.operand_types[useful] & (Reg8|Reg16|Reg32))
+       {
+         case Reg8:
+           size = 1;
+           break;
+         case Reg16:
+           size = 2;
+           break;
+         case Reg32:
+           size = 4;
+           break;
+       }
+     else
+     {
+       j = opcode_suffix_to_type(i.suffix);
+       size = (j==Byte)?1: (j==Word)?2:4;
+     }
+ #if 0    
+       switch (i.types[useful] & (Mem8|Mem16|Mem32|Disp))
+       {
+         case Mem8:
+         case Disp8:
+           size = 1;
+           break;
+         case Mem16:
+         case Disp16:
+           size = 2;
+           break;
+         case Mem32:
+         case Disp32:
+           size = 4;
+           break;
+       }
+ #endif
+     switch (i.tm.opcode_des & ODMASK)
+     {
+       case 0:
+         accmod = i.tm.opcode_des & RWField;
+         if (reverse)
+         {
+ 	  if (i.tm.opcode_des == WriteMem)
+ 	    accmod = ReadMem;
+ 	  else if (i.tm.opcode_des == RAndWMem)
+ 	    accmod = ReadMem;
+ 	  else if (i.tm.opcode_des == ReadMem)
+ 	    accmod = WriteMem;
+ 	}
+         break;
+       case ProtOp:  
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 6;	/* 48 bits */
+ 	break;
+       case F16bOp:
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 2;
+ 	break;
+       case F32bOp:
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 4;
+ 	break;		
+       case F64bOp:
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 8;
+ 	break;			
+       case F80bOp:
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 10;
+ /*	addrmod = 2;  ModRm */
+ 	break;
+       case F224bOp:
+ 	accmod = i.tm.opcode_des & RWField;
+ 	size = 11;	/* Why not ! */
+ 	break;
+       case StackOp:
+ 	accmod = (i.tm.opcode_des == PushOp) ? WriteMem : ReadMem;
+ 	size = 4;
+ 	skipf = 2; /* by register and stack Op */
+     }
+     if (i.tm.opcode_des & FnstcwOP)
+       {
+         if (fnstcw_mode == FNSTCW_AUTO)
+           set_fnstcw_mode();
+         if (!(fnstcw_mode & FNSTCW_REAL))
+           size = 4;
+       }
+     if (skipf == 0) /* by stack */
+     {
+       p = frag_more(1);
+       p[0] = 0x68;	/* means pushl $xxx */
+       if (i.disps[useful]->X_op == O_constant)
+       {
+ #if 0
+         if (i.types[useful] & (Disp8 | Abs8))
+         {
+           p = frag_more (1);
+           md_number_to_chars (p, (valueT)i.disps[useful]->X_add_number, 1);
+         }
+ 	else if (i.types[useful] & (Disp16 | Abs16))
+ 	{
+ 	  p = frag_more (2);
+ 	  md_number_to_chars (p, (valueT)i.disps[useful]->X_add_number, 2);
+ 	}
+ 	else
+ #endif
+         {	/* Disp32|Abs32 */
+           p = frag_more (4);
+           md_number_to_chars (p, (valueT)i.disps[useful]->X_add_number, 4);
+ 	}
+       }
+       else
+       {		/* not absolute_section */
+         /* need a 32-bit fixup (don't support 8bit non-absolute disps) */
+         p = frag_more (4);
+         fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
+ 		     i.disps[useful], 0,
+ 		     TC_RELOC(i.disp_reloc[useful], BFD_RELOC_32));
+       }
+     }
+     else 
+     {
+       long add_offset;
+       int overflow = 0;
+       p = frag_more(1);
+       p[0] = 0x50;	/* pushl %eax */
+       /* avoid leal (%eax), %eax */
+       if (!(i.rm.mode == 0 && i.rm.regmem == 0))
+       {
+         p = frag_more (2);
+         p[0] = 0x8d;	/* leal ... */
+         /* Now the modrm byte and base index byte (if present). */
+         p++;
+         /* p = frag_more (1); */
+         /* md_number_to_chars (p, i.rm, 1); */
+         if (i.disps[useful])
+           add_offset = i.disps[useful]->X_add_number;
+         else
+           add_offset = 0;
+         if(i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING && i.bi.base == ESP_REG_NUM)
+         {
+           /* problem: the address depends on %esp and by pushl %eax, we
+              change %esp. So we must add a disp to the address */
+           add_offset += 4;
+           if (add_offset != 0 && i.rm.mode == 0)
+           {
+             /* no disp, so add a 8 bits disp */
+             overflow = 1;
+             md_number_to_chars (p, (i.rm.regmem << 0 | 0 << 3 | 1 << 6), 1);
+           }
+           else if (i.rm.mode == 1 && !fits_in_signed_byte(add_offset))
+           {
+             /* already a disp, but not enough */
+             overflow = 2;
+             md_number_to_chars (p, (i.rm.regmem << 0 | 0 << 3 | 2 << 6), 1);
+           }
+           else
+             md_number_to_chars (p, (i.rm.regmem << 0 | 0 << 3 | i.rm.mode << 6), 1);
+         }
+         else
+           md_number_to_chars (p, (i.rm.regmem << 0 | 0 << 3 | i.rm.mode << 6), 1);
+         /* If i.rm.regmem == ESP (4) && i.rm.mode != Mode 3 (Register mode)
+ 				   ==> need second modrm byte. */
+ 	if (i.rm.regmem == ESCAPE_TO_TWO_BYTE_ADDRESSING && i.rm.mode != 3)
+ 	{
+ 	  p = frag_more (1);
+ 	  /* md_number_to_chars (p, i.bi, 1); */
+ 	  md_number_to_chars (p, (i.bi.base << 0 | i.bi.index << 3 | i.bi.scale << 6), 1);
+ 	}
+ 	if (overflow || i.disps[useful])
+ 	{
+ 	  if (overflow || i.disps[useful]->X_op == O_constant)
+ 	  {
+ 	    if ((i.types[useful] & (Disp8 | Abs8) && overflow < 2) || overflow == 1)
+ 	    {
+ 	      p = frag_more (1);
+ 	      md_number_to_chars (p, add_offset, 1);
+ 	    }
+ #if 0
+             else if (i.types[useful] & (Disp16 | Abs16))
+ 	    {
+ 	      p = frag_more (2);
+ 	      md_number_to_chars (p, add_offset, 2);
+ 	      as_fatal("Error inside do_checker");
+ 	    }
+ #endif
+             else
+ 	    {	/* Disp32|Abs32 */
+ 	      p = frag_more (4);
+ 	      md_number_to_chars (p, add_offset, 4);
+ 	    }
+ 	  }
+ 	  else
+ 	  { /* not absolute_section *//*TG: FIXME */
+ 	    /* need a 32-bit fixup (don't support 8bit non-absolute disps) */
+ 	    p = frag_more (4);
+ 	    expressionP = *(i.disps[useful]);
+ 	    expressionP.X_add_number = add_offset;
+ 	    fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
+ 		&expressionP,  0, TC_RELOC(i.disp_reloc[useful], BFD_RELOC_32)); /* reloc(4,1,i.disp_reloc[useful])); */
+ 	  }
+ 	}
+       }    
+     }
+   }
+   if (skipf == -1)
+   {
+     if ((i.tm.base_opcode & 0xff) == i.tm.base_opcode)
+       skipf = 1;
+     else if ((i.tm.base_opcode & 0xffff) == i.tm.base_opcode)
+       skipf = 2;
+     else if ((i.tm.base_opcode & 0xffffff) == i.tm.base_opcode)
+       skipf = 3;
+     else if ((i.tm.base_opcode & 0xffffffff) == i.tm.base_opcode)
+       skipf = 4;
+     skipf += i.prefixes;
+   }
+   /* All is ready to create the name of the function */
+   sprintf(name,"chkr_%1x_%1x_%1x_%1x_chkr", skipf, addrmod, accmod, size);
+ 
+   do_chkr_emit_call(name,1);
+ }
+ #endif
+ 
  /*
   * Here we decide which fixups can be adjusted to make them relative to
   * the beginning of the section instead of the symbol.  Basically we need
*************** md_assemble (line)
*** 1456,1461 ****
--- 1947,1956 ----
  	    i.prefix[i.prefixes++] = i.seg->seg_prefix;
  	  }
        }
+ #ifdef CHECKER
+     if ((checkerflag & CHKR_ENABLE) == CHKR_ENABLE)
+       do_checker(found_reverse_match, line);
+ #endif
    }
  
    /* Handle conversion of 'int $3' --> special int3 insn. */
*************** md_assemble (line)
*** 1813,1818 ****
--- 2308,2318 ----
  	  }			/* end immediate output */
        }
  
+ #ifdef CHECKER
+       if (postchecker && (checkerflag & CHKR_ON_STACK))
+       	do_postchecker();
+ #endif
+ 
  #ifdef DEBUG386
      if (flag_debug)
        {
*************** md_number_to_chars (con, value, nbytes)
*** 2503,2508 ****
--- 3003,3027 ----
    number_to_chars_littleendian (con, value, nbytes);
  }
  
+ #ifdef CHECKER
+ static void 
+ s_app (arg)
+  int arg;
+ {
+  if (checkerflag & CHKR_VERBOSE)
+    as_tsktsk("s_app called by %s", arg ? "APP" : "NO_APP");
+  /* If #APP has been detected, ARG is true and we want to use the 
+       real fnstcw */
+  if (fnstcw_mode == FNSTCW_AUTO)
+    set_fnstcw_mode();
+  if (!(fnstcw_mode & FNSTCW_FORCE))
+    {
+      fnstcw_mode &= ~FNSTCW_REAL;
+      fnstcw_mode |= arg ? FNSTCW_REAL : 0;
+    }
+ }
+ #endif
+ 
  #ifdef OBJ_COFF
  
  /* Apply a fixup (fixS) to segment data, once it has been determined
*************** CONST char *md_shortopts = "mVQ:";
*** 2853,2858 ****
--- 3372,3391 ----
  CONST char *md_shortopts = "m";
  #endif
  struct option md_longopts[] = {
+ #ifdef CHECKER
+ #define OPTION_CHECKER (OPTION_MD_BASE)
+   {"checker", no_argument, NULL, OPTION_CHECKER},
+ #define OPTION_CHKR_NOSTACK (OPTION_MD_BASE + 1)
+   {"checker-nostack", no_argument, NULL, OPTION_CHKR_NOSTACK},
+ #define OPTION_NOCHECKER (OPTION_MD_BASE + 2)
+   {"nochecker", no_argument, NULL, OPTION_NOCHECKER},
+ #define OPTION_CHKR_VERBOSE (OPTION_MD_BASE + 3)
+   {"checker-verbose", no_argument, NULL, OPTION_CHKR_VERBOSE},
+ #define OPTION_CHKR_STATS (OPTION_MD_BASE + 4)
+   {"checker-stats", no_argument, NULL, OPTION_CHKR_STATS},
+ #define OPTION_CHKR_FNSTCW (OPTION_MD_BASE + 5)
+   {"checker-real-fnstcw", no_argument, NULL, OPTION_CHKR_FNSTCW},
+ #endif
    {NULL, no_argument, NULL, 0}
  };
  size_t md_longopts_size = sizeof(md_longopts);
*************** md_parse_option (c, arg)
*** 2880,2885 ****
--- 3413,3444 ----
        break;
  #endif
  
+ #if CHECKER
+     case OPTION_CHECKER:
+       /* enable code insertion */
+       checkerflag |= CHKR_ON_CALL | CHKR_FRAME_P | CHKR_ON_STACK | CHKR_ENABLE;
+       break;
+     case OPTION_CHKR_NOSTACK:
+       /* make stack checker not working */
+       checkerflag &= ~CHKR_ON_STACK;
+       break;
+     case OPTION_NOCHECKER:
+       /* Disable code insertion */
+       checkerflag = 0;
+       break;
+     case OPTION_CHKR_VERBOSE:
+       /* checker verbose */
+       checkerflag |= CHKR_VERBOSE;
+       break;
+     case OPTION_CHKR_STATS:
+       checkerflag |= CHKR_STATS;
+       break;
+     case OPTION_CHKR_FNSTCW:
+       /* about fnstcw */
+       fnstcw_mode = FNSTCW_REAL | FNSTCW_FORCE;
+       break;
+ #endif /* CHECKER */
+ 
      default:
        return 0;
      }
*************** md_show_usage (stream)
*** 2892,2897 ****
--- 3451,3464 ----
  {
    fprintf (stream, "\
  -m			do long jump\n");
+ #ifdef CHECKER
+   fprintf (stream, "\
+ --checker		enable checker\n\
+ --nochecker		disable checker\n\
+ --checker-verbose	verbose option for checker\n\
+ --checker-stats		print number of insertion\n\
+ --checker-real-fnstcw	input file was not produced by GCC\n");
+ #endif
  }
  
  /* We have no need to default values of symbols.  */
*************** tc_aout_fix_to_chars (where, fixP, segme
*** 3068,3073 ****
--- 3635,3650 ----
  	      | ((nbytes_r_length[fixP->fx_size] << 1) & 0x06)
  	      | (((fixP->fx_pcrel << 0) & 0x01) & 0x0f));
  }
+ 
+ #ifdef CHECKER
+ void
+ tc_aout_pre_write_hook(headers)
+     object_headers *headers;
+ {
+  if ((checkerflag & CHKR_ENABLE) == CHKR_ENABLE)
+    H_SET_VERSION(headers, CHKR_AOUT_VERSION);
+ }
+ #endif
  
  #endif /* OBJ_AOUT or OBJ_BOUT */
  
Only in binutils-2.5.2l.17/gas/config: tc-i386.c.orig
Only in binutils-2.5.2l.17/gas/config: tc-i386.c~
diff -rcp binutils-2.5.2l.17.orig/gas/config/tc-i386.h binutils-2.5.2l.17/gas/config/tc-i386.h
*** binutils-2.5.2l.17.orig/gas/config/tc-i386.h	Wed May 17 04:29:11 1995
--- binutils-2.5.2l.17/gas/config/tc-i386.h	Tue Nov 28 16:23:39 1995
*************** extern int tc_coff_sizemachdep PARAMS ((
*** 120,126 ****
--- 120,128 ----
  #endif
  #define LOCAL_LABELS_FB
  
+ #ifndef CHECKER
  #define tc_aout_pre_write_hook(x)	{;}	/* not used */
+ #endif
  #define tc_crawl_symbol_chain(a)	{;}	/* not used */
  #define tc_headers_hook(a)		{;}	/* not used */
  
*************** typedef struct
*** 282,287 ****
--- 284,333 ----
       'operand_types[i] = Reg|Imm' specifies that operand i can be
       either a register or an immediate operand */
    unsigned int operand_types[3];
+ 
+ #ifdef CHECKER
+   /* opcode_des describes what the opcode does: i.e. read, write, the both,
+         or stack. Used by Checker */
+   unsigned int opcode_des;
+ #define ODMASK 	 0x3c		/* ie 00111100 */
+ #define RWField  0x3
+ #define NoMemAcc 0x0		/* Normal instructions */
+ #define ReadMem  0x1
+ #define WriteMem 0x2
+ #define RAndWMem (ReadMem|WriteMem)
+ #define StackOp  0x4		/* Stack instructions (push, pop...)*/
+ #define PushOp	 (StackOp|WriteMem)
+ #define PopOp	 (StackOp|ReadMem)
+ #define StOp	 0x80		/* For addl $xx,%esp */
+ #define CvOp	 0x40		/* For movs??, movz?? */
+ #define CallOp	 0x100		/* For call */
+ #define JmpOp	 0x200		/* For jmp * */
+ #define FnstcwOP 0x400		/* For fnstcw */
+ #define ErrOp	 0x800		/* Instruction not supported */
+ #define StrOp    0x8		/* String instructions */
+ #define RStrOp	 (StrOp|ReadMem)
+ #define WStrOp   (StrOp|WriteMem)
+ #define RWStrOp  (StrOp|ReadMem|WriteMem)
+ #define ProtOp   0x0c		/* protection instructions */
+ #define RProtOp  (ProtOp|ReadMem)
+ #define WProtOp  (ProtOp|WriteMem)
+ #define F16bOp	 0x10		/* fp instructions */
+ #define RF16bOp  (F16bOp|ReadMem)
+ #define WF16bOp  (F16bOp|WriteMem)
+ #define F32bOp	 0x14
+ #define RF32bOp  (F32bOp|ReadMem)
+ #define WF32bOp  (F32bOp|WriteMem)
+ #define F64bOp   0x1c
+ #define RF64bOp  (F64bOp|ReadMem)
+ #define WF64bOp  (F64bOp|WriteMem)
+ #define F80bOp   0x20
+ #define RF80bOp  (F80bOp|ReadMem)
+ #define WF80bOp  (F80bOp|WriteMem)
+ #define IntOp	 0x24		/* int, into, int3 */
+ #define F224bOp   0x28		/* fstenv, fldenv */
+ #define RF224bOp  (F224bOp|ReadMem)
+ #define WF224bOp  (F224bOp|WriteMem)
+ #endif
  }
  template;
  
*************** base_index_byte;
*** 354,359 ****
--- 400,417 ----
  #ifdef BFD_ASSEMBLER
  void i386_validate_fix ();
  #define TC_VALIDATE_FIX(FIXP,SEGTYPE,SKIP) i386_validate_fix(FIXP)
+ #endif
+ 
+ #ifdef CHECKER
+ #define CHKR_AOUT_VERSION 0x40
+ extern int checkerflag;
+ #define CHKR_ENABLE   3
+ #define CHKR_ON_STACK 4
+ #define CHKR_VERBOSE  8
+ #define CHKR_FRAME_P  16
+ #define CHKR_ON_CALL  32
+ #define CHKR_STATS    64
+ #define CHKR_FNSTCW   128
  #endif
  
  #endif /* TC_I386 */
diff -rcp binutils-2.5.2l.17.orig/gas/read.c binutils-2.5.2l.17/gas/read.c
*** binutils-2.5.2l.17.orig/gas/read.c	Sat Mar 18 02:59:00 1995
--- binutils-2.5.2l.17/gas/read.c	Wed Jul  5 13:47:38 1995
*************** read_a_source_file (name)
*** 686,691 ****
--- 686,696 ----
  	      new_buf = xmalloc (100);
  	      new_length = 100;
  	      new_tmp = new_buf;
+ 	      
+ #ifdef CHECKER
+ 	      strcpy(new_tmp, ".appon\n");
+ 	      new_tmp += 7;
+ #endif
  
  	      scrub_string = s;
  	      scrub_last_string = ends;
*************** read_a_source_file (name)
*** 704,709 ****
--- 709,726 ----
  		      new_length += 100;
  		    }
  		}
+ 		
+ #ifdef CHECKER
+ 		/* 8 is strlen(".appoff\n") */
+ 		if ((new_tmp + 8) >= (new_buf + new_length))
+ 		  {
+ 		    new_buf = xrealloc (new_buf, new_length + 8);
+ 		    new_tmp = new_buf + new_length;
+ 		    new_length += 8;
+ 		  }
+ 		strcpy(new_tmp, ".appoff\n");
+ 		new_tmp += 8;
+ #endif
  
  	      if (tmp_buf)
  		free (tmp_buf);
diff -rcp binutils-2.5.2l.17.orig/include/opcode/i386.h binutils-2.5.2l.17/include/opcode/i386.h
*** binutils-2.5.2l.17.orig/include/opcode/i386.h	Fri Mar 24 03:50:57 1995
--- binutils-2.5.2l.17/include/opcode/i386.h	Wed Jul  5 14:15:40 1995
*************** You should have received a copy of the G
*** 17,193 ****
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
  
  static const template i386_optab[] = {
  
  #define _ None
  /* move instructions */
  #define MOV_AX_DISP32 0xa0
! { "mov", 2, 0xa0, _, DW|NoModrm, { Disp32, Acc, 0 } },
! { "mov", 2, 0x88, _, DW|Modrm, { Reg, Reg|Mem, 0 } },
! { "mov", 2, 0xb0, _, ShortFormW, { Imm, Reg, 0 } },
! { "mov", 2, 0xc6, _,  W|Modrm,  { Imm, Reg|Mem, 0 } },
! { "mov", 2, 0x8c, _, D|Modrm,  { SReg3|SReg2, Reg16|Mem, 0 } },
  /* move to/from control debug registers */
! { "mov", 2, 0x0f20, _, D|Modrm, { Control, Reg32, 0} },
! { "mov", 2, 0x0f21, _, D|Modrm, { Debug, Reg32, 0} },
! { "mov", 2, 0x0f24, _, D|Modrm, { Test, Reg32, 0} },
  
  /* move with sign extend */
  /* "movsbl" & "movsbw" must not be unified into "movsb" to avoid
     conflict with the "movs" string move instruction.  Thus,
     {"movsb", 2, 0x0fbe, _, ReverseRegRegmem|Modrm, { Reg8|Mem,  Reg16|Reg32, 0} },
     is not kosher; we must seperate the two instructions. */
! {"movsbl", 2, 0x0fbe, _, ReverseRegRegmem|Modrm|Data32, { Reg8|Mem,  Reg32, 0} },
! {"movsbw", 2, 0x0fbe, _, ReverseRegRegmem|Modrm|Data16, { Reg8|Mem,  Reg16, 0} },
! {"movswl", 2, 0x0fbf, _, ReverseRegRegmem|Modrm, { Reg16|Mem, Reg32, 0} },
  
  /* move with zero extend */
! {"movzb", 2, 0x0fb6, _, ReverseRegRegmem|Modrm, { Reg8|Mem, Reg16|Reg32, 0} },
! {"movzwl", 2, 0x0fb7, _, ReverseRegRegmem|Modrm, { Reg16|Mem, Reg32, 0} },
  
  /* push instructions */
! {"push", 1, 0x50, _, ShortForm, { WordReg,0,0 } },
! {"push", 1, 0xff, 0x6,  Modrm, { WordReg|WordMem, 0, 0 } },
! {"push", 1, 0x6a, _, NoModrm, { Imm8S, 0, 0} },
! {"push", 1, 0x68, _, NoModrm, { Imm16|Imm32, 0, 0} },
! {"push", 1, 0x06, _,  Seg2ShortForm, { SReg2,0,0 } },
! {"push", 1, 0x0fa0, _, Seg3ShortForm, { SReg3,0,0 } },
  /* push all */
! {"pusha", 0, 0x60, _, NoModrm, { 0, 0, 0 } },
  
  /* pop instructions */
! {"pop", 1, 0x58, _, ShortForm, { WordReg,0,0 } },
! {"pop", 1, 0x8f, 0x0,  Modrm, { WordReg|WordMem, 0, 0 } },
  #define POP_SEG_SHORT 0x7
! {"pop", 1, 0x07, _,  Seg2ShortForm, { SReg2,0,0 } },
! {"pop", 1, 0x0fa1, _, Seg3ShortForm, { SReg3,0,0 } },
  /* pop all */
! {"popa", 0, 0x61, _, NoModrm, { 0, 0, 0 } },
  
  /* xchg exchange instructions
     xchg commutes:  we allow both operand orders */
! {"xchg", 2, 0x90, _, ShortForm, { WordReg, Acc, 0 } },
! {"xchg", 2, 0x90, _, ShortForm, { Acc, WordReg, 0 } },
! {"xchg", 2, 0x86, _, W|Modrm, { Reg, Reg|Mem, 0 } },
! {"xchg", 2, 0x86, _, W|Modrm, { Reg|Mem, Reg, 0 } },
  
  /* in/out from ports */
! {"in", 2, 0xe4, _, W|NoModrm, { Imm8, Acc, 0 } },
! {"in", 2, 0xec, _, W|NoModrm, { InOutPortReg, Acc, 0 } },
! {"in", 1, 0xe4, _, W|NoModrm, { Imm8, 0, 0 } },
! {"in", 1, 0xec, _, W|NoModrm, { InOutPortReg, 0, 0 } },
! {"out", 2, 0xe6, _, W|NoModrm, { Acc, Imm8, 0 } },
! {"out", 2, 0xee, _, W|NoModrm, { Acc, InOutPortReg, 0 } },
! {"out", 1, 0xe6, _, W|NoModrm, { Imm8, 0, 0 } },
! {"out", 1, 0xee, _, W|NoModrm, { InOutPortReg, 0, 0 } },
  
  /* load effective address */
! {"lea", 2, 0x8d, _, Modrm, { WordMem, WordReg, 0 } },
  
  /* load segment registers from memory */
! {"lds", 2, 0xc5, _, Modrm, { Mem, Reg32, 0} },
! {"les", 2, 0xc4, _, Modrm, { Mem, Reg32, 0} },
! {"lfs", 2, 0x0fb4, _, Modrm, { Mem, Reg32, 0} },
! {"lgs", 2, 0x0fb5, _, Modrm, { Mem, Reg32, 0} },
! {"lss", 2, 0x0fb2, _, Modrm, { Mem, Reg32, 0} },
  
  /* flags register instructions */
! {"clc", 0, 0xf8, _, NoModrm, { 0, 0, 0} },
! {"cld", 0, 0xfc, _, NoModrm, { 0, 0, 0} },
! {"cli", 0, 0xfa, _, NoModrm, { 0, 0, 0} },
! {"clts", 0, 0x0f06, _, NoModrm, { 0, 0, 0} },
! {"cmc", 0, 0xf5, _, NoModrm, { 0, 0, 0} },
! {"lahf", 0, 0x9f, _, NoModrm, { 0, 0, 0} },
! {"sahf", 0, 0x9e, _, NoModrm, { 0, 0, 0} },
! {"pushf", 0, 0x9c, _, NoModrm|Data32, { 0, 0, 0} },
! {"popf", 0, 0x9d, _, NoModrm|Data32, { 0, 0, 0} },
! {"pushfl", 0, 0x9c, _, NoModrm|Data32, { 0, 0, 0} },
! {"popfl", 0, 0x9d, _, NoModrm|Data32, { 0, 0, 0} },
! {"pushfw", 0, 0x9c, _, NoModrm|Data16, { 0, 0, 0} },
! {"popfw", 0, 0x9d, _, NoModrm|Data16, { 0, 0, 0} },
! {"stc", 0, 0xf9, _, NoModrm, { 0, 0, 0} },
! {"std", 0, 0xfd, _, NoModrm, { 0, 0, 0} },
! {"sti", 0, 0xfb, _, NoModrm, { 0, 0, 0} },
! 
! {"add", 2, 0x0,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"add", 2, 0x83, 0,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"add", 2, 0x4,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"add", 2, 0x80, 0, W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"inc", 1, 0x40, _, ShortForm, { WordReg, 0, 0} },
! {"inc", 1, 0xfe, 0, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"sub", 2, 0x28,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"sub", 2, 0x83, 5,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"sub", 2, 0x2c,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"sub", 2, 0x80, 5,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"dec", 1, 0x48, _, ShortForm, { WordReg, 0, 0} },
! {"dec", 1, 0xfe, 1, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"sbb", 2, 0x18,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"sbb", 2, 0x83, 3,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"sbb", 2, 0x1c,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"sbb", 2, 0x80, 3,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"cmp", 2, 0x38,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"cmp", 2, 0x83, 7,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"cmp", 2, 0x3c,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"cmp", 2, 0x80, 7,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"test", 2, 0x84, _, W|Modrm, { Reg|Mem, Reg, 0} },
! {"test", 2, 0x84, _, W|Modrm, { Reg, Reg|Mem, 0} },
! {"test", 2, 0xa8, _, W|NoModrm, { Imm, Acc, 0} },
! {"test", 2, 0xf6, 0, W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"and", 2, 0x20,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"and", 2, 0x83, 4,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"and", 2, 0x24,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"and", 2, 0x80, 4,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"or", 2, 0x08,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"or", 2, 0x83, 1,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"or", 2, 0x0c,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"or", 2, 0x80, 1,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"xor", 2, 0x30,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"xor", 2, 0x83, 6,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"xor", 2, 0x34,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"xor", 2, 0x80, 6,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"adc", 2, 0x10,  _, DW|Modrm, { Reg, Reg|Mem, 0} },
! {"adc", 2, 0x83, 2,  Modrm, { Imm8S, WordReg|WordMem, 0} },
! {"adc", 2, 0x14,  _,  W|NoModrm, { Imm,  Acc,    0} },
! {"adc", 2, 0x80, 2,  W|Modrm, { Imm, Reg|Mem, 0} },
! 
! {"neg", 1, 0xf6, 3, W|Modrm, { Reg|Mem, 0, 0} },
! {"not", 1, 0xf6, 2, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"aaa", 0, 0x37, _, NoModrm, { 0, 0, 0} },
! {"aas", 0, 0x3f, _, NoModrm, { 0, 0, 0} },
! {"daa", 0, 0x27, _, NoModrm, { 0, 0, 0} },
! {"das", 0, 0x2f, _, NoModrm, { 0, 0, 0} },
! {"aad", 0, 0xd50a, _, NoModrm, { 0, 0, 0} },
! {"aam", 0, 0xd40a, _, NoModrm, { 0, 0, 0} },
  
  /* conversion insns */
  /* conversion:  intel naming */
! {"cbw", 0, 0x98, _, NoModrm|Data16, { 0, 0, 0} },
! {"cwd", 0, 0x99, _, NoModrm|Data16, { 0, 0, 0} },
! {"cwde", 0, 0x98, _, NoModrm|Data32, { 0, 0, 0} },
! {"cdq", 0, 0x99, _, NoModrm|Data32, { 0, 0, 0} },
  /*  att naming */
! {"cbtw", 0, 0x98, _, NoModrm|Data16, { 0, 0, 0} },
! {"cwtl", 0, 0x98, _, NoModrm|Data32, { 0, 0, 0} },
! {"cwtd", 0, 0x99, _, NoModrm|Data16, { 0, 0, 0} },
! {"cltd", 0, 0x99, _, NoModrm|Data32, { 0, 0, 0} },
  
  /* Warning! the mul/imul (opcode 0xf6) must only have 1 operand!  They are
     expanding 64-bit multiplies, and *cannot* be selected to accomplish
     'imul %ebx, %eax' (opcode 0x0faf must be used in this case)
     These multiplies can only be selected with single operand forms. */
! {"mul",  1, 0xf6, 4, W|Modrm, { Reg|Mem, 0, 0} },
! {"imul", 1, 0xf6, 5, W|Modrm, { Reg|Mem, 0, 0} },
  
  
  
--- 17,199 ----
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
  
+ #ifdef CHECKER
+ #define C(a) ,a
+ #else
+ #define C(a)
+ #endif
+ 
  static const template i386_optab[] = {
  
  #define _ None
  /* move instructions */
  #define MOV_AX_DISP32 0xa0
! { "mov", 2, 0xa0, _, DW|NoModrm, { Disp32, Acc, 0 } C(ReadMem)},
! { "mov", 2, 0x88, _, DW|Modrm, { Reg, Reg|Mem, 0 } C(WriteMem)},
! { "mov", 2, 0xb0, _, ShortFormW, { Imm, Reg, 0 } C(NoMemAcc)},
! { "mov", 2, 0xc6, _,  W|Modrm,  { Imm, Reg|Mem, 0 } C(WriteMem)},
! { "mov", 2, 0x8c, _, D|Modrm,  { SReg3|SReg2, Reg16|Mem, 0 } C(WriteMem)},
  /* move to/from control debug registers */
! { "mov", 2, 0x0f20, _, D|Modrm, { Control, Reg32, 0} C(NoMemAcc)},
! { "mov", 2, 0x0f21, _, D|Modrm, { Debug, Reg32, 0} C(NoMemAcc)},
! { "mov", 2, 0x0f24, _, D|Modrm, { Test, Reg32, 0} C(NoMemAcc)},
  
  /* move with sign extend */
  /* "movsbl" & "movsbw" must not be unified into "movsb" to avoid
     conflict with the "movs" string move instruction.  Thus,
     {"movsb", 2, 0x0fbe, _, ReverseRegRegmem|Modrm, { Reg8|Mem,  Reg16|Reg32, 0} },
     is not kosher; we must seperate the two instructions. */
! {"movsbl", 2, 0x0fbe, _, ReverseRegRegmem|Modrm|Data32, { Reg8|Mem,  Reg32, 0} C(CvOp|ReadMem)},
! {"movsbw", 2, 0x0fbe, _, ReverseRegRegmem|Modrm|Data16, { Reg8|Mem,  Reg16, 0} C(CvOp|ReadMem)},
! {"movswl", 2, 0x0fbf, _, ReverseRegRegmem|Modrm, { Reg16|Mem, Reg32, 0} C(CvOp|ReadMem)},
  
  /* move with zero extend */
! {"movzb", 2, 0x0fb6, _, ReverseRegRegmem|Modrm, { Reg8|Mem, Reg16|Reg32, 0} C(CvOp|ReadMem)},
! {"movzwl", 2, 0x0fb7, _, ReverseRegRegmem|Modrm, { Reg16|Mem, Reg32, 0} C(CvOp|ReadMem)},
  
  /* push instructions */
! {"push", 1, 0x50, _, ShortForm, { WordReg,0,0 } C(PushOp)},
! {"push", 1, 0xff, 0x6,  Modrm, { WordReg|WordMem, 0, 0 } C(PushOp)},
! {"push", 1, 0x6a, _, NoModrm, { Imm8S, 0, 0} C(PushOp)},
! {"push", 1, 0x68, _, NoModrm, {Imm16|Imm32, 0, 0} C(PushOp)},
! {"push", 1, 0x06, _,  Seg2ShortForm, { SReg2,0,0 } C(PushOp)},
! {"push", 1, 0x0fa0, _, Seg3ShortForm, { SReg3,0,0 } C(PushOp)},
  /* push all */
! {"pusha", 0, 0x60, _, NoModrm, { 0, 0, 0 } C(PushOp)},
  
  /* pop instructions */
! {"pop", 1, 0x58, _, ShortForm, { WordReg,0,0 } C(PopOp)},
! {"pop", 1, 0x8f, 0x0,  Modrm, { WordReg|WordMem, 0, 0 } C(PopOp)},
  #define POP_SEG_SHORT 0x7
! {"pop", 1, 0x07, _,  Seg2ShortForm, { SReg2,0,0 } C(PopOp)},
! {"pop", 1, 0x0fa1, _, Seg3ShortForm, { SReg3,0,0 } C(PopOp)},
  /* pop all */
! {"popa", 0, 0x61, _, NoModrm, { 0, 0, 0 } C(PopOp)},
  
  /* xchg exchange instructions
     xchg commutes:  we allow both operand orders */
! {"xchg", 2, 0x90, _, ShortForm, { WordReg, Acc, 0 } C(NoMemAcc)},
! {"xchg", 2, 0x90, _, ShortForm, { Acc, WordReg, 0 } C(NoMemAcc)},
! {"xchg", 2, 0x86, _, W|Modrm, { Reg, Reg|Mem, 0 } C(RAndWMem)},
! {"xchg", 2, 0x86, _, W|Modrm, { Reg|Mem, Reg, 0 } C(RAndWMem)},
  
  /* in/out from ports */
! {"in", 2, 0xe4, _, W|NoModrm, { Imm8, Acc, 0 } C(NoMemAcc)},
! {"in", 2, 0xec, _, W|NoModrm, { InOutPortReg, Acc, 0 } C(NoMemAcc)},
! {"in", 1, 0xe4, _, W|NoModrm, { Imm8, 0, 0 } C(NoMemAcc)},
! {"in", 1, 0xec, _, W|NoModrm, { InOutPortReg, 0, 0 } C(NoMemAcc)},
! {"out", 2, 0xe6, _, W|NoModrm, { Acc, Imm8, 0 } C(NoMemAcc)},
! {"out", 2, 0xee, _, W|NoModrm, { Acc, InOutPortReg, 0 } C(NoMemAcc)},
! {"out", 1, 0xe6, _, W|NoModrm, { Imm8, 0, 0 } C(NoMemAcc)},
! {"out", 1, 0xee, _, W|NoModrm, { InOutPortReg, 0, 0 } C(NoMemAcc)},
  
  /* load effective address */
! {"lea", 2, 0x8d, _, Modrm, { WordMem, WordReg, 0 } C(NoMemAcc)},
  
  /* load segment registers from memory */
! {"lds", 2, 0xc5, _, Modrm, { Mem, Reg32, 0} C(ReadMem|ErrOp)},
! {"les", 2, 0xc4, _, Modrm, { Mem, Reg32, 0} C(ReadMem|ErrOp)},
! {"lfs", 2, 0x0fb4, _, Modrm, { Mem, Reg32, 0} C(ReadMem|ErrOp)},
! {"lgs", 2, 0x0fb5, _, Modrm, { Mem, Reg32, 0} C(ReadMem|ErrOp)},
! {"lss", 2, 0x0fb2, _, Modrm, { Mem, Reg32, 0} C(ReadMem|ErrOp)},
  
  /* flags register instructions */
! {"clc", 0, 0xf8, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"cld", 0, 0xfc, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"cli", 0, 0xfa, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"clts", 0, 0x0f06, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"cmc", 0, 0xf5, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"lahf", 0, 0x9f, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"sahf", 0, 0x9e, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"pushf", 0, 0x9c, _, NoModrm|Data32, { 0, 0, 0} C(PushOp)},
! {"popf", 0, 0x9d, _, NoModrm|Data32, { 0, 0, 0} C(PopOp)},
! {"pushfl", 0, 0x9c, _, NoModrm|Data32, { 0, 0, 0} C(PushOp)},
! {"popfl", 0, 0x9d, _, NoModrm|Data32, { 0, 0, 0} C(PopOp)},
! {"pushfw", 0, 0x9c, _, NoModrm|Data16, { 0, 0, 0} C(PushOp)},
! {"popfw", 0, 0x9d, _, NoModrm|Data16, { 0, 0, 0} C(PopOp)},
! {"stc", 0, 0xf9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"std", 0, 0xfd, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"sti", 0, 0xfb, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! 
! {"add", 2, 0x0,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"add", 2, 0x83, 0,  Modrm, { Imm8S, WordReg|WordMem, 0} C(RAndWMem)},
! {"add", 2, 0x4,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"add", 2, 0x80, 0, W|Modrm, { Imm, Reg|Mem, 0} C(StOp|RAndWMem)},
! 
! {"inc", 1, 0x40, _, ShortForm, { WordReg, 0, 0} C(NoMemAcc)},
! {"inc", 1, 0xfe, 0, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"sub", 2, 0x28,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"sub", 2, 0x83, 5,  Modrm, { Imm8S, WordReg|WordMem, 0} C(RAndWMem)},
! {"sub", 2, 0x2c,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"sub", 2, 0x80, 5,  W|Modrm, { Imm, Reg|Mem, 0} C(RAndWMem)},
! 
! {"dec", 1, 0x48, _, ShortForm, { WordReg, 0, 0} C(NoMemAcc)},
! {"dec", 1, 0xfe, 1, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"sbb", 2, 0x18,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"sbb", 2, 0x83, 3,  Modrm, { Imm8S, WordReg|WordMem, 0} C(RAndWMem)},
! {"sbb", 2, 0x1c,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"sbb", 2, 0x80, 3,  W|Modrm, { Imm, Reg|Mem, 0} C(RAndWMem)},
! 
! {"cmp", 2, 0x38,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(ReadMem)},
! {"cmp", 2, 0x83, 7,  Modrm, { Imm8S, WordReg|WordMem, 0} C(ReadMem)},
! {"cmp", 2, 0x3c,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"cmp", 2, 0x80, 7,  W|Modrm, { Imm, Reg|Mem, 0} C(ReadMem)},
! 
! {"test", 2, 0x84, _, W|Modrm, { Reg|Mem, Reg, 0} C(ReadMem)},
! {"test", 2, 0x84, _, W|Modrm, { Reg, Reg|Mem, 0} C(ReadMem)},
! {"test", 2, 0xa8, _, W|NoModrm, { Imm, Acc, 0} C(NoMemAcc)},
! {"test", 2, 0xf6, 0, W|Modrm, { Imm, Reg|Mem, 0} C(ReadMem)},
! 
! {"and", 2, 0x20,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(WriteMem)},
! {"and", 2, 0x83, 4,  Modrm, { Imm8S, WordReg|WordMem, 0} C(WriteMem)},
! {"and", 2, 0x24,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"and", 2, 0x80, 4,  W|Modrm, { Imm, Reg|Mem, 0} C(WriteMem)},
! 
! {"or", 2, 0x08,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(WriteMem)},
! {"or", 2, 0x83, 1,  Modrm, { Imm8S, WordReg|WordMem, 0} C(WriteMem)},
! {"or", 2, 0x0c,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"or", 2, 0x80, 1,  W|Modrm, { Imm, Reg|Mem, 0} C(WriteMem)},
! 
! {"xor", 2, 0x30,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"xor", 2, 0x83, 6,  Modrm, { Imm8S, WordReg|WordMem, 0} C(RAndWMem)},
! {"xor", 2, 0x34,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"xor", 2, 0x80, 6,  W|Modrm, { Imm, Reg|Mem, 0} C(RAndWMem)},
! 
! {"adc", 2, 0x10,  _, DW|Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"adc", 2, 0x83, 2,  Modrm, { Imm8S, WordReg|WordMem, 0} C(RAndWMem)},
! {"adc", 2, 0x14,  _,  W|NoModrm, { Imm,  Acc,    0} C(NoMemAcc)},
! {"adc", 2, 0x80, 2,  W|Modrm, { Imm, Reg|Mem, 0} C(RAndWMem)},
! 
! {"neg", 1, 0xf6, 3, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! {"not", 1, 0xf6, 2, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"aaa", 0, 0x37, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"aas", 0, 0x3f, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"daa", 0, 0x27, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"das", 0, 0x2f, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"aad", 0, 0xd50a, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"aam", 0, 0xd40a, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  
  /* conversion insns */
  /* conversion:  intel naming */
! {"cbw", 0, 0x98, _, NoModrm|Data16, { 0, 0, 0} C(NoMemAcc)},
! {"cwd", 0, 0x99, _, NoModrm|Data16, { 0, 0, 0} C(NoMemAcc)},
! {"cwde", 0, 0x98, _, NoModrm|Data32, { 0, 0, 0} C(NoMemAcc)},
! {"cdq", 0, 0x99, _, NoModrm|Data32, { 0, 0, 0} C(NoMemAcc)},
  /*  att naming */
! {"cbtw", 0, 0x98, _, NoModrm|Data16, { 0, 0, 0} C(NoMemAcc)},
! {"cwtl", 0, 0x98, _, NoModrm|Data32, { 0, 0, 0} C(NoMemAcc)},
! {"cwtd", 0, 0x99, _, NoModrm|Data16, { 0, 0, 0} C(NoMemAcc)},
! {"cltd", 0, 0x99, _, NoModrm|Data32, { 0, 0, 0} C(NoMemAcc)},
  
  /* Warning! the mul/imul (opcode 0xf6) must only have 1 operand!  They are
     expanding 64-bit multiplies, and *cannot* be selected to accomplish
     'imul %ebx, %eax' (opcode 0x0faf must be used in this case)
     These multiplies can only be selected with single operand forms. */
! {"mul",  1, 0xf6, 4, W|Modrm, { Reg|Mem, 0, 0} C(ReadMem)},
! {"imul", 1, 0xf6, 5, W|Modrm, { Reg|Mem, 0, 0} C(ReadMem)},
  
  
  
*************** static const template i386_optab[] = {
*** 196,338 ****
     These instructions are exceptions:  'imul $2, %eax, %ecx' would put
     '%eax' in the reg field and '%ecx' in the regmem field if we did not
     switch them. */
! {"imul", 2, 0x0faf, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} },
! {"imul", 3, 0x6b, _, Modrm|ReverseRegRegmem, { Imm8S, WordReg|Mem, WordReg} },
! {"imul", 3, 0x69, _, Modrm|ReverseRegRegmem, { Imm16|Imm32, WordReg|Mem, WordReg} },
  /*
    imul with 2 operands mimicks imul with 3 by puting register both
    in i.rm.reg & i.rm.regmem fields
  */
! {"imul", 2, 0x6b, _, Modrm|imulKludge, { Imm8S, WordReg, 0} },
! {"imul", 2, 0x69, _, Modrm|imulKludge, { Imm16|Imm32, WordReg, 0} },
! {"div", 1, 0xf6, 6, W|Modrm, { Reg|Mem, 0, 0} },
! {"div", 2, 0xf6, 6, W|Modrm, { Reg|Mem, Acc, 0} },
! {"idiv", 1, 0xf6, 7, W|Modrm, { Reg|Mem, 0, 0} },
! {"idiv", 2, 0xf6, 7, W|Modrm, { Reg|Mem, Acc, 0} },
! 
! {"rol", 2, 0xd0, 0, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"rol", 2, 0xc0, 0, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"rol", 2, 0xd2, 0, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"rol", 1, 0xd0, 0, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"ror", 2, 0xd0, 1, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"ror", 2, 0xc0, 1, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"ror", 2, 0xd2, 1, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"ror", 1, 0xd0, 1, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"rcl", 2, 0xd0, 2, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"rcl", 2, 0xc0, 2, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"rcl", 2, 0xd2, 2, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"rcl", 1, 0xd0, 2, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"rcr", 2, 0xd0, 3, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"rcr", 2, 0xc0, 3, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"rcr", 2, 0xd2, 3, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"rcr", 1, 0xd0, 3, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"sal", 2, 0xd0, 4, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"sal", 2, 0xc0, 4, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"sal", 2, 0xd2, 4, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"sal", 1, 0xd0, 4, W|Modrm, { Reg|Mem, 0, 0} },
! {"shl", 2, 0xd0, 4, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"shl", 2, 0xc0, 4, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"shl", 2, 0xd2, 4, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"shl", 1, 0xd0, 4, W|Modrm, { Reg|Mem, 0, 0} },
  
! {"shld", 3, 0x0fa4, _, Modrm, { Imm8, WordReg, WordReg|Mem} },
! {"shld", 3, 0x0fa5, _, Modrm, { ShiftCount, WordReg, WordReg|Mem} },
  {"shld", 2, 0x0fa5, _, Modrm, { WordReg, WordReg|Mem, 0} },
  
! {"shr", 2, 0xd0, 5, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"shr", 2, 0xc0, 5, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"shr", 2, 0xd2, 5, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"shr", 1, 0xd0, 5, W|Modrm, { Reg|Mem, 0, 0} },
! 
! {"shrd", 3, 0x0fac, _, Modrm, { Imm8, WordReg, WordReg|Mem} },
! {"shrd", 3, 0x0fad, _, Modrm, { ShiftCount, WordReg, WordReg|Mem} },
! {"shrd", 2, 0x0fad, _, Modrm, { WordReg, WordReg|Mem, 0} },
! 
! {"sar", 2, 0xd0, 7, W|Modrm, { Imm1, Reg|Mem, 0} },
! {"sar", 2, 0xc0, 7, W|Modrm, { Imm8, Reg|Mem, 0} },
! {"sar", 2, 0xd2, 7, W|Modrm, { ShiftCount, Reg|Mem, 0} },
! {"sar", 1, 0xd0, 7, W|Modrm, { Reg|Mem, 0, 0} },
  
  /* control transfer instructions */
  #define CALL_PC_RELATIVE 0xe8
! {"call", 1, 0xe8, _, JumpDword, { Disp32, 0, 0} },
! {"call", 1, 0xff, 2, Modrm|Data32, { Reg|Mem|JumpAbsolute, 0, 0} },
! {"callw", 1, 0xff, 2, Modrm|Data16, { Reg|Mem|JumpAbsolute, 0, 0} },
  #define CALL_FAR_IMMEDIATE 0x9a
! {"lcall", 2, 0x9a, _, JumpInterSegment, { Imm16, Abs32|Imm32, 0} },
! {"lcall", 1, 0xff, 3, Modrm|Data32, { Mem, 0, 0} },
! {"lcallw", 1, 0xff, 3, Modrm|Data16, { Mem, 0, 0} },
  
  #define JUMP_PC_RELATIVE 0xeb
! {"jmp", 1, 0xeb, _, Jump, { Disp, 0, 0} },
! {"jmp", 1, 0xff, 4, Modrm, { Reg32|Mem|JumpAbsolute, 0, 0} },
  #define JUMP_FAR_IMMEDIATE 0xea
! {"ljmp", 2, 0xea, _, JumpInterSegment, { Imm16, Imm32, 0} },
! {"ljmp", 1, 0xff, 5, Modrm|Data32, { Mem, 0, 0} },
  
! {"ret", 0, 0xc3, _, NoModrm|Data32, { 0, 0, 0} },
! {"ret", 1, 0xc2, _, NoModrm|Data32, { Imm16, 0, 0} },
! {"retw", 0, 0xc3, _, NoModrm|Data16, { 0, 0, 0} },
! {"retw", 1, 0xc2, _, NoModrm|Data16, { Imm16, 0, 0} },
! {"lret", 0, 0xcb, _, NoModrm|Data32, { 0, 0, 0} },
! {"lret", 1, 0xca, _, NoModrm|Data32, { Imm16, 0, 0} },
! {"lretw", 0, 0xcb, _, NoModrm|Data16, { 0, 0, 0} },
! {"lretw", 1, 0xca, _, NoModrm|Data16, { Imm16, 0, 0} },
! {"enter", 2, 0xc8, _, NoModrm|Data32, { Imm16, Imm8, 0} },
! {"leave", 0, 0xc9, _, NoModrm|Data32, { 0, 0, 0} },
! {"enterw", 2, 0xc8, _, NoModrm|Data16, { Imm16, Imm8, 0} },
! {"leavew", 0, 0xc9, _, NoModrm|Data16, { 0, 0, 0} },
  
  /* conditional jumps */
! {"jo", 1, 0x70, _, Jump, { Disp, 0, 0} },
  
! {"jno", 1, 0x71, _, Jump, { Disp, 0, 0} },
  
! {"jb", 1, 0x72, _, Jump, { Disp, 0, 0} },
! {"jc", 1, 0x72, _, Jump, { Disp, 0, 0} },
! {"jnae", 1, 0x72, _, Jump, { Disp, 0, 0} },
  
! {"jnb", 1, 0x73, _, Jump, { Disp, 0, 0} },
! {"jnc", 1, 0x73, _, Jump, { Disp, 0, 0} },
! {"jae", 1, 0x73, _, Jump, { Disp, 0, 0} },
  
! {"je", 1, 0x74, _, Jump, { Disp, 0, 0} },
! {"jz", 1, 0x74, _, Jump, { Disp, 0, 0} },
  
! {"jne", 1, 0x75, _, Jump, { Disp, 0, 0} },
! {"jnz", 1, 0x75, _, Jump, { Disp, 0, 0} },
  
! {"jbe", 1, 0x76, _, Jump, { Disp, 0, 0} },
! {"jna", 1, 0x76, _, Jump, { Disp, 0, 0} },
  
! {"jnbe", 1, 0x77, _, Jump, { Disp, 0, 0} },
! {"ja", 1, 0x77, _, Jump, { Disp, 0, 0} },
  
! {"js", 1, 0x78, _, Jump, { Disp, 0, 0} },
  
! {"jns", 1, 0x79, _, Jump, { Disp, 0, 0} },
  
! {"jp", 1, 0x7a, _, Jump, { Disp, 0, 0} },
! {"jpe", 1, 0x7a, _, Jump, { Disp, 0, 0} },
  
! {"jnp", 1, 0x7b, _, Jump, { Disp, 0, 0} },
! {"jpo", 1, 0x7b, _, Jump, { Disp, 0, 0} },
  
! {"jl", 1, 0x7c, _, Jump, { Disp, 0, 0} },
! {"jnge", 1, 0x7c, _, Jump, { Disp, 0, 0} },
  
! {"jnl", 1, 0x7d, _, Jump, { Disp, 0, 0} },
! {"jge", 1, 0x7d, _, Jump, { Disp, 0, 0} },
  
! {"jle", 1, 0x7e, _, Jump, { Disp, 0, 0} },
! {"jng", 1, 0x7e, _, Jump, { Disp, 0, 0} },
  
! {"jnle", 1, 0x7f, _, Jump, { Disp, 0, 0} },
! {"jg", 1, 0x7f, _, Jump, { Disp, 0, 0} },
  
  #if 0  /* XXX where are these macros used?
  	  To get them working again, they need to take
--- 202,344 ----
     These instructions are exceptions:  'imul $2, %eax, %ecx' would put
     '%eax' in the reg field and '%ecx' in the regmem field if we did not
     switch them. */
! {"imul", 2, 0x0faf, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} C(ReadMem)},
! {"imul", 3, 0x6b, _, Modrm|ReverseRegRegmem, { Imm8S, WordReg|Mem, WordReg} C(ReadMem)},
! {"imul", 3, 0x69, _, Modrm|ReverseRegRegmem, { Imm16|Imm32, WordReg|Mem, WordReg} C(ReadMem)},
  /*
    imul with 2 operands mimicks imul with 3 by puting register both
    in i.rm.reg & i.rm.regmem fields
  */
! {"imul", 2, 0x6b, _, Modrm|imulKludge, { Imm8S, WordReg, 0} C(NoMemAcc)},
! {"imul", 2, 0x69, _, Modrm|imulKludge, { Imm16|Imm32, WordReg, 0} C(NoMemAcc)},
! {"div", 1, 0xf6, 6, W|Modrm, { Reg|Mem, 0, 0} C(ReadMem)},
! {"div", 2, 0xf6, 6, W|Modrm, { Reg|Mem, Acc, 0} C(ReadMem)},
! {"idiv", 1, 0xf6, 7, W|Modrm, { Reg|Mem, 0, 0} C(ReadMem)},
! {"idiv", 2, 0xf6, 7, W|Modrm, { Reg|Mem, Acc, 0} C(ReadMem)},
! 
! {"rol", 2, 0xd0, 0, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"rol", 2, 0xc0, 0, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"rol", 2, 0xd2, 0, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"rol", 1, 0xd0, 0, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"ror", 2, 0xd0, 1, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"ror", 2, 0xc0, 1, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"ror", 2, 0xd2, 1, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"ror", 1, 0xd0, 1, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"rcl", 2, 0xd0, 2, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"rcl", 2, 0xc0, 2, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"rcl", 2, 0xd2, 2, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"rcl", 1, 0xd0, 2, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"rcr", 2, 0xd0, 3, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"rcr", 2, 0xc0, 3, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"rcr", 2, 0xd2, 3, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"rcr", 1, 0xd0, 3, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"sal", 2, 0xd0, 4, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"sal", 2, 0xc0, 4, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"sal", 2, 0xd2, 4, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"sal", 1, 0xd0, 4, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! {"shl", 2, 0xd0, 4, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"shl", 2, 0xc0, 4, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"shl", 2, 0xd2, 4, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"shl", 1, 0xd0, 4, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
  
! {"shld", 3, 0x0fa4, _, Modrm, { Imm8, WordReg, WordReg|Mem} C(RAndWMem)},
! {"shld", 3, 0x0fa5, _, Modrm, { ShiftCount, WordReg, WordReg|Mem} C(RAndWMem)},
  {"shld", 2, 0x0fa5, _, Modrm, { WordReg, WordReg|Mem, 0} },
  
! {"shr", 2, 0xd0, 5, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"shr", 2, 0xc0, 5, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"shr", 2, 0xd2, 5, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"shr", 1, 0xd0, 5, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
! 
! {"shrd", 3, 0x0fac, _, Modrm, { Imm8, WordReg, WordReg|Mem} C(RAndWMem)},
! {"shrd", 3, 0x0fad, _, Modrm, { ShiftCount, WordReg, WordReg|Mem} C(RAndWMem)},
! {"shrd", 2, 0x0fad, _, Modrm, { WordReg, WordReg|Mem, 0} C(RAndWMem)},
! 
! {"sar", 2, 0xd0, 7, W|Modrm, { Imm1, Reg|Mem, 0} C(RAndWMem)},
! {"sar", 2, 0xc0, 7, W|Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"sar", 2, 0xd2, 7, W|Modrm, { ShiftCount, Reg|Mem, 0} C(RAndWMem)},
! {"sar", 1, 0xd0, 7, W|Modrm, { Reg|Mem, 0, 0} C(RAndWMem)},
  
  /* control transfer instructions */
  #define CALL_PC_RELATIVE 0xe8
! {"call", 1, 0xe8, _, JumpDword, { Disp32, 0, 0} C(CallOp)},
! {"call", 1, 0xff, 2, Modrm|Data32, { Reg|Mem|JumpAbsolute, 0, 0} C(ReadMem|CallOp)},
! {"callw", 1, 0xff, 2, Modrm|Data16, { Reg|Mem|JumpAbsolute, 0, 0} C(ReadMem|CallOp)},
  #define CALL_FAR_IMMEDIATE 0x9a
! {"lcall", 2, 0x9a, _, JumpInterSegment, { Imm16, Abs32|Imm32, 0} C(CallOp|ErrOp)},
! {"lcall", 1, 0xff, 3, Modrm|Data32, { Mem, 0, 0} C(ReadMem|CallOp|ErrOp)},
! {"lcallw", 1, 0xff, 3, Modrm|Data16, { Mem, 0, 0} C(ReadMem|CallOp|ErrOp)},
  
  #define JUMP_PC_RELATIVE 0xeb
! {"jmp", 1, 0xeb, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jmp", 1, 0xff, 4, Modrm, { Reg32|Mem|JumpAbsolute, 0, 0} C(ReadMem|JmpOp)},
  #define JUMP_FAR_IMMEDIATE 0xea
! {"ljmp", 2, 0xea, _, JumpInterSegment, { Imm16, Imm32, 0} C(NoMemAcc|ErrOp)},
! {"ljmp", 1, 0xff, 5, Modrm|Data32, { Mem, 0, 0} C(ReadMem|JmpOp|ErrOp)},
  
! {"ret", 0, 0xc3, _, NoModrm|Data32, { 0, 0, 0} C(StackOp)},
! {"ret", 1, 0xc2, _, NoModrm|Data32, { Imm16, 0, 0} C(StackOp)},
! {"retw", 0, 0xc3, _, NoModrm|Data16, { 0, 0, 0} C(StackOp)},
! {"retw", 1, 0xc2, _, NoModrm|Data16, { Imm16, 0, 0} C(StackOp)},
! {"lret", 0, 0xcb, _, NoModrm|Data32, { 0, 0, 0} C(StackOp|ErrOp)},
! {"lret", 1, 0xca, _, NoModrm|Data32, { Imm16, 0, 0} C(StackOp|ErrOp)},
! {"lretw", 0, 0xcb, _, NoModrm|Data16, { 0, 0, 0} C(StackOp|ErrOp)},
! {"lretw", 1, 0xca, _, NoModrm|Data16, { Imm16, 0, 0} C(StackOp|ErrOp)},
! {"enter", 2, 0xc8, _, NoModrm|Data32, { Imm16, Imm8, 0} C(StackOp)},
! {"leave", 0, 0xc9, _, NoModrm|Data32, { 0, 0, 0} C(StOp|StackOp)},
! {"enterw", 2, 0xc8, _, NoModrm|Data16, { Imm16, Imm8, 0} C(StackOp)},
! {"leavew", 0, 0xc9, _, NoModrm|Data16, { 0, 0, 0} C(StOp|StackOp)},
  
  /* conditional jumps */
! {"jo", 1, 0x70, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jno", 1, 0x71, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jb", 1, 0x72, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jc", 1, 0x72, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jnae", 1, 0x72, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jnb", 1, 0x73, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jnc", 1, 0x73, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jae", 1, 0x73, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"je", 1, 0x74, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jz", 1, 0x74, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jne", 1, 0x75, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jnz", 1, 0x75, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jbe", 1, 0x76, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jna", 1, 0x76, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jnbe", 1, 0x77, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"ja", 1, 0x77, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"js", 1, 0x78, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jns", 1, 0x79, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jp", 1, 0x7a, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jpe", 1, 0x7a, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jnp", 1, 0x7b, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jpo", 1, 0x7b, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jl", 1, 0x7c, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jnge", 1, 0x7c, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jnl", 1, 0x7d, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jge", 1, 0x7d, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jle", 1, 0x7e, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jng", 1, 0x7e, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
! {"jnle", 1, 0x7f, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
! {"jg", 1, 0x7f, _, Jump, { Disp, 0, 0} C(NoMemAcc)},
  
  #if 0  /* XXX where are these macros used?
  	  To get them working again, they need to take
*************** static const template i386_optab[] = {
*** 345,410 ****
    (o == 0xe3)
  #endif
  
! {"jcxz", 1, 0xe3, _, JumpByte|Data16, { Disp, 0, 0} },
! {"jecxz", 1, 0xe3, _, JumpByte|Data32, { Disp, 0, 0} },
  
  #define IS_LOOP_ECX_TIMES(o) \
    (o == 0xe2 || o == 0xe1 || o == 0xe0)
  
! {"loop", 1, 0xe2, _, JumpByte, { Disp, 0, 0} },
  
! {"loopz", 1, 0xe1, _, JumpByte, { Disp, 0, 0} },
! {"loope", 1, 0xe1, _, JumpByte, { Disp, 0, 0} },
  
! {"loopnz", 1, 0xe0, _, JumpByte, { Disp, 0, 0} },
! {"loopne", 1, 0xe0, _, JumpByte, { Disp, 0, 0} },
  
! /* set byte on flag instructions */
! {"seto", 1, 0x0f90, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setno", 1, 0x0f91, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setb", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setc", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setnae", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setnb", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setnc", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setae", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"sete", 1, 0x0f94, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setz", 1, 0x0f94, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setne", 1, 0x0f95, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setnz", 1, 0x0f95, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setbe", 1, 0x0f96, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setna", 1, 0x0f96, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setnbe", 1, 0x0f97, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"seta", 1, 0x0f97, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"sets", 1, 0x0f98, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setns", 1, 0x0f99, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setp", 1, 0x0f9a, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setpe", 1, 0x0f9a, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setnp", 1, 0x0f9b, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setpo", 1, 0x0f9b, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setl", 1, 0x0f9c, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setnge", 1, 0x0f9c, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setnl", 1, 0x0f9d, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setge", 1, 0x0f9d, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setle", 1, 0x0f9e, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setng", 1, 0x0f9e, 0, Modrm, { Reg8|Mem, 0, 0} },
  
! {"setnle", 1, 0x0f9f, 0, Modrm, { Reg8|Mem, 0, 0} },
! {"setg", 1, 0x0f9f, 0, Modrm, { Reg8|Mem, 0, 0} },
  
  #define IS_STRING_INSTRUCTION(o) \
    ((o) == 0xa6 || (o) == 0x6c || (o) == 0x6e || (o) == 0x6e || \
--- 351,416 ----
    (o == 0xe3)
  #endif
  
! {"jcxz", 1, 0xe3, _, JumpByte|Data16, { Disp, 0, 0} C(NoMemAcc)},
! {"jecxz", 1, 0xe3, _, JumpByte|Data32, { Disp, 0, 0} C(NoMemAcc)},
  
  #define IS_LOOP_ECX_TIMES(o) \
    (o == 0xe2 || o == 0xe1 || o == 0xe0)
  
! {"loop", 1, 0xe2, _, JumpByte, { Disp, 0, 0} C(NoMemAcc)},
  
! {"loopz", 1, 0xe1, _, JumpByte, { Disp, 0, 0} C(NoMemAcc)},
! {"loope", 1, 0xe1, _, JumpByte, { Disp, 0, 0} C(NoMemAcc)},
  
! {"loopnz", 1, 0xe0, _, JumpByte, { Disp, 0, 0} C(NoMemAcc)},
! {"loopne", 1, 0xe0, _, JumpByte, { Disp, 0, 0} C(NoMemAcc)},
  
! /* set byte on flag instructions */ /*TG: FIXME */
! {"seto", 1, 0x0f90, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setno", 1, 0x0f91, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setb", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setc", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setnae", 1, 0x0f92, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setnb", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setnc", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setae", 1, 0x0f93, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"sete", 1, 0x0f94, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setz", 1, 0x0f94, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setne", 1, 0x0f95, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setnz", 1, 0x0f95, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setbe", 1, 0x0f96, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setna", 1, 0x0f96, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setnbe", 1, 0x0f97, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"seta", 1, 0x0f97, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"sets", 1, 0x0f98, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setns", 1, 0x0f99, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setp", 1, 0x0f9a, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setpe", 1, 0x0f9a, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setnp", 1, 0x0f9b, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setpo", 1, 0x0f9b, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setl", 1, 0x0f9c, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setnge", 1, 0x0f9c, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setnl", 1, 0x0f9d, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setge", 1, 0x0f9d, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setle", 1, 0x0f9e, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setng", 1, 0x0f9e, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
! {"setnle", 1, 0x0f9f, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
! {"setg", 1, 0x0f9f, 0, Modrm, { Reg8|Mem, 0, 0} C(WriteMem)},
  
  #define IS_STRING_INSTRUCTION(o) \
    ((o) == 0xa6 || (o) == 0x6c || (o) == 0x6e || (o) == 0x6e || \
*************** static const template i386_optab[] = {
*** 412,757 ****
     (o) == 0xd7)
  
  /* string manipulation */
! {"cmps", 0, 0xa6, _, W|NoModrm, { 0, 0, 0} },
! {"scmp", 0, 0xa6, _, W|NoModrm, { 0, 0, 0} },
! {"ins", 0, 0x6c, _, W|NoModrm, { 0, 0, 0} },
! {"outs", 0, 0x6e, _, W|NoModrm, { 0, 0, 0} },
! {"lods", 0, 0xac, _, W|NoModrm, { 0, 0, 0} },
! {"slod", 0, 0xac, _, W|NoModrm, { 0, 0, 0} },
! {"movs", 0, 0xa4, _, W|NoModrm, { 0, 0, 0} },
! {"smov", 0, 0xa4, _, W|NoModrm, { 0, 0, 0} },
! {"scas", 0, 0xae, _, W|NoModrm, { 0, 0, 0} },
! {"ssca", 0, 0xae, _, W|NoModrm, { 0, 0, 0} },
! {"stos", 0, 0xaa, _, W|NoModrm, { 0, 0, 0} },
! {"ssto", 0, 0xaa, _, W|NoModrm, { 0, 0, 0} },
! {"xlat", 0, 0xd7, _, NoModrm, { 0, 0, 0} },
  
  /* bit manipulation */
! {"bsf", 2, 0x0fbc, _, Modrm|ReverseRegRegmem, { Reg|Mem, Reg, 0} },
! {"bsr", 2, 0x0fbd, _, Modrm|ReverseRegRegmem, { Reg|Mem, Reg, 0} },
! {"bt", 2, 0x0fa3, _, Modrm, { Reg, Reg|Mem, 0} },
! {"bt", 2, 0x0fba, 4, Modrm, { Imm8, Reg|Mem, 0} },
! {"btc", 2, 0x0fbb, _, Modrm, { Reg, Reg|Mem, 0} },
! {"btc", 2, 0x0fba, 7, Modrm, { Imm8, Reg|Mem, 0} },
! {"btr", 2, 0x0fb3, _, Modrm, { Reg, Reg|Mem, 0} },
! {"btr", 2, 0x0fba, 6, Modrm, { Imm8, Reg|Mem, 0} },
! {"bts", 2, 0x0fab, _, Modrm, { Reg, Reg|Mem, 0} },
! {"bts", 2, 0x0fba, 5, Modrm, { Imm8, Reg|Mem, 0} },
  
  /* interrupts & op. sys insns */
  /* See gas/config/tc-i386.c for conversion of 'int $3' into the special
     int 3 insn. */
  #define INT_OPCODE 0xcd
  #define INT3_OPCODE 0xcc
! {"int", 1, 0xcd, _, NoModrm, { Imm8, 0, 0} },
! {"int3", 0, 0xcc, _, NoModrm, { 0, 0, 0} },
! {"into", 0, 0xce, _, NoModrm, { 0, 0, 0} },
! {"iret", 0, 0xcf, _, NoModrm|Data32, { 0, 0, 0} },
! {"iretw", 0, 0xcf, _, NoModrm|Data16, { 0, 0, 0} },
  /* i386sl (and i486sl?) only */
! {"rsm", 0, 0x0faa, _, NoModrm,{ 0, 0, 0} },
  
! {"boundl", 2, 0x62, _, Modrm|Data32, { Reg32, Mem, 0} },
! {"boundw", 2, 0x62, _, Modrm|Data16, { Reg16, Mem, 0} },
  
! {"hlt", 0, 0xf4, _, NoModrm, { 0, 0, 0} },
! {"wait", 0, 0x9b, _, NoModrm, { 0, 0, 0} },
  /* nop is actually 'xchgl %eax, %eax' */
! {"nop", 0, 0x90, _, NoModrm, { 0, 0, 0} },
  
  /* protection control */
! {"arpl", 2, 0x63, _, Modrm, { Reg16, Reg16|Mem, 0} },
! {"lar", 2, 0x0f02, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} },
! {"lgdt", 1, 0x0f01, 2, Modrm, { Mem, 0, 0} },
! {"lidt", 1, 0x0f01, 3, Modrm, { Mem, 0, 0} },
! {"lldt", 1, 0x0f00, 2, Modrm, { WordReg|Mem, 0, 0} },
! {"lmsw", 1, 0x0f01, 6, Modrm, { WordReg|Mem, 0, 0} },
! {"lsl", 2, 0x0f03, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} },
! {"ltr", 1, 0x0f00, 3, Modrm, { WordReg|Mem, 0, 0} },
! 
! {"sgdt", 1, 0x0f01, 0, Modrm, { Mem, 0, 0} },
! {"sidt", 1, 0x0f01, 1, Modrm, { Mem, 0, 0} },
! {"sldt", 1, 0x0f00, 0, Modrm, { WordReg|Mem, 0, 0} },
! {"smsw", 1, 0x0f01, 4, Modrm, { WordReg|Mem, 0, 0} },
! {"str", 1, 0x0f00, 1, Modrm, { Reg16|Mem, 0, 0} },
  
! {"verr", 1, 0x0f00, 4, Modrm, { WordReg|Mem, 0, 0} },
! {"verw", 1, 0x0f00, 5, Modrm, { WordReg|Mem, 0, 0} },
  
  /* floating point instructions */
  
  /* load */
! {"fld", 1, 0xd9c0, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"flds", 1, 0xd9, 0, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem float */
! {"fldl", 1, 0xdd, 0, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem double */
! {"fldl", 1, 0xd9c0, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"fild", 1, 0xdf, 0, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem word (16) */
! {"fildl", 1, 0xdb, 0, Modrm, { Mem, 0, 0} },	/* %st0 <-- mem dword (32) */
! {"fildq",1, 0xdf, 5, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem qword (64) */
! {"fildll",1, 0xdf, 5, Modrm, { Mem, 0, 0} },	/* %st0 <-- mem qword (64) */
! {"fldt", 1, 0xdb, 5, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem efloat */
! {"fbld", 1, 0xdf, 4, Modrm, { Mem, 0, 0} },		/* %st0 <-- mem bcd */
  
  /* store (no pop) */
! {"fst", 1, 0xddd0, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"fsts", 1, 0xd9, 2, Modrm, { Mem, 0, 0} },		/* %st0 --> mem float */
! {"fstl", 1, 0xdd, 2, Modrm, { Mem, 0, 0} },		/* %st0 --> mem double */
! {"fstl", 1, 0xddd0, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"fist", 1, 0xdf, 2, Modrm, { Mem, 0, 0} },		/* %st0 --> mem word (16) */
! {"fistl", 1, 0xdb, 2, Modrm, { Mem, 0, 0} },	/* %st0 --> mem dword (32) */
  
  /* store (with pop) */
! {"fstp", 1, 0xddd8, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"fstps", 1, 0xd9, 3, Modrm, { Mem, 0, 0} },	/* %st0 --> mem float */
! {"fstpl", 1, 0xdd, 3, Modrm, { Mem, 0, 0} },	/* %st0 --> mem double */
! {"fstpl", 1, 0xddd8, _, ShortForm, { FloatReg, 0, 0} }, /* register */
! {"fistp", 1, 0xdf, 3, Modrm, { Mem, 0, 0} },	/* %st0 --> mem word (16) */
! {"fistpl",1, 0xdb, 3, Modrm, { Mem, 0, 0} },	/* %st0 --> mem dword (32) */
! {"fistpq",1, 0xdf, 7, Modrm, { Mem, 0, 0} },	/* %st0 --> mem qword (64) */
! {"fistpll",1,0xdf, 7, Modrm, { Mem, 0, 0} },	/* %st0 --> mem qword (64) */
! {"fstpt", 1, 0xdb, 7, Modrm, { Mem, 0, 0} },	/* %st0 --> mem efloat */
! {"fbstp", 1, 0xdf, 6, Modrm, { Mem, 0, 0} },	/* %st0 --> mem bcd */
  
  /* exchange %st<n> with %st0 */
! {"fxch", 1, 0xd9c8, _, ShortForm, { FloatReg, 0, 0} },
! {"fxch", 0, 0xd9c9, _, NoModrm, { 0, 0, 0} }, /* alias for fxch %st, %st(1) */
  
  /* comparison (without pop) */
! {"fcom", 1, 0xd8d0, _, ShortForm, { FloatReg, 0, 0} },
! {"fcoms", 1, 0xd8, 2, Modrm, { Mem, 0, 0} },	/* compare %st0, mem float  */
! {"ficoml", 1, 0xda, 2, Modrm, { Mem, 0, 0} },	/* compare %st0, mem word  */ 
! {"fcoml", 1, 0xdc, 2, Modrm, { Mem, 0, 0} },	/* compare %st0, mem double  */
! {"fcoml", 1, 0xd8d0, _, ShortForm, { FloatReg, 0, 0} },
! {"ficoms", 1, 0xde, 2, Modrm, { Mem, 0, 0} },	/* compare %st0, mem dword */
  
  /* comparison (with pop) */
! {"fcomp", 1, 0xd8d8, _, ShortForm, { FloatReg, 0, 0} },
! {"fcomps", 1, 0xd8, 3, Modrm, { Mem, 0, 0} },	/* compare %st0, mem float  */
! {"ficompl", 1, 0xda, 3, Modrm, { Mem, 0, 0} },	/* compare %st0, mem word  */ 
! {"fcompl", 1, 0xdc, 3, Modrm, { Mem, 0, 0} },	/* compare %st0, mem double  */
! {"fcompl", 1, 0xd8d8, _, ShortForm, { FloatReg, 0, 0} },
! {"ficomps", 1, 0xde, 3, Modrm, { Mem, 0, 0} },	/* compare %st0, mem dword */
! {"fcompp", 0, 0xded9, _, NoModrm, { 0, 0, 0} },	/* compare %st0, %st1 & pop 2 */
  
  /* unordered comparison (with pop) */
! {"fucom", 1, 0xdde0, _, ShortForm, { FloatReg, 0, 0} },
! {"fucomp", 1, 0xdde8, _, ShortForm, { FloatReg, 0, 0} },
! {"fucompp", 0, 0xdae9, _, NoModrm, { 0, 0, 0} }, /* ucompare %st0, %st1 & pop twice */
  
! {"ftst", 0, 0xd9e4, _, NoModrm, { 0, 0, 0} },	/* test %st0 */
! {"fxam", 0, 0xd9e5, _, NoModrm, { 0, 0, 0} },	/* examine %st0 */
  
  /* load constants into %st0 */
! {"fld1", 0, 0xd9e8, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- 1.0 */
! {"fldl2t", 0, 0xd9e9, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- log2(10) */
! {"fldl2e", 0, 0xd9ea, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- log2(e) */
! {"fldpi", 0, 0xd9eb, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- pi */
! {"fldlg2", 0, 0xd9ec, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- log10(2) */
! {"fldln2", 0, 0xd9ed, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- ln(2) */
! {"fldz", 0, 0xd9ee, _, NoModrm, { 0, 0, 0} },	/* %st0 <-- 0.0 */
  
  /* arithmetic */
  
  /* add */
! {"fadd", 1, 0xd8c0, _, ShortForm, { FloatReg, 0, 0} },
! {"fadd", 2, 0xd8c0, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} },
! {"fadd", 0, 0xdcc1, _, NoModrm, { 0, 0, 0} }, /* alias for fadd %st, %st(1) */
! {"faddp", 1, 0xdac0, _, ShortForm, { FloatReg, 0, 0} },
! {"faddp", 2, 0xdac0, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} },
! {"faddp", 0, 0xdec1, _, NoModrm, { 0, 0, 0} }, /* alias for faddp %st, %st(1) */
! {"fadds", 1, 0xd8, 0, Modrm, { Mem, 0, 0} },
! {"fiaddl", 1, 0xda, 0, Modrm, { Mem, 0, 0} },
! {"faddl", 1, 0xdc, 0, Modrm, { Mem, 0, 0} },
! {"fiadds", 1, 0xde, 0, Modrm, { Mem, 0, 0} },
  
  /* sub */
  /* Note:  intel has decided that certain of these operations are reversed
     in assembler syntax. */
! {"fsub", 1, 0xd8e0, _, ShortForm, { FloatReg, 0, 0} },
! {"fsub", 2, 0xd8e0, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fsub", 2, 0xdce8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fsub", 2, 0xdce0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fsub", 0, 0xdce1, _, NoModrm, { 0, 0, 0} },
! {"fsubp", 1, 0xdae0, _, ShortForm, { FloatReg, 0, 0} },
! {"fsubp", 2, 0xdae0, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fsubp", 2, 0xdee8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fsubp", 2, 0xdee0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fsubp", 0, 0xdee1, _, NoModrm, { 0, 0, 0} },
! {"fsubs", 1, 0xd8, 4, Modrm, { Mem, 0, 0} },
! {"fisubl", 1, 0xda, 4, Modrm, { Mem, 0, 0} },
! {"fsubl", 1, 0xdc, 4, Modrm, { Mem, 0, 0} },
! {"fisubs", 1, 0xde, 4, Modrm, { Mem, 0, 0} },
  
  /* sub reverse */
! {"fsubr", 1, 0xd8e8, _, ShortForm, { FloatReg, 0, 0} },
! {"fsubr", 2, 0xd8e8, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fsubr", 2, 0xdce0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fsubr", 2, 0xdce8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fsubr", 0, 0xdce9, _, NoModrm, { 0, 0, 0} },
! {"fsubrp", 1, 0xdae8, _, ShortForm, { FloatReg, 0, 0} },
! {"fsubrp", 2, 0xdae8, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fsubrp", 2, 0xdee0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fsubrp", 2, 0xdee8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fsubrp", 0, 0xdee9, _, NoModrm, { 0, 0, 0} },
! {"fsubrs", 1, 0xd8, 5, Modrm, { Mem, 0, 0} },
! {"fisubrl", 1, 0xda, 5, Modrm, { Mem, 0, 0} },
! {"fsubrl", 1, 0xdc, 5, Modrm, { Mem, 0, 0} },
! {"fisubrs", 1, 0xde, 5, Modrm, { Mem, 0, 0} },
  
  /* mul */
! {"fmul", 1, 0xd8c8, _, ShortForm, { FloatReg, 0, 0} },
! {"fmul", 2, 0xd8c8, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} },
! {"fmul", 0, 0xdcc9, _, NoModrm, { 0, 0, 0} },
! {"fmulp", 1, 0xdac8, _, ShortForm, { FloatReg, 0, 0} },
! {"fmulp", 2, 0xdac8, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} },
! {"fmulp", 0, 0xdec9, _, NoModrm, { 0, 0, 0} },
! {"fmuls", 1, 0xd8, 1, Modrm, { Mem, 0, 0} },
! {"fimull", 1, 0xda, 1, Modrm, { Mem, 0, 0} },
! {"fmull", 1, 0xdc, 1, Modrm, { Mem, 0, 0} },
! {"fimuls", 1, 0xde, 1, Modrm, { Mem, 0, 0} },
  
  /* div */
  /* Note:  intel has decided that certain of these operations are reversed
     in assembler syntax. */
! {"fdiv", 1, 0xd8f0, _, ShortForm, { FloatReg, 0, 0} },
! {"fdiv", 2, 0xd8f0, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fdiv", 2, 0xdcf8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fdiv", 2, 0xdcf0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fdiv", 0, 0xdcf1, _, NoModrm, { 0, 0, 0} },
! {"fdivp", 1, 0xdaf0, _, ShortForm, { FloatReg, 0, 0} },
! {"fdivp", 2, 0xdaf0, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fdivp", 2, 0xdef8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fdivp", 2, 0xdef0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fdivp", 0, 0xdef1, _, NoModrm, { 0, 0, 0} },
! {"fdivs", 1, 0xd8, 6, Modrm, { Mem, 0, 0} },
! {"fidivl", 1, 0xda, 6, Modrm, { Mem, 0, 0} },
! {"fdivl", 1, 0xdc, 6, Modrm, { Mem, 0, 0} },
! {"fidivs", 1, 0xde, 6, Modrm, { Mem, 0, 0} },
  
  /* div reverse */
! {"fdivr", 1, 0xd8f8, _, ShortForm, { FloatReg, 0, 0} },
! {"fdivr", 2, 0xd8f8, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fdivr", 2, 0xdcf0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fdivr", 2, 0xdcf8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fdivr", 0, 0xdcf9, _, NoModrm, { 0, 0, 0} },
! {"fdivrp", 1, 0xdaf8, _, ShortForm, { FloatReg, 0, 0} },
! {"fdivrp", 2, 0xdaf8, _, ShortForm, { FloatReg, FloatAcc, 0} },
  #ifdef NON_BROKEN_OPCODES
! {"fdivrp", 2, 0xdef0, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #else
! {"fdivrp", 2, 0xdef8, _, ShortForm, { FloatAcc, FloatReg, 0} },
  #endif
! {"fdivrp", 0, 0xdef9, _, NoModrm, { 0, 0, 0} },
! {"fdivrs", 1, 0xd8, 7, Modrm, { Mem, 0, 0} },
! {"fidivrl", 1, 0xda, 7, Modrm, { Mem, 0, 0} },
! {"fdivrl", 1, 0xdc, 7, Modrm, { Mem, 0, 0} },
! {"fidivrs", 1, 0xde, 7, Modrm, { Mem, 0, 0} },
! 
! {"f2xm1", 0,   0xd9f0, _, NoModrm, { 0, 0, 0} },
! {"fyl2x", 0,   0xd9f1, _, NoModrm, { 0, 0, 0} },
! {"fptan", 0,   0xd9f2, _, NoModrm, { 0, 0, 0} },
! {"fpatan", 0,  0xd9f3, _, NoModrm, { 0, 0, 0} },
! {"fxtract", 0, 0xd9f4, _, NoModrm, { 0, 0, 0} },
! {"fprem1", 0,  0xd9f5, _, NoModrm, { 0, 0, 0} },
! {"fdecstp", 0,  0xd9f6, _, NoModrm, { 0, 0, 0} },
! {"fincstp", 0,  0xd9f7, _, NoModrm, { 0, 0, 0} },
! {"fprem", 0,   0xd9f8, _, NoModrm, { 0, 0, 0} },
! {"fyl2xp1", 0, 0xd9f9, _, NoModrm, { 0, 0, 0} },
! {"fsqrt", 0,   0xd9fa, _, NoModrm, { 0, 0, 0} },
! {"fsincos", 0, 0xd9fb, _, NoModrm, { 0, 0, 0} },
! {"frndint", 0, 0xd9fc, _, NoModrm, { 0, 0, 0} },
! {"fscale", 0,  0xd9fd, _, NoModrm, { 0, 0, 0} },
! {"fsin", 0,    0xd9fe, _, NoModrm, { 0, 0, 0} },
! {"fcos", 0,    0xd9ff, _, NoModrm, { 0, 0, 0} },
  
! {"fchs", 0, 0xd9e0, _, NoModrm, { 0, 0, 0} },
! {"fabs", 0, 0xd9e1, _, NoModrm, { 0, 0, 0} },
  
  /* processor control */
! {"fninit", 0, 0xdbe3, _, NoModrm, { 0, 0, 0} },
! {"finit", 0, 0xdbe3, _, NoModrm, { 0, 0, 0} },
! {"fldcw", 1, 0xd9, 5, Modrm, { Mem, 0, 0} },
! {"fnstcw", 1, 0xd9, 7, Modrm, { Mem, 0, 0} },
! {"fstcw", 1, 0xd9, 7, Modrm, { Mem, 0, 0} },
! {"fnstsw", 1, 0xdfe0, _, NoModrm, { Acc, 0, 0} },
! {"fnstsw", 1, 0xdd, 7, Modrm, { Mem, 0, 0} },
! {"fnstsw", 0, 0xdfe0, _, NoModrm, { 0, 0, 0} },
! {"fstsw", 1, 0xdfe0, _, NoModrm, { Acc, 0, 0} },
! {"fstsw", 1, 0xdd, 7, Modrm, { Mem, 0, 0} },
! {"fstsw", 0, 0xdfe0, _, NoModrm, { 0, 0, 0} },
! {"fnclex", 0, 0xdbe2, _, NoModrm, { 0, 0, 0} },
! {"fclex", 0, 0xdbe2, _, NoModrm, { 0, 0, 0} },
  /*
   We ignore the short format (287) versions of fstenv/fldenv & fsave/frstor
   instructions;  i'm not sure how to add them or how they are different.
   My 386/387 book offers no details about this.
  */
! {"fnstenv", 1, 0xd9, 6, Modrm, { Mem, 0, 0} },
! {"fstenv", 1, 0xd9, 6, Modrm, { Mem, 0, 0} },
! {"fldenv", 1, 0xd9, 4, Modrm, { Mem, 0, 0} },
! {"fnsave", 1, 0xdd, 6, Modrm, { Mem, 0, 0} },
! {"fsave", 1, 0xdd, 6, Modrm, { Mem, 0, 0} },
! {"frstor", 1, 0xdd, 4, Modrm, { Mem, 0, 0} },
! 
! {"ffree", 1, 0xddc0, _, ShortForm, { FloatReg, 0, 0} },
! {"fnop", 0, 0xd9d0, _, NoModrm, { 0, 0, 0} },
! {"fwait", 0, 0x9b, _, NoModrm, { 0, 0, 0} },
  
  /*
    opcode prefixes; we allow them as seperate insns too
    (see prefix table below)
  */
! {"aword", 0, 0x67, _, NoModrm, { 0, 0, 0} },
! {"addr16", 0, 0x67, _, NoModrm, { 0, 0, 0} },
! {"word", 0, 0x66, _, NoModrm, { 0, 0, 0} },
! {"data16", 0, 0x66, _, NoModrm, { 0, 0, 0} },
! {"lock", 0, 0xf0, _, NoModrm, { 0, 0, 0} },
! {"cs", 0, 0x2e, _, NoModrm, { 0, 0, 0} },
! {"ds", 0, 0x3e, _, NoModrm, { 0, 0, 0} },
! {"es", 0, 0x26, _, NoModrm, { 0, 0, 0} },
! {"fs", 0, 0x64, _, NoModrm, { 0, 0, 0} },
! {"gs", 0, 0x65, _, NoModrm, { 0, 0, 0} },
! {"ss", 0, 0x36, _, NoModrm, { 0, 0, 0} },
! {"rep", 0, 0xf3, _, NoModrm, { 0, 0, 0} },
! {"repe", 0, 0xf3, _, NoModrm, { 0, 0, 0} },
! {"repz", 0, 0xf3, _, NoModrm, { 0, 0, 0} },
! {"repne", 0, 0xf2, _, NoModrm, { 0, 0, 0} },
! {"repnz", 0, 0xf2, _, NoModrm, { 0, 0, 0} },
  
  /* 486 extensions */
  
! {"bswap", 1, 0x0fc8, _, ShortForm, { Reg32,0,0 } },
! {"xadd", 2, 0x0fc0, _, DW|Modrm, { Reg, Reg|Mem, 0 } },
! {"cmpxchg", 2, 0x0fb0, _, DW|Modrm, { Reg, Reg|Mem, 0 } },
! {"invd", 0, 0x0f08, _, NoModrm, { 0, 0, 0} },
! {"wbinvd", 0, 0x0f09, _, NoModrm, { 0, 0, 0} },
! {"invlpg", 1, 0x0f01, 7, Modrm, { Mem, 0, 0} },
  
  /* 586 extensions */
  {"cpuid", 0, 0x0fa2, _, NoModrm, { 0, 0, 0} },
  
! {"", 0, 0, 0, 0, { 0, 0, 0} }	/* sentinel */
  };
  #undef _
  
--- 418,763 ----
     (o) == 0xd7)
  
  /* string manipulation */
! {"cmps", 0, 0xa6, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"scmp", 0, 0xa6, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"ins", 0, 0x6c, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"outs", 0, 0x6e, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"lods", 0, 0xac, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"slod", 0, 0xac, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"movs", 0, 0xa4, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"smov", 0, 0xa4, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"scas", 0, 0xae, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"ssca", 0, 0xae, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"stos", 0, 0xaa, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"ssto", 0, 0xaa, _, W|NoModrm, { 0, 0, 0} C(StrOp)},
! {"xlat", 0, 0xd7, _, NoModrm, { 0, 0, 0} C(StrOp)},
  
  /* bit manipulation */
! {"bsf", 2, 0x0fbc, _, Modrm|ReverseRegRegmem, { Reg|Mem, Reg, 0} C(RAndWMem)},
! {"bsr", 2, 0x0fbd, _, Modrm|ReverseRegRegmem, { Reg|Mem, Reg, 0} C(RAndWMem)},
! {"bt", 2, 0x0fa3, _, Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"bt", 2, 0x0fba, 4, Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"btc", 2, 0x0fbb, _, Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"btc", 2, 0x0fba, 7, Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"btr", 2, 0x0fb3, _, Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"btr", 2, 0x0fba, 6, Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
! {"bts", 2, 0x0fab, _, Modrm, { Reg, Reg|Mem, 0} C(RAndWMem)},
! {"bts", 2, 0x0fba, 5, Modrm, { Imm8, Reg|Mem, 0} C(RAndWMem)},
  
  /* interrupts & op. sys insns */
  /* See gas/config/tc-i386.c for conversion of 'int $3' into the special
     int 3 insn. */
  #define INT_OPCODE 0xcd
  #define INT3_OPCODE 0xcc
! {"int", 1, 0xcd, _, NoModrm, { Imm8, 0, 0} C(IntOp)},
! {"int3", 0, 0xcc, _, NoModrm, { 0, 0, 0} C(IntOp)},
! {"into", 0, 0xce, _, NoModrm, { 0, 0, 0} C(IntOp)},
! {"iret", 0, 0xcf, _, NoModrm|Data32, { 0, 0, 0} C(NoMemAcc|ErrOp)},
! {"iretw", 0, 0xcf, _, NoModrm|Data16, { 0, 0, 0} C(NoMemAcc|ErrOp)},
  /* i386sl (and i486sl?) only */
! {"rsm", 0, 0x0faa, _, NoModrm,{ 0, 0, 0} C(NoMemAcc|ErrOp)},
  
! {"boundl", 2, 0x62, _, Modrm|Data32, { Reg32, Mem, 0} C(RF64bOp)},
! {"boundw", 2, 0x62, _, Modrm|Data16, { Reg16, Mem, 0} C(RF32bOp)},
  
! {"hlt", 0, 0xf4, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"wait", 0, 0x9b, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  /* nop is actually 'xchgl %eax, %eax' */
! {"nop", 0, 0x90, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  
  /* protection control */
! {"arpl", 2, 0x63, _, Modrm, { Reg16, Reg16|Mem, 0} C(ReadMem)},
! {"lar", 2, 0x0f02, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} C(ReadMem)},
! {"lgdt", 1, 0x0f01, 2, Modrm, { Mem, 0, 0} C(RProtOp)},
! {"lidt", 1, 0x0f01, 3, Modrm, { Mem, 0, 0} C(RProtOp)},
! {"lldt", 1, 0x0f00, 2, Modrm, { WordReg|Mem, 0, 0} C(ReadMem)},
! {"lmsw", 1, 0x0f01, 6, Modrm, { WordReg|Mem, 0, 0} C(ReadMem)},
! {"lsl", 2, 0x0f03, _, Modrm|ReverseRegRegmem, { WordReg|Mem, WordReg, 0} C(ReadMem)},
! {"ltr", 1, 0x0f00, 3, Modrm, { WordReg|Mem, 0, 0} C(ReadMem)},
! 
! {"sgdt", 1, 0x0f01, 0, Modrm, { Mem, 0, 0} C(WProtOp)},
! {"sidt", 1, 0x0f01, 1, Modrm, { Mem, 0, 0} C(WProtOp)},
! {"sldt", 1, 0x0f00, 0, Modrm, { WordReg|Mem, 0, 0} C(WriteMem)},
! {"smsw", 1, 0x0f01, 4, Modrm, { WordReg|Mem, 0, 0} C(WriteMem)},
! {"str", 1, 0x0f00, 1, Modrm, { Reg16|Mem, 0, 0} C(WriteMem)},
  
! {"verr", 1, 0x0f00, 4, Modrm, { WordReg|Mem, 0, 0} C(NoMemAcc)},
! {"verw", 1, 0x0f00, 5, Modrm, { WordReg|Mem, 0, 0} C(NoMemAcc)},
  
  /* floating point instructions */
  
  /* load */
! {"fld", 1, 0xd9c0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"flds", 1, 0xd9, 0, Modrm, { Mem, 0, 0} C(RF32bOp)},		/* %st0 <-- mem float */
! {"fldl", 1, 0xdd, 0, Modrm, { Mem, 0, 0} C(RF64bOp)},		/* %st0 <-- mem double */
! {"fldl", 1, 0xd9c0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"fild", 1, 0xdf, 0, Modrm, { Mem, 0, 0} C(RF16bOp)},		/* %st0 <-- mem word (16) */
! {"fildl", 1, 0xdb, 0, Modrm, { Mem, 0, 0} C(RF32bOp)},	/* %st0 <-- mem dword (32) */
! {"fildq",1, 0xdf, 5, Modrm, { Mem, 0, 0} C(RF64bOp)},		/* %st0 <-- mem qword (64) */
! {"fildll",1, 0xdf, 5, Modrm, { Mem, 0, 0} C(RF64bOp)},	/* %st0 <-- mem qword (64) */
! {"fldt", 1, 0xdb, 5, Modrm, { Mem, 0, 0} C(RF80bOp)},		/* %st0 <-- mem efloat */
! {"fbld", 1, 0xdf, 4, Modrm, { Mem, 0, 0} C(RF80bOp)},		/* %st0 <-- mem bcd */
  
  /* store (no pop) */
! {"fst", 1, 0xddd0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"fsts", 1, 0xd9, 2, Modrm, { Mem, 0, 0} C(WF32bOp)},		/* %st0 --> mem float */
! {"fstl", 1, 0xdd, 2, Modrm, { Mem, 0, 0} C(WF64bOp)},		/* %st0 --> mem double */
! {"fstl", 1, 0xddd0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"fist", 1, 0xdf, 2, Modrm, { Mem, 0, 0} C(WF16bOp)},		/* %st0 --> mem word (16) */
! {"fistl", 1, 0xdb, 2, Modrm, { Mem, 0, 0} C(WF32bOp)},	/* %st0 --> mem dword (32) */
  
  /* store (with pop) */
! {"fstp", 1, 0xddd8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"fstps", 1, 0xd9, 3, Modrm, { Mem, 0, 0} C(WF32bOp)},	/* %st0 --> mem float */
! {"fstpl", 1, 0xdd, 3, Modrm, { Mem, 0, 0} C(WF64bOp)},	/* %st0 --> mem double */
! {"fstpl", 1, 0xddd8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)}, /* register */
! {"fistp", 1, 0xdf, 3, Modrm, { Mem, 0, 0} C(WF16bOp)},	/* %st0 --> mem word (16) */
! {"fistpl",1, 0xdb, 3, Modrm, { Mem, 0, 0} C(WF32bOp)},	/* %st0 --> mem dword (32) */
! {"fistpq",1, 0xdf, 7, Modrm, { Mem, 0, 0} C(WF64bOp)},	/* %st0 --> mem qword (64) */
! {"fistpll",1,0xdf, 7, Modrm, { Mem, 0, 0} C(WF64bOp)},	/* %st0 --> mem qword (64) */
! {"fstpt", 1, 0xdb, 7, Modrm, { Mem, 0, 0} C(WF80bOp)},	/* %st0 --> mem efloat */
! {"fbstp", 1, 0xdf, 6, Modrm, { Mem, 0, 0} C(WF80bOp)},	/* %st0 --> mem bcd */
  
  /* exchange %st<n> with %st0 */
! {"fxch", 1, 0xd9c8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fxch", 0, 0xd9c9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)}, /* alias for fxch %st, %st(1) */
  
  /* comparison (without pop) */
! {"fcom", 1, 0xd8d0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fcoms", 1, 0xd8, 2, Modrm, { Mem, 0, 0} C(RF32bOp)},	/* compare %st0, mem float  */
! {"ficoml", 1, 0xda, 2, Modrm, { Mem, 0, 0} C(RF16bOp)},	/* compare %st0, mem word  */ 
! {"fcoml", 1, 0xdc, 2, Modrm, { Mem, 0, 0} C(RF64bOp)},	/* compare %st0, mem double  */
! {"fcoml", 1, 0xd8d0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"ficoms", 1, 0xde, 2, Modrm, { Mem, 0, 0} C(RF32bOp)},	/* compare %st0, mem dword */
  
  /* comparison (with pop) */
! {"fcomp", 1, 0xd8d8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fcomps", 1, 0xd8, 3, Modrm, { Mem, 0, 0} C(RF32bOp)},	/* compare %st0, mem float  */
! {"ficompl", 1, 0xda, 3, Modrm, { Mem, 0, 0} C(RF16bOp)},	/* compare %st0, mem word  */ 
! {"fcompl", 1, 0xdc, 3, Modrm, { Mem, 0, 0} C(RF64bOp)},	/* compare %st0, mem double  */
! {"fcompl", 1, 0xd8d8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"ficomps", 1, 0xde, 3, Modrm, { Mem, 0, 0} C(RF32bOp)},	/* compare %st0, mem dword */
! {"fcompp", 0, 0xded9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* compare %st0, %st1 & pop 2 */
  
  /* unordered comparison (with pop) */
! {"fucom", 1, 0xdde0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fucomp", 1, 0xdde8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fucompp", 0, 0xdae9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)}, /* ucompare %st0, %st1 & pop twice */
  
! {"ftst", 0, 0xd9e4, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* test %st0 */
! {"fxam", 0, 0xd9e5, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* examine %st0 */
  
  /* load constants into %st0 */
! {"fld1", 0, 0xd9e8, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- 1.0 */
! {"fldl2t", 0, 0xd9e9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- log2(10) */
! {"fldl2e", 0, 0xd9ea, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- log2(e) */
! {"fldpi", 0, 0xd9eb, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- pi */
! {"fldlg2", 0, 0xd9ec, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- log10(2) */
! {"fldln2", 0, 0xd9ed, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- ln(2) */
! {"fldz", 0, 0xd9ee, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},	/* %st0 <-- 0.0 */
  
  /* arithmetic */
  
  /* add */
! {"fadd", 1, 0xd8c0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fadd", 2, 0xd8c0, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
! {"fadd", 0, 0xdcc1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)}, /* alias for fadd %st, %st(1) */
! {"faddp", 1, 0xdac0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"faddp", 2, 0xdac0, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
! {"faddp", 0, 0xdec1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)}, /* alias for faddp %st, %st(1) */
! {"fadds", 1, 0xd8, 0, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fiaddl", 1, 0xda, 0, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"faddl", 1, 0xdc, 0, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fiadds", 1, 0xde, 0, Modrm, { Mem, 0, 0} C(RF16bOp)},
  
  /* sub */
  /* Note:  intel has decided that certain of these operations are reversed
     in assembler syntax. */
! {"fsub", 1, 0xd8e0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fsub", 2, 0xd8e0, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fsub", 2, 0xdce8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fsub", 2, 0xdce0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fsub", 0, 0xdce1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsubp", 1, 0xdae0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fsubp", 2, 0xdae0, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fsubp", 2, 0xdee8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fsubp", 2, 0xdee0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fsubp", 0, 0xdee1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsubs", 1, 0xd8, 4, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fisubl", 1, 0xda, 4, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fsubl", 1, 0xdc, 4, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fisubs", 1, 0xde, 4, Modrm, { Mem, 0, 0} C(RF16bOp)},
  
  /* sub reverse */
! {"fsubr", 1, 0xd8e8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fsubr", 2, 0xd8e8, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fsubr", 2, 0xdce0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fsubr", 2, 0xdce8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fsubr", 0, 0xdce9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsubrp", 1, 0xdae8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fsubrp", 2, 0xdae8, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fsubrp", 2, 0xdee0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fsubrp", 2, 0xdee8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fsubrp", 0, 0xdee9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsubrs", 1, 0xd8, 5, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fisubrl", 1, 0xda, 5, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fsubrl", 1, 0xdc, 5, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fisubrs", 1, 0xde, 5, Modrm, { Mem, 0, 0} C(RF16bOp)},
  
  /* mul */
! {"fmul", 1, 0xd8c8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fmul", 2, 0xd8c8, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
! {"fmul", 0, 0xdcc9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fmulp", 1, 0xdac8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fmulp", 2, 0xdac8, _, ShortForm|FloatD, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
! {"fmulp", 0, 0xdec9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fmuls", 1, 0xd8, 1, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fimull", 1, 0xda, 1, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fmull", 1, 0xdc, 1, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fimuls", 1, 0xde, 1, Modrm, { Mem, 0, 0} C(RF16bOp)},
  
  /* div */
  /* Note:  intel has decided that certain of these operations are reversed
     in assembler syntax. */
! {"fdiv", 1, 0xd8f0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fdiv", 2, 0xd8f0, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fdiv", 2, 0xdcf8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fdiv", 2, 0xdcf0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fdiv", 0, 0xdcf1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fdivp", 1, 0xdaf0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fdivp", 2, 0xdaf0, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fdivp", 2, 0xdef8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fdivp", 2, 0xdef0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fdivp", 0, 0xdef1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fdivs", 1, 0xd8, 6, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fidivl", 1, 0xda, 6, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fdivl", 1, 0xdc, 6, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fidivs", 1, 0xde, 6, Modrm, { Mem, 0, 0} C(RF16bOp)},
  
  /* div reverse */
! {"fdivr", 1, 0xd8f8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fdivr", 2, 0xd8f8, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fdivr", 2, 0xdcf0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fdivr", 2, 0xdcf8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fdivr", 0, 0xdcf9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fdivrp", 1, 0xdaf8, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fdivrp", 2, 0xdaf8, _, ShortForm, { FloatReg, FloatAcc, 0} C(NoMemAcc)},
  #ifdef NON_BROKEN_OPCODES
! {"fdivrp", 2, 0xdef0, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #else
! {"fdivrp", 2, 0xdef8, _, ShortForm, { FloatAcc, FloatReg, 0} C(NoMemAcc)},
  #endif
! {"fdivrp", 0, 0xdef9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fdivrs", 1, 0xd8, 7, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fidivrl", 1, 0xda, 7, Modrm, { Mem, 0, 0} C(RF32bOp)},
! {"fdivrl", 1, 0xdc, 7, Modrm, { Mem, 0, 0} C(RF64bOp)},
! {"fidivrs", 1, 0xde, 7, Modrm, { Mem, 0, 0} C(RF16bOp)},
! 
! {"f2xm1", 0,   0xd9f0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fyl2x", 0,   0xd9f1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fptan", 0,   0xd9f2, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fpatan", 0,  0xd9f3, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fxtract", 0, 0xd9f4, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fprem1", 0,  0xd9f5, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fdecstp", 0,  0xd9f6, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fincstp", 0,  0xd9f7, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fprem", 0,   0xd9f8, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fyl2xp1", 0, 0xd9f9, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsqrt", 0,   0xd9fa, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsincos", 0, 0xd9fb, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"frndint", 0, 0xd9fc, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fscale", 0,  0xd9fd, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fsin", 0,    0xd9fe, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fcos", 0,    0xd9ff, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  
! {"fchs", 0, 0xd9e0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fabs", 0, 0xd9e1, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  
  /* processor control */
! {"fninit", 0, 0xdbe3, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"finit", 0, 0xdbe3, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fldcw", 1, 0xd9, 5, Modrm, { Mem, 0, 0} C(WF16bOp)},
! {"fnstcw", 1, 0xd9, 7, Modrm, { Mem, 0, 0} C(WF16bOp|FnstcwOP)},
! {"fstcw", 1, 0xd9, 7, Modrm, { Mem, 0, 0} C(WF16bOp)},
! {"fnstsw", 1, 0xdfe0, _, NoModrm, { Acc, 0, 0} C(NoMemAcc)},
! {"fnstsw", 1, 0xdd, 7, Modrm, { Mem, 0, 0} C(WF32bOp)},
! {"fnstsw", 0, 0xdfe0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fstsw", 1, 0xdfe0, _, NoModrm, { Acc, 0, 0} C(NoMemAcc)},
! {"fstsw", 1, 0xdd, 7, Modrm, { Mem, 0, 0} C(WF32bOp)},
! {"fstsw", 0, 0xdfe0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fnclex", 0, 0xdbe2, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fclex", 0, 0xdbe2, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  /*
   We ignore the short format (287) versions of fstenv/fldenv & fsave/frstor
   instructions;  i'm not sure how to add them or how they are different.
   My 386/387 book offers no details about this.
  */
! {"fnstenv", 1, 0xd9, 6, Modrm, { Mem, 0, 0} C(WF224bOp)},
! {"fstenv", 1, 0xd9, 6, Modrm, { Mem, 0, 0} C(WF224bOp)},
! {"fldenv", 1, 0xd9, 4, Modrm, { Mem, 0, 0} C(RF224bOp)},
! {"fnsave", 1, 0xdd, 6, Modrm, { Mem, 0, 0} C(WF80bOp|ErrOp)},
! {"fsave", 1, 0xdd, 6, Modrm, { Mem, 0, 0} C(WF80bOp|ErrOp)},
! {"frstor", 1, 0xdd, 4, Modrm, { Mem, 0, 0} C(RF80bOp|ErrOp)},
! 
! {"ffree", 1, 0xddc0, _, ShortForm, { FloatReg, 0, 0} C(NoMemAcc)},
! {"fnop", 0, 0xd9d0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fwait", 0, 0x9b, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
  
  /*
    opcode prefixes; we allow them as seperate insns too
    (see prefix table below)
  */
! {"aword", 0, 0x67, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"addr16", 0, 0x67, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"word", 0, 0x66, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"data16", 0, 0x66, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"lock", 0, 0xf0, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"cs", 0, 0x2e, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"ds", 0, 0x3e, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"es", 0, 0x26, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"fs", 0, 0x64, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"gs", 0, 0x65, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"ss", 0, 0x36, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"rep", 0, 0xf3, _, NoModrm, { 0, 0, 0} C(StrOp)},
! {"repe", 0, 0xf3, _, NoModrm, { 0, 0, 0} C(StrOp)},
! {"repz", 0, 0xf3, _, NoModrm, { 0, 0, 0} C(StrOp)},
! {"repne", 0, 0xf2, _, NoModrm, { 0, 0, 0} C(StrOp)},
! {"repnz", 0, 0xf2, _, NoModrm, { 0, 0, 0} C(StrOp)},
  
  /* 486 extensions */
  
! {"bswap", 1, 0x0fc8, _, ShortForm, { Reg32,0,0 } C(NoMemAcc)},
! {"xadd", 2, 0x0fc0, _, DW|Modrm, { Reg, Reg|Mem, 0 } C(RAndWMem)},
! {"cmpxchg", 2, 0x0fb0, _, DW|Modrm, { Reg, Reg|Mem, 0 } C(RAndWMem)},
! {"invd", 0, 0x0f08, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"wbinvd", 0, 0x0f09, _, NoModrm, { 0, 0, 0} C(NoMemAcc)},
! {"invlpg", 1, 0x0f01, 7, Modrm, { Mem, 0, 0} C(NoMemAcc)},
  
  /* 586 extensions */
  {"cpuid", 0, 0x0fa2, _, NoModrm, { 0, 0, 0} },
  
! {"", 0, 0, 0, 0, { 0, 0, 0} C(NoMemAcc)}	/* sentinel */
  };
  #undef _
  
