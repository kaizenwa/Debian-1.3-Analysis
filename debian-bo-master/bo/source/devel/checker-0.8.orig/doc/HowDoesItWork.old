This file describes how malloc and checker work.
 Written by Tristan Gingold (c) 1993.

You can (or must) add comments. You can complete or correct what I
(and others) write.
Excuse me for the English mistakes. If you spend time to see them, take time
to correct them.

  /\     I won't describe the file line for line.
 /||\
/ .. \
------

   Intro: ( I assume you know the C language and what malloc is)

How is the memory organized?
The standard way is to divide the memory of a process into three segments:
+--------------+---------------+--------------+--------------+---------------+
|   text seg   |   data seg    |  bss seg     |>> >      < <<|  stack seg    |
|    (code)    | (initialized) | (fill to 0)  |>> >      < <<|               |
|  read only   | read & write  | read & write |>> >      < <<|               |
+--------------+---------------+--------------+--------------+---------------+
0            &etext          &edata          &end           esp      0xbfffffff
text and data segment are read from the executable. bss segment is allocated
when the executable is run and initialized to 0. Besides the bss segment, the
process can allocate memory by brk(2) or sbrk(3), but usually it calls
malloc(3). The memory allocated is called the heap. The heap grows upward. At
the end of the process' memory, space is reserved for the stack.

Usually, the stack segment grows (downward) automatically.

This malloc uses a table to save information concerning the heap.
So, each block of the heap has an entry in this table.
This table is named _heapinfo[]. There is an entry for BLOCKSIZE(4096)
bytes. At the beginning, it has a fixed size HEAP. When this size is too small,
malloc grows this table. See malloc.c:morecore.

Blocks can be grouped with others (if they follow each other), or can be
sub-divided in fragments. Fragment size is a power of 2. The minimum size of a
fragment is sizeof(struct list), because free frags(ments) are linked and
structure list, which is inside the fragment, contains the links.
So malloc often allocs more memory than necessary, but it is rather fast.

Note: malloc(0) returns 0.


 malloc:
The first task of malloc is to initialise itself if it hasn't been done.
if __malloc_initialized is null, malloc calls initialize. This flag is also
used in other pieces of software that work with malloc.

malloc checks that size is greater than sizeof(struct list) and changes 
size if necessary. Thus, fragments too small to hold the pieces of information
needed by checker, should not exist.

According to size, malloc will alloc blocks or a fragment.

 Blocks:
malloc loops until it reaches a large enough block or until the loop is
complete.
If no memory is found, malloc will get more memory (with morecore), but
perhaps the last block has memory, so malloc can join the two zones. The new
block is linked.
If memory is found, malloc removes the block from the free list.

Garbage detecting:
When calling __chkr_garbage_detector() the data and stack are searched
for pointers to heap blocks. These blocks are then recursively
searched for pointers to other heap blocks.

Blocks not found in this search are signalled as garbage.

__chkr_evol_detector() does the same search but does not report lost
blocks that are already reported in a previous __chkr_garbage_detector()
__or chkr_evol_detector().

About bitmaps:
There are three bitmaps: data, heap and stack.
&text          &end                             sbrk(0)               
+-------+-------+--------+------+----------+--------+-----------------------+
| data  |  bss  | data   | heap |>  heap   | stack  |>> >                   |
| seg   |  seg  | bitmap |      |>  bitmap | bitmap |>> >                   |
+-------+-------+--------+------+----------+--------+-----------------------+
                ^        ^      ^          ^        ^
                |        |      |          |        +-- real_heap_end
                |        |      |          +----------- chkr_stack_bitmap
                |        |      +---------------------- chkr_heap_bitmap 
                |        +----------------------------- chkr_heap_begin
                +-------------------------------------- chkr_data_bitmap

We don't always know the size of the stack segment. It is always equal to
 STACK_LIMIT - %esp.

/* End of File */