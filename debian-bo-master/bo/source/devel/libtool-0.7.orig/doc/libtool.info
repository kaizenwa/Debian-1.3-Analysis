This is Info file libtool.info, produced by Makeinfo version 1.67 from
the input file libtool.texi.

START-INFO-DIR-ENTRY
* Libtool: (libtool).   Generic shared library support script.
END-INFO-DIR-ENTRY

   This file documents the Libtool library support script.

   Copyright (C) 1996 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: libtool.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Shared library support for GNU
******************************

   This file documents GNU libtool, a script that allows package
developers to provide generic shared library support.  This edition
documents version 0.7.

* Menu:

* Introduction::                What the heck is libtool?
* Libtool Paradigm::            How libtool's view of libraries is different.
* Using Libtool::               Example of using libtool to build libraries.
* Invoking libtool::            Running the `libtool' script.
* Integrating Libtool::         Using libtool in your own packages.
* Versioning::                  Using library interface versions.
* Library Tips::                Tips for library interface design.
* Index::                       Index of concepts, variables, and programs.

 -- The Detailed Node Listing --

Introduction

* Motivation::                  Why does GNU need a libtool?
* Issues::                      The problems that need to be addressed.
* Other Implementations::       How other people have solved these issues.
* Postmortem::                  Learning from past difficulties.

Using Libtool

* Creating Object Files::       Compiling object files for libraries.
* Linking Libraries::           Creating libraries from object files.
* Linking Executables::         Linking object files against libtool libraries.
* Installing Libraries::        Making libraries available to users.
* Installing Executables::      Making programs available to users.
* Static Libraries::            When shared libraries are not wanted.

Invoking `libtool'

* Compile Mode::                Creating library object files.
* Link Mode::                   Generating executables and libraries.
* Install Mode::                Making libraries and executables public.
* Finish Mode::                 Completing a library installation.
* Uninstall Mode::              Removing executables and libraries.

Integrating Libtool with Your Own Packages

* Makefile Rules::              Writing Makefile rules for libtool.
* Using Automake::              Automatically supporting libtool.
* Configuring::                 Configuring libtool for a host system.
* Distributing::                What files to distribute with your package.

Configuring Libtool

* Invoking ltconfig::           `ltconfig' command line options.
* ltconfig Example::            Manually configuring a `libtool'.
* AM_PROG_LIBTOOL::             Configuring `libtool' in `configure.in'.

Including Libtool with Your Package

* Invoking libtoolize::         `libtoolize' command line options.

Library Interface Versions

* Interfaces::                  What are library interfaces?
* Libtool Versioning::          Libtool's versioning system.
* Updating Version Info::       Changing version information before releases.

Tips for Interface Design

* C Header Files::              How to write portable include files.


File: libtool.info,  Node: Introduction,  Next: Libtool Paradigm,  Prev: Top,  Up: Top

Introduction
************

   In the past, if a source code package developer wanted to take
advantage of the power of shared libraries, he needed to write custom
support code for each platform his package ran on.  He also had to
design a configuration interface so that the user could choose what
sort of libraries were built.

   GNU libtool simplifies the developer's job by encapsulating both the
platform-specific dependencies, and the user interface, in a single
script.  GNU libtool is designed so that the complete functionality of
each host type is available via a generic interface, but nasty quirks
are hidden from the programmer.

   GNU libtool's consistent interface is reassuring... users don't need
to read obscure documentation in order to have their favorite source
package build shared libraries.  They just run your package `configure'
script (or equivalent), and libtool does all the dirty work.

   There are several examples throughout this document.  All assume the
same environment: we want to build a library, `libhello', in a generic
way.

   `libhello' could be a shared library, a static library, or both...
whatever is available on the host system, as long as libtool has been
ported to it.

   This chapter explains the original design philosophy of libtool.
Feel free to skip to the next chapter, unless you are interested in
history, or want to write code to extend libtool in a consistent way.

* Menu:

* Motivation::                  Why does GNU need a libtool?
* Issues::                      The problems that need to be addressed.
* Other Implementations::       How other people have solved these issues.
* Postmortem::                  Learning from past difficulties.


File: libtool.info,  Node: Motivation,  Next: Issues,  Prev: Introduction,  Up: Introduction

Motivation for Writing Libtool
==============================

   Since early 1995, several different GNU developers have recognized
the importance of having shared library support for their packages.  The
primary motivation for such a change is to encourage modularity and
reuse of code (both conceptually and physically) in GNU programs.

   Such a demand means that the way libraries are built in GNU packages
needs to be general, to allow for any library type the user might want.
The problem is compounded by the absence of a standard procedure for
creating shared libraries on different platforms.

   The following sections outline the major issues facing shared library
support in GNU, and how I propose that shared library support could be
standardized with libtool.

   The following specifications were used in developing and evaluating
this system:

  1. The system must be as elegant as possible.

  2. The system must be fully integrated with the GNU Autoconf and
     Automake utilities, so that it will be easy for GNU maintainers to
     use.  However, the system must not require these tools, so that it
     can be used by non-GNU packages.

  3. Portability to other (non-GNU) architectures and tools is
     desirable.


File: libtool.info,  Node: Issues,  Next: Other Implementations,  Prev: Motivation,  Up: Introduction

Implementation Issues
=====================

   The following issues need to be addressed in any reusable shared
library system, specifically libtool:

  1. The user should be able to control what sort of libraries are
     built.

  2. It can be tricky to run dynamically linked programs whose
     libraries have not yet been installed.  LD_LIBRARY_PATH must be
     set properly (if it is supported), or the program fails.

  3. The system must operate consistently even on hosts which don't
     support shared libraries.

  4. The commands required to build shared libraries may differ wildly
     from host to host.  These need to be guessed and tested at
     configure time in a consistent way.

  5. It is not always obvious with which suffix a shared object should
     be installed.  This makes it difficult for Makefile rules, since
     they generally assume that filenames are the same from host to
     host.

  6. The system needs a simple library version number abstraction, so
     that shared libraries can be upgraded in place.  The programmer
     should be informed how to design the interfaces to the library to
     maximize binary compatibility.

  7. The install Makefile target should warn the user to set
     LD_LIBRARY_PATH (or equivalent) or run `ldconfig', if required.


File: libtool.info,  Node: Other Implementations,  Next: Postmortem,  Prev: Issues,  Up: Introduction

Other Implementations
=====================

   I have investigated several different implementations of building
shared libraries as part of a freeware package.  At first, I made notes
on the features of each of these packages for comparison purposes.

   Now it is clear that none of these packages have documented the
details of shared library systems that libtool requires.  So, other
packages have been more or less abandoned as influences.


File: libtool.info,  Node: Postmortem,  Prev: Other Implementations,  Up: Introduction

A Postmortem Analysis of Other Implementations
==============================================

   In all fairness, each of the implementations that I examined do the
job that they were intended to do, for a number of different host
systems.  However, none of these solutions seem to function well as a
generalized, reuseable component.

   Most were too complex for me to use (much less modify) without
understanding exactly what the implementation does, and they were
generally not documented.

   I think the main problem is that different vendors have different
views of what libraries are, and none of the packages I examined seemed
to be confident enough to settle on a single paradigm that just *works*.

   Ideally, libtool would be a standard that would be implemented as
series of extensions and modifications to existing library systems to
make them work consistently.  However, I don't have the time or power
to convince operating system developers to mend their evil ways, and I
want to build shared libraries right now, even on buggy, broken,
confused operating systems.

   For this reason, I have designed libtool as an independent shell
script.  It isolates the problems and inconsistencies in library
building that plague Makefile writers by wrapping the compiler suite on
different platforms with a consistent, powerful interface.

   I hope that libtool will be useful to and used by the GNU community,
and that the lessons I've learned in writing it will be taken up and
implemented by designers of library systems.


File: libtool.info,  Node: Libtool Paradigm,  Next: Using Libtool,  Prev: Introduction,  Up: Top

The Libtool Paradigm
********************

   At first, libtool was designed to support an arbitrary number of
library object types.  After porting libtool to more platforms, the
author discovered a new (at least for him) paradigm of what libraries
and programs are.

   In summary: "libraries are programs with multiple entry points, and
more formally defined interfaces."

   Version 0.7 of libtool was a complete redesign and rewrite of
libtool to reflect this new paradigm.  So far, it has proved to be
successful: libtool is simpler and more functional than before.

   The best way to introduce the libtool paradigm is to contrast it with
the paradigm of existing library systems, with examples from each.  It
is a new way of thinking, so it may take a little time to absorb, but
when you understand it the world gets simpler.


File: libtool.info,  Node: Using Libtool,  Next: Invoking libtool,  Prev: Libtool Paradigm,  Up: Top

Using Libtool
*************

   It makes little sense to talk about using libtool in your own
packages until you have seen how it makes your life simpler.  The
examples in this chapter introduce the main features of libtool by
comparing the standard library building procedure to libtool's
operation on two different platforms:

`a23'
     An Ultrix 4.2 platform with only static libraries.

`burger'
     A NetBSD/i386 1.2 platform with shared libraries.

   You can follow these examples on your own platform, using the
pre-configured (*note Configuring::.) libtool script that was installed
with the libtool distribution.

   Source files for the following examples are taken from the `demo'
subdirectory of the libtool distribution.  Assume that we are building a
library, `libhello', out of the files `foo.c' and `hello.c'.

   After we have built that library, we want to create a program by
linking `main.o' against `libhello'.

* Menu:

* Creating Object Files::       Compiling object files for libraries.
* Linking Libraries::           Creating libraries from object files.
* Linking Executables::         Linking object files against libtool libraries.
* Installing Libraries::        Making libraries available to users.
* Installing Executables::      Making programs available to users.
* Static Libraries::            When shared libraries are not wanted.


File: libtool.info,  Node: Creating Object Files,  Next: Linking Libraries,  Prev: Using Libtool,  Up: Using Libtool

Creating Object Files
=====================

   To create an object file from a source file, the compiler is invoked
with the `-c' flag (and any other desired flags):

     burger$ gcc -g -O -c main.c
     burger$

   The above compiler command produces an object file, `main.o', from
the source file `main.c'.

   For most library systems, creating object files that become part of a
static library is as simple as creating object files that are linked to
form an executable:

     burger$ gcc -g -O -c foo.c
     burger$ gcc -g -O -c hello.c
     burger$

   Shared libraries, however, may only be built from
"position-independant code" (PIC).  So, special flags must be passed to
the compiler to tell it to generate PIC rather than the standard
position-dependant code.

   Since this is a library implementation detail, libtool hides the
complexity of PIC compiler flags by using separate library object files
(which end in `.lo' instead of `.o').  On systems without shared
libraries (or without special PIC compiler flags), these library object
files are identical to "standard" object files.

   To create library object files for `foo.c' and `hello.c', simply
invoke libtool with the standard compilation command as an argument:

     a23$ libtool gcc -g -O -c foo.c
     gcc -g -O -c foo.c
     ln -s foo.o foo.lo
     a23$ libtool gcc -g -O -c hello.c
     gcc -g -O -c hello.c
     ln -s hello.o hello.lo
     a23$

   Note that libtool creates two object files for each invocation.  The
`.lo' file is a library object, and the `.o' file is a standard object
file.  On `a23', these files are identical, because only static
libraries are supported.

   On shared library systems, libtool automatically inserts the PIC
generation flags into the compilation command, so that the library
object and the standard object differ:

     burger$ libtool gcc -g -O -c foo.c
     gcc -g -O -c -fPIC -DPIC foo.c
     mv -f foo.o foo.lo
     gcc -g -O -c foo.c
     burger$ libtool gcc -g -O -c hello.c
     gcc -g -O -c -fPIC -DPIC hello.c
     mv -f hello.o hello.lo
     gcc -g -O -c hello.c
     burger$


File: libtool.info,  Node: Linking Libraries,  Next: Linking Executables,  Prev: Creating Object Files,  Up: Using Libtool

Linking Libraries
=================

   Without libtool, the programmer would invoke the `ar' command to
create a static library:

     burger$ ar cru libhello.a hello.o foo.o
     burger$

   But of course, that would be too simple, so many systems require that
you run the `ranlib' command on the resulting library (to give it
better karma, or something):

     burger$ ranlib libhello.a
     burger$

   It seems more natural to use the C compiler for this task, given
libtool's "libraries are programs" approach.  So, on platforms without
shared libraries, libtool simply acts as a wrapper for the system `ar'
(and possibly `ranlib') commands.

   Again, the libtool library name differs from the standard name (it
has a `.la' suffix instead of a `.a' suffix).  The arguments to libtool
are the same ones you would use to produce an executable named
`libhello.la' with your compiler:

     burger$ libtool gcc -g -O -o libhello.la foo.o hello.o
     libtool: cannot build libtool library `libhello.la' from non-libtool \
                     objects
     burger$

   Aha!  Libtool caught a common error... trying to build a library
from standard objects instead of library objects.  This doesn't matter
for static libraries, but on shared library systems, it is of great
importance.

   So, let's try again, this time with the library object files:

     a23$ libtool gcc -g -O -o libhello.la foo.lo hello.lo
     libtool: you must specify an installation directory with `-rpath'
     a23$

   Argh.  Another complication in building shared libraries is that we
need to specify the path to the directory in which they (eventually)
will be installed.  So, we try again, with an `rpath' setting of
`/usr/local/lib':

     a23$ libtool gcc -g -O -o libhello.la foo.lo hello.lo \
                     -rpath /usr/local/lib
     mkdir .libs
     ar cru .libs/libhello.a foo.o hello.o
     ranlib .libs/libhello.a
     creating libhello.la
     a23$

   Now, let's try the same trick on the shared library platform:

     burger$ libtool gcc -g -O -o libhello.la foo.lo hello.lo \
                     -rpath /usr/local/lib
     mkdir .libs
     rm -f .libs/libhello.*
     ld -Bshareable -o .libs/libhello.so.0.0 foo.lo hello.lo
     ar cru .libs/libhello.a foo.o hello.o
     ranlib .libs/libhello.a
     creating libhello.la
     burger$

   Now that's significantly cooler... libtool just ran an obscure `ld'
command to create a shared library, as well as the static library.

   Note how libtool creates extra files in the `.libs' subdirectory,
rather than the current directory.  This feature is to make it easier to
clean up the build directory, and to help ensure that other programs
fail horribly if you accidentally forget to use libtool when you should.


File: libtool.info,  Node: Linking Executables,  Next: Installing Libraries,  Prev: Linking Libraries,  Up: Using Libtool

Linking Executables
===================

   If you choose at this point to "install" the library (put it in a
permanent location) before linking executables against it, then you
don't need to use libtool to do the linking.  Simply use the appropriate
`-L' and `-l' flags to specify the library's location.

   Some system linkers insist on encoding the full directory name of
each shared library in the resulting executable.  Libtool has to work
around this misfeature by special magic to ensure that only permanent
directory names are put into installed executables.

   The importance of this bug must not be overlooked: it won't cause
programs to crash in obvious ways.  It creates a security hole, and
possibly even worse, if you are modifying the library source code after
you have installed the package, you will change the behaviour of the
installed programs!

   So, if you want to link programs against the library before you
install it, you must use libtool to do the linking.

   Here's the old way of linking against an uninstalled library:

     burger$ gcc -g -O -o hell.old main.o libhello.a
     burger$

   Libtool's way is almost the same(1):

     a23$ libtool gcc -g -O -o hell main.o libhello.la
     gcc -g -O -o hell main.o ./.libs/libhello.a
     a23$

   That looks too simple to be true.  All libtool did was transform
`libhello.la' to `./.libs/libhello.a', but remember that `a23' has no
shared libraries.

   On `burger' the situation is different:

     burger$ libtool gcc -g -O -o hell main.o libhello.la
     gcc -g -O -o .libs/hell main.o -L./.libs -R/usr/local/lib -lhello
     creating hell
     burger$

   Notice that the executable, `hell' was actually created in the
`.libs' subdirectory.  Then, a wrapper script was created in the
current directory.

   On NetBSD 1.2, libtool encodes the installation directory of
`libhello', `/usr/local/lib', by using the `-R' compiler flag.  Then,
the wrapper script guarantees that the executable finds the correct
shared library (the one in `./.libs') until it is properly installed.

   Let's compare the two different programs:

     burger$ time ./hell.old
     Welcome to GNU Hell!
     ** This is not GNU Hello.  There is no built-in mail reader. **
             0.21 real         0.02 user         0.08 sys
     burger$ time ./hell
     Welcome to GNU Hell!
     ** This is not GNU Hello.  There is no built-in mail reader. **
             0.63 real         0.09 user         0.59 sys
     burger$

   The wrapper script takes significantly longer to execute, but at
least the results are correct, even though the shared library hasn't
been installed yet.

   So, what about all the space savings that shared libraries are
supposed to yield?

     burger$ ls -l hell.old libhello.a
     -rwxr-xr-x  1 gord  gord  15481 Nov 14 12:11 hell.old
     -rw-r--r--  1 gord  gord   4274 Nov 13 18:02 libhello.a
     burger$ ls -l .libs/hell .libs/libhello.*
     -rwxr-xr-x  1 gord  gord  11647 Nov 14 12:10 .libs/hell
     -rw-r--r--  1 gord  gord   4274 Nov 13 18:44 .libs/libhello.a
     -rwxr-xr-x  1 gord  gord  12205 Nov 13 18:44 .libs/libhello.so.0.0
     burger$

   Well, that sucks.  Maybe I should just scrap this project and take up
basket weaving.

   Actually, it just proves an important point: shared libraries incur
overhead because of their (relative) complexity.  In this situation, the
price of being dynamic is eight kilobytes, and the payoff is about four
kilobytes.  So, having a shared `libhello' won't be an advantage until
we link it against at least a few more programs.

   ---------- Footnotes ----------

   (1)  However, you should never use `-L' or `-l' flags to link
against an uninstalled libtool library.  Just specify the relative path
to the `.la' file, such as `../intl/libintl.la'.


File: libtool.info,  Node: Installing Libraries,  Next: Installing Executables,  Prev: Linking Executables,  Up: Using Libtool

Installing Libraries
====================

   Installing libraries on a non-libtool system is quite
straightforward... just copy them into place:(1)

     burger$ su
     Password: ********
     burger# cp libhello.a /usr/local/lib/libhello.a
     burger#

   Oops, don't forget the `ranlib' command:

     burger# ranlib /usr/local/lib/libhello.a
     burger#

   Libtool installation is quite simple, as well.  Just use the
`install' or `cp' command that you normally would:

     a23# libtool cp libhello.la /usr/local/lib/libhello.la
     cp libhello.la /usr/local/lib/libhello.la
     cp .libs/libhello.a /usr/local/lib/libhello.a
     ranlib /usr/local/lib/libhello.a
     a23#

   Note that the libtool library `libhello.la' is also installed, for
informational purposes, and to help libtool with uninstallation (*note
Uninstall Mode::.).

   Here is the shared library example:

     burger# libtool install -c libhello.la /usr/local/lib/libhello.la
     install -c .libs/libhello.so.0.0 /usr/local/lib/libhello.so.0.0
     install -c libhello.la /usr/local/lib/libhello.la
     install -c .libs/libhello.a /usr/local/lib/libhello.a
     ranlib /usr/local/lib/libhello.a
     burger#

   It is safe to specify the `-s' (strip symbols) flag to the install
program (if you use a BSD-compatible install) when installing libraries.
Libtool will either ignore the `-s' flag, or will run a program that
will strip only debugging and compiler symbols from the library.

   Once the libraries have been put in place, there may be some
additional configuration that you need to do before using them.  First,
you must make sure that where the library is installed actually agrees
with the `-rpath' flag you used to build it.

   Then, running `libtool -n --finish LIBDIR' can give you further
hints on what to do:

     burger# libtool -n --finish /usr/local/lib
     ldconfig -m /usr/local/lib
     To link against installed libraries in LIBDIR, users may have to:
        - add LIBDIR to their `LD_LIBRARY_PATH' environment variable
        - use the `-LLIBDIR' linker flag
     burger#

   After you have completed these steps, you can go on to begin using
the installed libraries.  You may also install any executables that
depend on libraries you created.

   ---------- Footnotes ----------

   (1)  Don't accidentally strip the libraries, though, or they will be
unusable.


File: libtool.info,  Node: Installing Executables,  Next: Static Libraries,  Prev: Installing Libraries,  Up: Using Libtool

Installing Executables
======================

   If you used libtool to link any executables against uninstalled
libtool libraries (*note Linking Executables::.), you need to use
libtool to install the executables after the libraries have been
installed (*note Installing Libraries::.).

   So, for our Ultrix example, we would run:

     a23# libtool install -c hell /usr/local/bin/hell
     install -c hell /usr/local/bin/hell
     a23#

   On shared library systems, libtool just ignores the wrapper script
and installs the correct binary:

     burger# libtool install -c hell /usr/local/bin/hell
     install -c .libs/hell /usr/local/bin/hell
     burger#


File: libtool.info,  Node: Static Libraries,  Prev: Installing Executables,  Up: Using Libtool

Linking Static Libraries
========================

   Sometimes it is desirable to create a static archive that can never
be shared.  The most frequent case is when you have a "convenience
library" that is a collection of unrelated object files without a
really nice interface.

   Why return to `ar' and `ranlib' silliness when you've had a taste of
libtool?  libtool works consistently with standard object files, static
libraries, and programs created without libtool's help.

   So, to create a static library:

  1. Compile the object files with or without using libtool.  It doesn't
     matter whether these objects are PIC (end with the `.lo' suffix)
     or not.

  2. Link the files in the same way you would a libtool library, but
     use a `.a' suffix (instead of `.la'):

          burger$ libtool gcc -o libhello.a main.o foo.lo hello.lo
          rm -f libhello.a
          ar cru libhello.a main.o foo.o hello.o
          ranlib libhello.a
          burger$

  3. If you want to install the library (but you probably don't), then
     you can use libtool to do it, too:

          burger$ libtool ./install-sh -c libhello.a /local/lib/libhello.a
          ./install-sh -c libhello.a /local/lib/libhello.a
          ranlib /local/lib/libhello.a
          burger$

   Another common situation where static linking is desirable is in
creating a standalone binary.  Use libtool to do the linking and add the
`-static' flag.


File: libtool.info,  Node: Invoking libtool,  Next: Integrating Libtool,  Prev: Using Libtool,  Up: Top

Invoking `libtool'
******************

   The `libtool' program has the following synopsis:

     libtool [OPTION]... [MODE-ARG]...

and accepts the following options:

`-n'
`--dry-run'
     Don't create, modify, or delete any files, just show what commands
     would be executed by libtool.

`--finish'
     Same as `--mode=finish'.

`--help'
     Display a help message and exit.  If `--mode=MODE' is specified,
     then detailed help for operation mode MODE is displayed.

`--mode=MODE'
     Use operation mode MODE.  By default, the operation mode is
     inferred from the contents of MODE-ARGS.

     If MODE is specified, it must be one of the following:

    `compile'
          Compile a source file into a libtool object.

    `finish'
          Complete the installation of libtool libraries on the system.

    `install'
          Install libraries or executables.

    `link'
          Create a library or an executable.

    `uninstall'
          Delete libraries or executables.

`--version'
     Print libtool version information and exit.

* Menu:

* Compile Mode::                Creating library object files.
* Link Mode::                   Generating executables and libraries.
* Install Mode::                Making libraries and executables public.
* Finish Mode::                 Completing a library installation.
* Uninstall Mode::              Removing executables and libraries.


File: libtool.info,  Node: Compile Mode,  Next: Link Mode,  Prev: Invoking libtool,  Up: Invoking libtool

Compile Mode
============

   For `compile' mode, MODE-ARGS is a compiler command to be used in
creating a `standard' object file.  These arguments should begin with
the name of the C compiler, and contain the `-c' compiler flag so that
only an object file is created.

   Libtool determines the name of the output file by removing the
directory component from the source file name, then substituting the C
source code suffix `.c' with the library object suffix, `.lo'.

   If shared libraries are being built, any necessary PIC generation
flags are substituted into the compilation command.


File: libtool.info,  Node: Link Mode,  Next: Install Mode,  Prev: Compile Mode,  Up: Invoking libtool

Link Mode
=========

   `link' mode links together object files (including library objects)
to form another library or to create an executable program.

   MODE-ARGS consist of a command using the C compiler to create an
output file (with the `-o' flag) from several object files.

   The following components of MODE-ARGS are treated specially:

`-LLIBDIR'
     Search LIBDIR for required libraries that have already been
     installed.

`-lNAME'
     OUTPUT-FILE requires the installed library `libNAME'.

`-o OUTPUT-FILE'
     Create OUTPUT-FILE from the specified objects and libraries.

`-rpath LIBDIR'
     If OUTPUT-FILE is a library, it will eventually be installed in
     LIBDIR.

`-static'
     If OUTPUT-FILE is a program, then do not link it against any
     shared libraries.  If OUTPUT-FILE is a library, then only create a
     static library.

`-version-info CURRENT[:REVISION[:AGE]]'
     If OUTPUT-FILE is a libtool library, use library version
     information CURRENT, REVISION, and AGE to build it.  If not
     specified, each of these variables defaults to 0 (*note
     Versioning::.).

   If the OUTPUT-FILE ends in `.la', then a libtool library is created,
which must be built only from library objects (`.lo' files)(1)  The
`-rpath' option is required.  In the current implementation, libtool
libraries may not depend on other uninstalled libtool libraries.

   If the OUTPUT-FILE ends in `.a', then a standard library is created
using `ar' and possibly `ranlib'.

   If OUTPUT-FILE ends in `.o' or `.lo', then a reloadable object file
is created from the input files (generally using `ld -r').  This method
is called "incremental linking".

   Otherwise, an executable program is created.

   ---------- Footnotes ----------

   (1)  Object files with a `.l_o' suffix are also accepted, to help
with Automake's `ansi2knr' support (*note Automatic de-ANSI-fication:
(automake.info)ANSI.).


File: libtool.info,  Node: Install Mode,  Next: Finish Mode,  Prev: Link Mode,  Up: Invoking libtool

Install Mode
============

   In `install' mode, libtool interprets MODE-ARGS as an installation
command beginning with `cp', or a BSD-compatible `install' program.

   The rest of the MODE-ARGS are interpreted as arguments to that
command.

   The command is run, and any necessary unprivileged post-installation
commands are also completed.


File: libtool.info,  Node: Finish Mode,  Next: Uninstall Mode,  Prev: Install Mode,  Up: Invoking libtool

Finish Mode
===========

   `finish' mode helps system administrators install libtool libraries
so that they can be located and linked into user programs.

   Each MODE-ARG is interpreted as the name of a library directory.
Running this command may require superuser privileges, so the
`--dry-run' option may be useful.


File: libtool.info,  Node: Uninstall Mode,  Prev: Finish Mode,  Up: Invoking libtool

Uninstall Mode
==============

   This mode deletes installed libraries (and other files).

   The first MODE-ARG is the name of the program to use to delete files
(typically `/bin/rm').

   The remaning MODE-ARGS are either flags for the deletion program
(beginning with a `-'), or the names of files to delete.


File: libtool.info,  Node: Integrating Libtool,  Next: Versioning,  Prev: Invoking libtool,  Up: Top

Integrating Libtool with Your Own Packages
******************************************

   This chapter describes how to integrate libtool with your packages so
that your users can install hassle-free shared libraries.

* Menu:

* Makefile Rules::              Writing Makefile rules for libtool.
* Using Automake::              Automatically supporting libtool.
* Configuring::                 Configuring libtool for a host system.
* Distributing::                What files to distribute with your package.


File: libtool.info,  Node: Makefile Rules,  Next: Using Automake,  Prev: Integrating Libtool,  Up: Integrating Libtool

Writing Makefile Rules for Libtool
==================================

   Libtool is fully integrated with Automake (*note The Automake
Manual: (automake.info)Top.), starting with Automake version 1.2.

   If you want to use libtool in a regular `Makefile' (or
`Makefile.in'), you are on your own.  If you're not using Automake 1.2,
and you don't know how to incorporate libtool into your package you
need to do one of the following:

  1. Download Automake (version 1.2 or later) from your nearest GNU
     mirror, install it, and start using it.

  2. Learn how to write Makefile rules by hand.  They're sometimes
     complex, but if you're clever enough to write rules for compiling
     your old libraries, then you should be able to easily figure out
     new rules for libtool libraries (hint: examine the `Makefile.in'
     in the `demo' subdirectory of the libtool distribution... note
     especially that it was generated automatically from the
     `Makefile.am' by Automake).


File: libtool.info,  Node: Using Automake,  Next: Configuring,  Prev: Makefile Rules,  Up: Integrating Libtool

Using Automake with Libtool
===========================

   Libtool library support fits conveniently into Automake's
understanding of what a `PROGRAM' is.

   Here are some samples from the Automake `Makefile.am' in the libtool
distribution's `demo' subdirectory.

   First, to link a program against a libtool library, just use the
`program_LDADD' variable:

     bin_PROGRAMS = hell hell.static
     
     # Build hell from main.c and libhello.la
     hell_SOURCES = main.c
     hell_LDADD = libhello.la
     
     # Create a statically-linked version of hell.
     hell_static_SOURCES = main.c
     hell_static_LDADD = libhello.la
     hell_static_LDFLAGS = -static

   You may use the `program_LDFLAGS' variable to stuff in any flags you
want to pass to libtool while linking `program' (such as `-static' to
create a statically-linked executable).

   Building a libtool library is almost as trivial... note the use of
`libhello_la_LDFLAGS' to pass the `-version-info' (*note Versioning::.)
and `-rpath' options to libtool:

     # Build a libtool library, libhello.la for installation in libdir.
     lib_PROGRAMS = libhello.la
     libhello_la_SOURCES = hello.c foo.c
     libhello_la_LDFLAGS = -version-info 3:12:1 -rpath $(libdir)


File: libtool.info,  Node: Configuring,  Next: Distributing,  Prev: Using Automake,  Up: Integrating Libtool

Configuring Libtool
===================

   Libtool requires intimate knowledge of your compiler suite and
operating system in order to be able to create shared libraries and
link against them properly.  When you install the libtool distribution,
a system-specific libtool script is installed into your binary
directory.

   However, when you distribute libtool with your own packages (*note
Distributing::.), you do not always know which compiler suite and
operating system are used to compile your package.

   For this reason, libtool must be "configured" before it can be used.
This idea should be familiar to anybody who has used a GNU `configure'
script.  `configure' runs a number of tests for system features, then
generates the `Makefiles' (and possibly a `config.h' header file),
after which you can run `make' and build the package.

   Libtool has its own equivalent to the `configure' script, `ltconfig'.

* Menu:

* Invoking ltconfig::           `ltconfig' command line options.
* ltconfig Example::            Manually configuring a `libtool'.
* AM_PROG_LIBTOOL::             Configuring `libtool' in `configure.in'.


File: libtool.info,  Node: Invoking ltconfig,  Next: ltconfig Example,  Prev: Configuring,  Up: Configuring

Invoking `ltconfig'
-------------------

   `ltconfig' runs a series of configuration tests, then creates a
system-specific `libtool' in the current directory.  The `ltconfig'
program has the following synopsis:

     ltconfig [OPTION]... LTMAIN [HOST]

and accepts the following options:

`--disable-shared'
     Create a `libtool' that only builds static libraries.

`--help'
     Display a help message and exit.

`--no-verify'
     Do not use `config.sub' to verify that HOST is a valid canonical
     host system name.

`--quiet'
`--silent'
     Do not print informational messages when running configuration
     tests.

`--srcdir=DIR'
     Look for `config.guess' and `config.sub' in DIR.

`--version'
     Print `ltconfig' version information and exit.

`--with-gcc'
     Assume that the GNU C compiler will be used when invoking the
     created `libtool' to compile and link object files.

   LTMAIN is the `ltmain.sh' shell script fragment that provides the
basic libtool functionality (*note Distributing::.).

   HOST is the canonical host system name, which by default is guessed
by running `config.guess'.

   `ltconfig' also recognizes the following environment variables:

CC
     The C compiler that will be used by the generated `libtool'.

CFLAGS
     Compiler flags used to generate standard object files.

CPPFLAGS
     C preprocessor flags.

LD
     The system linker to use (if the generated `libtool' requires one).

RANLIB
     Program to use rather than checking for `ranlib'.


File: libtool.info,  Node: ltconfig Example,  Next: AM_PROG_LIBTOOL,  Prev: Invoking ltconfig,  Up: Configuring

Using `ltconfig'
----------------

   Here is a simple example of using `ltconfig' to configure libtool on
my NetBSD/i386 1.2 system:

     burger$ ./ltconfig ltmain.sh
     checking host system type... i386-unknown-netbsd1.2
     checking for ranlib... ranlib
     checking for library strip program... strip -x
     checking for gcc... gcc
     checking whether we are using GNU C... yes
     checking for gcc option to produce PIC... -fPIC -DPIC
     checking for gcc option to statically link programs... -static
     checking if ld is GNU ld... no
     checking if ld supports shared libraries... yes
     checking dynamic linker characteristics... netbsd1.2 ld.so
     checking if libtool supports shared libraries... yes
     checking whether to build shared libraries... yes
     creating libtool
     burger$

   This example shows how to configure `libtool' for cross-compiling to
a i486 GNU/Hurd 0.1 system (assuming compiler tools reside in
`/local/i486-gnu/bin'):

     burger$ export PATH=/local/i486-gnu/bin:$PATH
     burger$ ./ltconfig ltmain.sh i486-gnu0.1
     checking host system type... i486-unknown-gnu0.1
     checking for ranlib... ranlib
     checking for library strip program... strip -x
     checking for gcc... gcc
     checking whether we are using GNU C... yes
     checking for gcc option to produce PIC... -fPIC -DPIC
     checking for gcc option to statically link programs... -static
     checking if ld is GNU ld... yes
     checking if GNU ld supports shared libraries... yes
     checking dynamic linker characteristics... gnu0.1 ld.so
     checking if libtool supports shared libraries... yes
     checking whether to build shared libraries... yes
     creating libtool
     burger$


File: libtool.info,  Node: AM_PROG_LIBTOOL,  Prev: ltconfig Example,  Up: Configuring

The `AM_PROG_LIBTOOL' macro
---------------------------

   If you are using GNU Autoconf (or Automake), you should add a call to
`AM_PROG_LIBTOOL' to your `configure.in' file.  This macro offers
seamless integration between the `configure' script and `ltconfig'.

   `AM_PROG_LIBTOOL' also adds support for the `--enable-shared' and
`--disable-shared' `configure' flags.

   When you invoke the `libtoolize' program (*note Invoking
libtoolize::.), it will tell you where to find a definition of
`AM_PROG_LIBTOOL'.  If you use Automake, the `aclocal' program will
automatically add `AM_PROG_LIBTOOL' support to your `configure'
script.(1)

   ---------- Footnotes ----------

   (1)  `AM_PROG_LIBTOOL' requires that you define the Makefile
variable `top_builddir' in your `Makefile.in'.  Automake does this
automatically, but Autoconf users should set it to the relative path to
the top of your build directory (`../..', for example).


File: libtool.info,  Node: Distributing,  Prev: Configuring,  Up: Integrating Libtool

Including Libtool with Your Package
===================================

   In order to use libtool, you need to include the following files with
your package:

`config.guess'
     Attempt to guess a canonical system name.

`config.sub'
     Canonical system name validation subroutine script.

`ltconfig'
     Generate a libtool script for a given system.

`ltmain.sh'
     A generic script implementing basic libtool functionality.

   Note that the libtool script itself should *not* be included with
your package.  *Note Configuring::.

   Rather than coping these files into your package manually, you should
use the `libtoolize' program.

* Menu:

* Invoking libtoolize::         `libtoolize' command line options.


File: libtool.info,  Node: Invoking libtoolize,  Prev: Distributing,  Up: Distributing

Invoking `libtoolize'
---------------------

   The `libtoolize' program provides a standard way to add libtool
support to your package.  In the future, it may implement better usage
checking, or other features to make libtool even easier to use.

   The `libtoolize' program has the following synopsis:

     libtoolize [OPTION]...

and accepts the following options:

`--automake'
     Work silently, and assume that Automake libtool support is used.

     `libtoolize --automake' is used by Automake to add libtool files to
     your package, when `AM_PROG_LIBTOOL' appears in your
     `configure.in'.

`--copy'
`-c'
     Copy files from the libtool data directory rather than creating
     symlinks.

`--force'
`-f'
     Replace existing libtool files.  By default, `libtoolize' won't
     overwrite existing files.

`--help'
     Display a help message and exit.

`--version'
     Print `libtoolize' version information and exit.

   `libtoolize' displays hints for adding libtool support to your
package, as well.


File: libtool.info,  Node: Versioning,  Next: Library Tips,  Prev: Integrating Libtool,  Up: Top

Library Interface Versions
**************************

   The most difficult issue introduced by shared libraries is that of
creating and resolving runtime dependencies.  Dependencies on programs
and libraries are often described in terms of a single name, such as
`sed'.  So, I may say "libtool depends on sed," and that is good enough
for most purposes.

   However, when an interface changes regularly, we need to be more
specific: "Gnus 5.1 requires Emacs 19.28 or above."  Here, the
description of an interface consists of a name, and a "version number."

   Even that sort of description is not accurate enough for some
purposes.  What if Emacs 20 changes enough to break Gnus 5.1?

   The same problem exists in shared libraries: we require a formal
version system to describe the sorts of dependencies that programs have
on shared libraries, so that the dynamic linker can guarantee that
programs are linked only against libraries that provide the interface
they require.

* Menu:

* Interfaces::                  What are library interfaces?
* Libtool Versioning::          Libtool's versioning system.
* Updating Version Info::       Changing version information before releases.


File: libtool.info,  Node: Interfaces,  Next: Libtool Versioning,  Prev: Versioning,  Up: Versioning

What Are Library Interfaces?
============================

   Interfaces for libraries may be any of the following (and more):

   * global variables (names and types)

   * global functions (arguments types and number, return types, and
     function names)

   * standard input, standard output, standard error, and file formats

   * sockets, pipes, and other inter-process communication protocols

   Note that static functions do not count as interfaces, because they
are not directly available to the user of the library.


File: libtool.info,  Node: Libtool Versioning,  Next: Updating Version Info,  Prev: Interfaces,  Up: Versioning

Libtool's Versioning System
===========================

   Libtool has its own formal versioning system.  It is not as flexible
as some, but it is definitely the simplest of the more powerful
versioning systems.

   Think of a library as exporting several sets of interfaces,
arbitrarily represented by integers.  When a program is linked against
a library, it may use any subset of all those interfaces.

   Libtool's description of the interfaces that a program uses is very
simple: it encodes the least and the greatest interface numbers in the
resulting binary (FIRST-INTERFACE, LAST-INTERFACE).

   Then, the dynamic linker is guaranteed that if a library supports
*every* interface number between FIRST-INTERFACE and LAST-INTERFACE,
then the program can be relinked against that library.

   Note that this can cause problems because libtool's compatibility
requirements are actually stricter than is necessary.

   Say `libhello' supports interfaces 5, 16, 17, 18, and 19, and that
libtool is used to link `test' against `libhello'.

   Libtool encodes the numbers 5 and 19 in `test', and the dynamic
linker will only link `test' against libraries that support *every*
interface between 5 and 19.  So, the dynamic linker refuses to link
`test' against `libhello'!

   In order to eliminate this problem, libtool only allows libraries to
declare consecutive interface numbers.  So, `libhello' can declare at
most that it supports interfaces 16 through 19.  Then, the dynamic
linker will link `test' against `libhello'.

   So, libtool library versions are described by three integers:

CURRENT
     The most recent interface number that this library implements.

AGE
     The difference between the oldest and newest interfaces that this
     library implements.  In other words, the library implements all the
     interface numbers in the range from number `CURRENT - AGE' to
     `CURRENT'.

REVISION
     The implementation number of the CURRENT interface.

   If two libraries have identical CURRENT and AGE numbers, then the
dynamic linker chooses the library with the greater REVISION number.


File: libtool.info,  Node: Updating Version Info,  Prev: Libtool Versioning,  Up: Versioning

Updating the Library Version Information
========================================

   If you want to use libtool's versioning system, then you must specify
the version information to libtool using the `-version-info' flag
during link mode (*note Link Mode::.).

   This flag accepts an argument of the form
`CURRENT[:REVISION[:AGE]]'.  So, passing `-version-info 3:12:1' sets
CURRENT to 3, REVISION to 12, and AGE to 1.

   If either REVISION or AGE are omitted, they default to 0.  Also note
that AGE must be less than or equal to the CURRENT interface number.

   Here are a set of rules to help you update your library version
information:

  1. Start with version information of `0:0:0' for each libtool library.

  2. Update the version information only immediately before a public
     release of your software.  More frequent updates are unnecessary,
     and only guarantee that the current interface number gets larger
     faster.

  3. If the library source code has changed at all since the last
     update, then increment REVISION (`C:R:A' becomes `C:R+1:A').

  4. If any interfaces have been added, removed, or changed since the
     last update, increment CURRENT, and set REVISION to 0.

  5. If any interfaces have been added since the last public release,
     then increment AGE.

  6. If any interfaces have been removed since the last public release,
     then set AGE to 0.

   *NEVER* try to set library version numbers so that they correspond
to the release of the package that you are making.  This is an abuse
that only fosters misunderstanding of the purpose of library versions.


File: libtool.info,  Node: Library Tips,  Next: Index,  Prev: Versioning,  Up: Top

Tips for Interface Design
*************************

   Writing a good library interface takes a lot of practice and thorough
understanding of the problem that the library is intended to solve.

   If you design a good interface, it won't have to change often, you
won't have to keep updating documentation, and users won't have to keep
relearning how to use the library.

   Here is a brief list of tips for library interface design, which may
help you in your exploits:

Plan ahead
     Try to make every interface truly minimal, so that you won't need
     to delete entry points very often.

Avoid interface changes
     Some people love redesigning and changing entry points just for
     the heck of it (note: *renaming* a function is considered changing
     an entry point).  Don't be one of those people.  If you must
     redesign an interface, then leave compatibility functions behind
     so that users don't need to rewrite their code.

Use opaque data types
     The fewer data type definitions a library user has access to, the
     better.  If possible, design your functions to accept a generic
     pointer (which you can cast to an internal data type), and provide
     access functions rather than allowing the user to directly
     manipulate the data.  That way, you have the freedom to change the
     data structures without changing the interface.

     This is essentially the same thing as using abstract data types and
     inheritance in an object-oriented system.

Use header files
     If you are careful to document each of your library's global
     functions and variables in header files, and include them in your
     source files, then the compiler will let you know if you make any
     interface changes by accident (*note C Header Files::.).

Use the `static' keyword whenever possible
     The fewer global functions your library has, the more flexibility
     you'll have in changing them.  Static functions and variables may
     change forms as often as you like... your users cannot access
     them, so they aren't interface changes.

* Menu:

* C Header Files::              How to write portable include files.


File: libtool.info,  Node: C Header Files,  Prev: Library Tips,  Up: Library Tips

Writing C Header Files
======================

   Writing portable C header files can be difficult, since they may be
read by different types of compilers:

C++ compilers
     C++ compilers require that functions be declared with full
     prototypes, since C++ is more strongly typed than C.  C functions
     and variables also need to be declared with the `extern "C"'
     directive, so that the names aren't mangled.

ANSI C compilers
     ANSI C compilers are not as strict as C++ compilers, but functions
     should be prototyped to avoid unnecessary warnings when the header
     file is `#include'd.

non-ANSI C compilers
     Non-ANSI compilers will report errors if functions are prototyped.

   These complications mean that your library interface headers must use
some C preprocessor magic in order to be usable by each of the above
compilers.

   `foo.h' in the `demo' subdirectory of the libtool distribution
serves as an example for how to write a header file that can be safely
installed in a system directory.

   Here are the relevant portions of that file:

     /* __BEGIN_DECLS should be used at the beginning of your C declarations,
        so that C++ compilers don't mangle their names. */
     #ifndef __BEGIN_DECLS
     # ifdef __cplusplus
     #  define __BEGIN_DECLS extern "C" {
     # else
     #  define __BEGIN_DECLS
     # endif
     #endif
     #ifndef __END_DECLS
     # ifdef __cplusplus
     #  define __END_DECLS };
     # else
     #  define __END_DECLS
     # endif
     #endif
     
     /* __P is a macro used to wrap function prototypes, so that compilers that
        don't understand ANSI C prototypes still work, and ANSI C compilers can
        issue warnings about type mismatches. */
     #ifndef __P
     # if defined (__STDC__) || defined (_AIX) \
             || (defined (__mips) && defined (_SYSTYPE_SVR4)) \
             || defined(WIN32) || defined(__cplusplus)
     #  define __P(protos) protos
     # else
     #  define __P(protos) ()
     # endif
     #endif

   These macros are used in `foo.h' as follows:

     #ifdef _FOO_H_
     #define _FOO_H_
     
     /* The above macro definitions. */
     ...
     
     __BEGIN_DECLS
     int foo __P((void));
     int hello __P((void));
     __END_DECLS
     
     #endif /* !_FOO_H_ */

   Note that the `#ifdef _FOO_H_' prevents the body of `foo.h' from
being read more than once in a given compilation, which prevents
multiple definition errors.

   Feel free to copy the definitions of `__P', `__BEGIN_DECLS', and
`__END_DECLS' into your own headers.  Then, you may use them to create
header files that are valid for C++, ANSI, and non-ANSI compilers.


File: libtool.info,  Node: Index,  Prev: Library Tips,  Up: Top

Index
*****

* Menu:

* .libs subdirectory:                    Linking Libraries.
* `.la' files:                           Linking Libraries.
* `.lo' files:                           Creating Object Files.
* ar:                                    Linking Libraries.
* Buggy system linkers:                  Linking Executables.
* Bugs, subtle ones caused by buggy linkers: Linking Executables.
* Compiling object files:                Creating Object Files.
* Complexity of library systems:         Postmortem.
* Convenience libraries:                 Static Libraries.
* Definition of libraries:               Libtool Paradigm.
* Design issues:                         Issues.
* Design philosophy:                     Motivation.
* Examples of using libtool:             Using Libtool.
* install:                               Installing Libraries.
* Installation, finishing:               Installing Libraries.
* Libraries, definition of:              Libtool Paradigm.
* Libraries, finishing installation:     Installing Libraries.
* Libraries, stripping:                  Installing Libraries.
* Library object file:                   Creating Object Files.
* Libtool examples:                      Using Libtool.
* Libtool libraries:                     Linking Libraries.
* Libtool specifications:                Motivation.
* Linking against installed libraries:   Linking Executables.
* Linking against uninstalled libraries: Linking Executables.
* Motivation for writing libtool:        Motivation.
* Object files, compiling:               Creating Object Files.
* Object files, library:                 Creating Object Files.
* Other implementations, flaws in:       Postmortem.
* PIC (position-independant code):       Creating Object Files.
* Position-independant code:             Creating Object Files.
* Postinstallation:                      Installing Libraries.
* Program wrapper scripts:               Linking Executables.
* ranlib:                                Linking Libraries.
* Reuseability of library systems:       Postmortem.
* Security problems with buggy linkers:  Linking Executables.
* Specifications for libtool:            Motivation.
* Standalone binaries:                   Static Libraries.
* Static linking:                        Static Libraries.
* strip:                                 Installing Libraries.
* Stripping libraries:                   Installing Libraries.
* su:                                    Installing Libraries.
* Tricky design issues:                  Issues.
* Wrapper scripts for programs:          Linking Executables.



Tag Table:
Node: Top979
Node: Introduction3952
Node: Motivation5754
Node: Issues7091
Node: Other Implementations8499
Node: Postmortem9051
Node: Libtool Paradigm10678
Node: Using Libtool11612
Node: Creating Object Files13089
Node: Linking Libraries15316
Node: Linking Executables18206
Node: Installing Libraries22129
Node: Installing Executables24638
Node: Static Libraries25428
Node: Invoking libtool26964
Node: Compile Mode28481
Node: Link Mode29183
Node: Install Mode31207
Node: Finish Mode31655
Node: Uninstall Mode32085
Node: Integrating Libtool32487
Node: Makefile Rules33101
Node: Using Automake34213
Node: Configuring35568
Node: Invoking ltconfig36813
Node: ltconfig Example38429
Node: AM_PROG_LIBTOOL40268
Node: Distributing41293
Node: Invoking libtoolize42104
Node: Versioning43216
Node: Interfaces44507
Node: Libtool Versioning45140
Node: Updating Version Info47363
Node: Library Tips49069
Node: C Header Files51316
Node: Index54067

End Tag Table
