############################################################################
#
#	File:     pdco.icn
#
#	Subject:  Procedures for programmer-defined control operations
#
#	Author:   Ralph E. Griswold and Robert J. Alexander
#
#	Date:     July 15, 1995
#
############################################################################
#  
#  These procedures use co-expressions to used to model the built-in
#  control structures of Icon and also provide new ones.
#  
#   Alt{e1,e2}		models e1 | e2
#
#   Apply{e1,e2, ...}   produces result of applying the procedures
#   		        in e1 to argments e2, ...
#
#   Binop{op,e1,e2}     produces the result of applying op to e1 and e2
#
#   Cat{e1,e2, ...}     produces the results of concatenating the
#   		   	sequences for e1, e2, ...
#  
#   Compare{e1,e2}	compares result sequences of e1 and e2
#  
#   Cond{e1,e2, ...}	models the generalized Lisp conditional
#  
#   Every{e1,e2}	models every e1 do e2
#
#   Everynth{e,i,j}	produces every ith value in e starting at j
#  
#   Galt{e1,e2, ...}	models generalized alternation: e1 | e2 |
#                       ...
#
#   Gconj{e1,e2,...}	models generalized conjunction: e1 & e2 & ...
#
#   The programmer-defined control operation above shows an interesting
#   technique for modeling conjunction via recursive generative
#   procedures.
#
#   Inter{e1,e2, ...}	produces results of e1, e2, ... alternately
#  
#   Lcond{e1,e2, ...}	models the Lisp conditional
#
#   Length{e}		returns the length of e
#  
#   Limit{e1,e2}	models e1 \ e2
#
#   Palin{e}		x produces results of concatenating the sequences
#   		   	for e and then its reverse.
#
#   Parallel{e1,e2, ...}
#			Synonym for Inter{e1, e2, ...}
#
#   Permute{e1,e2}	permutes each n-subsequence of e1 by the
#   		  	n positional values in e2.  If e2 does not
#   		   	consist of all the integers in the range 1 to
#   		  	n, "interesting" things happen (see the use
#   		   	of map() for transpositions).
#  
#   Random{e1,e2, ...}	produces results of e1, e2, ... at random
#
#   Reduce{op, x, e}	"reduces" the sequence e by starting with the value x
#			and repetitively applying op to the current
#		  	value and values from e.
#  
#   Repalt{e}		models |e

#   Repeat{e1, e2}	repeats the sequence for e1 e2 times
#  
#   Resume{e1,e2,e3}	models every e1 \ e2 do e3
#
#   Reverse{e}	   	produces the results of e in reverse order
#  
#   Rotate(e, i)	rotates the sequence for e left by i; negative
#   		   	i rotates to the right
#
#   Select{e1,e2}	produces results from e1 by position
#                       according to e2
#
#   TileMirror{e}	produces the results of concatenating e and its
#			reverse, with the center and last value removed;
#			this produces a sequence for tiling
#
#   Trinop(op,e2,e2,e3} produces the result of applying op to
#   		   	e1, e2, and e3
#
#   Unop{op,e}	   	produces the result of applying op to e
#
#   Valrpt{e1,e2}	replicates each value in e1 by the corresponding
#   		   	integer value in e2.
#
#   Wobble{e}	   	produces e(1), e(2), e(1), e(2), e(3), e(2), ...
#  
#   Comments:
#
#   Because of the handling of the scope of local identifiers in
#   co-expressions, expressions in programmer-defined control
#   operations cannot communicate through local identifiers.  Some
#   constructions, such as break and return, cannot be used in argu-
#   ments to programmer-defined control operations.
#  
############################################################################
#
#  Requires:  co-expressions
#
############################################################################
#
#  Links:  lists
#
############################################################################

link lists

procedure Alt(L)	#: PDCO to model alternation

   suspend |@L[1]
   suspend |@L[2]

end

procedure Apply(L)	#: PDCO to apply procedures to arguments
   local p, i, args

   while p := @L[1] do {
      p := proc(p, 3 to 0 by -1) | stop("*** invalid procedure in Apply{}")
      repeat {
         args := []
         every i := 2 to *L  do {
            put(args, @L[i]) | break break
            }
         suspend p ! args
         }
      every i := 2 to *L do
         L[i] := ^L[i]
      }

end

procedure Binop(L)	#: PDCO to apply binary operation to sequences
   local op, x, y

   op := proc(@L[1], 2) | stop("*** invalid first argument to Binop{}")

   while x := @L[2] & y := @L[3] do
      suspend op(x, y)

end

procedure Cat(L)	#: PDCO to concatenate sequences
   local C

   every C := !L do
      suspend |@C

end

procedure Compare(L)	#: PDCO to compare sequences
   local x1, x2

   while x1 := @L[1] do
      (x1 === @L[2]) | fail
   if @L[2] then fail else return *L[1]

end

procedure Cond(L)	#: pdoc for generalized Lisp conditional
   local i, x

   every i := 1 to *L do
      if x := @L[i] then {
         suspend x
         suspend |@L[i]
         fail
         }

end

procedure Every(L)	#: PDCO to model iteration

   while @L[1] do @^L[2]

end

procedure Everynth(L)	#: PDCO generate nth values in sequence
   local i, j, x

   i := @L[2] | 1
   i := integer(i) | stop("*** invalid second argument to Everynth{}")
   j := @L[3] | 1
   j := integer(j) | stop("*** invalid third argument to Everynth{}")

   every 1 to j - 1 do
      @L[1] | fail

   suspend @L[1]

   repeat {
      every 1 to i - 1 do
         @L[1] | fail
      x := @L[1] | fail
      suspend x
      }

end

procedure Galt(L)	#: PDCO for generalized alternation
   local C

   every C := !L do suspend |@C

end

procedure Gconj(L)	#: PDCO for generalized conjunction

   suspend Gconj_(L,1)

end

procedure Gconj_(L,i,v)

   local e
   if e := L[i] then {
      suspend v:= |@e & Gconj_(L,i + 1,v)
      L[i] := ^e
      }
   else suspend v

end

procedure Inter(L)	#: PDCO to interleave sequences

   suspend |@!L

end

procedure Lcond(L)	#: PDCO for Lisp conditional
   local i

   every i := 1 to *L by 2 do
      if @L[i] then {
         suspend |@L[i + 1]
         fail
         }

end

procedure Length(L)	#: PDCO to produce length of sequence
   local i

   i := 0

   while @L[1] do i +:= 1

   return i

end

procedure Limit(L)	#: PDCO to model limtation
   local i, x

   while i := @L[2] do {
      every 1 to i do
         if x := @L[1] then suspend x
         else break
      L[1] := ^L[1]
      }

end

procedure Palin(L)	#: PDCO to produce palindromic sequence
   local tail, x

   tail := []

   while x := @L[1] do {
      suspend x
      push(tail, x)
      } 

   every suspend !tail

end

procedure Parallel(L)	#: synonym for Inter()

   Parallel := Inter			# redefine for next use

   suspend Inter(L)

end

procedure Permute(L)	#: PDCO for permutations
   local temp1, temp2, chunk, i, x

   temp1 := []
   temp2 := []
   i := 0

   while x := @L[2] do {
      put(temp1, x)
      put(temp2, i +:= 1)
      }
   
   repeat {
      chunk := []
      every 1 to i do
         put(chunk, @L[1]) | fail
      suspend !lmap(temp1, temp2, chunk)
      }

end

procedure Random(L)	#: PDCO to generate from sequences at random
   local x

   while x := @?L do suspend x

end

procedure Repalt(L)	#: PDCO to model repeated alternation
   local x

   repeat {
      suspend |@L[1]
      if *L[1] == 0 then fail
      L[1] := ^L[1]
      }

end

procedure Reduce(L)	#: PDCO to reduce sequence using binary operation
   local op, x

   op := proc(@L[1], 2) | stop("*** invalid operation for Reduce{}")
   x := @L[2] | fail

   while x := op(x, @L[3])

   return x

end

procedure Repeat(L)	#: PDCO to repeat sequence
   local i, x

   while i := @L[2] do {
      if not(i := integer(i)) then stop("*** invalid repetition in Repeat{}")
      every 1 to i do {
         suspend |@L[1]
         L[1] := ^L[1]
         }
      }

end

procedure Resume(L)	#: PDCO to model limited iteration
   local i

   while i := @L[2] do {
      L[1] := ^L[1]
      every 1 to i do if @L[1] then @^L[3] else break
      }

end

procedure Reverse(L)	#: PDCO to reverse sequence
   local result

   result := []

   while push(result, @L[1])

   suspend !result

end

procedure Rotate(L)	#: PDCO to rotate sequence
   local result, i

   i := integer(@L[2]) | stop("*** invalid specification in Rotate{}")
   result := []

   while put(result, @L[1])

   suspend !lrotate(result, i)

end


procedure Select(L)	#: PDCO to select subsequence
   local i, j, x

   j := 0

   while i := @L[2] do {
      while j < i do
         if x := @L[1] then j +:= 1
         else fail
      if i = j then suspend x
      else stop("*** sequence error in Select{}")
      }

end

procedure TileMirror(L)	#: PDCO to produce tile mirroring
   local tail, x

   tail := []

   while x := @L[1] do {
      suspend x
      push(tail, x)
      } 

   get(tail)

   pull(tail)

   every suspend !tail

end

procedure Trinop(L)	#: PDCO to apply trinary operator to sequneces
   local op, x, y, z

   op := proc(@L[1], 3) | stop("*** invalid first argument to Trinop{}")

   while x := @L[2] & y := @L[3] & z := @L[4] do
      suspend op(x, y, z)

end

procedure Unop(L)	#: PDCO to apply unary operation to sequence
   local op, x

   op := proc(@L[1], 1) | stop("*** invalid first argument to Unop{}")

   while x := @L[2] do
      suspend op(x)

end

procedure Valrpt(L)	#: PDCO to replicate values in a sequence
   local x, i

   while x := @L[1] do {
      i := @L[2] | {
         if *L[2] = 0 then fail
         else {
            L[2] := ^L[2]
            i := @L[2] | fail
            }
         }
      i := integer(i) | stop("*** invalid repetition in Valrpt{}")
      suspend (1 to i) & x
      }

end

procedure Wobble(L)	#: PDCO to produce sequence values alternately
   local x, y

   x := @L[1] | fail
   suspend x

   while y := @L[1] do {
      suspend y | x | y
      x := y
      }

end
