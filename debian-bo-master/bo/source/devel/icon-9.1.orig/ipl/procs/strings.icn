############################################################################
#
#	File:     strings.icn
#
#	Subject:  Procedures for string utilities
#
#	Author:   Ralph E. Griswold
#
#	Date:     February 3, 1995
#
############################################################################
#  
#  These procedures perform simple operations on strings.
#  
#	charcnt(s, c)	   Returns the number of instancs of characters in c
#			   in s.
#
#       compress(s,c)      Compress consecutive occurrences of charac-
#                          ters in c that occur in s.
#
#	is_pal(s)	   Succeeds if s is palindromic
#  
#       omit(s,c)          Omit all occurrences of characters in c
#                          that occur in s.
#
#       replace(s1,s2,s3)  In s1, replace all occurrences of s2 by s3.
#  
#       rotate(s,i)        Rotate s i characters to the left (negative i
#                          produces rotation to the right); the default
#                          value of i is 1.
#  
############################################################################

procedure charcnt(s,c)
   local count

   count := 0

   s ? {
      while tab(upto(c)) do
         count +:= *tab(many(c))
      }

   return count

end
procedure compress(s,c)
   local result, s1

   result := ""

   s ? {
      while result ||:= tab(upto(c)) do {
         result ||:= (s1 := move(1))
         tab(many(s1))
         }
      return result || tab(0)
      }
end

procedure is_pal(s)

   return reverse(s) == s

end

#  omit characters
#
procedure omit(s,c)
   local result, s1

   result := ""

   s ? {
      while result ||:= tab(upto(c)) do {
         s1 := move(1)
         tab(many(s1))
         }
      return result || tab(0)
      }
end

#  replace string
#
procedure replace(s1,s2,s3)
   local result, i

   result := ""
   i := *s2

   s1 ? {
      while result ||:= tab(find(s2)) do {
         result ||:= s3
         move(i)
         }
      return result || tab(0)
      }
end

#  rotate string
#
procedure rotate(s,i)
   if s == "" then return s
   /i := 1
   if i <= 0 then i +:= *s
   i %:= *s
   return s[i + 1:0] || s[1:i + 1]
end
