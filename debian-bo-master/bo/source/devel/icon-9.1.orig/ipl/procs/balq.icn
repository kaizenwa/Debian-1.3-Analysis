#############################################################################
#
#	File:     balq.icn
#
#	Subject:  Procedures for scanning strings with quotes
#
#	Author:   David A. Gamey
#
#	Date:     March 14, 1995
#
#############################################################################
#
#	Descriptions:
#
#     balq( c1, c2, c3, c4, c5, s, i1, i2 ) : i3
#
#        generates the sequence of integer positions in s preceeding a 
#        character of c1 in s[i1:i2] that is (a) balanced with respect to
#        characters in c2 and c3 and (b) not "quoted" by characters in c4 
#        with "escape" sequences as defined in c5, but 
#        fails if there is no such position.
#
#        defaults:   same as for bal,
#                    c4  the single and double quote characters ' and "
#                    c5  the backwards slash \
#        errors:     same as for bal,
#                    c4 & c5 not csets
#
#     balqc( c1, c2, c3, c4, c5, s1, s2, s3, i1, i2 ) : i3
#
#        like balq with the addition that balanced characters within 
#        "comments", as delimited by the strings s1 and s2, are also 
#        excluded from balancing.  In addition, if s1 is given and s2 
#        is null then the comment terminates at the end of string.
#
#        defaults:   same as for balq,
#                    s3 is the subject string
#                    s1 "/*" 
#                    s2 "*/" if s1 defaults, null otherwise
#        errors:     same as for balq,
#                    s1 is not a string
#                    s2 is not a string (if s1 defaults or is specified) 
#
#############################################################################
#
#  02Aug94 - D.Gamey -  added Balqc
#
#############################################################################

procedure balq( cstop, copen, cclose, cquote, cescape, s, i1, i2 )

local quote, pcount, spos
local ca, c, sp

if /s := &subject then /i1 := &pos
/i1 := 1
/i2 := 0
/cstop   := &cset                                     # stopping characters
/copen   := '('                                       # open characters
/cclose  := ')'                                       # close characters
/cquote  := '\'\"'                                    # quote characters
/cescape := '\\'                                      # escape characters


pcount := 0                                           # "parenthesis" counter
spos   := i1                                          # scanning position

ca := cstop ++ copen ++ cclose ++ cquote ++ cescape   # characters to check

while sp := s[ spos := upto( ca, s, spos, i2 ) ] do { 
      
      if /quote & ( pcount = 0 ) & any( cstop, sp) then suspend spos
      
      if any( c := ( copen | cclose | cquote | cescape ), sp ) then
         
         case c of {
            
            copen  : if /quote then 
                        pcount +:= 1
            
            cclose : if /quote then 
                        if ( pcount -:= 1 ) < 0 then
                           fail
            
            cquote : if /quote then 
                        quote := sp 
                     else 
                        if quote == sp then quote := &null
            
            cescape: if \quote then
                        spos +:= 1
            }
      
      spos +:= 1
      
      }

end

procedure balqc( cstop, copen, cclose, cquote, cescape, scm, ecm, s, i1, i2 )

local quote, pcount, spos
local ca, c, sp
local ccom, comnt

if /s := &subject then /i1 := &pos
/i1 := 1
/i2 := 0
/cstop   := &cset                                     # stopping characters
/copen   := '('                                       # open characters
/cclose  := ')'                                       # close characters
/cquote  := '\'\"'                                    # quote characters
/cescape := '\\'                                      # escape characters

if /scm & /ecm then {
   scm := "/*"                                        # start of comment
   ecm := "*/"                                        # end of comment
   }
else 
   if \scm & /ecm then 
      ecm := &null                                    # icon style comment

ccom := ''
ccom ++:= cset(\scm[1])
ccom ++:= cset(\ecm[1])

pcount := 0                                           # "parenthesis" counter
spos   := i1                                          # scanning position

ca := cstop ++ copen ++ cclose ++ cquote ++ cescape ++ ccom # chars to check

while sp := s[ spos := upto( ca, s, spos, i2 ) ] do { 
      
      if /quote & ( pcount = 0 ) & /comnt & any( cstop, sp) then 
         suspend spos
      
      if any( c := ( copen | cclose | cquote | cescape | ccom ), sp ) then
         
         case c of {
            
            copen  : if /quote & /comnt then 
                        pcount +:= 1
            
            cclose : if /quote & /comnt then 
                        if ( pcount -:= 1 ) < 0 then
                           fail
            
            cquote : if /comnt then
                        if /quote then 
                           quote := sp 
                        else 
                           if quote == sp then quote := &null
            
            cescape: if \quote then 
                        spos +:= 1

            ccom   : if /quote then 
                        if /comnt then {
                           if comnt := ( s[ spos +: *scm ] == scm ) then
                              spos +:= *scm - 1
                           }
                        else
                           if \ecm == s[ spos +: *ecm ] then {
                              spos +:= *ecm - 1
                              comnt := &null
                              }
                              
            }
      
      spos +:= 1
      
      }

end
