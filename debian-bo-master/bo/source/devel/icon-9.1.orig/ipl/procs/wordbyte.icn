############################################################################
#
#	File:     wordbyte.icn
#
#	Subject:  Procedures to manipulate words and bytes
#
#	Author:   Robert J. Alexander
#
#	Date:     September 22, 1993
#
############################################################################
# 
#  These procedures read numbers in several different formats. The numbers
#  are read directly from files.
# 
#  The naming convention is Get<signed><endian><bits>, where
# 
# 	<signed> is "S" if signed, otherwise ""
# 	<endian> is "I" if Motorola, "R" if Intel (the mnemonic intent
# 				is Integer and Reversed, not great choices
#				but they stuck)
#	<bits> is 16 or 32
#
############################################################################

#
#  GetI32() -- Return the unsigned value of the next
#  non-byte-reversed 32-bit word of data from file.
#
procedure GetI32(f)
  local s,i
  (s := reads(f,4) & *s = 4) | fail
  i := 0
  s ? {
    while i := i * 256 + ord(move(1))
  }
  return i
end

#
#  GetSI32() -- Return the signed value of the next
#  non-byte-reversed 32-bit word of data from file.
#
procedure GetSI32(f)
  return Signed32(GetI32(f))
end

#
#  GetR32() -- Return the unsigned value of the next byte-reversed
#  32-bit word of data from file.
#
procedure GetR32(f)
  local s,m,i
  (s := reads(f,4) & *s = 4) | fail
  i := 0
  m := 1
  s ? {
    while i +:= m * ord(move(1)) do
        m *:= 256
  }
  return i
end

#
#  GetSR32() -- Return the signed value of the next byte-reversed
#  32-bit word of data from file.
#
procedure GetSR32(f)
  return Signed32(GetR32(f))
end

#
#  Unsigned32() -- Convert a signed to its unsigned equivalent.
#
procedure Unsigned32(i)
  return if i < 0 then i + 4294967296 else i
end

#
#  Signed32() -- Convert an unsigned to its signed equivalent.
#
procedure Signed32(i)
  return if i >= 2147483648 then i - 4294967296 else i
end

#
#  GetI16() -- Return the unsigned integer value of the 16-bit
#  non-byte-reversed word in file f.
#
procedure GetI16(f)
  return 256 * ord(reads(f)) + ord(reads(f))
end

#
#  GetSI16() -- Return the signed integer value of the 16-bit
#  non-byte-reversed word in file f.
#
procedure GetSI16(f)
  return Signed16(GetI16(f))
end

#
#  GetR16() -- Return the unsigned integer value of the 16-bit
#  byte-reversed word in file f.
#
procedure GetR16(f)
  return ord(reads(f)) + 256 * ord(reads(f))
end

#
#  GetSR16() -- Return the signed integer value of the 16-bit
#  byte-reversed word in file f.
#
procedure GetSR16(f)
  return Signed16(GetR16(f))
end

#
#  Unsigned16() -- Convert a signed to its unsigned equivalent.
#
procedure Unsigned16(i)
  return if i < 0 then i + 65536 else i
end

#
#  Signed16() -- Convert an unsigned to its signed equivalent.
#
procedure Signed16(i)
  return if i >= 32768 then i - 65536 else i
end


#
#  Procedures to access bytes from files as numeric 8-bit
#  values.
#

#
#  GetByte() -- Return the unsigned integer value of the next byte of file f.
#
procedure GetByte(f)
  return ord(reads(f))
end

#
#  GetSByte() -- Return the signed integer value of the next byte of file f.
#
procedure GetSByte(f)
  return SignedByte(GetByte(f))
end

#
#  PeekByte() -- Peek at the next byte without consuming it.
#
procedure PeekByte(f)
  local value
  value := GetByte(f)
  seek(f,where(f) - 1)
  return value
end

#
#  UnsignedByte() -- Convert a signed to its unsigned equivalent.
#
procedure UnsignedByte(i)
  return if i < 0 then i + 256 else i
end

#
#  SignedByte() -- Convert an unsigned to its signed equivalent.
#
procedure SignedByte(i)
  return if i >= 128 then i - 256 else i
end

