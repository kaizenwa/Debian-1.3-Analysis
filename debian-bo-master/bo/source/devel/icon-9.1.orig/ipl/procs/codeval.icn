############################################################################
#
#	File:     codeval.icn
#
#	Subject:  Procedures to encode and decode Icon values
#
#	Author:   Ralph E. Griswold
#
#	Date:     May 28, 1994
#
############################################################################
#
#     These procedures provide a way of storing any Icon value as a string
#  and retrieving it.
#
#     The procedure encode(x) converts x to a string s that can be converted
#  back to x by decode(s). These procedures handle all kinds of values,
#  including structures of arbitrary complexity with loops.
#
#     For "scalar" types -- null, integer, real, cset, and string --
#
#	decode(encode(x)) === x
#
#     For structures types -- list, set, table, and record types --
#  decode(encode(x)) is, for course, not identical to x, but it has the
#  same "shape" and its elements bear the same relation to the original
#  as if they were encoded and decode individually.
#
#     Not much can be done with files and procedures except to preserve
#  type and identification.  For co-expressions, only type can be
#  preserved, since there is no way to find out the expression with
#  which a co-expression was created.
#
#     The encoding of strings and csets handles all characters in a way
#  that it is safe to write the encoding to a file and read it back.
#
#     The string encoding of a value can be long. Icon itself imposes no
#  restrictions on the lengths of lines that can be written or read, but
#  some platforms do.  If encoded values are to be saved in files on
#  such platforms, procedures may be needed to deal write and read long
#  strings in pieces.
#
############################################################################
#
#     The encoding of a value consists of four parts:  a tag, a length,
#  a type code, and a string of the specified length that encodes the value
#  itself.
#
#     The tag serves as a unique identification. If a value appears more than
#  once, only its tag appears after the first encoding.  Tags are strings
#  starting with "t" followed by zero or more lowercase letters.
#
#     The length is simply the length of the encoded value that follows.
#
#     The type codes consist of single letters taken from the first character
#  of the type name, with upper- and lowercase used to avoid ambiguities.
#  The type code "t" identifies tags to distinguish them from encoded
#  values.
#
#     Where a structure contains several elements, the encodings of the
#  elements are concatenated. Note that the form of the encoding contains
#  the information needed to separate consecutive elements.
#
#     Here are some examples of values and their encodings:
#
#	x                        encode(x)
#  -------------------------------------------------------
#
#	1                        "t1i1"
#	2.0                      "ta3r2.0"
#	&null                    "tb0n"
#	"\xff"                   "tc6s\"\\xff\""
#	'\x03\x04'               "td10c'\\x03\\x04'"
#	main                     "te4pmain"
#	create 1 to 10           "tf0C"
#	[]                       "tg0L"
#	set()                    "th0S"
#	table("a")               "ti7Ttj3s\"a\""
#	["hi", "there"]          "tk19Ltl4s\"hi\"tm7s\"there\""
#
#  A loop is illsutrated by
#
#	L := []
#	put(L,L)
#
#  for which the encoding is
#
#	x                        encode(x)
#  -------------------------------------------------------
#
#	L                        "tn4L2ttn"
#
#  Of course, you don't have to know all this to use encode() and decode().
#
############################################################################
#
#  Links:  gener, ivalue, procname, typecode
#
############################################################################
#
#  Requires:  co-expressions
#
############################################################################

invocable all

link gener
link ivalue
link procname
link typecode

#  Encode a value as a string.
#
procedure encode(x, outlab)
   local str, tag, typed
   static label

   initial label := create "t" || star(string(&lcase))

#  Table of labels is reset for each top-level call and passed on.

   /outlab := table()

#  If the value is labelled, produce the encoding directly.
   if str := \outlab[x] then return *str || "t" || str

   typed := typecode(x)

   tag := outlab[x] := @label

   str := ""					# in case of concatenation

   case typed of {
      !"iscrfw": str := image(x)		# first the scalars
      !"nC":     ""
      !"LS":     every str ||:= encode(!x, outlab)		# elements
				# default, then elements
      "T":       every str ||:= encode(x[[]] | !sort(x,3), outlab)
				# type, then elements
      "R":       every str ||:= encode(type(x) | !x, outlab)
      "p":       str := procname(x)
      default:   stop("unsupported type in encode: ",image(x))
      }

   return tag || *str || typed || str

end

#  Generate decoded results.  At the top level, there is only one,
#  but for structures, decode() is called recursively and generates the
#  their decoded elements. 
#
procedure decode(s, inlab)
   local tag, size, typed, value, C, L, R, S, T, f, w

   /inlab := table()			# reset on top-level call

   while *s ~= 0 do {
      s ?:= {
         tag := tab(many(&lcase))		# may fail, if so, not used
         size := tab(many(&digits))
         typed := move(1)
         value := move(size)
         tab(0)					# s gets the rest
         }
      suspend case typed of {
         "t":      inlab[value]		# label for an object
         !"iscrn": inlab[tag] := ivalue(value)
         "L":      {
            inlab[tag] := L := []	# insert object for label
            every put(L, decode(value, inlab))
            L				# value produced
            }
         "R":      {			# note use of co-expressions to control
					# generation; the record must be created
					# before the fields are processed.
            C := create decode(value, inlab)
            inlab[tag] := R := proc(@C)() | stop("error in decoding record")
            every !R := @C
            R
            }
         "S":      {
            inlab[tag] := S := set()
            every insert(S,decode(value, inlab))
            S				# value produced
            }
         "T":      {
            C := create decode(value, inlab)
            inlab[tag] := T := table(@C)
            while T[@C] := @C
            T
            }
         "f":      {
            f := ivalue(value) | {
               value ? {
                  ="file("
                  open(tab(-1)) | stop("*** cannot open encoded file")
                  }
               }
            inlab[tag] := f
            }
         "w":      {
            w := ivalue(value) | {
               value ? {
                  ="window("
                  open(tab(-1), "x") | stop("*** cannot open encoded window")
                  }
               }
            inlab[tag] := w
            }
         "C":      inlab[tag] := create &fail	# can't hurt much to fail
         "p":      inlab[tag] := (proc(value) | 
            stop("encoded procedure not found")) \ 1
         default:  stop("unsupported type in decode: ",typed)
         }
      }
end
