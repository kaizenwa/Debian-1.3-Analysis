############################################################################
#
#	File:     kaleido.icn
#
#	Subject:  Program to produce kaleidoscopic display
#
#	Author:   Ralph E. Griswold
#
#	Date:     April 25, 1995
#
############################################################################
#
#  This program displays kaleidoscopic images.  The controls on the
#  user interface are relatively intuitive -- trying them will give
#  a better idea of what's possible than a prose description here.
#
#  This program is based on an earlier one by Steve Wampler, which in
#  turn was based on a C program by Lorraine Callahan.
#
############################################################################
#
#  Requires:  Version 9 graphics
#
############################################################################
#
#  Links:  interact, randomize, vsetup
#
############################################################################

link interact
link randomiz
link vsetup

#  Interface globals

global vidgets				# table of vidgets
global root				# the root vidget
global size				# size of display area (width & height)
global half				# half size of display area
global pane				# graphics context for viewing

#  Parameters that can be set from the interface

global delayval				# delay between drawing circles
global density				# number of circles in steady state
global draw				# drawing procedure
global max_off				# maximum offset of circle
global min_off				# minimum offset of circle
global max_radius			# maximum radius of circle
global min_radius			# minimum radius of circle

#  State information

global draw_list			# list of pending drawing parameters
global reset				# nonnull when display needs resetting
global state				# pause/run state

procedure main()

   vidgets := ui()			# initialize the interface

   init()				# initialize application

   kaleidoscope()			# run the kaleidoscope

end

#  Circle erasure

procedure clrcircles()

   #  Get oldest circle specification and redraw to erase.

   outcircles(
     get(draw_list),			# off1
     get(draw_list),			# off2
     get(draw_list),			# radius
     get(draw_list)			# color
     )

   return

end

#  Circle density callback

procedure density_cb(vidget, value)

   density := value

   reset := 1

end

#  File menu callback

procedure file_cb(vidget, value)

   case value[1] of {
      "snapshot @S":  return snapshot(pane, -half, -half, size, size)
      "quit     @Q":  exit()
      }

end

#  Initialization

procedure init()

   # Set values from interface.

   root := vidgets["root"]
   size := vidgets["region"].uw
   half := size / 2
   if vidgets["region"].uh ~= size then stop("*** improper interface layout")

   pane := Clone("bg=black", "dx=" || (vidgets["region"].ux + half),
      "dy=" || (vidgets["region"].uy + half))
   Clip(pane, -half, -half, size, size)

#  Set initial values.

   delayval := 0
   density := 30
   max_radius := size / 4
   min_radius := 1
   draw := FillCircle

#  Initialize vidget states.

   VSetState(vidgets["sld_speed"], delayval)
   VSetState(vidgets["sld_density"], density)
   VSetState(vidgets["sld_min_radius"], min_radius)
   VSetState(vidgets["sld_max_radius"], max_radius)
   VSetState(vidgets["shape"], "disc")

   randomize()

   state := &null

   return

end

#  The kaleidoscope proper

procedure kaleidoscope()

   #  Each time through this loop, the display is cleared and a
   #  new drawing is started.

   repeat {

      WAttrib(pane, "drawop=copy")
      EraseArea(pane, -half, -half, size, size)
      WAttrib(pane, "drawop=reverse")
      draw_list := []				# new drawing list
      reset := &null

      #  In this loop a new circle is drawn and an old one erased, once the
      #  specified density has been reached.  This maintains a steady state.

      repeat {
         while (*Pending() > 0) | \state do {
            ProcessEvent(root, , shortcuts)
            if \reset then break break next
            }
         WDelay(delayval)
         putcircles()
         WDelay(delayval)

         #  Don't start clearing circles until the specified density has
         #  been reached. (The drawing list has four elements for each circle).

         if *draw_list > 4 * density then clrcircles()
         }
      }

end

#  Maximum radius callback

procedure max_radius_cb(vidget, value)

   max_radius := value

   if max_radius < min_radius then {	# if max < min lower min
      min_radius := max_radius
      VSetState(vidgets["sld_min_radius"], min_radius)
      }

   reset := 1

   return

end

#  Minimum radius callback

procedure min_radius_cb(vidget, value)

   min_radius := value

   if min_radius > max_radius then {	# if min > max raise max
      max_radius := min_radius
      VSetState(vidgets["sld_max_radius"], max_radius)
      }

   reset := 1

   return

end

#  Symmetric circle drawing

procedure outcircles(off1, off2, radius, color)

   Fg(pane, color)

   # Draw in symmetric positions.

   draw(pane, off1, off2, radius)
   draw(pane, off1, -off2, radius)
   draw(pane, -off1, off2, radius)
   draw(pane, -off1,-off2, radius)
   draw(pane, off2, off1, radius)
   draw(pane, off2, -off1, radius)
   draw(pane, -off2, off1, radius)
   draw(pane, -off2,-off1, radius)

   return

end

#  Pause callback

procedure pause_cb(vidget, value)

   state := value

   return

end

#  Circle placement

procedure putcircles()
   local off1, off2, radius, color
   static colors

   initial colors := PaletteChars("c1")

   #  Get a random center point and radius.

   off1 := ?size % half
   off2 := ?size % half
   radius := (max_radius - min_radius) * ?0 + min_radius

   #  Get a random color.

   color := PaletteColor("c1", ?colors)

   #  Append circle specifications to drawing list.
   
   put(draw_list, off1, off2, radius, color)

   #  Draw the circle

   outcircles(off1, off2, radius, color)

   return

end

#  Reset callback

procedure reset_cb(vidget, value)

   reset := 1

   return

end

#  Shape callback

procedure shape_cb(vidget, value)

   draw := case value of {
     "disc":  FillCircle
     "ring":  DrawCircle
     }

   reset := 1

   return

end

#  Processing of keyboard shortcuts

procedure shortcuts(e)

   if &meta then
      case map(e) of {			# fold case
         "q":	exit()
         "s":	return snapshot(pane, -half, -half, size, size)
         }

   return

end

#  Drawing speed callback

procedure speed_cb(vidget, value)

   delayval := value

   return

end

#===<<vib:begin>>===	modify using vib; do not remove this marker line
procedure ui_atts()
   return ["size=600,455", "bg=pale-gray", "label=kaleido"]
end

procedure ui(win, cbk)
return vsetup(win, cbk,
   [":Sizer:::0,0,600,455:kaleido",],
   ["file:Menu:pull::12,3,36,21:File",file_cb,
      ["snapshot @S","quit     @Q"]],
   ["label01:Label:::13,180,21,13:min",],
   ["label02:Label:::152,180,21,13:max",],
   ["label03:Label:::13,240,21,13:min",],
   ["label04:Label:::152,240,21,13:max",],
   ["label05:Label:::13,300,21,13:min",],
   ["label06:Label:::152,300,21,13:max",],
   ["label07:Label:::7,120,28,13:slow",],
   ["label08:Label:::151,120,28,13:fast",],
   ["lbl_density:Label:::67,160,49,13:density",],
   ["lbl_max_radius:Label:::43,280,98,13:maximum radius",],
   ["lbl_min_radius:Label:::44,220,98,13:minimum radius",],
   ["lbl_speed:Label:::74,100,35,13:speed",],
   ["line:Line:::0,30,600,30:",],
   ["pause:Button:regular:1:33,55,45,20:pause",pause_cb],
   ["reset:Button:regular::111,55,45,20:reset",reset_cb],
   ["shape:Choice::2:66,359,57,42:",shape_cb,
      ["disc","ring"]],
   ["sld_density:Slider:h:1:42,180,100,15:1,100,50",density_cb],
   ["sld_max_radius:Slider:h:1:42,300,100,15:1,230,115",max_radius_cb],
   ["sld_min_radius:Slider:h:1:42,240,100,15:1,230,115",min_radius_cb],
   ["sld_speed:Slider:h:1:42,120,100,15:500,0,250",speed_cb],
   ["region:Rect:raised::188,42,400,400:",],
   )
end
#===<<vib:end>>===	end of section maintained by vib
