This is Info file g77.info, produced by Makeinfo version 1.67 from the
input file g77.texi.

   This file explains how to use the GNU Fortran system.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1995-1997 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.

   Contributed by James Craig Burley (<burley@gnu.ai.mit.edu>).
Inspired by a first pass at translating `g77-0.5.16/f/DOC' that was
contributed to Craig by David Ronis (<ronis@onsager.chem.mcgill.ca>).

INFO-DIR-SECTION Fortran Programming
START-INFO-DIR-ENTRY
* g77: (g77).               The GNU Fortran compilation system.
END-INFO-DIR-ENTRY


File: g77.info,  Node: Log10 Intrinsic,  Next: Long Intrinsic,  Prev: Log Intrinsic,  Up: Table of Intrinsic Functions

Log10 Intrinsic
...............

     Log10(X)

Log10: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the natural logarithm of X, which must be greater than zero
or, if type `COMPLEX', must not be zero.

   The inverse function is `10. ** LOG10(X)'.

   *Note Log Intrinsic::, for the natural logarithm function.


File: g77.info,  Node: Long Intrinsic,  Next: LShift Intrinsic,  Prev: Log10 Intrinsic,  Up: Table of Intrinsic Functions

Long Intrinsic
..............

     Long(A)

Long: `INTEGER(KIND=1)' function.

A: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.


File: g77.info,  Node: LShift Intrinsic,  Next: LStat Intrinsic,  Prev: Long Intrinsic,  Up: Table of Intrinsic Functions

LShift Intrinsic
................

     LShift(I, SHIFT)

LShift: `INTEGER' function, the `KIND=' value of the type being that of
argument I.

I: `INTEGER'; scalar; INTENT(IN).

SHIFT: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: LStat Intrinsic,  Next: LTime Intrinsic,  Prev: LShift Intrinsic,  Up: Table of Intrinsic Functions

LStat Intrinsic
...............

     LStat(FILE, SARRAY)

LStat: `INTEGER(KIND=1)' function.

FILE: `CHARACTER'; scalar; INTENT(IN).

SARRAY: `INTEGER(KIND=1)'; DIMENSION(13); INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Obtains data about the given FILE and places them in the array
SARRAY.  If FILE is a symbolic link it returns data on the link itself,
so the routine is available only on systems that support symbolic links.
The values in this array are extracted from the `stat' structure as
returned by `fstat(2)' q.v., as follows:

  1. File mode

  2. Inode number

  3. ID of device containing directory entry for file

  4. Device id (if relevant)

  5. Number of links

  6. Owner's uid

  7. Owner's gid

  8. File size (bytes)

  9. Last access time

 10. Last modification time

 11. Last file status change time

 12. Preferred i/o block size

 13. Number of blocks allocated

   Not all these elements are relevant on all systems.  If an element
is not relevant, it is returned as 0.

   Returns 0 on success, otherwise an error number.


File: g77.info,  Node: LTime Intrinsic,  Next: Max Intrinsic,  Prev: LStat Intrinsic,  Up: Table of Intrinsic Functions

LTime Intrinsic
...............

     CALL LTime(STIME, TARRAY)

STIME: `INTEGER(KIND=1)'; scalar; INTENT(IN).

TARRAY: `INTEGER(KIND=1)'; DIMENSION(9); INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Given a system time value STIME, fills TARRAY with values extracted
from it appropriate to the GMT time zone using `localtime(3)'.

   The array elements are as follows:

  1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
     seconds

  2. Minutes after the hour, range 0-59

  3. Hours past midnight, range 0-23

  4. Day of month, range 0-31

  5. Number of months since January, range 0-12

  6. Number of days since Sunday, range 0-6

  7. Years since 1900

  8. Days since January 1

  9. Daylight savings indicator: positive if daylight savings is in
     effect, zero if not, and negative if the information isn't
     available.


File: g77.info,  Node: Max Intrinsic,  Next: Max0 Intrinsic,  Prev: LTime Intrinsic,  Up: Table of Intrinsic Functions

Max Intrinsic
.............

     Max(A-1, A-2, ..., A-n)

Max: `INTEGER' or `REAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

A: `INTEGER' or `REAL'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the argument with the largest value.

   *Note Min Intrinsic::, for the opposite function.


File: g77.info,  Node: Max0 Intrinsic,  Next: Max1 Intrinsic,  Prev: Max Intrinsic,  Up: Table of Intrinsic Functions

Max0 Intrinsic
..............

     Max0(A-1, A-2, ..., A-n)

Max0: `INTEGER(KIND=1)' function.

A: `INTEGER(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MAX()' that is specific to one type for A.  *Note
Max Intrinsic::.


File: g77.info,  Node: Max1 Intrinsic,  Next: MClock Intrinsic,  Prev: Max0 Intrinsic,  Up: Table of Intrinsic Functions

Max1 Intrinsic
..............

     Max1(A-1, A-2, ..., A-n)

Max1: `INTEGER(KIND=1)' function.

A: `REAL(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MAX()' that is specific to one type for A and a
different return type.  *Note Max Intrinsic::.


File: g77.info,  Node: MClock Intrinsic,  Next: Min Intrinsic,  Prev: Max1 Intrinsic,  Up: Table of Intrinsic Functions

MClock Intrinsic
................

     MClock()

MClock: `INTEGER(KIND=2)' function.

Intrinsic groups: `unix'.

Description:

   Returns the number of clock ticks since the start of the process.
Only defined on systems with `clock(3)' (q.v.).


File: g77.info,  Node: Min Intrinsic,  Next: Min0 Intrinsic,  Prev: MClock Intrinsic,  Up: Table of Intrinsic Functions

Min Intrinsic
.............

     Min(A-1, A-2, ..., A-n)

Min: `INTEGER' or `REAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

A: `INTEGER' or `REAL'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the argument with the smallest value.

   *Note Max Intrinsic::, for the opposite function.


File: g77.info,  Node: Min0 Intrinsic,  Next: Min1 Intrinsic,  Prev: Min Intrinsic,  Up: Table of Intrinsic Functions

Min0 Intrinsic
..............

     Min0(A-1, A-2, ..., A-n)

Min0: `INTEGER(KIND=1)' function.

A: `INTEGER(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MIN()' that is specific to one type for A.  *Note
Min Intrinsic::.


File: g77.info,  Node: Min1 Intrinsic,  Next: Mod Intrinsic,  Prev: Min0 Intrinsic,  Up: Table of Intrinsic Functions

Min1 Intrinsic
..............

     Min1(A-1, A-2, ..., A-n)

Min1: `INTEGER(KIND=1)' function.

A: `REAL(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MIN()' that is specific to one type for A and a
different return type.  *Note Min Intrinsic::.


File: g77.info,  Node: Mod Intrinsic,  Next: MvBits Intrinsic,  Prev: Min1 Intrinsic,  Up: Table of Intrinsic Functions

Mod Intrinsic
.............

     Mod(A, P)

Mod: `INTEGER' or `REAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

A: `INTEGER' or `REAL'; scalar; INTENT(IN).

P: `INTEGER' or `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns remainder calculated as:

     A - (INT(A / P) * P)

   P must not be zero.


File: g77.info,  Node: MvBits Intrinsic,  Next: NInt Intrinsic,  Prev: Mod Intrinsic,  Up: Table of Intrinsic Functions

MvBits Intrinsic
................

     CALL MvBits(FROM, FROMPOS, LEN, TO, TOPOS)

FROM: `INTEGER'; scalar; INTENT(IN).

FROMPOS: `INTEGER'; scalar; INTENT(IN).

LEN: `INTEGER'; scalar; INTENT(IN).

TO: `INTEGER' with same `KIND=' value as for FROM; scalar;
INTENT(INOUT).

TOPOS: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `mil', `f90', `vxt'.


File: g77.info,  Node: NInt Intrinsic,  Next: Not Intrinsic,  Prev: MvBits Intrinsic,  Up: Table of Intrinsic Functions

NInt Intrinsic
..............

     NInt(A)

NInt: `INTEGER(KIND=1)' function.

A: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns A with the fractional portion of its magnitude eliminated by
rounding to the nearest whole number and with its sign preserved,
converted to type `INTEGER(KIND=1)'.

   If A is type `COMPLEX', its real part is rounded and converted.

   A fractional portion exactly equal to `.5' is rounded to the whole
number that is larger in magnitude.  (Also called "Fortran round".)

   *Note Int Intrinsic::, for how to convert, truncate to whole number.

   *Note ANInt Intrinsic::, for how to round to nearest whole number
without converting.


File: g77.info,  Node: Not Intrinsic,  Next: Or Intrinsic,  Prev: NInt Intrinsic,  Up: Table of Intrinsic Functions

Not Intrinsic
.............

     Not(I)

Not: `INTEGER' function, the `KIND=' value of the type being that of
argument I.

I: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `mil', `f90', `vxt'.

Description:

   Returns value resulting from boolean NOT of each bit in I.


File: g77.info,  Node: Or Intrinsic,  Next: PError Intrinsic,  Prev: Not Intrinsic,  Up: Table of Intrinsic Functions

Or Intrinsic
............

     Or(I, J)

Or: `INTEGER' or `LOGICAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

I: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

J: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.

Description:

   Returns value resulting from boolean OR of pair of bits in each of I
and J.


File: g77.info,  Node: PError Intrinsic,  Next: Rand Intrinsic,  Prev: Or Intrinsic,  Up: Table of Intrinsic Functions

PError Intrinsic
................

     CALL PError(STRING)

STRING: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Prints (on the C `stderr' stream) a newline-terminated error message
corresponding to the last system error.  This is prefixed by STRING, a
colon and a space.  See `perror(3)'.


File: g77.info,  Node: Rand Intrinsic,  Next: Real Intrinsic,  Prev: PError Intrinsic,  Up: Table of Intrinsic Functions

Rand Intrinsic
..............

     Rand(FLAG)

Rand: `REAL(KIND=1)' function.

FLAG: `INTEGER'; OPTIONAL; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Returns a uniform quasi-random number between 0 and 1.  If FLAG is
0, the next number in sequence is returned; if FLAG is 1, the generator
is restarted by calling `srand(0)'; if FLAG has any other value, it is
used as a new seed with `srand'.

   *Note SRand Intrinsic::.

   *Note:* As typically implemented (by the routine of the same name in
the C library), this random number generator is a very poor one, though
the BSD and GNU libraries provide a much better implementation than the
`traditional' one.  On a different system you almost certainly want to
use something better.


File: g77.info,  Node: Real Intrinsic,  Next: RealPart Intrinsic,  Prev: Rand Intrinsic,  Up: Table of Intrinsic Functions

Real Intrinsic
..............

     Real(A)

Real: `REAL' function.  The exact type is `REAL(KIND=1)' when argument
A is any type other than `COMPLEX', or when it is `COMPLEX(KIND=1)'.
When A is any `COMPLEX' type other than `COMPLEX(KIND=1)', this
intrinsic is valid only when used as the argument to `REAL()', as
explained below.

A: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Converts A to `REAL(KIND=1)'.

   Use of `REAL()' with a `COMPLEX' argument (other than
`COMPLEX(KIND=1)') is restricted to the following case:

     REAL(REAL(A))

This expression converts the real part of A to `REAL(KIND=1)'.

   *Note REAL() and AIMAG() of Complex::, for more information.


File: g77.info,  Node: RealPart Intrinsic,  Next: Rename Intrinsic,  Prev: Real Intrinsic,  Up: Table of Intrinsic Functions

RealPart Intrinsic
..................

     RealPart(Z)

RealPart: `REAL' function, the `KIND=' value of the type being that of
argument Z.

Z: `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: `gnu'.

Description:

   The real part of Z is returned, without conversion.

   *Note:* The way to do this in standard Fortran 90 is `REAL(Z)'.
However, when, for example, Z is `COMPLEX(KIND=2)', `REAL(Z)' means
something different for some compilers that are not true Fortran 90
compilers but offer some extensions standardized by Fortran 90 (such as
the `DOUBLE COMPLEX' type, also known as `COMPLEX(KIND=2)').

   The advantage of `REALPART()' is that, while not necessarily more or
less portable than `REAL()', it is more likely to cause a compiler that
doesn't support it to produce a diagnostic than generate incorrect code.

   *Note REAL() and AIMAG() of Complex::, for more information.


File: g77.info,  Node: Rename Intrinsic,  Next: RShift Intrinsic,  Prev: RealPart Intrinsic,  Up: Table of Intrinsic Functions

Rename Intrinsic
................

     CALL Rename(PATH1, PATH2, STATUS)

PATH1: `CHARACTER'; scalar; INTENT(IN).

PATH2: `CHARACTER'; scalar; INTENT(IN).

STATUS: `INTEGER'; OPTIONAL; scalar; INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Renames the file PATH1 to PATH2.  See `rename(2)'.  If the STATUS
argument is supplied, it contains 0 on success or an error code
otherwise upon return.


File: g77.info,  Node: RShift Intrinsic,  Next: Second Intrinsic,  Prev: Rename Intrinsic,  Up: Table of Intrinsic Functions

RShift Intrinsic
................

     RShift(I, SHIFT)

RShift: `INTEGER' function, the `KIND=' value of the type being that of
argument I.

I: `INTEGER'; scalar; INTENT(IN).

SHIFT: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: Second Intrinsic,  Next: Second Intrinsic (Form SECOND (subroutine)),  Prev: RShift Intrinsic,  Up: Table of Intrinsic Functions

Second Intrinsic
................

     Second()

Second: `REAL(KIND=1)' function.

Intrinsic groups: `unix'.

Description:

   Returns the process' runtime in seconds--the same value as the UNIX
function `etime' returns.

   This routine is known from Cray Fortran.


File: g77.info,  Node: Second Intrinsic (Form SECOND (subroutine)),  Next: Short Intrinsic,  Prev: Second Intrinsic,  Up: Table of Intrinsic Functions

Second Intrinsic (Form SECOND (subroutine))
...........................................

     CALL Second(SECONDS)

SECONDS: `REAL(KIND=1)'; scalar; INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Returns the process' runtime in seconds in SECONDS--the same value
as the UNIX function `etime' returns.

   This routine is known from Cray Fortran.


File: g77.info,  Node: Short Intrinsic,  Next: Sign Intrinsic,  Prev: Second Intrinsic (Form SECOND (subroutine)),  Up: Table of Intrinsic Functions

Short Intrinsic
...............

     Short(A)

Short: `INTEGER(KIND=6)' function.

A: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.


File: g77.info,  Node: Sign Intrinsic,  Next: Signal Intrinsic,  Prev: Short Intrinsic,  Up: Table of Intrinsic Functions

Sign Intrinsic
..............

     Sign(A, B)

Sign: `INTEGER' or `REAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

A: `INTEGER' or `REAL'; scalar; INTENT(IN).

B: `INTEGER' or `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: Signal Intrinsic,  Next: Sin Intrinsic,  Prev: Sign Intrinsic,  Up: Table of Intrinsic Functions

Signal Intrinsic
................

     CALL Signal(NUMBER, HANDLER)

NUMBER: `INTEGER'; scalar; INTENT(IN).

HANDLER: Signal handler (`INTEGER FUNCTION' or `SUBROUTINE') or
dummy/global `INTEGER(KIND=1)' scalar.

Intrinsic groups: `unix'.

Description:

   If HANDLER is a an `EXTERNAL' routine, arranges for it to be invoked
with a single integer argument (of system-dependent length) when signal
NUMBER occurs.  If NUMBER is an integer it can be used to turn off
handling of signal HANDLER or revert to its default action.  See
`signal(2)'.

   Note that HANDLER will be called with C conventions, so its value in
Fortran terms is obtained by applying `%loc' (or LOC) to it.


File: g77.info,  Node: Sin Intrinsic,  Next: SinH Intrinsic,  Prev: Signal Intrinsic,  Up: Table of Intrinsic Functions

Sin Intrinsic
.............

     Sin(X)

Sin: `REAL' or `COMPLEX' function, the exact type being that of
argument X.

X: `REAL' or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: SinH Intrinsic,  Next: Sleep Intrinsic,  Prev: Sin Intrinsic,  Up: Table of Intrinsic Functions

SinH Intrinsic
..............

     SinH(X)

SinH: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: Sleep Intrinsic,  Next: Sngl Intrinsic,  Prev: SinH Intrinsic,  Up: Table of Intrinsic Functions

Sleep Intrinsic
...............

     CALL Sleep(SECONDS)

SECONDS: `INTEGER(KIND=1)'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Causes the process to pause for SECONDS seconds.  See `sleep(2)'.


File: g77.info,  Node: Sngl Intrinsic,  Next: SqRt Intrinsic,  Prev: Sleep Intrinsic,  Up: Table of Intrinsic Functions

Sngl Intrinsic
..............

     Sngl(A)

Sngl: `REAL(KIND=1)' function.

A: `REAL(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: SqRt Intrinsic,  Next: SRand Intrinsic,  Prev: Sngl Intrinsic,  Up: Table of Intrinsic Functions

SqRt Intrinsic
..............

     SqRt(X)

SqRt: `REAL' or `COMPLEX' function, the exact type being that of
argument X.

X: `REAL' or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: SRand Intrinsic,  Next: Stat Intrinsic,  Prev: SqRt Intrinsic,  Up: Table of Intrinsic Functions

SRand Intrinsic
...............

     CALL SRand(SEED)

SEED: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Reinitialises the generator with the seed in SEED.  *Note IRand
Intrinsic::.  *Note Rand Intrinsic::.


File: g77.info,  Node: Stat Intrinsic,  Next: SymLnk Intrinsic,  Prev: SRand Intrinsic,  Up: Table of Intrinsic Functions

Stat Intrinsic
..............

     Stat(FILE, SARRAY)

Stat: `INTEGER(KIND=1)' function.

FILE: `CHARACTER'; scalar; INTENT(IN).

SARRAY: `INTEGER(KIND=1)'; DIMENSION(13); INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Obtains data about the given FILE and places them in the array
SARRAY.  The values in this array are extracted from the `stat'
structure as returned by `fstat(2)' q.v., as follows:

  1. File mode

  2. Inode number

  3. ID of device containing directory entry for file

  4. Device id (if relevant)

  5. Number of links

  6. Owner's uid

  7. Owner's gid

  8. File size (bytes)

  9. Last access time

 10. Last modification time

 11. Last file status change time

 12. Preferred i/o block size

 13. Number of blocks allocated

   Not all these elements are relevant on all systems.  If an element
is not relevant, it is returned as 0.

   Returns 0 on success, otherwise an error number.


File: g77.info,  Node: SymLnk Intrinsic,  Next: System Intrinsic,  Prev: Stat Intrinsic,  Up: Table of Intrinsic Functions

SymLnk Intrinsic
................

     CALL SymLnk(PATH1, PATH2, STATUS)

PATH1: `CHARACTER'; scalar; INTENT(IN).

PATH2: `CHARACTER'; scalar; INTENT(IN).

STATUS: `INTEGER'; OPTIONAL; scalar; INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Makes a symbolic link from PATH1 to PATH2.  If the STATUS argument
is supplied, it contains 0 on success or an error code otherwise.
Available only on systems that support symbolic links (see
`symlink(2)').


File: g77.info,  Node: System Intrinsic,  Next: System_Clock Intrinsic,  Prev: SymLnk Intrinsic,  Up: Table of Intrinsic Functions

System Intrinsic
................

     CALL System(COMMAND, STATUS)

COMMAND: `CHARACTER'; scalar; INTENT(IN).

STATUS: `INTEGER(KIND=1)'; OPTIONAL; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Passes the command COMMAND to a shell (see `system(3)').  If
argument STATUS is present, it contains the value returned by
`system(3)', presumably 0 if the shell command succeeded.  Note that
which shell is used to invoke the command is system-dependent and
environment-dependent.


File: g77.info,  Node: System_Clock Intrinsic,  Next: Tan Intrinsic,  Prev: System Intrinsic,  Up: Table of Intrinsic Functions

System_Clock Intrinsic
......................

     CALL System_Clock(COUNT, RATE, MAX)

COUNT: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

RATE: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

MAX: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

Intrinsic groups: `f90'.

Description:

   Returns in COUNT the current value of the system clock; this is the
value returned by the UNIX function `times(2)' in this implementation,
but isn't in general.  RATE is the number of clock ticks per second and
MAX is the maximum value this can take, which isn't very useful in this
implementation since it's just the maximum C `unsigned int' value.


File: g77.info,  Node: Tan Intrinsic,  Next: TanH Intrinsic,  Prev: System_Clock Intrinsic,  Up: Table of Intrinsic Functions

Tan Intrinsic
.............

     Tan(X)

Tan: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: TanH Intrinsic,  Next: Time Intrinsic,  Prev: Tan Intrinsic,  Up: Table of Intrinsic Functions

TanH Intrinsic
..............

     TanH(X)

TanH: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).


File: g77.info,  Node: Time Intrinsic,  Next: TtyNam Intrinsic,  Prev: TanH Intrinsic,  Up: Table of Intrinsic Functions

Time Intrinsic
..............

     Time()

Time: `INTEGER(KIND=2)' function.

Intrinsic groups: `unix'.

Description:

   Returns the current time encoded as an integer in the manner of the
UNIX function `time(3)'.  This value is suitable for passing to `CTIME',
`GMTIME', and `LTIME'.


File: g77.info,  Node: TtyNam Intrinsic,  Next: UMask Intrinsic,  Prev: Time Intrinsic,  Up: Table of Intrinsic Functions

TtyNam Intrinsic
................

     TtyNam(UNIT)

TtyNam: `CHARACTER*(*)' function.

UNIT: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Returns the name of the terminal device open on logical unit UNIT or
a blank string if UNIT is not connected to a terminal.


File: g77.info,  Node: UMask Intrinsic,  Next: Unlink Intrinsic,  Prev: TtyNam Intrinsic,  Up: Table of Intrinsic Functions

UMask Intrinsic
...............

     CALL UMask(MASK, OLD)

MASK: `INTEGER'; scalar; INTENT(IN).

OLD: `INTEGER'; OPTIONAL; scalar; INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Sets the file creation mask to OLD and returns the old value in
argument OLD if it is supplied.  See `umask(2)'.


File: g77.info,  Node: Unlink Intrinsic,  Next: XOr Intrinsic,  Prev: UMask Intrinsic,  Up: Table of Intrinsic Functions

Unlink Intrinsic
................

     CALL Unlink(FILE, STATUS)

FILE: `CHARACTER'; scalar; INTENT(IN).

STATUS: `INTEGER(KIND=1)'; OPTIONAL; scalar; INTENT(OUT).

Intrinsic groups: `unix'.

Description:

   Unlink the file FILE.  If the STATUS argument is supplied, it
contains 0 on success or an error code otherwise.  See `unlink(2)'.


File: g77.info,  Node: XOr Intrinsic,  Next: ZAbs Intrinsic,  Prev: Unlink Intrinsic,  Up: Table of Intrinsic Functions

XOr Intrinsic
.............

     XOr(I, J)

XOr: `INTEGER' or `LOGICAL' function, the exact type being the result
of cross-promoting the types of all the arguments.

I: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

J: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.

Description:

   Returns value resulting from boolean exclusive-OR of pair of bits in
each of I and J.


File: g77.info,  Node: ZAbs Intrinsic,  Next: ZCos Intrinsic,  Prev: XOr Intrinsic,  Up: Table of Intrinsic Functions

ZAbs Intrinsic
..............

     ZAbs(A)

ZAbs: `REAL(KIND=2)' function.

A: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.

Description:

   Archaic form of `ABS()' that is specific to one type for A.  *Note
Abs Intrinsic::.


File: g77.info,  Node: ZCos Intrinsic,  Next: ZExp Intrinsic,  Prev: ZAbs Intrinsic,  Up: Table of Intrinsic Functions

ZCos Intrinsic
..............

     ZCos(X)

ZCos: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: ZExp Intrinsic,  Next: ZLog Intrinsic,  Prev: ZCos Intrinsic,  Up: Table of Intrinsic Functions

ZExp Intrinsic
..............

     ZExp(X)

ZExp: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: ZLog Intrinsic,  Next: ZSin Intrinsic,  Prev: ZExp Intrinsic,  Up: Table of Intrinsic Functions

ZLog Intrinsic
..............

     ZLog(X)

ZLog: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.

Description:

   Archaic form of `LOG()' that is specific to one type for X.  *Note
Log Intrinsic::.


File: g77.info,  Node: ZSin Intrinsic,  Next: ZSqRt Intrinsic,  Prev: ZLog Intrinsic,  Up: Table of Intrinsic Functions

ZSin Intrinsic
..............

     ZSin(X)

ZSin: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: ZSqRt Intrinsic,  Prev: ZSin Intrinsic,  Up: Table of Intrinsic Functions

ZSqRt Intrinsic
...............

     ZSqRt(X)

ZSqRt: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.


File: g77.info,  Node: Scope and Classes of Names,  Prev: Functions and Subroutines,  Up: Language

Scope and Classes of Symbolic Names
===================================

   (The following information augments or overrides the information in
Chapter 18 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.  Chapter 18 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

* Menu:

* Underscores in Symbol Names::


File: g77.info,  Node: Underscores in Symbol Names,  Up: Scope and Classes of Names

Underscores in Symbol Names
---------------------------

   Underscores (`_') are accepted in symbol names after the first
character (which must be a letter).


File: g77.info,  Node: Other Dialects,  Next: Other Compilers,  Prev: Compiler,  Up: Top

Other Dialects
**************

   GNU Fortran supports a variety of features that are not considered
part of the GNU Fortran language itself, but are representative of
various dialects of Fortran that `g77' supports in whole or in part.

   Any of the features listed below might be disallowed by `g77' unless
some command-line option is specified.  Currently, some of the features
are accepted using the default invocation of `g77', but that might
change in the future.

   *Note: This portion of the documentation definitely needs a lot of
work!*

* Menu:

* Source Form::       Details of fixed-form and free-form source.
* Trailing Comment::  Use of `/*' to start a comment.
* Debug Line::        Use of `D' in column 1.
* Dollar Signs::      Use of `$' in symbolic names.
* Case Sensitivity::  Uppercase and lowercase in source files.
* VXT Fortran::       ...versus the GNU Fortran language.
* Fortran 90::        ...versus the GNU Fortran language.
* Pedantic Compilation::  Enforcing the standard.
* Distensions::       Misfeatures supported by GNU Fortran.


File: g77.info,  Node: Source Form,  Next: Trailing Comment,  Up: Other Dialects

Source Form
===========

   GNU Fortran accepts programs written in either fixed form or free
form.

   Fixed form corresponds to ANSI FORTRAN 77 (plus popular extensions,
such as allowing tabs) and Fortran 90's fixed form.

   Free form corresponds to Fortran 90's free form (though possibly not
entirely up-to-date, and without complaining about some things that for
which Fortran 90 requires diagnostics, such as the spaces in the
constant in `R = 3 . 1').

   The way a Fortran compiler views source files depends entirely on the
implementation choices made for the compiler, since those choices are
explicitly left to the implementation by the published Fortran
standards.  GNU Fortran currently tries to be somewhat like a few
popular compilers (`f2c', DEC Fortran, and so on), though a cleaner
default definition along with more flexibility offered by command-line
options is likely to be offered in version 0.6.

   This section describes how `g77' interprets source lines.

* Menu:

* Carriage Returns::  Carriage returns ignored.
* Tabs::              Tabs converted to spaces.
* Short Lines::       Short lines padded with spaces (fixed-form only).
* Long Lines::        Long lines truncated.
* Ampersands::        Special Continuation Lines.


File: g77.info,  Node: Carriage Returns,  Next: Tabs,  Up: Source Form

Carriage Returns
----------------

   Carriage returns (`\r') in source lines are ignored.  This is
somewhat different from `f2c', which seems to treat them as spaces
outside character/Hollerith constants, and encodes them as `\r' inside
such constants.


File: g77.info,  Node: Tabs,  Next: Short Lines,  Prev: Carriage Returns,  Up: Source Form

Tabs
----

   A source line with a <TAB> character anywhere in it is treated as
entirely significant--however long it is--instead of ending in column
72 (for fixed-form source) or 132 (for free-form source).  This also is
different from `f2c', which encodes tabs as `\t' (the ASCII <TAB>
character) inside character and Hollerith constants, but nevertheless
seems to treat the column position as if it had been affected by the
canonical tab positioning.

   `g77' effectively translates tabs to the appropriate number of
spaces (a la the default for the UNIX `expand' command) before doing
any other processing, other than (currently) noting whether a tab was
found on a line and using this information to decide how to interpret
the length of the line and continued constants.

   Note that this default behavior probably will change for version 0.6,
when it will presumably be available via a command-line option.  The
default as of version 0.6 is planned to be a "pure visual" model, where
tabs are immediately converted to spaces and otherwise have no effect,
so the way a typical user sees source lines produces a consistent
result no matter how the spacing in those source lines is actually
implemented via tabs, spaces, and trailing tabs/spaces before newline.
Command-line options are likely to be added to specify whether all or
just-tabbed lines are to be extended to 132 or full input-line length,
and perhaps even an option will be added to specify the truncated-line
behavior to which some Digital compilers default (and which affects the
way continued character/Hollerith constants are interpreted).


File: g77.info,  Node: Short Lines,  Next: Long Lines,  Prev: Tabs,  Up: Source Form

Short Lines
-----------

   Source lines shorter than the applicable fixed-form length are
treated as if they were padded with spaces to that length.  (None of
this is relevant to source files written in free form.)

   This affects only continued character and Hollerith constants, and
is a different interpretation than provided by some other popular
compilers (although a bit more consistent with the traditional
punched-card basis of Fortran and the way the Fortran standard
expressed fixed source form).

   `g77' might someday offer an option to warn about cases where
differences might be seen as a result of this treatment, and perhaps an
option to specify the alternate behavior as well.

   Note that this padding cannot apply to lines that are effectively of
infinite length--such lines are specified using command-line options
like `-ffixed-line-length-none', for example.


File: g77.info,  Node: Long Lines,  Next: Ampersands,  Prev: Short Lines,  Up: Source Form

Long Lines
----------

   Source lines longer than the applicable length are truncated to that
length.  Currently, `g77' does not warn if the truncated characters are
not spaces, to accommodate existing code written for systems that
treated truncated text as commentary (especially in columns 73 through
80).


File: g77.info,  Node: Ampersands,  Prev: Long Lines,  Up: Source Form

Ampersand Continuation Line
---------------------------

   A `&' in column 1 of fixed-form source denotes an arbitrary-length
continuation line, imitating the behavior of `f2c'.


File: g77.info,  Node: Trailing Comment,  Next: Debug Line,  Prev: Source Form,  Up: Other Dialects

Trailing Comment
================

   `g77' supports use of `/*' to start a trailing comment.  In the GNU
Fortran language, `!' is used for this purpose.

   `/*' is not in the GNU Fortran language because the use of `/*' in a
program might suggest to some readers that a block, not trailing,
comment is started (and thus ended by `*/', not end of line), since
that is the meaning of `/*' in C.

   Also, such readers might think they can use `//' to start a trailing
comment as an alternative to `/*', but `//' already denotes
concatenation, and such a "comment" might actually result in a program
that compiles without error (though it would likely behave incorrectly).


File: g77.info,  Node: Debug Line,  Next: Dollar Signs,  Prev: Trailing Comment,  Up: Other Dialects

Debug Line
==========

   Use of `D' or `d' as the first character (column 1) of a source line
denotes a debug line.

   In turn, a debug line is treated as either a comment line or a
normal line, depending on whether debug lines are enabled.

   When treated as a comment line, a line beginning with `D' or `d' is
treated as if it the first character was `C' or `c', respectively.
When treated as a normal line, such a line is treated as if the first
character was <SPC> (space).

   (Currently, `g77' provides no means for treating debug lines as
normal lines.)


File: g77.info,  Node: Dollar Signs,  Next: Case Sensitivity,  Prev: Debug Line,  Up: Other Dialects

Dollar Signs in Symbol Names
============================

   Dollar signs (`$') are allow in symbol names (after the first
character) when the `-fdollar-ok' option is specified.


File: g77.info,  Node: Case Sensitivity,  Next: VXT Fortran,  Prev: Dollar Signs,  Up: Other Dialects

Case Sensitivity
================

   GNU Fortran offers the programmer way too much flexibility in
deciding how source files are to be treated vis-a-vis uppercase and
lowercase characters.  There are 66 useful settings that affect case
sensitivity, plus 10 settings that are nearly useless, with the
remaining 116 settings being either redundant or useless.

   None of these settings have any effect on the contents of comments
(the text after a `c' or `C' in Column 1, for example) or of character
or Hollerith constants.  Note that things like the `E' in the statement
`CALL FOO(3.2E10)' and the `TO' in `ASSIGN 10 TO LAB' are considered
built-in keywords, and so are affected by these settings.

   Low-level switches are identified in this section as follows:

     A Source Case Conversion:

          0 Preserve (see Note 1)

          1 Convert to Upper Case

          2 Convert to Lower Case

     B Built-in Keyword Matching:

          0 Match Any Case (per-character basis)

          1 Match Upper Case Only

          2 Match Lower Case Only

          3 Match InitialCaps Only (see tables for spellings)

     C Built-in Intrinsic Matching:

          0 Match Any Case (per-character basis)

          1 Match Upper Case Only

          2 Match Lower Case Only

          3 Match InitialCaps Only (see tables for spellings)

     D User-defined Symbol Possibilities (warnings only):

          0 Allow Any Case (per-character basis)

          1 Allow Upper Case Only

          2 Allow Lower Case Only

          3 Allow InitialCaps Only (see Note 2)

   Note 1: `g77' eventually will support `NAMELIST' in a manner that is
consistent with these source switches--in the sense that input will be
expected to meet the same requirements as source code in terms of
matching symbol names and keywords (for the exponent letters).

   Currently, however, `NAMELIST' is supported by `libf2c', which
uppercases `NAMELIST' input and symbol names for matching.  This means
not only that `NAMELIST' output currently shows symbol (and keyword)
names in uppercase even if lower-case source conversion (option A2) is
selected, but that `NAMELIST' cannot be adequately supported when
source case preservation (option A0) is selected.

   If A0 is selected, a warning message will be output for each
`NAMELIST' statement to this effect.  The behavior of the program is
undefined at run time if two or more symbol names appear in a given
`NAMELIST' such that the names are identical when converted to upper
case (e.g. `NAMELIST /X/ VAR, Var, var').  For complete and total
elegance, perhaps there should be a warning when option A2 is selected,
since the output of NAMELIST is currently in uppercase but will someday
be lowercase (when a `libg77' is written), but that seems to be
overkill for a product in beta test.

   Note 2: Rules for InitialCaps names are:

   - Must be a single uppercase letter, *or*

   - Must start with an uppercase letter and contain at least one
     lowercase letter.

   So `A', `Ab', `ABc', `AbC', and `Abc' are valid InitialCaps names,
but `AB', `A2', and `ABC' are not.  Note that most, but not all,
built-in names meet these requirements--the exceptions are some of the
two-letter format specifiers, such as `BN' and `BZ'.

   Here are the names of the corresponding command-line options:

     A0: -fsource-case-preserve
     A1: -fsource-case-upper
     A2: -fsource-case-lower
     
     B0: -fmatch-case-any
     B1: -fmatch-case-upper
     B2: -fmatch-case-lower
     B3: -fmatch-case-initcap
     
     C0: -fintrin-case-any
     C1: -fintrin-case-upper
     C2: -fintrin-case-lower
     C3: -fintrin-case-initcap
     
     D0: -fsymbol-case-any
     D1: -fsymbol-case-upper
     D2: -fsymbol-case-lower
     D3: -fsymbol-case-initcap

   Useful combinations of the above settings, along with abbreviated
option names that set some of these combinations all at once:

      1: A0--  B0---  C0---  D0---    -fcase-preserve
      2: A0--  B0---  C0---  D-1--
      3: A0--  B0---  C0---  D--2-
      4: A0--  B0---  C0---  D---3
      5: A0--  B0---  C-1--  D0---
      6: A0--  B0---  C-1--  D-1--
      7: A0--  B0---  C-1--  D--2-
      8: A0--  B0---  C-1--  D---3
      9: A0--  B0---  C--2-  D0---
     10: A0--  B0---  C--2-  D-1--
     11: A0--  B0---  C--2-  D--2-
     12: A0--  B0---  C--2-  D---3
     13: A0--  B0---  C---3  D0---
     14: A0--  B0---  C---3  D-1--
     15: A0--  B0---  C---3  D--2-
     16: A0--  B0---  C---3  D---3
     17: A0--  B-1--  C0---  D0---
     18: A0--  B-1--  C0---  D-1--
     19: A0--  B-1--  C0---  D--2-
     20: A0--  B-1--  C0---  D---3
     21: A0--  B-1--  C-1--  D0---
     22: A0--  B-1--  C-1--  D-1--    -fcase-strict-upper
     23: A0--  B-1--  C-1--  D--2-
     24: A0--  B-1--  C-1--  D---3
     25: A0--  B-1--  C--2-  D0---
     26: A0--  B-1--  C--2-  D-1--
     27: A0--  B-1--  C--2-  D--2-
     28: A0--  B-1--  C--2-  D---3
     29: A0--  B-1--  C---3  D0---
     30: A0--  B-1--  C---3  D-1--
     31: A0--  B-1--  C---3  D--2-
     32: A0--  B-1--  C---3  D---3
     33: A0--  B--2-  C0---  D0---
     34: A0--  B--2-  C0---  D-1--
     35: A0--  B--2-  C0---  D--2-
     36: A0--  B--2-  C0---  D---3
     37: A0--  B--2-  C-1--  D0---
     38: A0--  B--2-  C-1--  D-1--
     39: A0--  B--2-  C-1--  D--2-
     40: A0--  B--2-  C-1--  D---3
     41: A0--  B--2-  C--2-  D0---
     42: A0--  B--2-  C--2-  D-1--
     43: A0--  B--2-  C--2-  D--2-    -fcase-strict-lower
     44: A0--  B--2-  C--2-  D---3
     45: A0--  B--2-  C---3  D0---
     46: A0--  B--2-  C---3  D-1--
     47: A0--  B--2-  C---3  D--2-
     48: A0--  B--2-  C---3  D---3
     49: A0--  B---3  C0---  D0---
     50: A0--  B---3  C0---  D-1--
     51: A0--  B---3  C0---  D--2-
     52: A0--  B---3  C0---  D---3
     53: A0--  B---3  C-1--  D0---
     54: A0--  B---3  C-1--  D-1--
     55: A0--  B---3  C-1--  D--2-
     56: A0--  B---3  C-1--  D---3
     57: A0--  B---3  C--2-  D0---
     58: A0--  B---3  C--2-  D-1--
     59: A0--  B---3  C--2-  D--2-
     60: A0--  B---3  C--2-  D---3
     61: A0--  B---3  C---3  D0---
     62: A0--  B---3  C---3  D-1--
     63: A0--  B---3  C---3  D--2-
     64: A0--  B---3  C---3  D---3    -fcase-initcap
     65: A-1-  B01--  C01--  D01--    -fcase-upper
     66: A--2  B0-2-  C0-2-  D0-2-    -fcase-lower

   Number 22 is the "strict" ANSI FORTRAN 77 model wherein all input
(except comments, character constants, and Hollerith strings) must be
entered in uppercase.  Use `-fcase-strict-upper' to specify this
combination.

   Number 43 is like Number 22 except all input must be lowercase.  Use
`-fcase-strict-lower' to specify this combination.

   Number 65 is the "classic" ANSI FORTRAN 77 model as implemented on
many non-UNIX machines whereby all the source is translated to
uppercase.  Use `-fcase-upper' to specify this combination.

   Number 66 is the "canonical" UNIX model whereby all the source is
translated to lowercase.  Use `-fcase-lower' to specify this
combination.

   There are a few nearly useless combinations:

     67: A-1-  B01--  C01--  D--2-
     68: A-1-  B01--  C01--  D---3
     69: A-1-  B01--  C--23  D01--
     70: A-1-  B01--  C--23  D--2-
     71: A-1-  B01--  C--23  D---3
     72: A--2  B01--  C0-2-  D-1--
     73: A--2  B01--  C0-2-  D---3
     74: A--2  B01--  C-1-3  D0-2-
     75: A--2  B01--  C-1-3  D-1--
     76: A--2  B01--  C-1-3  D---3

   The above allow some programs to be compiled but with restrictions
that make most useful programs impossible: Numbers 67 and 72 warn about
*any* user-defined symbol names (such as `SUBROUTINE FOO'); Numbers 68
and 73 warn about any user-defined symbol names longer than one
character that don't have at least one non-alphabetic character after
the first; Numbers 69 and 74 disallow any references to intrinsics; and
Numbers 70, 71, 75, and 76 are combinations of the restrictions in
67+69, 68+69, 72+74, and 73+74, respectively.

   All redundant combinations are shown in the above tables anyplace
where more than one setting is shown for a low-level switch.  For
example, `B0-2-' means either setting 0 or 2 is valid for switch B.
The "proper" setting in such a case is the one that copies the setting
of switch A--any other setting might slightly reduce the speed of the
compiler, though possibly to an unmeasurable extent.

   All remaining combinations are useless in that they prevent
successful compilation of non-null source files (source files with
something other than comments).


File: g77.info,  Node: VXT Fortran,  Next: Fortran 90,  Prev: Case Sensitivity,  Up: Other Dialects

VXT Fortran
===========

   `g77' supports certain constructs that have different meanings in
VXT Fortran than they do in the GNU Fortran language.

   Generally, this manual uses the invented term VXT Fortran to refer
VAX FORTRAN (circa v4).  That compiler offered many popular features,
though not necessarily those that are specific to the VAX processor
architecture, the VMS operating system, or Digital Equipment
Corporation's Fortran product line.  (VAX and VMS probably are
trademarks of Digital Equipment Corporation.)

   An extension offered by a Digital Fortran product that also is
offered by several other Fortran products for different kinds of
systems is probably going to be considered for inclusion in `g77'
someday, and is considered a VXT Fortran feature.

   The `-fvxt' option generally specifies that, where the meaning of a
construct is ambiguous (means one thing in GNU Fortran and another in
VXT Fortran), the VXT Fortran meaning is to be assumed.

* Menu:

* Double Quote Meaning::  `"2000' as octal constant.
* Exclamation Point::     `!' in column 6.


File: g77.info,  Node: Double Quote Meaning,  Next: Exclamation Point,  Up: VXT Fortran

Meaning of Double Quote
-----------------------

   `g77' treats double-quote (`"') as beginning an octal constant of
`INTEGER(KIND=1)' type when the `-fvxt' option is specified.  The form
of this octal constant is

     "OCTAL-DIGITS

where OCTAL-DIGITS is a nonempty string of characters in the set
`01234567'.

   For example, the `-fvxt' option permits this:

     PRINT *, "20
     END

The above program would print the value `16'.

   *Note Integer Type::, for information on the preferred construct for
integer constants specified using GNU Fortran's octal notation.

   (In the GNU Fortran language, the double-quote character (`"')
delimits a character constant just as does apostrophe (`'').  There is
no way to allow both constructs in the general case, since statements
like `PRINT *,"2000 !comment?"' would be ambiguous.)


File: g77.info,  Node: Exclamation Point,  Prev: Double Quote Meaning,  Up: VXT Fortran

Meaning of Exclamation Point in Column 6
----------------------------------------

   `g77' treats an exclamation point (`!') in column 6 of a fixed-form
source file as a continuation character rather than as the beginning of
a comment (as it does in any other column) when the `-fvxt' option is
specified.

   The following program, when run, prints a message indicating whether
it is interpreted according to GNU Fortran (and Fortran 90) rules or
VXT Fortran rules:

     C234567  (This line begins in column 1.)
           I = 0
          !1
           IF (I.EQ.0) PRINT *, ' I am a VXT Fortran program'
           IF (I.EQ.1) PRINT *, ' I am a Fortran 90 program'
           IF (I.LT.0 .OR. I.GT.1) PRINT *, ' I am a HAL 9000 computer'
           END

   (In the GNU Fortran and Fortran 90 languages, exclamation point is a
valid character and, unlike space (<SPC>) or zero (`0'), marks a line
as a continuation line when it appears in column 6.)


File: g77.info,  Node: Fortran 90,  Next: Pedantic Compilation,  Prev: VXT Fortran,  Up: Other Dialects

Fortran 90
==========

   The GNU Fortran language includes a number of features that are part
of Fortran 90, even when the `-ff90' option is not specified.  The
features enabled by `-ff90' are intended to be those that, when `-ff90'
is not specified, would have another meaning to `g77'--usually meaning
something invalid in the GNU Fortran language.

   So, the purpose of `-ff90' is not to specify whether `g77' is to
gratuitously reject Fortran 90 constructs.  The `-pedantic' option
specified with `-fno-f90' is intended to do that, although its
implementation is certainly incomplete at this point.

   When `-ff90' is specified:

   * The type of `REAL(EXPR)' and `AIMAG(EXPR)', where EXPR is
     `COMPLEX' type, is the same type as the real part of EXPR.

     For example, assuming `Z' is type `COMPLEX(KIND=2)', `REAL(Z)'
     would return a value of type `REAL(KIND=2)', not of type
     `REAL(KIND=1)', since `-ff90' is specified.

