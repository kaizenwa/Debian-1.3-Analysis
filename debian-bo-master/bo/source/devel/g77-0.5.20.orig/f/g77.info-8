This is Info file g77.info, produced by Makeinfo version 1.67 from the
input file g77.texi.

   This file explains how to use the GNU Fortran system.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1995-1997 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.

   Contributed by James Craig Burley (<burley@gnu.ai.mit.edu>).
Inspired by a first pass at translating `g77-0.5.16/f/DOC' that was
contributed to Craig by David Ronis (<ronis@onsager.chem.mcgill.ca>).

INFO-DIR-SECTION Fortran Programming
START-INFO-DIR-ENTRY
* g77: (g77).               The GNU Fortran compilation system.
END-INFO-DIR-ENTRY


File: g77.info,  Node: Pedantic Compilation,  Next: Distensions,  Prev: Fortran 90,  Up: Other Dialects

Pedantic Compilation
====================

   The `-fpedantic' command-line option specifies that `g77' is to warn
about code that is not standard-conforming.  This is useful for finding
some extensions `g77' accepts that other compilers might not accept.
(Note that the `-pedantic' and `-pedantic-errors' options always imply
`-fpedantic'.)

   With `-fno-f90' in force, ANSI FORTRAN 77 is used as the standard
for conforming code.  With `-ff90' in force, Fortran 90 is used.

   The constructs for which `g77' issues diagnostics when `-fpedantic'
and `-fno-f90' are in force are:

   * Automatic arrays, as in

          SUBROUTINE X(N)
          REAL A(N)
          ...

     where `A' is not listed in any `ENTRY' statement, and thus is not
     a dummy argument.

   * The commas in `READ (5), I' and `WRITE (10), J'.

     These commas are disallowed by FORTRAN 77, but, while strictly
     superfluous, are syntactically elegant, especially given that
     commas are required in statements such as `READ 99, I' and `PRINT
     *, J'.  Many compilers permit the superfluous commas for this
     reason.

   * `DOUBLE COMPLEX', either explicitly or implicitly.

     An explicit use of this type is via a `DOUBLE COMPLEX' or
     `IMPLICIT DOUBLE COMPLEX' statement, for examples.

     An example of an implicit use is the expression `C*D', where `C'
     is `COMPLEX(KIND=1)' and `D' is `DOUBLE PRECISION'.  This
     expression is prohibited by ANSI FORTRAN 77 because the rules of
     promotion would suggest that it produce a `DOUBLE COMPLEX'
     result--a type not provided for by that standard.

   * Automatic conversion of numeric expressions to `INTEGER(KIND=1)'
     in contexts such as:

        - Array-reference indexes.

        - Alternate-return values.

        - Computed `GOTO'.

        - `FORMAT' run-time expressions (not yet supported).

        - Dimension lists in specification statements.

        - Numbers for I/O statements (such as `READ (UNIT=3.2), I')

        - Sizes of `CHARACTER' entities in specification statements.

        - Kind types in specification entities (a Fortran 90 feature).

        - Initial, terminal, and incrementation parameters for
          implied-`DO' constructs in `DATA' statements.

   * Automatic conversion of `LOGICAL' expressions to `INTEGER' in
     contexts such as arithmetic `IF' (where `COMPLEX' expressions are
     disallowed anyway).

   * Zero-size array dimensions, as in:

          INTEGER I(10,20,4:2)

   * Zero-length `CHARACTER' entities, as in:

          PRINT *, ''

   * Substring operators applied to character constants and named
     constants, as in:

          PRINT *, 'hello'(3:5)

   * Null arguments passed to statement function, as in:

          PRINT *, FOO(,3)

   * Disagreement among program units regarding whether a given `COMMON'
     area is `SAVE'd (for targets where program units in a single source
     file are "glued" together as they typically are for UNIX
     development environments).

   * Disagreement among program units regarding the size of a named
     `COMMON' block.

   * Specification statements following first `DATA' statement.

     (In the GNU Fortran language, `DATA I/1/' may be followed by
     `INTEGER J', but not `INTEGER I'.  The `-fpedantic' option
     disallows both of these.)

   * Semicolon as statement separator, as in:

          CALL FOO; CALL BAR

   * Use of `&' in column 1 of fixed-form source (to indicate
     continuation).

   * Use of `CHARACTER' constants to initialize numeric entities, and
     vice versa.

   * Expressions having two arithmetic operators in a row, such as
     `X*-Y'.

   If `-fpedantic' is specified along with `-ff90', the following
constructs result in diagnostics:

   * Use of semicolon as a statement separator on a line that has an
     `INCLUDE' directive.


File: g77.info,  Node: Distensions,  Prev: Pedantic Compilation,  Up: Other Dialects

Distensions
===========

   The `-fugly-*' command-line options determine whether certain
features supported by VAX FORTRAN and other such compilers, but
considered too ugly to be in code that can be changed to use safer
and/or more portable constructs, are accepted.  These are humorously
referred to as "distensions", extensions that just plain look ugly in
the harsh light of day.

   *Note:* The `-fugly' option, which currently serves as shorthand to
enable all of the distensions below, is likely to be removed in a
future version of `g77'.  That's because it's likely new distensions
will be added that conflict with existing ones in terms of assigning
meaning to a given chunk of code.  (Also, it's pretty clear that users
should not use `-fugly' as shorthand when the next release of `g77'
might add a distension to that that causes their existing code, when
recompiled, to behave differently--perhaps even fail to compile or run
correctly.)

* Menu:

* Ugly Implicit Argument Conversion::  Disabled via `-fno-ugly-args'.
* Ugly Assumed-Size Arrays::           Enabled via `-fugly-assumed'.
* Ugly Null Arguments::                Enabled via `-fugly-comma'.
* Ugly Complex Part Extraction::       Enabled via `-fugly-complex'.
* Ugly Conversion of Initializers::    Disabled via `-fno-ugly-init'.
* Ugly Integer Conversions::           Enabled via `-fugly-logint'.
* Ugly Assigned Labels::               Enabled via `-fugly-assign'.


File: g77.info,  Node: Ugly Implicit Argument Conversion,  Next: Ugly Assumed-Size Arrays,  Up: Distensions

Implicit Argument Conversion
----------------------------

   The `-fno-ugly-args' option disables passing typeless and Hollerith
constants as actual arguments in procedure invocations.  For example:

     CALL FOO(4HABCD)
     CALL BAR('123'O)

These constructs can be too easily used to create non-portable code,
but are not considered as "ugly" as others.  Further, they are widely
used in existing Fortran source code in ways that often are quite
portable.  Therefore, they are enabled by default.


File: g77.info,  Node: Ugly Assumed-Size Arrays,  Next: Ugly Null Arguments,  Prev: Ugly Implicit Argument Conversion,  Up: Distensions

Ugly Assumed-Size Arrays
------------------------

   The `-fugly-assumed' option enables the treatment of any array with
a final dimension specified as `1' as an assumed-size array, as if `*'
had been specified instead.

   For example, `DIMENSION X(1)' is treated as if it had read
`DIMENSION X(*)' if `X' is listed as a dummy argument in a preceding
`SUBROUTINE', `FUNCTION', or `ENTRY' statement in the same program unit.

   Use an explicit lower bound to avoid this interpretation.  For
example, `DIMENSION X(1:1)' is never treated as if it had read
`DIMENSION X(*)' or `DIMENSION X(1:*)'.  Nor is `DIMENSION X(2-1)'
affected by this option, since that kind of expression is unlikely to
have been intended to designate an assumed-size array.

   This option is used to prevent warnings being issued about apparent
out-of-bounds reference such as `X(2) = 99'.

   It also prevents the array from being used in contexts that disallow
assumed-size arrays, such as `PRINT *,X'.  In such cases, a diagnostic
is generated and the source file is not compiled.

   The construct affected by this option is used only in old code that
pre-exists the widespread acceptance of adjustable and assumed-size
arrays in the Fortran community.

   *Note:* This option does not affect how `DIMENSION X(1)' is treated
if `X' is listed as a dummy argument only *after* the `DIMENSION'
statement (presumably in an `ENTRY' statement).  For example,
`-fugly-assumed' has no effect on the following program unit:

     SUBROUTINE X
     REAL A(1)
     RETURN
     ENTRY Y(A)
     PRINT *, A
     END


File: g77.info,  Node: Ugly Complex Part Extraction,  Next: Ugly Conversion of Initializers,  Prev: Ugly Null Arguments,  Up: Distensions

Ugly Complex Part Extraction
----------------------------

   The `-fugly-complex' option enables use of the `REAL()' and `AIMAG()'
intrinsics with arguments that are `COMPLEX' types other than
`COMPLEX(KIND=1)'.

   With `-ff90' in effect, these intrinsics return the unconverted real
and imaginary parts (respectively) of their argument.

   With `-fno-f90' in effect, these intrinsics convert the real and
imaginary parts to `REAL(KIND=1)', and return the result of that
conversion.

   Due to this ambiguity, the GNU Fortran language defines these
constructs as invalid, except in the specific case where they are
entirely and solely passed as an argument to an invocation of the
`REAL()' intrinsic.  For example,

     REAL(REAL(Z))

is permitted even when `Z' is `COMPLEX(KIND=2)' and `-fno-ugly-complex'
is in effect, because the meaning is clear.

   `g77' enforces this restriction, unless `-fugly-complex' is
specified, in which case the appropriate interpretation is chosen and
no diagnostic is issued.

   *Note CMPAMBIG::, for information on how to cope with existing code
with unclear expectations of `REAL()' and `AIMAG()' with
`COMPLEX(KIND=2)' arguments.

   *Note RealPart Intrinsic::, for information on the `REALPART()'
intrinsic, used to extract the real part of a complex expression
without conversion.  *Note ImagPart Intrinsic::, for information on the
`IMAGPART()' intrinsic, used to extract the imaginary part of a complex
expression without conversion.


File: g77.info,  Node: Ugly Null Arguments,  Next: Ugly Complex Part Extraction,  Prev: Ugly Assumed-Size Arrays,  Up: Distensions

Ugly Null Arguments
-------------------

   The `-fugly-comma' option enables use of a single trailing comma to
mean "pass an extra trailing null argument" in a list of actual
arguments to a procedure other than a statement function, and use of an
empty list of arguments to mean "pass a single null argument".

   (Null arguments often are used in some procedure-calling schemes to
indicate omitted arguments.)

   For example, `CALL FOO(,)' means "pass two null arguments", rather
than "pass one null argument".  Also, `CALL BAR()' means "pass one null
argument".

   This construct is considered "ugly" because it does not provide an
elegant way to pass a single null argument that is syntactically
distinct from passing no arguments.  That is, this construct changes
the meaning of code that makes no use of the construct.

   So, with `-fugly-comma' in force, `CALL FOO()' and `I = JFUNC()'
pass a single null argument, instead of passing no arguments as
required by the Fortran 77 and 90 standards.

   *Note:* Many systems gracefully allow the case where a procedure
call passes one extra argument that the called procedure does not
expect.

   So, in practice, there might be no difference in the behavior of a
program that does `CALL FOO()' or `I = JFUNC()' and is compiled with
`-fugly-comma' in force as compared to its behavior when compiled with
the default, `-fno-ugly-comma', in force, assuming `FOO' and `JFUNC' do
not expect any arguments to be passed.


File: g77.info,  Node: Ugly Conversion of Initializers,  Next: Ugly Integer Conversions,  Prev: Ugly Complex Part Extraction,  Up: Distensions

Ugly Conversion of Initializers
-------------------------------

   The constructs disabled by `-fno-ugly-init' are:

   * Use of Hollerith and typeless constants in contexts where they set
     initial (compile-time) values for variables, arrays, and named
     constants--that is, `DATA' and `PARAMETER' statements, plus
     type-declaration statements specifying initial values.

     Here are some sample initializations that are disabled by the
     `-fno-ugly-init' option:

          PARAMETER (VAL='9A304FFE'X)
          REAL*8 STRING/8HOUTPUT00/
          DATA VAR/4HABCD/

   * In the same contexts as above, use of character constants to
     initialize numeric items and vice versa (one constant per item).

     Here are more sample initializations that are disabled by the
     `-fno-ugly-init' option:

          INTEGER IA
          CHARACTER BELL
          PARAMETER (IA = 'A')
          PARAMETER (BELL = 7)

   * Use of Hollerith and typeless constants on the right-hand side of
     assignment statements to numeric types, and in other contexts
     (such as passing arguments in invocations of intrinsic procedures
     and statement functions) that are treated as assignments to known
     types (the dummy arguments, in these cases).

     Here are sample statements that are disabled by the
     `-fno-ugly-init' option:

          IVAR = 4HABCD
          PRINT *, IMAX0(2HAB, 2HBA)

   The above constructs, when used, can tend to result in non-portable
code.  But, they are widely used in existing Fortran code in ways that
often are quite portable.  Therefore, they are enabled by default.


File: g77.info,  Node: Ugly Integer Conversions,  Next: Ugly Assigned Labels,  Prev: Ugly Conversion of Initializers,  Up: Distensions

Ugly Integer Conversions
------------------------

   The constructs enabled via `-fugly-logint' are:

   * Automatic conversion between `INTEGER' and `LOGICAL' as dictated by
     context (typically implies nonportable dependencies on how a
     particular implementation encodes `.TRUE.' and `.FALSE.').

   * Use of a `LOGICAL' variable in `ASSIGN' and assigned-`GOTO'
     statements.

   The above constructs are disabled by default because use of them
tends to lead to non-portable code.  Even existing Fortran code that
uses that often turns out to be non-portable, if not outright buggy.

   Some of this is due to differences among implementations as far as
how `.TRUE.' and `.FALSE.' are encoded as `INTEGER' values--Fortran
code that assumes a particular coding is likely to use one of the above
constructs, and is also likely to not work correctly on implementations
using different encodings.

   *Note Equivalence Versus Equality::, for more information.


File: g77.info,  Node: Ugly Assigned Labels,  Prev: Ugly Integer Conversions,  Up: Distensions

Ugly Assigned Labels
--------------------

   The `-fugly-assign' option forces `g77' to use the same storage for
assigned labels as it would for a normal assignment to the same
variable.

   For example, consider the following code fragment:

     I = 3
     ASSIGN 10 TO I

Normally, for portability and improved diagnostics, `g77' reserves
distinct storage for a "sibling" of `I', used only for `ASSIGN'
statements to that variable (along with the corresponding
assigned-`GOTO' and assigned-`FORMAT'-I/O statements that reference the
variable).

   However, some code (that violates the ANSI FORTRAN 77 standard)
attempts to copy assigned labels among variables involved with `ASSIGN'
statements, as in:

     ASSIGN 10 TO I
     ISTATE(5) = I
     ...
     J = ISTATE(ICUR)
     GOTO J

Such code doesn't work under `g77' unless `-fugly-assign' is specified
on the command-line, ensuring that the value of `I' referenced in the
second line is whatever value `g77' uses to designate statement label
`10', so the value may be copied into the `ISTATE' array, later
retrieved into a variable of the appropriate type (`J'), and used as
the target of an assigned-`GOTO' statement.

   *Note:* To avoid subtle program bugs, when `-fugly-assign' is
specified, `g77' requires the type of variables specified in
assigned-label contexts *must* be the same type returned by `%LOC()'.
On many systems, this type is effectively the same as
`INTEGER(KIND=1)', while, on others, it is effectively the same as
`INTEGER(KIND=2)'.

   Do *not* depend on `g77' actually writing valid pointers to these
variables, however.  While `g77' currently chooses that implementation,
it might be changed in the future.

   *Note Assigned Statement Labels (ASSIGN and GOTO): Assigned
Statement Labels, for implementation details on assigned-statement
labels.


File: g77.info,  Node: Compiler,  Next: Other Dialects,  Prev: Language,  Up: Top

The GNU Fortran Compiler
************************

   The GNU Fortran compiler, `g77', supports programs written in the
GNU Fortran language and in some other dialects of Fortran.

   Some aspects of how `g77' works are universal regardless of dialect,
and yet are not properly part of the GNU Fortran language itself.
These are described below.

   *Note: This portion of the documentation definitely needs a lot of
work!*

* Menu:

* Compiler Types::
* Compiler Constants::
* Compiler Intrinsics::


File: g77.info,  Node: Compiler Types,  Next: Compiler Constants,  Up: Compiler

Compiler Types
==============

   Fortran implementations have a fair amount of freedom given them by
the standard as far as how much storage space is used and how much
precision and range is offered by the various types such as
`LOGICAL(KIND=1)', `INTEGER(KIND=1)', `REAL(KIND=1)', `REAL(KIND=2)',
`COMPLEX(KIND=1)', and `CHARACTER'.  Further, many compilers offer
so-called `*N' notation, but the interpretation of N varies across
compilers and target architectures.

   The standard requires that `LOGICAL(KIND=1)', `INTEGER(KIND=1)', and
`REAL(KIND=1)' occupy the same amount of storage space, and that
`COMPLEX(KIND=1)' and `REAL(KIND=2)' take twice as much storage space
as `REAL(KIND=1)'.  Further, it requires that `COMPLEX(KIND=1)'
entities be ordered such that when a `COMPLEX(KIND=1)' variable is
storage-associated (such as via `EQUIVALENCE') with a two-element
`REAL(KIND=1)' array named `R', `R(1)' corresponds to the real element
and `R(2)' to the imaginary element of the `COMPLEX(KIND=1)' variable.

   (Few requirements as to precision or ranges of any of these are
placed on the implementation, nor is the relationship of storage sizes
of these types to the `CHARACTER' type specified, by the standard.)

   `g77' follows the above requirements, warning when compiling a
program requires placement of items in memory that contradict the
requirements of the target architecture.  (For example, a program can
require placement of a `REAL(KIND=2)' on a boundary that is not an even
multiple of its size, but still an even multiple of the size of a
`REAL(KIND=1)' variable.  On some target architectures, using the
canonical mapping of Fortran types to underlying architectural types,
such placement is prohibited by the machine definition or the
Application Binary Interface (ABI) in force for the configuration
defined for building `gcc' and `g77'.  `g77' warns about such
situations when it encounters them.)

   `g77' follows consistent rules for configuring the mapping between
Fortran types, including the `*N' notation, and the underlying
architectural types as accessed by a similarly-configured applicable
version of the `gcc' compiler.  These rules offer a widely portable,
consistent Fortran/C environment, although they might well conflict
with the expectations of users of Fortran compilers designed and
written for particular architectures.

   These rules are based on the configuration that is in force for the
version of `gcc' built in the same release as `g77' (and which was
therefore used to build both the `g77' compiler components and the
`libf2c' run-time library):

`REAL(KIND=1)'
     Same as `float' type.

`REAL(KIND=2)'
     Same as whatever floating-point type that is twice the size of a
     `float'--usually, this is a `double'.

`INTEGER(KIND=1)'
     Same as an integral type that is occupies the same amount of
     memory storage as `float'--usually, this is either an `int' or a
     `long int'.

`LOGICAL(KIND=1)'
     Same `gcc' type as `INTEGER(KIND=1)'.

`INTEGER(KIND=2)'
     Twice the size, and usually nearly twice the range, as
     `INTEGER(KIND=1)'--usually, this is either a `long int' or a `long
     long int'.

`LOGICAL(KIND=2)'
     Same `gcc' type as `INTEGER(KIND=2)'.

`INTEGER(KIND=3)'
     Same `gcc' type as signed `char'.

`LOGICAL(KIND=3)'
     Same `gcc' type as `INTEGER(KIND=3)'.

`INTEGER(KIND=6)'
     Twice the size, and usually nearly twice the range, as
     `INTEGER(KIND=3)'--usually, this is a `short'.

`LOGICAL(KIND=6)'
     Same `gcc' type as `INTEGER(KIND=6)'.

`COMPLEX(KIND=1)'
     Two `REAL(KIND=1)' scalars (one for the real part followed by one
     for the imaginary part).

`COMPLEX(KIND=2)'
     Two `REAL(KIND=2)' scalars.

`NUMERIC-TYPE*N'
     (Where NUMERIC-TYPE is any type other than `CHARACTER'.)  Same as
     whatever `gcc' type occupies N times the storage space of a `gcc'
     `char' item.

`DOUBLE PRECISION'
     Same as `REAL(KIND=2)'.

`DOUBLE COMPLEX'
     Same as `COMPLEX(KIND=2)'.

   Note that the above are proposed correspondences and might change in
future versions of `g77'--avoid writing code depending on them.

   Other types supported by `g77' are derived from gcc types such as
`char', `short', `int', `long int', `long long int', `long double', and
so on.  That is, whatever types `gcc' already supports, `g77' supports
now or probably will support in a future version.  The rules for the
`NUMERIC-TYPE*N' notation apply to these types, and new values for
`NUMERIC-TYPE(KIND=N)' will be assigned in a way that encourages
clarity, consistency, and portability.


File: g77.info,  Node: Compiler Constants,  Next: Compiler Intrinsics,  Prev: Compiler Types,  Up: Compiler

Compiler Constants
==================

   `g77' strictly assigns types to *all* constants not documented as
"typeless" (typeless constants including `'1'Z', for example).  Many
other Fortran compilers attempt to assign types to typed constants
based on their context.  This results in hard-to-find bugs, nonportable
code, and is not in the spirit (though it strictly follows the letter)
of the 77 and 90 standards.

   `g77' might offer, in a future release, explicit constructs by which
a wider variety of typeless constants may be specified, and/or
user-requested warnings indicating places where `g77' might differ from
how other compilers assign types to constants.

   *Note Context-Sensitive Constants::, for more information on this
issue.


File: g77.info,  Node: Compiler Intrinsics,  Prev: Compiler Constants,  Up: Compiler

Compiler Intrinsics
===================

   `g77' offers an ever-widening set of intrinsics.  Currently these
all are procedures (functions and subroutines).

   Some of these intrinsics are unimplemented, but their names reserved
to reduce future problems with existing code as they are implemented.
Others are implemented as part of the GNU Fortran language, while yet
others are provided for compatibility with other dialects of Fortran
but are not part of the GNU Fortran language.

   To manage these distinctions, `g77' provides intrinsic *groups*, a
facility that is simply an extension of the intrinsic groups provided
by the GNU Fortran language.

* Menu:

* Intrinsic Groups::  How intrinsics are grouped for easy management.
* Other Intrinsics::  Intrinsics other than those in the GNU
                       Fortran language.


File: g77.info,  Node: Intrinsic Groups,  Next: Other Intrinsics,  Up: Compiler Intrinsics

Intrinsic Groups
----------------

   A given specific intrinsic belongs in one or more groups.  Each
group is deleted, disabled, hidden, or enabled by default or a
command-line option.  The meaning of each term follows.

Deleted
     No intrinsics are recognized as belonging to that group.

Disabled
     Intrinsics are recognized as belonging to the group, but
     references to them (other than via the `INTRINSIC' statement) are
     disallowed through that group.

Hidden
     Intrinsics in that group are recognized and enabled (if
     implemented) *only* if the first mention of the actual name of an
     intrinsic in a program unit is in an `INTRINSIC' statement.

Enabled
     Intrinsics in that group are recognized and enabled (if
     implemented).

   The distinction between deleting and disabling a group is illustrated
by the following example.  Assume intrinsic `FOO' belongs only to group
`FGR'.  If group `FGR' is deleted, the following program unit will
successfully compile, because `FOO()' will be seen as a reference to an
external function named `FOO':

     PRINT *, FOO()
     END

If group `FGR' is disabled, compiling the above program will produce
diagnostics, either because the `FOO' intrinsic is improperly invoked
or, if properly invoked, it is not enabled.  To change the above
program so it references an external function `FOO' instead of the
disabled `FOO' intrinsic, add the following line to the top:

     EXTERNAL FOO

So, deleting a group tells `g77' to pretend as though the intrinsics in
that group do not exist at all, whereas disabling it tells `g77' to
recognize them as (disabled) intrinsics in intrinsic-like contexts.

   Hiding a group is like enabling it, but the intrinsic must be first
named in an `INTRINSIC' statement to be considered a reference to the
intrinsic rather than to an external procedure.  This might be the
"safest" way to treat a new group of intrinsics when compiling old
code, because it allows the old code to be generally written as if
those new intrinsics never existed, but to be changed to use them by
inserting `INTRINSIC' statements in the appropriate places.  However,
it should be the goal of development to use `EXTERNAL' for all names of
external procedures that might be intrinsic names.

   If an intrinsic is in more than one group, it is enabled if any of
its containing groups are enabled; if not so enabled, it is hidden if
any of its containing groups are hidden; if not so hidden, it is
disabled if any of its containing groups are disabled; if not so
disabled, it is deleted.  This extra complication is necessary because
some intrinsics, such as `IBITS', belong to more than one group, and
hence should be enabled if any of the groups to which they belong are
enabled, and so on.

   The groups are:

`gnu'
     Intrinsics the GNU Fortran language supports that are extensions to
     the Fortran standards (77 and 90).

`f2c'
     Intrinsics supported by AT&T's `f2c' converter and/or `libf2c'.

`f90'
     Fortran 90 intrinsics.

`mil'
     MIL-STD 1753 intrinsics (`MVBITS', `IAND', `BTEST', and so on).

`unix'
     UNIX intrinsics (`IARGC', `EXIT', `ERF', and so on).

`vxt'
     VAX/VMS FORTRAN (current as of v4) intrinsics.


File: g77.info,  Node: Other Intrinsics,  Prev: Intrinsic Groups,  Up: Compiler Intrinsics

Other Intrinsics
----------------

   `g77' supports intrinsics other than those in the GNU Fortran
language proper.  This set of intrinsics is described below.

   (Note that the blank lines appearing in the menu below are not
intentional--they result from a bug in the `makeinfo' program.)

* Menu:


* CDAbs Intrinsic::     Absolute value (archaic).
* CDCos Intrinsic::
* CDExp Intrinsic::
* CDLog Intrinsic::     Natural logarithm (archaic).
* CDSin Intrinsic::
* CDSqRt Intrinsic::

* Date Intrinsic::      Get current date as dd-Mon-yy.

* DCmplx Intrinsic::
* DConjg Intrinsic::    Complex conjugate (archaic).

* DFloat Intrinsic::

* DImag Intrinsic::

* DReal Intrinsic::

* IDate Intrinsic (Form IDATE (VXT)):: Get local time info (VAX/VMS).

* Secnds Intrinsic::    Get local time offset since midnight.

* Time Intrinsic (Form TIME (VXT))::


File: g77.info,  Node: CDAbs Intrinsic,  Next: CDCos Intrinsic,  Up: Other Intrinsics

CDAbs Intrinsic
...............

     CDAbs(A)

CDAbs: `REAL(KIND=2)' function.

A: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `ABS()' that is specific to one type for A.  *Note
Abs Intrinsic::.


File: g77.info,  Node: CDCos Intrinsic,  Next: CDExp Intrinsic,  Prev: CDAbs Intrinsic,  Up: Other Intrinsics

CDCos Intrinsic
...............

     CDCos(X)

CDCos: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: CDExp Intrinsic,  Next: CDLog Intrinsic,  Prev: CDCos Intrinsic,  Up: Other Intrinsics

CDExp Intrinsic
...............

     CDExp(X)

CDExp: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: CDLog Intrinsic,  Next: CDSin Intrinsic,  Prev: CDExp Intrinsic,  Up: Other Intrinsics

CDLog Intrinsic
...............

     CDLog(X)

CDLog: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `LOG()' that is specific to one type for X.  *Note
Log Intrinsic::.


File: g77.info,  Node: CDSin Intrinsic,  Next: CDSqRt Intrinsic,  Prev: CDLog Intrinsic,  Up: Other Intrinsics

CDSin Intrinsic
...............

     CDSin(X)

CDSin: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: CDSqRt Intrinsic,  Next: Date Intrinsic,  Prev: CDSin Intrinsic,  Up: Other Intrinsics

CDSqRt Intrinsic
................

     CDSqRt(X)

CDSqRt: `COMPLEX(KIND=2)' function.

X: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: Date Intrinsic,  Next: DCmplx Intrinsic,  Prev: CDSqRt Intrinsic,  Up: Other Intrinsics

Date Intrinsic
..............

     CALL Date(DATE)

DATE: `CHARACTER'; scalar; INTENT(OUT).

Intrinsic groups: `vxt'.

Description:

   Returns DATE in the form `DD-MMM-YY', representing the numeric day
of the month DD, a three-character abbreviation of the month name MMM
and the last two digits of the year YY, e.g. `25-Nov-96'.

   This intrinsic is not recommended, due to the year 2000 approaching.
*Note CTime Intrinsic::, for information on obtaining more digits for
the current (or any) date.


File: g77.info,  Node: DCmplx Intrinsic,  Next: DConjg Intrinsic,  Prev: Date Intrinsic,  Up: Other Intrinsics

DCmplx Intrinsic
................

     DCmplx(X, Y)

DCmplx: `COMPLEX(KIND=2)' function.

X: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Y: `INTEGER' or `REAL'; OPTIONAL (must be omitted if X is `COMPLEX');
scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: DConjg Intrinsic,  Next: DFloat Intrinsic,  Prev: DCmplx Intrinsic,  Up: Other Intrinsics

DConjg Intrinsic
................

     DConjg(Z)

DConjg: `COMPLEX(KIND=2)' function.

Z: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.

Description:

   Archaic form of `CONJG()' that is specific to one type for Z.  *Note
ATan2 Intrinsic::.


File: g77.info,  Node: DFloat Intrinsic,  Next: DImag Intrinsic,  Prev: DConjg Intrinsic,  Up: Other Intrinsics

DFloat Intrinsic
................

     DFloat(A)

DFloat: `REAL(KIND=2)' function.

A: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: DImag Intrinsic,  Next: DReal Intrinsic,  Prev: DFloat Intrinsic,  Up: Other Intrinsics

DImag Intrinsic
...............

     DImag(Z)

DImag: `REAL(KIND=2)' function.

Z: `COMPLEX(KIND=2)'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `vxt'.


File: g77.info,  Node: DReal Intrinsic,  Next: IDate Intrinsic (Form IDATE (VXT)),  Prev: DImag Intrinsic,  Up: Other Intrinsics

DReal Intrinsic
...............

     DReal(A)

DReal: `REAL(KIND=2)' function.

A: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: `vxt'.


File: g77.info,  Node: IDate Intrinsic (Form IDATE (VXT)),  Next: Secnds Intrinsic,  Prev: DReal Intrinsic,  Up: Other Intrinsics

IDate Intrinsic (Form IDATE (VXT))
..................................

     CALL IDate(D, M, Y)

D: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

M: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

Y: `INTEGER(KIND=1)'; scalar; INTENT(OUT).

Intrinsic groups: `vxt'.

Description:

   Returns the numerical values of the current local time.  The date is
returned in D, the month in M (in the range 1-12), and the year in Y
(in the range 0-99).

   This intrinsic is not recommended, due to the year 2000 approaching.
*Note IDate Intrinsic::, for information on obtaining more digits for
the current local date.


File: g77.info,  Node: Secnds Intrinsic,  Next: Time Intrinsic (Form TIME (VXT)),  Prev: IDate Intrinsic (Form IDATE (VXT)),  Up: Other Intrinsics

Secnds Intrinsic
................

     Secnds(T)

Secnds: `REAL(KIND=1)' function.

T: `REAL(KIND=1)'; scalar; INTENT(IN).

Intrinsic groups: `vxt'.

Description:

   Returns the local time in seconds since midnight minus the value T.


File: g77.info,  Node: Time Intrinsic (Form TIME (VXT)),  Prev: Secnds Intrinsic,  Up: Other Intrinsics

Time Intrinsic (Form TIME (VXT))
................................

     CALL Time(TIME)

TIME: `CHARACTER*8'; scalar; INTENT(OUT).

Intrinsic groups: `vxt'.


File: g77.info,  Node: Other Compilers,  Next: Other Languages,  Prev: Other Dialects,  Up: Top

Other Compilers
***************

   An individual Fortran source file can be compiled to an object
(`*.o') file instead of to the final program executable.  This allows
several portions of a program to be compiled at different times and
linked together whenever a new version of the program is needed.
However, it introduces the issue of "object compatibility" across the
various object files (and libraries, or `*.a' files) that are linked
together to produce any particular executable file.

   Object compatibility is an issue when combining, in one program,
Fortran code compiled by more than one compiler (or more than one
configuration of a compiler).  If the compilers disagree on how to
transform the names of procedures, there will normally be errors when
linking such programs.  Worse, if the compilers agree on naming, but
disagree on issues like how to pass parameters, return arguments, and
lay out `COMMON' areas, the earliest detected errors might be the
incorrect results produced by the program (and that assumes these
errors are detected, which is not always the case).

   Normally, `g77' generates code that is object-compatible with code
generated by a version of `f2c' configured (with, for example, `f2c.h'
definitions) to be generally compatible with `g77' as built by `gcc'.
(Normally, `f2c' will, by default, conform to the appropriate
configuration, but it is possible that older or perhaps even newer
versions of `f2c', or versions having certain configuration changes to
`f2c' internals, will produce object files that are incompatible with
`g77'.)

   For example, a Fortran string subroutine argument will become two
arguments on the C side: a `char *' and an `int' length.

   Much of this compatibility results from the fact that `g77' uses the
same run-time library, `libf2c', used by `f2c'.

   Other compilers might or might not generate code that is
object-compatible with `libf2c' and current `g77', and some might offer
such compatibility only when explicitly selected via a command-line
option to the compiler.

   *Note: This portion of the documentation definitely needs a lot of
work!*

* Menu:

* Dropping f2c Compatibility::  When speed is more important.
* Compilers Other Than f2c::    Interoperation with code from other compilers.


File: g77.info,  Node: Dropping f2c Compatibility,  Next: Compilers Other Than f2c,  Up: Other Compilers

Dropping `f2c' Compatibility
============================

   Specifying `-fno-f2c' allows `g77' to generate, in some cases,
faster code, by not needing to allow to the possibility of linking with
code compiled by `f2c'.

   For example, this affects how `REAL(KIND=1)', `COMPLEX(KIND=1)', and
`COMPLEX(KIND=2)' functions are called.  With `-fno-f2c', they are
compiled as returning the appropriate `gcc' type (`float', `__complex__
float', `__complex__ double', in many configurations).

   With `-ff2c' in force, they are compiled differently (with perhaps
slower run-time performance) to accommodate the restrictions inherent
in `f2c''s use of K&R C as an intermediate language--`REAL(KIND=1)'
functions return C's `double' type, while `COMPLEX' functions return
`void' and use an extra argument pointing to a place for the functions
to return their values.

   It is possible that, in some cases, leaving `-ff2c' in force might
produce faster code than using `-fno-f2c'.  Feel free to experiment,
but remember to experiment with changing the way *entire programs and
their Fortran libraries are compiled* at a time, since this sort of
experimentation affects the interface of code generated for a Fortran
source file--that is, it affects object compatibility.

   Note that `f2c' compatibility is a fairly static target to achieve,
though not necessarily perfectly so, since, like `g77', it is still
being improved.  However, specifying `-fno-f2c' causes `g77' to
generate code that will probably be incompatible with code generated by
future versions of `g77' when the same option is in force.  You should
make sure you are always able to recompile complete programs from
source code when upgrading to new versions of `g77' or `f2c',
especially when using options such as `-fno-f2c'.

   Therefore, if you are using `g77' to compile libraries and other
object files for possible future use and you don't want to require
recompilation for future use with subsequent versions of `g77', you
might want to stick with `f2c' compatibility for now, and carefully
watch for any announcements about changes to the `f2c'/`libf2c'
interface that might affect existing programs (thus requiring
recompilation).

   It is probable that a future version of `g77' will not, by default,
generate object files compatible with `f2c', and that version probably
would no longer use `libf2c'.  If you expect to depend on this
compatibility in the long term, use the options `-ff2c -ff2c-library'
when compiling all of the applicable code.  This should cause future
versions of `g77' either to produce compatible code (at the expense of
the availability of some features and performance), or at the very
least, to produce diagnostics.


File: g77.info,  Node: Compilers Other Than f2c,  Prev: Dropping f2c Compatibility,  Up: Other Compilers

Compilers Other Than `f2c'
==========================

   On systems with Fortran compilers other than `f2c' and `g77', code
compiled by `g77' is not expected to work well with code compiled by
the native compiler.  (This is true for `f2c'-compiled objects as
well.)  Libraries compiled with the native compiler probably will have
to be recompiled with `g77' to be used with `g77'-compiled code.

   Reasons for such incompatibilities include:

   * There might be differences in the way names of Fortran procedures
     are translated for use in the system's object-file format.  For
     example, the statement `CALL FOO' might be compiled by `g77' to
     call a procedure the linker `ld' sees given the name `_foo_',
     while the apparently corresponding statement `SUBROUTINE FOO'
     might be compiled by the native compiler to define the
     linker-visible name `_foo', or `_FOO_', and so on.

   * There might be subtle type mismatches which cause subroutine
     arguments and function return values to get corrupted.

     This is why simply getting `g77' to transform procedure names the
     same way a native compiler does is not usually a good idea--unless
     some effort has been made to ensure that, aside from the way the
     two compilers transform procedure names, everything else about the
     way they generate code for procedure interfaces is identical.

   * Native compilers use libraries of private I/O routines which will
     not be available at link time unless you have the native
     compiler--and you would have to explicitly ask for them.

     For example, on the Sun you would have to add `-L/usr/lang/SCx.x
     -lF77 -lV77' to the link command.


File: g77.info,  Node: Other Languages,  Next: Installation,  Prev: Other Compilers,  Up: Top

Other Languages
***************

   *Note: This portion of the documentation definitely needs a lot of
work!*

* Menu:

* Interoperating with C and C++::


File: g77.info,  Node: Interoperating with C and C++,  Up: Other Languages

Tools and advice for interoperating with C and C++
==================================================

   The following discussion assumes that you are running `g77' in `f2c'
compatibility mode, i.e. not using `-fno-f2c'.  It provides some advice
about quick and simple techniques for linking Fortran and C (or C++),
the most common requirement.  For the full story consult the
description of code generation.  *Note Debugging and Interfacing::.

   When linking Fortran and C, it's usually best to use `g77' to do the
linking so that the correct libraries are included (including the maths
one).  If you're linking with C++ you will want to add `-lstdc++',
`-lg++' or whatever.  If you need to use another driver program (or
`ld' directly), you can find out what linkage options `g77' passes by
running `g77 -v'.

* Menu:

* C Interfacing Tools::
* C Access to Type Information::
* f2c Skeletons and Prototypes::
* C++ Considerations::
* Startup Code::


File: g77.info,  Node: C Interfacing Tools,  Next: C Access to Type Information,  Up: Interoperating with C and C++

C Interfacing Tools
-------------------

   Even if you don't actually use it as a compiler, `f2c' from
`ftp://ftp.netlib.org/f2c/src', can be a useful tool when you're
interfacing (linking) Fortran and C.  *Note Generating Skeletons and
Prototypes with `f2c': f2c Skeletons and Prototypes.

   To use `f2c' for this purpose you only need retrieve and build the
`src' directory from the distribution, consult the `README'
instructions there for machine-specifics, and install the `f2c' program
on your path.

   Something else that might be useful is `cfortran.h' from
`ftp://zebra/desy.de/cfortran'.  This is a fairly general tool which
can be used to generate interfaces for calling in both directions
between Fortran and C.  It can be used in `f2c' mode with
`g77'--consult its documentation for details.


File: g77.info,  Node: C Access to Type Information,  Next: f2c Skeletons and Prototypes,  Prev: C Interfacing Tools,  Up: Interoperating with C and C++

Accessing Type Information in C
-------------------------------

   Generally, C code written to link with `g77' code--calling and/or
being called from Fortran--should `#include <f2c.h>' to define the C
versions of the Fortran types.  Don't assume Fortran `INTEGER' types
correspond to C `int's, for instance; instead, declare them as
`integer', a type defined by `f2c.h'.  `f2c.h' is installed where `gcc'
will find it by default, assuming you use a copy of `gcc' compatible
with `g77', probably built at the same time as `g77'.


File: g77.info,  Node: f2c Skeletons and Prototypes,  Next: C++ Considerations,  Prev: C Access to Type Information,  Up: Interoperating with C and C++

Generating Skeletons and Prototypes with `f2c'
----------------------------------------------

   A simple and foolproof way to write `g77'-callable C routines--e.g.
to interface with an existing library--is to write a file (named, for
example, `fred.f') of dummy Fortran skeletons comprising just the
declaration of the routine(s) and dummy arguments plus `END' statements.
Then run `f2c' on file `fred.f' to produce `fred.c' into which you can
edit useful code, confident the calling sequence is correct, at least.
(There are some errors otherwise commonly made in generating C
interfaces with f2c conventions, such as not using `doublereal' as the
return type of a `REAL' `FUNCTION'.)

   `f2c' also can help with calling Fortran from C, using its `-P'
option to generate C prototypes appropriate for calling the Fortran.(1)
If the Fortran code containing any routines to be called from C is in
file `joe.f', use the command `f2c -P joe.f' to generate the file
`joe.P' containing prototype information.  `#include' this in the C
which has to call the Fortran routines to make sure you get it right.

   *Note Arrays (DIMENSION: Arrays, for information on the differences
between the way Fortran (including compilers like `g77') and C handle
arrays.

   ---------- Footnotes ----------

   (1)  The files generated like this can also be used for inter-unit
consistency checking of dummy and actual arguments, although the
`ftnchek' tool from `ftp://ftp.netlib.org/fortran' is probably better
for this purpose.


File: g77.info,  Node: C++ Considerations,  Next: Startup Code,  Prev: f2c Skeletons and Prototypes,  Up: Interoperating with C and C++

C++ Considerations
------------------

   `f2c' can be used to generate suitable code for compilation with a
C++ system using the `-C++' option.  The important thing about linking
`g77'-compiled code with C++ is that the prototypes for the `g77'
routines must specify C linkage to avoid name mangling.  So, use an
`extern "C"' declaration.  `f2c''s `-C++' option will take care of this
when generating skeletons or prototype files as above, and also avoid
clashes with C++ reserved words in addition to those in C.


File: g77.info,  Node: Startup Code,  Prev: C++ Considerations,  Up: Interoperating with C and C++

Startup Code
------------

   Unlike with some runtime systems, it shouldn't be necessary (unless
there are bugs) to use a Fortran main program to ensure the
runtime--specifically the i/o system--is initialized.  However, to use
the `g77' intrinsics `GETARG()' and `IARGC()' the `main()' routine from
the `libf2c' library must be used, either explicitly or implicitly by
using a Fortran main program.  This `main()' program calls `MAIN__()'
(where the names are C-type `extern' names, i.e. not mangled).  You
need to provide this nullary procedure as the entry point for your C
code if using `libf2c''s `main'.  In some cases it might be necessary to
provide a dummy version of this to avoid linkers complaining about
failure to resolve `MAIN__()' if linking against `libf2c' and not using
`main()' from it.


File: g77.info,  Node: Installation,  Next: Debugging and Interfacing,  Prev: Other Languages,  Up: Top

Installing GNU Fortran
**********************

   The following information describes how to install `g77'.

   The information in this file generally pertains to dealing with
*source* distributions of `g77' and `gcc'.  It is possible that some of
this information will be applicable to some *binary* distributions of
these products--however, since these distributions are not made by the
maintainers of `g77', responsibility for binary distributions rests with
whoever built and first distributed them.

   Nevertheless, efforts to make `g77' easier to both build and install
from source and package up as a binary distribution are ongoing.

* Menu:

* Prerequisites::          Make sure your system is ready for `g77'.
* Problems Installing::    Known trouble areas.
* Settings::               Changing `g77' internals before building.
* Quick Start::            The easier procedure for non-experts.
* Complete Installation::  For experts, or those who want to be: the details.
* Distributing Binaries::  If you plan on distributing your `g77'.

