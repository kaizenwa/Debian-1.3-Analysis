This is Info file g77.info, produced by Makeinfo version 1.67 from the
input file g77.texi.

   This file explains how to use the GNU Fortran system.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1995-1997 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.

   Contributed by James Craig Burley (<burley@gnu.ai.mit.edu>).
Inspired by a first pass at translating `g77-0.5.16/f/DOC' that was
contributed to Craig by David Ronis (<ronis@onsager.chem.mcgill.ca>).

INFO-DIR-SECTION Fortran Programming
START-INFO-DIR-ENTRY
* g77: (g77).               The GNU Fortran compilation system.
END-INFO-DIR-ENTRY


File: g77.info,  Node: Character Type,  Prev: Integer Type,  Up: Data Types and Constants

Character Type
--------------

   (Corresponds to Section 4.8 of ANSI X3.9-1978 FORTRAN 77.)

   A character constant may be delimited by a pair of double quotes
(`"') instead of apostrophes.  In this case, an apostrophe within the
constant represents a single apostrophe, while a double quote is
represented in the source text of the constant by two consecutive double
quotes with no intervening blanks.

   A character constant may be empty (have a length of zero).

   A character constant may include a substring specification, The
value of such a constant is the value of the substring--for example,
the value of `'hello'(3:5)' is the same as the value of `'llo''.


File: g77.info,  Node: Expressions,  Next: Specification Statements,  Prev: Data Types and Constants,  Up: Language

Expressions
===========

   (The following information augments or overrides the information in
Chapter 6 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.  Chapter 6 of that document otherwise serves as the basis for
the relevant aspects of GNU Fortran.)

* Menu:

* %LOC()::


File: g77.info,  Node: %LOC(),  Up: Expressions

The `%LOC()' Construct
----------------------

     %LOC(ARG)

   The `%LOC()' construct is an expression that yields the value of the
location of its argument, ARG, in memory.  The size of the type of the
expression depends on the system--typically, it is equivalent to either
`INTEGER(KIND=1)' or `INTEGER(KIND=2)', though it is actually type
`INTEGER(KIND=0)'.

   The argument to `%LOC()' must be suitable as the left-hand side of
an assignment statement.  That is, it may not be a general expression
involving operators such as addition, subtraction, and so on, nor may
it be a constant.

   Use of `%LOC()' is recommended only for code that is accessing
facilities outside of GNU Fortran, such as operating system or
windowing facilities.  It is best to constrain such uses to isolated
portions of a program--portions that deal specifically and exclusively
with low-level, system-dependent facilities.  Such portions might well
provide a portable interface for use by the program as a whole, but are
themselves not portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

   Do not depend on `%LOC()' returning a pointer that can be safely
used to *define* (change) the argument.  While this might work in some
circumstances, it is hard to predict whether it will continue to work
when a program (that works using this unsafe behavior) is recompiled
using different command-line options or a different version of `g77'.

   Generally, `%LOC()' is safe when used as an argument to a procedure
that makes use of the value of the corresponding dummy argument only
during its activation, and only when such use is restricted to
referencing (reading) the value of the argument to `%LOC()'.

   *Implementation Note:* Currently, `g77' passes arguments (those not
passed using a construct such as `%VAL()') by reference or descriptor,
depending on the type of the actual argument.  Thus, given `INTEGER I',
`CALL FOO(I)' would seem to mean the same thing as `CALL FOO(%LOC(I))',
and in fact might compile to identical code.

   However, `CALL FOO(%LOC(I))' emphatically means "pass the address of
`I' in memory".  While `CALL FOO(I)' might use that same approach in a
particular version of `g77', another version or compiler might choose a
different implementation, such as copy-in/copy-out, to effect the
desired behavior--and which will therefore not necessarily compile to
the same code as would `CALL FOO(%LOC(I))' using the same version or
compiler.

   *Note Debugging and Interfacing::, for detailed information on how
this particular version of `g77' implements various constructs.


File: g77.info,  Node: Specification Statements,  Next: Control Statements,  Prev: Expressions,  Up: Language

Specification Statements
========================

   (The following information augments or overrides the information in
Chapter 8 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.  Chapter 8 of that document otherwise serves as the basis for
the relevant aspects of GNU Fortran.)

* Menu:

* NAMELIST::
* DOUBLE COMPLEX::


File: g77.info,  Node: NAMELIST,  Next: DOUBLE COMPLEX,  Up: Specification Statements

`NAMELIST' Statement
--------------------

   The `NAMELIST' statement, and related I/O constructs, are supported
by the GNU Fortran language in essentially the same way as they are by
`f2c'.


File: g77.info,  Node: DOUBLE COMPLEX,  Prev: NAMELIST,  Up: Specification Statements

`DOUBLE COMPLEX' Statement
--------------------------

   `DOUBLE COMPLEX' is a type-statement (and type) that specifies the
type `COMPLEX(KIND=2)' in GNU Fortran.


File: g77.info,  Node: Control Statements,  Next: Functions and Subroutines,  Prev: Specification Statements,  Up: Language

Control Statements
==================

   (The following information augments or overrides the information in
Chapter 11 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.  Chapter 11 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

* Menu:

* DO WHILE::
* END DO::
* Construct Names::
* CYCLE and EXIT::


File: g77.info,  Node: DO WHILE,  Next: END DO,  Up: Control Statements

DO WHILE
--------

   The `DO WHILE' statement, a feature of both the MIL-STD 1753 and
Fortran 90 standards, is provided by the GNU Fortran language.


File: g77.info,  Node: END DO,  Next: Construct Names,  Prev: DO WHILE,  Up: Control Statements

END DO
------

   The `END DO' statement is provided by the GNU Fortran language.

   This statement is used in one of two ways:

   * The Fortran 90 meaning, in which it specifies the termination
     point of a single `DO' loop started with a `DO' statement that
     specifies no termination label.

   * The MIL-STD 1753 meaning, in which it specifies the termination
     point of one or more `DO' loops, all of which start with a `DO'
     statement that specify the label defined for the `END DO'
     statement.

     This kind of `END DO' statement is merely a synonym for
     `CONTINUE', except it is permitted only when the statement is
     labeled and a target of one or more labeled `DO' loops.

     It is expected that this use of `END DO' will be removed from the
     GNU Fortran language in the future, though it is likely that it
     will long be supported by `g77' as a dialect form.


File: g77.info,  Node: Construct Names,  Next: CYCLE and EXIT,  Prev: END DO,  Up: Control Statements

Construct Names
---------------

   The GNU Fortran language supports construct names as defined by the
Fortran 90 standard.  These names are local to the program unit and are
defined as follows:

     CONSTRUCT-NAME: BLOCK-STATEMENT

Here, CONSTRUCT-NAME is the construct name itself; its definition is
connoted by the single colon (`:'); and BLOCK-STATEMENT is an `IF',
`DO', or `SELECT CASE' statement that begins a block.

   A block that is given a construct name must also specify the same
construct name in its termination statement:

     END BLOCK CONSTRUCT-NAME

Here, BLOCK must be `IF', `DO', or `SELECT', as appropriate.


File: g77.info,  Node: CYCLE and EXIT,  Prev: Construct Names,  Up: Control Statements

The `CYCLE' and `EXIT' Statements
---------------------------------

   The `CYCLE' and `EXIT' statements specify that the remaining
statements in the current iteration of a particular active (enclosing)
`DO' loop are to be skipped.

   `CYCLE' specifies that these statements are skipped, but the `END
DO' statement that marks the end of the `DO' loop be executed--that is,
the next iteration, if any, is to be started.  If the statement marking
the end of the `DO' loop is not `END DO'--in other words, if the loop
is not a block `DO'--the `CYCLE' statement does not execute that
statement, but does start the next iteration (if any).

   `EXIT' specifies that the loop specified by the `DO' construct is
terminated.

   The `DO' loop affected by `CYCLE' and `EXIT' is the innermost
enclosing `DO' loop when the following forms are used:

     CYCLE
     EXIT

   Otherwise, the following forms specify the construct name of the
pertinent `DO' loop:

     CYCLE CONSTRUCT-NAME
     EXIT CONSTRUCT-NAME

   `CYCLE' and `EXIT' can be viewed as glorified `GO TO' statements.
However, they cannot be easily thought of as `GO TO' statements in
obscure cases involving FORTRAN 77 loops.  For example:

           DO 10 I = 1, 5
           DO 10 J = 1, 5
              IF (J .EQ. 5) EXIT
           DO 10 K = 1, 5
              IF (K .EQ. 3) CYCLE
     10    PRINT *, 'I=', I, ' J=', J, ' K=', K
     20    CONTINUE

In particular, neither the `EXIT' nor `CYCLE' statements above are
equivalent to a `GO TO' statement to either label `10' or `20'.

   To understand the effect of `CYCLE' and `EXIT' in the above
fragment, it is helpful to first translate it to its equivalent using
only block `DO' loops:

           DO I = 1, 5
              DO J = 1, 5
                 IF (J .EQ. 5) EXIT
                 DO K = 1, 5
                    IF (K .EQ. 3) CYCLE
     10             PRINT *, 'I=', I, ' J=', J, ' K=', K
                 END DO
              END DO
           END DO
     20    CONTINUE

   Adding new labels allows translation of `CYCLE' and `EXIT' to `GO
TO' so they may be more easily understood by programmers accustomed to
FORTRAN coding:

           DO I = 1, 5
              DO J = 1, 5
                 IF (J .EQ. 5) GOTO 18
                 DO K = 1, 5
                    IF (K .EQ. 3) GO TO 12
     10             PRINT *, 'I=', I, ' J=', J, ' K=', K
     12          END DO
              END DO
     18    END DO
     20    CONTINUE

Thus, the `CYCLE' statement in the innermost loop skips over the
`PRINT' statement as it begins the next iteration of the loop, while
the `EXIT' statement in the middle loop ends that loop but *not* the
outermost loop.


File: g77.info,  Node: Functions and Subroutines,  Next: Scope and Classes of Names,  Prev: Control Statements,  Up: Language

Functions and Subroutines
=========================

   (The following information augments or overrides the information in
Chapter 15 of ANSI X3.9-1978 FORTRAN 77 in specifying the GNU Fortran
language.  Chapter 15 of that document otherwise serves as the basis
for the relevant aspects of GNU Fortran.)

* Menu:

* %VAL()::
* %REF()::
* %DESCR()::
* Generics and Specifics::
* REAL() and AIMAG() of Complex::
* CMPLX() of DOUBLE PRECISION::
* MIL-STD 1753::
* f77/f2c Intrinsics::
* Table of Intrinsic Functions::


File: g77.info,  Node: %VAL(),  Next: %REF(),  Up: Functions and Subroutines

The `%VAL()' Construct
----------------------

     %VAL(ARG)

   The `%VAL()' construct specifies that an argument, ARG, is to be
passed by value, instead of by reference or descriptor.

   `%VAL()' is restricted to actual arguments in invocations of
external procedures.

   Use of `%VAL()' is recommended only for code that is accessing
facilities outside of GNU Fortran, such as operating system or
windowing facilities.  It is best to constrain such uses to isolated
portions of a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.  Such portions might well
provide a portable interface for use by the program as a whole, but are
themselves not portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

   *Implementation Note:* Currently, `g77' passes all arguments either
by reference or by descriptor.

   Thus, use of `%VAL()' tends to be restricted to cases where the
called procedure is written in a language other than Fortran that
supports call-by-value semantics.  (C is an example of such a language.)

   *Note Procedures (SUBROUTINE and FUNCTION): Procedures, for detailed
information on how this particular version of `g77' passes arguments to
procedures.


File: g77.info,  Node: %REF(),  Next: %DESCR(),  Prev: %VAL(),  Up: Functions and Subroutines

The `%REF()' Construct
----------------------

     %REF(ARG)

   The `%REF()' construct specifies that an argument, ARG, is to be
passed by reference, instead of by value or descriptor.

   `%REF()' is restricted to actual arguments in invocations of
external procedures.

   Use of `%REF()' is recommended only for code that is accessing
facilities outside of GNU Fortran, such as operating system or
windowing facilities.  It is best to constrain such uses to isolated
portions of a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.  Such portions might well
provide a portable interface for use by the program as a whole, but are
themselves not portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

   Do not depend on `%REF()' supplying a pointer to the procedure being
invoked.  While that is a likely implementation choice, other
implementation choices are available that preserve Fortran
pass-by-reference semantics without passing a pointer to the argument,
ARG.  (For example, a copy-in/copy-out implementation.)

   *Implementation Note:* Currently, `g77' passes all arguments (other
than variables and arrays of type `CHARACTER') by reference.  Future
versions of, or dialects supported by, `g77' might not pass `CHARACTER'
functions by reference.

   Thus, use of `%REF()' tends to be restricted to cases where ARG is
type `CHARACTER' but the called procedure accesses it via a means other
than the method used for Fortran `CHARACTER' arguments.

   *Note Procedures (SUBROUTINE and FUNCTION): Procedures, for detailed
information on how this particular version of `g77' passes arguments to
procedures.


File: g77.info,  Node: %DESCR(),  Next: Generics and Specifics,  Prev: %REF(),  Up: Functions and Subroutines

The `%DESCR()' Construct
------------------------

     %DESCR(ARG)

   The `%DESCR()' construct specifies that an argument, ARG, is to be
passed by descriptor, instead of by value or reference.

   `%DESCR()' is restricted to actual arguments in invocations of
external procedures.

   Use of `%DESCR()' is recommended only for code that is accessing
facilities outside of GNU Fortran, such as operating system or
windowing facilities.  It is best to constrain such uses to isolated
portions of a program--portions the deal specifically and exclusively
with low-level, system-dependent facilities.  Such portions might well
provide a portable interface for use by the program as a whole, but are
themselves not portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

   Do not depend on `%DESCR()' supplying a pointer and/or a length
passed by value to the procedure being invoked.  While that is a likely
implementation choice, other implementation choices are available that
preserve the pass-by-reference semantics without passing a pointer to
the argument, ARG.  (For example, a copy-in/copy-out implementation.)
And, future versions of `g77' might change the way descriptors are
implemented, such as passing a single argument pointing to a record
containing the pointer/length information instead of passing that same
information via two arguments as it currently does.

   *Implementation Note:* Currently, `g77' passes all variables and
arrays of type `CHARACTER' by descriptor.  Future versions of, or
dialects supported by, `g77' might pass `CHARACTER' functions by
descriptor as well.

   Thus, use of `%DESCR()' tends to be restricted to cases where ARG is
not type `CHARACTER' but the called procedure accesses it via a means
similar to the method used for Fortran `CHARACTER' arguments.

   *Note Procedures (SUBROUTINE and FUNCTION): Procedures, for detailed
information on how this particular version of `g77' passes arguments to
procedures.


File: g77.info,  Node: Generics and Specifics,  Next: REAL() and AIMAG() of Complex,  Prev: %DESCR(),  Up: Functions and Subroutines

Generics and Specifics
----------------------

   The ANSI FORTRAN 77 language defines generic and specific intrinsics.
In short, the distinctions are:

   * *Specific* intrinsics have specific types for their arguments and
     a specific return type.

   * *Generic* intrinsics are treated, on a case-by-case basis in the
     program's source code, as one of several possible specific
     intrinsics.

     Typically, a generic intrinsic has a return type that is
     determined by the type of one or more of its arguments.

   The GNU Fortran language generalizes these concepts somewhat,
especially by providing intrinsic subroutines and generic intrinsics
that are treated as either a specific intrinsic subroutine or a
specific intrinsic function (e.g. `SECOND').

   However, GNU Fortran avoids generalizing this concept to the point
where existing code would be accepted as meaning something possibly
different than what was intended.

   For example, `ABS' is a generic intrinsic, so all working code
written using `ABS' of an `INTEGER' argument expects an `INTEGER'
return value.  Similarly, all such code expects that `ABS' of an
`INTEGER*2' argument returns an `INTEGER*2' return value.

   Yet, `IABS' is a *specific* intrinsic that accepts only an
`INTEGER(KIND=1)' argument.  Code that passes something other than an
`INTEGER(KIND=1)' argument to `IABS' is not valid GNU Fortran code,
because it is not clear what the author intended.

   For example, if `J' is `INTEGER(KIND=6)', `IABS(J)' is not defined
by the GNU Fortran language, because the programmer might have used
that construct to mean any of the following, subtly different, things:

   * Convert `J' to `INTEGER(KIND=1)' first (as if `IABS(INT(J))' had
     been written).

   * Convert the result of the intrinsic to `INTEGER(KIND=1)' (as if
     `INT(ABS(J))' had been written).

   * No conversion (as if `ABS(J)' had been written).

   The distinctions matter especially when types and values wider than
`INTEGER(KIND=1)' (such as `INTEGER(KIND=2)'), or when operations
performing more "arithmetic" than absolute-value, are involved.

   The following sample program is not a valid GNU Fortran program, but
might be accepted by other compilers.  If so, the output is likely to
be revealing in terms of how a given compiler treats intrinsics (that
normally are specific) when they are given arguments that do not
conform to their stated requirements:

           PROGRAM JCB002
     C
     C Written by James Craig Burley 1997-02-20.
     C Contact via Internet email: burley@gnu.ai.mit.edu
     C
     C Determine how compilers handle non-standard IDIM
     C on INTEGER*2 operands, which presumably can be
     C extrapolated into understanding how the compiler
     C generally treats specific intrinsics that are passed
     C arguments not of the correct types.
     C
     C If your compiler implements INTEGER*2 and INTEGER
     C as the same type, change all INTEGER*2 below to
     C INTEGER*1.
     C
           INTEGER*2 I0, I4
           INTEGER I1, I2, I3
           INTEGER*2 ISMALL, ILARGE
           INTEGER*2 ITOOLG, ITWO
           LOGICAL L2, L3, L4
     C
     C Find smallest INTEGER*2 number.
     C
           ISMALL=0
      10   I0 = ISMALL-1
           IF ((I0 .GE. ISMALL) .OR. (I0+1 .NE. ISMALL)) GOTO 20
           ISMALL = I0
           GOTO 10
      20   CONTINUE
     C
     C Find largest INTEGER*2 number.
     C
           ILARGE=0
      30   I0 = ILARGE+1
           IF ((I0 .LE. ILARGE) .OR. (I0-1 .NE. ILARGE)) GOTO 40
           ILARGE = I0
           GOTO 30
      40   CONTINUE
     C
     C Multiplying by two adds stress to the situation.
     C
           ITWO = 2
     C
     C Need a number that, added to -2, is too wide to fit in I*2.
     C
           ITOOLG = ISMALL
     C
     C Use IDIM the straightforward way.
     C
           I1 = IDIM (ILARGE, ISMALL) * ITWO + ITOOLG
     C
     C Try first interpretation.
     C
           I2 = (INT (ILARGE) - INT (ISMALL)) * ITWO + ITOOLG
     C
     C Try second interpretation.
     C
           I3 = (INT (ILARGE - ISMALL)) * ITWO + ITOOLG
     C
     C Try third interpretation.
     C
           I4 = (ILARGE - ISMALL) * ITWO + ITOOLG
     C
     C Print results.
     C
           PRINT *, 'ILARGE=', ILARGE
           PRINT *, 'ITWO=', ITWO
           PRINT *, 'ITOOLG=', ITOOLG
           PRINT *, 'ISMALL=', ISMALL
           PRINT *, 'I1=', I1
           PRINT *, 'I2=', I2
           PRINT *, 'I3=', I3
           PRINT *, 'I4=', I4
           PRINT *
           L2 = (I1 .EQ. I2)
           L3 = (I1 .EQ. I3)
           L4 = (I1 .EQ. I4)
           IF (L2 .AND. .NOT.L3 .AND. .NOT.L4) THEN
              PRINT *, 'Interp 1: IDIM(I*2,I*2) => IDIM(INT(I*2),INT(I*2))'
              STOP
           END IF
           IF (L3 .AND. .NOT.L2 .AND. .NOT.L4) THEN
              PRINT *, 'Interp 2: IDIM(I*2,I*2) => INT(DIM(I*2,I*2))'
              STOP
           END IF
           IF (L4 .AND. .NOT.L2 .AND. .NOT.L3) THEN
              PRINT *, 'Interp 3: IDIM(I*2,I*2) => DIM(I*2,I*2)'
              STOP
           END IF
           PRINT *, 'Results need careful analysis.'
           END

   It is possible that a future version of the GNU Fortran language
will permit specific intrinsic invocations with wrong-typed arguments
(such as `IDIM' in the above example) if the vast majority of
production compilers agree on the interpretation of such invocations.

   Especially if you know of a compiler that does not implement
interpretation 3 above (output `Interp 3: ...'), please let us know the
details (compiler product, version, machine, results, and so on).


File: g77.info,  Node: REAL() and AIMAG() of Complex,  Next: CMPLX() of DOUBLE PRECISION,  Prev: Generics and Specifics,  Up: Functions and Subroutines

`REAL()' and `AIMAG()' of Complex
---------------------------------

   The GNU Fortran language disallows `REAL(EXPR)' and `AIMAG(EXPR)',
where EXPR is any `COMPLEX' type other than `COMPLEX(KIND=1)', except
when they are used in the following way:

     REAL(REAL(EXPR))
     REAL(AIMAG(EXPR))

The above forms explicitly specify that the desired effect is to
convert the real or imaginary part of EXPR, which might be some `REAL'
type other than `REAL(KIND=1)', to type `REAL(KIND=1)', and have that
serve as the value of the expression.

   The GNU Fortran language offers clearly named intrinsics to extract
the real and imaginary parts of a complex entity without any conversion:

     REALPART(EXPR)
     IMAGPART(EXPR)

   To express the above using typical extended FORTRAN 77, use the
following constructs (when EXPR is `COMPLEX(KIND=2)'):

     DBLE(EXPR)
     DIMAG(EXPR)

   The FORTRAN 77 language offers no way to explicitly specify the real
and imaginary parts of a complex expression of arbitrary type,
apparently as a result of requiring support for only one `COMPLEX' type
(`COMPLEX(KIND=1)').  The concepts of converting an expression to type
`REAL(KIND=1)' and of extracting the real part of a complex expression
were thus "smooshed" by FORTRAN 77 into a single intrinsic, since they
happened to have the exact same effect in that language (due to having
only one `COMPLEX' type).

   *Note:* When `-ff90' is in effect, `g77' treats `REAL(EXPR)', where
EXPR is of type `COMPLEX', as `REALPART(EXPR)', whereas with
`-fugly-complex -fno-f90' in effect, it is treated as
`REAL(REALPART(EXPR))'.

   *Note Ugly Complex Part Extraction::, for more information.


File: g77.info,  Node: CMPLX() of DOUBLE PRECISION,  Next: MIL-STD 1753,  Prev: REAL() and AIMAG() of Complex,  Up: Functions and Subroutines

`CMPLX()' of `DOUBLE PRECISION'
-------------------------------

   In accordance with Fortran 90 and at least some (perhaps all) other
compilers, the GNU Fortran language defines `CMPLX()' as always
returning a result that is type `COMPLEX(KIND=1)'.

   This means `CMPLX(D1,D2)', where `D1' and `D2' are `REAL(KIND=2)'
(`DOUBLE PRECISION'), is treated as:

     CMPLX(SNGL(D1), SNGL(D2))

   The GNU Fortran language also provides the `DCMPLX()' intrinsic,
which is provided by some FORTRAN 77 compilers to construct a `DOUBLE
COMPLEX' entity from of `DOUBLE PRECISION' operands.  However, this
solution does not scale well when more `COMPLEX' types (having various
precisions and ranges) are offered by Fortran implementations.

   Fortran 90 extends the `CMPLX()' intrinsic by adding an extra
argument used to specify the desired kind of complex result.  However,
this solution is somewhat awkward to use.

   The GNU Fortran language provides a simple way to build a complex
value out of two numbers, with the precise type of the value determined
by the types of the two numbers (via the usual type-promotion
mechanism):

     COMPLEX(REAL, IMAG)

   When REAL and IMAG are the same `REAL' types, `COMPLEX()' performs
no conversion other than to put them together to form a complex result
of the same (complex version of real) type.

   *Note Complex Intrinsic::, for more information.


File: g77.info,  Node: MIL-STD 1753,  Next: f77/f2c Intrinsics,  Prev: CMPLX() of DOUBLE PRECISION,  Up: Functions and Subroutines

MIL-STD 1753 Support
--------------------

   The GNU Fortran language includes the MIL-STD 1753 intrinsics
`BTEST', `IAND', `IBCLR', `IBITS', `IBSET', `IEOR', `IOR', `ISHFT',
`ISHFTC', `MVBITS', and `NOT'.


File: g77.info,  Node: f77/f2c Intrinsics,  Next: Table of Intrinsic Functions,  Prev: MIL-STD 1753,  Up: Functions and Subroutines

`f77'/`f2c' Intrinsics
----------------------

   The bit-manipulation intrinsics supported by traditional `f77' and
by `f2c' are available in the GNU Fortran language.  These include
`AND', `LSHIFT', `OR', `RSHIFT', and `XOR'.

   Also supported are the intrinsics `CDABS', `CDCOS', `CDEXP',
`CDLOG', `CDSIN', `CDSQRT', `DCMPLX', `DCONJG', `DFLOAT', `DIMAG',
`DREAL', and `IMAG', `ZABS', `ZCOS', `ZEXP', `ZLOG', `ZSIN', and
`ZSQRT'.


File: g77.info,  Node: Table of Intrinsic Functions,  Prev: f77/f2c Intrinsics,  Up: Functions and Subroutines

Table of Intrinsic Functions
----------------------------

   (Corresponds to Section 15.10 of ANSI X3.9-1978 FORTRAN 77.)

   The GNU Fortran language adds various functions, subroutines, types,
and arguments to the set of intrinsic functions in ANSI FORTRAN 77.
The complete set of intrinsics supported by the GNU Fortran language is
described below.

   Note that a name is not treated as that of an intrinsic if it is
specified in an `EXTERNAL' statement in the same program unit; if a
command-line option is used to disable the groups to which the
intrinsic belongs; or if the intrinsic is not named in an `INTRINSIC'
statement and a command-line option is used to hide the groups to which
the intrinsic belongs.

   So, it is recommended that any reference in a program unit to an
intrinsic procedure that is not a standard FORTRAN 77 intrinsic be
accompanied by an appropriate `INTRINSIC' statement in that program
unit.  This sort of defensive programming makes it more likely that an
implementation will issue a diagnostic rather than generate incorrect
code for such a reference.

   The terminology used below is based on that of the Fortran 90
standard, so that the text may be more concise and accurate:

   * `OPTIONAL' means the argument may be omitted.

   * `A-1, A-2, ..., A-n' means more than one argument (generally named
     `A') may be specified.

   * `scalar' means the argument must not be an array (must be a
     variable or array element, or perhaps a constant if expressions
     are permitted).

   * `DIMENSION(4)' means the argument must be an array having 4
     elements.

   * `INTENT(IN)' means the argument must be an expression (such as a
     constant or a variable that is defined upon invocation of the
     intrinsic).

   * `INTENT(OUT)' means the argument must be definable by the
     invocation of the intrinsic (that is, must not be a constant nor
     an expression involving operators other than array reference and
     substring reference).

   * `INTENT(INOUT)' means the argument must be defined prior to, and
     definable by, invocation of the intrinsic (a combination of the
     requirements of `INTENT(IN)' and `INTENT(OUT)'.

   (Note that the blank lines appearing in the menu below are not
intentional--they result from a bug in the GNU `makeinfo' program...a
program that, if it did not exist, this document would be in far worse
shape!)

* Menu:


* Abort Intrinsic::     Abort the program.

* Abs Intrinsic::       Absolute value.

* Access Intrinsic::    Check file accessibility.

* AChar Intrinsic::     ASCII character from code.

* ACos Intrinsic::      Arc cosine.
* AImag Intrinsic::     Convert/extract imaginary part of complex.
* AInt Intrinsic::      Truncate to whole number.
* ALog Intrinsic::      Natural logarithm (archaic).
* ALog10 Intrinsic::    Natural logarithm (archaic).
* AMax0 Intrinsic::     Maximum value (archaic).
* AMax1 Intrinsic::     Maximum value (archaic).
* AMin0 Intrinsic::     Minimum value (archaic).
* AMin1 Intrinsic::     Minimum value (archaic).
* AMod Intrinsic::      Remainder (archaic).

* And Intrinsic::       Boolean AND.

* ANInt Intrinsic::     Round to nearest whole number.
* ASin Intrinsic::      Arc sine.
* ATan Intrinsic::      Arc tangent.
* ATan2 Intrinsic::     Arc tangent.

* BesJ0 Intrinsic::     Bessel function.
* BesJ1 Intrinsic::     Bessel function.
* BesJN Intrinsic::     Bessel function.
* BesY0 Intrinsic::     Bessel function.
* BesY1 Intrinsic::     Bessel function.
* BesYN Intrinsic::     Bessel function.

* Bit_Size Intrinsic::  Number of bits in argument's type.

* BTest Intrinsic::     Test bit.

* CAbs Intrinsic::      Absolute value (archaic).
* CCos Intrinsic::

* CExp Intrinsic::
* Char Intrinsic::      Character from code.

* ChDir Intrinsic::     Change directory.
* ChMod Intrinsic::     Change file modes.

* CLog Intrinsic::      Natural logarithm (archaic).
* Cmplx Intrinsic::     Construct `COMPLEX(KIND=1)' value.

* Complex Intrinsic::   Build complex value from real and
                         imaginary parts.

* Conjg Intrinsic::     Complex conjugate.
* Cos Intrinsic::
* CosH Intrinsic::
* CSin Intrinsic::
* CSqRt Intrinsic::

* CTime Intrinsic::     Convert time to Day Mon dd hh:mm:ss yyyy.

* DAbs Intrinsic::      Absolute value (archaic).
* DACos Intrinsic::     Arc cosine (archaic).
* DASin Intrinsic::     Arc sine (archaic).
* DATan Intrinsic::     Arc tangent (archaic).
* DATan2 Intrinsic::    Arc tangent (archaic).

* DbesJ0 Intrinsic::
* DbesJ1 Intrinsic::
* DbesJN Intrinsic::
* DbesY0 Intrinsic::
* DbesY1 Intrinsic::
* DbesYN Intrinsic::

* Dble Intrinsic::

* DCos Intrinsic::
* DCosH Intrinsic::
* DDiM Intrinsic::

* DErF Intrinsic::
* DErFC Intrinsic::

* DExp Intrinsic::

* DiM Intrinsic::

* DInt Intrinsic::      Truncate to whole number (archaic).
* DLog Intrinsic::      Natural logarithm (archaic).
* DLog10 Intrinsic::    Natural logarithm (archaic).
* DMax1 Intrinsic::     Maximum value (archaic).
* DMin1 Intrinsic::     Minimum value (archaic).
* DMod Intrinsic::      Remainder (archaic).
* DNInt Intrinsic::     Round to nearest whole number (archaic).
* DProd Intrinsic::

* DSign Intrinsic::
* DSin Intrinsic::
* DSinH Intrinsic::
* DSqRt Intrinsic::
* DTan Intrinsic::
* DTanH Intrinsic::

* Dtime Intrinsic::     Get elapsed time since last time.
* ErF Intrinsic::       Error function.
* ErFC Intrinsic::      Complementary error function.
* ETime Intrinsic::     Get elapsed time for process.
* Exit Intrinsic::      Terminate the program.

* Exp Intrinsic::

* Fdate Intrinsic::     Get current time as Day Mon dd hh:mm:ss yyyy.
* FGetC Intrinsic::

* Float Intrinsic::

* Flush Intrinsic::     Flush buffered output.
* FNum Intrinsic::      Get file descriptor from Fortran unit number.
* FPutC Intrinsic::
* FSeek Intrinsic::     Position file (low-level).
* FStat Intrinsic::     Get file information.
* FTell Intrinsic::     Get file position (low-level).
* GError Intrinsic::    Get error message for last error.
* GetArg Intrinsic::    Obtain command-line argument.
* GetCWD Intrinsic::    Get current working directory.
* GetEnv Intrinsic::    Get environment variable.
* GetGId Intrinsic::    Get process group id.
* GetLog Intrinsic::    Get login name.
* GetPId Intrinsic::    Get process id.
* GetUId Intrinsic::    Get process user id.
* GMTime Intrinsic::    Convert time to GMT time info.
* HostNm Intrinsic::    Get host name.

* IAbs Intrinsic::      Absolute value (archaic).

* IAChar Intrinsic::    ASCII code for character.

* IAnd Intrinsic::      Boolean AND.

* IArgC Intrinsic::     Obtain count of command-line arguments.

* IBClr Intrinsic::
* IBits Intrinsic::
* IBSet Intrinsic::

* IChar Intrinsic::     Code for character.

* IDate Intrinsic::     Get local time info.

* IDiM Intrinsic::
* IDInt Intrinsic::     Convert to `INTEGER' value truncated
                         to whole number (archaic).
* IDNInt Intrinsic::    Convert to `INTEGER' value rounded
                         to nearest whole number (archaic).

* IEOr Intrinsic::      Boolean XOR.

* IErrNo Intrinsic::    Get error number for last error.

* IFix Intrinsic::      Convert to `INTEGER' value truncated
                         to whole number.

* Imag Intrinsic::      Extract imaginary part of complex.

* ImagPart Intrinsic::  Extract imaginary part of complex.

* Index Intrinsic::
* Int Intrinsic::       Convert to `INTEGER' value truncated
                         to whole number.

* IOr Intrinsic::       Boolean OR.

* IRand Intrinsic::     Random number.
* IsaTty Intrinsic::    Is unit connected to a terminal?

* IShft Intrinsic::
* IShftC Intrinsic::

* ISign Intrinsic::

* ITime Intrinsic::     Get local time of day.
* Kill Intrinsic::      Signal a process.

* Len Intrinsic::

* Len_Trim Intrinsic::  Get last non-blank character in string.

* LGe Intrinsic::
* LGt Intrinsic::

* Link Intrinsic::      Make hard link in file system.

* LLe Intrinsic::
* LLt Intrinsic::

* LnBlnk Intrinsic::    Get last non-blank character in string.
* Loc Intrinsic::       Address of entity in core.

* Log Intrinsic::       Natural logarithm.
* Log10 Intrinsic::     Natural logarithm.

* Long Intrinsic::

* LShift Intrinsic::

* LStat Intrinsic::     Get file information.
* LTime Intrinsic::     Convert time to local time info.

* Max Intrinsic::       Maximum value.
* Max0 Intrinsic::      Maximum value (archaic).
* Max1 Intrinsic::      Maximum value (archaic).

* MClock Intrinsic::    Get number of clock ticks for process.

* Min Intrinsic::       Minimum value.
* Min0 Intrinsic::      Minimum value (archaic).
* Min1 Intrinsic::      Minimum value (archaic).
* Mod Intrinsic::       Remainder.

* MvBits Intrinsic::

* NInt Intrinsic::      Convert to `INTEGER' value rounded
                         to nearest whole number.

* Not Intrinsic::       Boolean NOT.

* Or Intrinsic::        Boolean OR.

* PError Intrinsic::    Print error message for last error.
* Rand Intrinsic::      Random number.

* Real Intrinsic::      Convert value to type `REAL(KIND=1)'.

* RealPart Intrinsic::  Extract real part of complex.

* Rename Intrinsic::    Rename file.

* RShift Intrinsic::

* Second Intrinsic::    Get CPU time for process in seconds.
* Second Intrinsic (Form SECOND (subroutine)):: Get CPU time for process
                         in seconds.
* Short Intrinsic::

* Sign Intrinsic::

* Signal Intrinsic::    Muck with signal handling.

* Sin Intrinsic::
* SinH Intrinsic::

* Sleep Intrinsic::     Sleep for a specified time.

* Sngl Intrinsic::
* SqRt Intrinsic::

* SRand Intrinsic::     Random seed.
* Stat Intrinsic::      Get file information.
* SymLnk Intrinsic::    Make symbolic link in file system.
* System Intrinsic::    Invoke shell (system) command.

* System_Clock Intrinsic:: Get current system clock value.

* Tan Intrinsic::
* TanH Intrinsic::

* Time Intrinsic::      Get current time as time value.

* TtyNam Intrinsic::    Get name of terminal device for unit.
* UMask Intrinsic::     Set file creation permissions mask.
* Unlink Intrinsic::    Unlink file.

* XOr Intrinsic::       Boolean XOR.
* ZAbs Intrinsic::      Absolute value (archaic).
* ZCos Intrinsic::
* ZExp Intrinsic::
* ZLog Intrinsic::      Natural logarithm (archaic).
* ZSin Intrinsic::
* ZSqRt Intrinsic::


File: g77.info,  Node: Abort Intrinsic,  Next: Abs Intrinsic,  Up: Table of Intrinsic Functions

Abort Intrinsic
...............

     CALL Abort()

Intrinsic groups: `unix'.

Description:

   Prints a message and potentially causes a core dump via `abort(3)'.


File: g77.info,  Node: Abs Intrinsic,  Next: Access Intrinsic,  Prev: Abort Intrinsic,  Up: Table of Intrinsic Functions

Abs Intrinsic
.............

     Abs(A)

Abs: `INTEGER' or `REAL' function.  The exact type depends on that of
argument A--if A is `COMPLEX', this function's type is `REAL' with the
same `KIND=' value as the type of A.  Otherwise, this function's type
is the same as that of A.

A: `INTEGER', `REAL', or `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the absolute value of A.

   If A is type `COMPLEX', the absolute value is computed as:

     SQRT(REALPART(A)**2, IMAGPART(A)**2)

Otherwise, it is computed by negating the A if it is negative, or
returning A.

   *Note Sign Intrinsic::, for how to explicitly compute the positive
or negative form of the absolute value of an expression.


File: g77.info,  Node: Access Intrinsic,  Next: AChar Intrinsic,  Prev: Abs Intrinsic,  Up: Table of Intrinsic Functions

Access Intrinsic
................

     Access(NAME, MODE)

Access: `INTEGER(KIND=1)' function.

NAME: `CHARACTER'; scalar; INTENT(IN).

MODE: `CHARACTER'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Checks file NAME for accessibility in the mode specified by MODE and
returns 0 if the file is accessible in that mode, otherwise an error
code if the file is inaccessible or MODE is invalid.  See `access(2)'.
MODE may be a concatenation of any of the following characters:

`r'
     Read permission

`w'
     Write permission

`x'
     Execute permission

`SPC'
     Existence


File: g77.info,  Node: AChar Intrinsic,  Next: ACos Intrinsic,  Prev: Access Intrinsic,  Up: Table of Intrinsic Functions

AChar Intrinsic
...............

     AChar(I)

AChar: `CHARACTER*1' function.

I: `INTEGER'; scalar; INTENT(IN).

Intrinsic groups: `f2c', `f90'.

Description:

   Returns the ASCII character corresponding to the code specified by I.

   *Note IAChar Intrinsic::, for the inverse function.

   *Note Char Intrinsic::, for the function corresponding to the
system's native character set.


File: g77.info,  Node: ACos Intrinsic,  Next: AImag Intrinsic,  Prev: AChar Intrinsic,  Up: Table of Intrinsic Functions

ACos Intrinsic
..............

     ACos(X)

ACos: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the arc-cosine (inverse cosine) of X in radians.

   *Note Cos Intrinsic::, for the inverse function.


File: g77.info,  Node: AImag Intrinsic,  Next: AInt Intrinsic,  Prev: ACos Intrinsic,  Up: Table of Intrinsic Functions

AImag Intrinsic
...............

     AImag(Z)

AImag: `REAL' function.  This intrinsic is valid when argument Z is
`COMPLEX(KIND=1)'.  When Z is any other `COMPLEX' type, this intrinsic
is valid only when used as the argument to `REAL()', as explained below.

Z: `COMPLEX'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the (possibly converted) imaginary part of Z.

   Use of `AIMAG()' with an argument of a type other than
`COMPLEX(KIND=1)' is restricted to the following case:

     REAL(AIMAG(Z))

This expression converts the imaginary part of Z to `REAL(KIND=1)'.

   *Note REAL() and AIMAG() of Complex::, for more information.


File: g77.info,  Node: AInt Intrinsic,  Next: ALog Intrinsic,  Prev: AImag Intrinsic,  Up: Table of Intrinsic Functions

AInt Intrinsic
..............

     AInt(A)

AInt: `REAL' function, the `KIND=' value of the type being that of
argument A.

A: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns A with the fractional portion of its magnitude truncated and
its sign preserved.  (Also called "truncation towards zero".)

   *Note ANInt Intrinsic::, for how to round to nearest whole number.

   *Note Int Intrinsic::, for how to truncate and then convert number
to `INTEGER'.


File: g77.info,  Node: ALog Intrinsic,  Next: ALog10 Intrinsic,  Prev: AInt Intrinsic,  Up: Table of Intrinsic Functions

ALog Intrinsic
..............

     ALog(X)

ALog: `REAL(KIND=1)' function.

X: `REAL(KIND=1)'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `LOG()' that is specific to one type for X.  *Note
Log Intrinsic::.


File: g77.info,  Node: ALog10 Intrinsic,  Next: AMax0 Intrinsic,  Prev: ALog Intrinsic,  Up: Table of Intrinsic Functions

ALog10 Intrinsic
................

     ALog10(X)

ALog10: `REAL(KIND=1)' function.

X: `REAL(KIND=1)'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `LOG10()' that is specific to one type for X.  *Note
Log10 Intrinsic::.


File: g77.info,  Node: AMax0 Intrinsic,  Next: AMax1 Intrinsic,  Prev: ALog10 Intrinsic,  Up: Table of Intrinsic Functions

AMax0 Intrinsic
...............

     AMax0(A-1, A-2, ..., A-n)

AMax0: `REAL(KIND=1)' function.

A: `INTEGER(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MAX()' that is specific to one type for A and a
different return type.  *Note Max Intrinsic::.


File: g77.info,  Node: AMax1 Intrinsic,  Next: AMin0 Intrinsic,  Prev: AMax0 Intrinsic,  Up: Table of Intrinsic Functions

AMax1 Intrinsic
...............

     AMax1(A-1, A-2, ..., A-n)

AMax1: `REAL(KIND=1)' function.

A: `REAL(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MAX()' that is specific to one type for A.  *Note
Max Intrinsic::.


File: g77.info,  Node: AMin0 Intrinsic,  Next: AMin1 Intrinsic,  Prev: AMax1 Intrinsic,  Up: Table of Intrinsic Functions

AMin0 Intrinsic
...............

     AMin0(A-1, A-2, ..., A-n)

AMin0: `REAL(KIND=1)' function.

A: `INTEGER(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MIN()' that is specific to one type for A and a
different return type.  *Note Min Intrinsic::.


File: g77.info,  Node: AMin1 Intrinsic,  Next: AMod Intrinsic,  Prev: AMin0 Intrinsic,  Up: Table of Intrinsic Functions

AMin1 Intrinsic
...............

     AMin1(A-1, A-2, ..., A-n)

AMin1: `REAL(KIND=1)' function.

A: `REAL(KIND=1)'; at least two such arguments must be provided;
scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MIN()' that is specific to one type for A.  *Note
Min Intrinsic::.


File: g77.info,  Node: AMod Intrinsic,  Next: And Intrinsic,  Prev: AMin1 Intrinsic,  Up: Table of Intrinsic Functions

AMod Intrinsic
..............

     AMod(A, P)

AMod: `REAL(KIND=1)' function.

A: `REAL(KIND=1)'; scalar; INTENT(IN).

P: `REAL(KIND=1)'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Archaic form of `MOD()' that is specific to one type for A.  *Note
Mod Intrinsic::.


File: g77.info,  Node: And Intrinsic,  Next: ANInt Intrinsic,  Prev: AMod Intrinsic,  Up: Table of Intrinsic Functions

And Intrinsic
.............

     And(I, J)

And: `INTEGER' or `LOGICAL' function, the exact type being the result
of cross-promoting the types of all the arguments.

I: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

J: `INTEGER' or `LOGICAL'; scalar; INTENT(IN).

Intrinsic groups: `f2c'.

Description:

   Returns value resulting from boolean AND of pair of bits in each of
I and J.


File: g77.info,  Node: ANInt Intrinsic,  Next: ASin Intrinsic,  Prev: And Intrinsic,  Up: Table of Intrinsic Functions

ANInt Intrinsic
...............

     ANInt(A)

ANInt: `REAL' function, the `KIND=' value of the type being that of
argument A.

A: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns A with the fractional portion of its magnitude eliminated by
rounding to the nearest whole number and with its sign preserved.

   A fractional portion exactly equal to `.5' is rounded to the whole
number that is larger in magnitude.  (Also called "Fortran round".)

   *Note AInt Intrinsic::, for how to truncate to whole number.

   *Note NInt Intrinsic::, for how to round and then convert number to
`INTEGER'.


File: g77.info,  Node: ASin Intrinsic,  Next: ATan Intrinsic,  Prev: ANInt Intrinsic,  Up: Table of Intrinsic Functions

ASin Intrinsic
..............

     ASin(X)

ASin: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the arc-sine (inverse sine) of X in radians.

   *Note Sin Intrinsic::, for the inverse function.


File: g77.info,  Node: ATan Intrinsic,  Next: ATan2 Intrinsic,  Prev: ASin Intrinsic,  Up: Table of Intrinsic Functions

ATan Intrinsic
..............

     ATan(X)

ATan: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the arc-tangent (inverse tangent) of X in radians.

   *Note Tan Intrinsic::, for the inverse function.


File: g77.info,  Node: ATan2 Intrinsic,  Next: BesJ0 Intrinsic,  Prev: ATan Intrinsic,  Up: Table of Intrinsic Functions

ATan2 Intrinsic
...............

     ATan2(Y, X)

ATan2: `REAL' function, the exact type being the result of
cross-promoting the types of all the arguments.

Y: `REAL'; scalar; INTENT(IN).

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: (standard FORTRAN 77).

Description:

   Returns the arc-tangent (inverse tangent) of the complex number (Y,
X) in radians.

   *Note Tan Intrinsic::, for the inverse function.


File: g77.info,  Node: BesJ0 Intrinsic,  Next: BesJ1 Intrinsic,  Prev: ATan2 Intrinsic,  Up: Table of Intrinsic Functions

BesJ0 Intrinsic
...............

     BesJ0(X)

BesJ0: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the first kind of order 0.  See
`bessel(3m)', on whose implementation the function depends.


File: g77.info,  Node: BesJ1 Intrinsic,  Next: BesJN Intrinsic,  Prev: BesJ0 Intrinsic,  Up: Table of Intrinsic Functions

BesJ1 Intrinsic
...............

     BesJ1(X)

BesJ1: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the first kind of order 1.  See
`bessel(3m)', on whose implementation the function depends.


File: g77.info,  Node: BesJN Intrinsic,  Next: BesY0 Intrinsic,  Prev: BesJ1 Intrinsic,  Up: Table of Intrinsic Functions

BesJN Intrinsic
...............

     BesJN(N, X)

BesJN: `REAL' function, the `KIND=' value of the type being that of
argument X.

N: `INTEGER'; scalar; INTENT(IN).

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the first kind of order N.  See
`bessel(3m)', on whose implementation the function depends.


File: g77.info,  Node: BesY0 Intrinsic,  Next: BesY1 Intrinsic,  Prev: BesJN Intrinsic,  Up: Table of Intrinsic Functions

BesY0 Intrinsic
...............

     BesY0(X)

BesY0: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the second kind of order 0.  See
`bessel(3m)', on whose implementation the function depends.


File: g77.info,  Node: BesY1 Intrinsic,  Next: BesYN Intrinsic,  Prev: BesY0 Intrinsic,  Up: Table of Intrinsic Functions

BesY1 Intrinsic
...............

     BesY1(X)

BesY1: `REAL' function, the `KIND=' value of the type being that of
argument X.

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the second kind of order 1.  See
`bessel(3m)', on whose implementation the function depends.


File: g77.info,  Node: BesYN Intrinsic,  Next: Bit_Size Intrinsic,  Prev: BesY1 Intrinsic,  Up: Table of Intrinsic Functions

BesYN Intrinsic
...............

     BesYN(N, X)

BesYN: `REAL' function, the `KIND=' value of the type being that of
argument X.

N: `INTEGER'; scalar; INTENT(IN).

X: `REAL'; scalar; INTENT(IN).

Intrinsic groups: `unix'.

Description:

   Calculates the Bessel function of the second kind of order N.  See
`bessel(3m)', on whose implementation the function depends.

