.TH NASM 1 "The Netwide Assembler Project"
.SH NAME
nasm \- the Netwide Assembler \- portable 80x86 assembler
.SH SYNOPSIS
.B nasm
[
.B \-f
format
] [
.B \-o
outfile
]
infile
.br
.B nasm \-h
.br
.B nasm \-r
.SH DESCRIPTION
The
.B nasm
command assembles the file
.I infile
and directs output to the file
.I outfile
if specified. If
.I outfile
is not specified,
.B nasm
will derive a default output file name from the name of its input
file, usually by appending `.o' or `.obj', or by removing all
extensions for a raw binary file. Failing that, the output file name
will be `nasm.out'.
.SS OPTIONS
.TP
.B \-h
Causes
.B nasm
to exit immediately, after giving a summary of its invocation
options, and listing all its supported output file formats.
.TP
.BI \-r
Causes
.B nasm
to exit immediately, after displaying its version number.
.TP
.BI \-f " format"
Specifies the output file format. Formats include
.IR bin ,
to produce flat-form binary files, and
.I aout
and
.I elf
to produce Linux a.out and ELF object files, respectively.
.TP
.BI \-o " outfile"
Specifies a precise name for the output file, overriding
.BR nasm 's
default means of determining it.
.PP
.RE
.SS SYNTAX
This man page does not fully describe the syntax of
.BR nasm 's
assembly language, but does give a summary of the differences from
other assemblers.
.PP
.I Registers
have no leading `%' sign, unlike
.BR gas ,
and floating-point stack registers are referred to as
.IR st0 ,
.IR st1 ,
and so on.
.PP
.I Floating-point instructions
may use either the single-operand form or the double. A
.I TO
keyword is provided; thus, one could either write
.PP
.ti +15n
fadd st0,st1
.br
.ti +15n
fadd st1,st0
.PP
or one could use the alternative single-operand forms
.PP
.ti +15n
fadd st1
.br
.ti +15n
fadd to st1
.PP
.I Uninitialised storage
is reserved using the
.IR RESB ,
.I RESW
and
.I RESD
pseudo-opcodes, each taking one parameter which gives the number of
bytes, words or doublewords to reserve.
.PP
.I Repetition
of data items is not done by the
.I DUP
keyword as seen in DOS assemblers, but by the use of the
.I TIMES
prefix, like this:
.PP
.ti +6n
.ta 9n
message:	times 3 db 'abc'
.br
.ti +15n
times 64-$+message db 0
.PP
which defines the string `abcabcabc', followed by the right number
of zero bytes to make the total length up to 64 bytes.
.PP
.I Symbol references
are always understood to be immediate (i.e. the address of the
symbol), unless square brackets are used, in which case the contents
of the memory location are used. Thus:
.PP
.ti +15n
mov ax,wordvar
.PP
loads AX with the address of the variable `wordvar', whereas
.PP
.ti +15n
mov ax,[wordvar]
.br
.ti +15n
mov ax,[wordvar+1]
.br
.ti +15n
mov ax,[es:wordvar+bx]
.PP
all refer to the
.I contents
of memory locations. The syntaxes
.PP
.ti +15n
mov ax,es:wordvar[bx]
.br
.ti +15n
es mov ax,wordvar[1]
.PP
are not legal at all, although the use of a segment register name as
an instruction prefix is valid, and can be used with instructions
such as
.I LODSB
which can't be overridden any other way (yet).
.PP
.I Constants
may be expressed numerically in most formats: a trailing H, Q or B
denotes hex, octal or binary respectively, and a leading `0x' or `$'
denotes hex as well. Leading zeros are not treated specially at all.
Character constants may be enclosed in single or double quotes;
there is no escape character. The ordering is little-endian
(reversed), so that the character constant
.I 'abcd'
denotes 0x64636261 and not 0x61626364.
.PP
.I Local labels
begin with a period, and their `locality' is granted by the
assembler prepending the name of the previous non-local symbol. Thus
declaring a label `.loop' after a label `label' has actually defined
a symbol called `label.loop'.
.SS DIRECTIVES
.I [SECTION name]
or
.I [SEGMENT name]
causes
.B nasm
to direct all following code to the named section. Section names
vary with output file format, although most formats support the
names
.IR .text ,
.I .data
and
.IR .bss .
(The exception is the
.I obj
format, in which all segments are user-definable.)
.PP
.I [ABSOLUTE address]
causes
.B nasm
to position its notional assembly point at an absolute address: so
no code or data may be generated, but you can use
.IR RESB ,
.I RESW
and
.I RESD
to move the assembly point further on, and you can define labels. So
this directive may be used to define data structures. When you have
finished doing absolute assembly, you must issue another
.I [SECTION]
directive to return to normal assembly.
.PP
.I [BITS 16]
or
.I [BITS 32]
switches the default processor mode for which
.B nasm
is generating code: it is equivalent to
.I USE16
or
.I USE32
in DOS assemblers.
.PP
.I [INCLUDE filename]
or
.I [INC filename]
includes another source file in the middle of the current one. So
far, only one level of inclusion is allowed.
.PP
.I [EXTERN symbol]
and
.I [GLOBAL symbol]
import and export symbol definitions, respectively, from and to
other modules. Note that the
.I GLOBAL
directive must appear before the definition of the symbol it refers
to.
.SS FORMAT-SPECIFIC DIRECTIVES
.I [ORG address]
is used by the
.I bin
flat-form binary output format, and specifies the address at which
the output code will eventually be loaded.
.PP
.I [GROUP grpname seg1 seg2...]
is used by the
.I obj
(Microsoft 16-bit) output format, and defines segment groups. This
format also uses
.IR [UPPERCASE] ,
which directs that all segment, group and symbol names output to the
object file should be in uppercase. Note that the actual assembly is
still case sensitive.
.SH BUGS
There is a reported seg-fault on some (Linux) systems with some large
source files.
.SH RESTRICTIONS
Numerous. There is no listing file or symbol map support, no macro
processor, and much, much more.
.SH SEE ALSO
.BR as "(" 1 "),"
.BR ld "(" 1 ")."
