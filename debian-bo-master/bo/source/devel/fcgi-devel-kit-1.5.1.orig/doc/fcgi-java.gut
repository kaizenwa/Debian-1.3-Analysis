Integrating FastCGI with Java
/fastcgi/words
fcgi-hd.gif
[FastCGI]
<center>Integrating FastCGI with Java</center>

<!--Copyright (c) 1996 Open Market, Inc.                                    -->
<!--See the file "LICENSE.TERMS" for information on usage and redistribution-->
<!--of this file, and for a DISCLAIMER OF ALL WARRANTIES.                   -->
<!-- $Id: fcgi-java.gut,v 1.2 1996/10/30 13:53:42 mbrown Exp $ -->

<P ALIGN=CENTER>
Steve Harris
<BR>
Open Market, Inc.
<BR>
<EM>7 May 1996</EM>
</P>

<h5 align=center>
Copyright &copy; 1996 Open Market, Inc.  245 First Street, Cambridge,
  MA 02142 U.S.A.<br>
Tel: 617-621-9500 Fax: 617-621-1703 URL:
  <a href="http://www.openmarket.com/">http://www.openmarket.com/</a><br>
</h5>
<hr>

<H3><A NAME = "S1"> 1. Introduction</A></H3>
Java is an object-oriented programming language developed by Sun
Microsystems.  The Java Depvelopers Kit (JDK), which contains the basic
Java class packages, is available from Sun in both source and binary
forms at Sun's
<a href="http://java.sun.com/java.sun.com/JDK-1.0/index.html">JavaSoft</a>
site.  This document assumes that you have some familiarity with the
basics of compiling and running Java programs. 
<p>
There are two kinds of applications built using Java.
<ul>
  <li> <i>Java Applets</i> are graphical components which are run off
       HTML pages via the <tt>&lt;APPLET&gt;</tt> HTML extention tag.<br><br>
       
  <li> <i>Java Applications (Apps) </i> are stand-alone programs
       that are run by invoking the Java interpreter directly. Like
       C programs, they have a <tt>main()</tt> method which the interpreter
       uses as an entry point.
</ul>
The initial emphasis on using Java for client side applets should not
obscure the fact that Java is a full strength programming language
which can be used to develop server side stand alone applications,
including CGI and now FastCGI applications.
<p>
The remainder of this document explains how to write and run FastCGI Java
applications. It also illustrates the conversion of a sample Java CGI program
to a FastCGI program.



<H3><A NAME = "S2"> 2. Writing FastCGI applications in Java</A></H3>

Writing a FastCGI application in Java is as simple as writing one in C.

<ol>
  <li> Import the <tt>FCGIInterface</tt> class.
  <li> Perform one-time initialization at the top of the
       <tt>main()</tt> method.
  <li> Create a new <tt>FCGIInterface</tt> object and send it an
       <tt>FCGIaccept()</tt> message in a loop.
  <li> Put the per-request application code inside that loop.
</ol>

On return from <tt>FCGIaccept()</tt> you can access the request's environment
variables using <tt>System.getProperty</tt> and perform request-related
I/O through the standard variables <tt>System.in</tt>,
<tt>System.out</tt>, and <tt>System.err</tt>.<p>

To illustrate these points, the kit includes <tt>examples/TinyCGI</tt>,
a CGI Java application, and <tt>examples/TinyFCGI</tt>, the FastCGI
version of TinyCGI.  These programs perform the same
functions as the C programs <tt>examples/tiny-cgi.c</tt> and
<tt>examples/tiny-fcgi.c</tt> that are used as examples in the
<A HREF="fcgi-devel-kit.htm#S3.1.1">FastCGI Developer's Kit document</A>.


<h4>A. TinyCGI</h4>
<PRE> 
class TinyCGI {	
	public static void main (String args[]) {		
		int count = 0;
                ++count;
		System.out.println("Content-type: text/html\n\n");
		System.out.println("&lt;html&gt;");
		System.out.println(
	                "&lt;head&gt;&lt;TITLE&gt;CGI-Hello&lt;/TITLE&gt;&lt;/head&gt;");
		System.out.println("&lt;body&gt;");
		System.out.println("&lt;H3&gt;CGI Hello&lt;/H3&gt;");
		System.out.println("request number " + count + 
					" running on host " 
				+ System.getProperty&lt;"SERVER_NAME"));
		System.out.println("&lt;/body&gt;");
		System.out.println("&lt;/html&gt;"); 
		}
	}

</PRE>
<h4>B. TinyFCGI</h4>
<PRE> 
import FCGIInterface;

class TinyFCGI {	
	public static void main (String args[]) {		
		int count = 0;
 		while(new FCGIInterface().FCGIaccept()>= 0) {
			count ++;
			System.out.println("Content-type: text/html\n\n");
			System.out.println("&lt;html&gt;");
			System.out.println(
			  "&lt;head&gt;&lt;TITLE&gt;FastCGI-Hello Java stdio&lt;/TITLE&gt;&lt;/head&gt;");
			System.out.println("&lt;body&gt;");
			System.out.println("&lt;H3&gt;FastCGI-Hello Java stdio&lt;/H3&gt;");
			System.out.println("request number " + count + 
					" running on host " 
				+ System.getProperty&lt;"SERVER_NAME"));
			System.out.println("&lt;/body&gt;");
			System.out.println("&lt;/html&gt;"); 
			}
		}
	}

</PRE>
<h4>C. Running these Examples</h4>

We assume that you have downloaded the JDK and the FastCGI Developer's
Kit, and that you have a Web server running that can access the
<tt>fcgi-devel-kit/examples</tt> directory. In all cases where we
specify paths, we are using relative paths within
<tt>fcgi-devel-kit</tt> or the JDK which will need to be enlarged to a
full path by the user.

<h5>Configuring</h5>
<ol>
  <li> Add your JDK's <tt>java/bin</tt> directory to your Unix <tt>PATH</tt>
       if it isn't there already.<br><br>
       
  <li> Add the directories <tt>fcgi-devel-kit/examples</tt> and
       <tt>fcgi-devel-kit/java/classes</tt> to your Java
       <tt>CLASSPATH</tt>.<br><br>
	
  <li>In your Open Market Secure WebServer configuration file,
      <tt>httpd.config</tt>, add the following two lines:<br><br>
       
       <tt>ExternalAppClass TinyFCGI -host </tt><i>hostName:portNum</i><br>
       <tt>Responder TinyFCGI fcgi-devel-kit/examples/TinyFCGI</tt><br><br>
              
       <ul>
       <li><i>hostName</i> is the name of your host machine.<br>
       <li><i>portNum</i> is the port that you've selected for
            communication between the Web server and the Java application.<br>
       </ul><br>

       On other servers you can use <tt>cgi-fcgi</tt> to get a
       similar effect.
       
  <li> Create a soft link <tt>examples/javexe</tt> to the
       <tt>java/bin</tt> directory in your JDK.
       This link is required only to run the
       CGI scripts <tt>examples/TinyCGI.cgi</tt> and
       <tt>examples/TinyFCGI.cgi</tt>, which use it to
       invoke the Java interpreter <tt>java/bin/java</tt>.
       It is not used by FastCGI applications.

   <li> You might have to modify <tt>examples/TinyFCGI.cgi</tt> to use a
	Unix shell for which your CLASSPATH is defined.
</ol>

<h5> Running </h5>

<ul>
  <li> To run TinyFCGI as FastCGI, you invoke the Java interpreter
       with the -D option, giving it the <tt>FCGI_PORT</tt> environment
       variable
       and the same <i>portNum</i> that was used in the Web server
       configuration. The command is:
       <br><br>
       <tt>java -DFCGI_PORT=portNum TinyFCGI</tt>
       <br><br>
       Then point your browser at <tt>fcgi-devel-kit/examples/TinyFCGI</tt>.
       Notice that each time you reload, the count increments.<br><br>
       
  <li> To run TinyCGI, point your browser at
       <tt>fcgi-devel-kit/examples/TinyCGI.cgi</tt> on your host machine.
       Notice that the count does not increment.<br><br>

  <li> Finally, you can run TinyFCGI as a straight CGI program by pointing
       your browser at <tt>fcgi-devel-kit/examples/TinyFCGI.cgi.</tt> The results
       are exactly the same as when you ran TinyCGI. Invoking a FastCGI
       program without an <tt>FCGI_PORT</tt> parameter tells the
       FastCGI interface
       to leave the normal CGI environment in place.
</ul>
<p>
Due to gaps in the Java interpreter's support for listening
sockets, Java FastCGI applications are currently limited to
being started as external applications.  They can't be started and
managed by the Web server because they are incapable of using
a listening socket that the Web server creates.



<H3><A NAME = "S3"> 3. Standard I/O and Application Libraries</A></H3>

As we have seen above, FastCGI for Java offers a redefinition
of standard I/O corresponding to the the <i>fcgi_stdio</i> functionality.
It also offers a set of directly callable I/O methods corresponding to
the <i>fcgiapp</i> C library. To understand where these methods occur
we need to look briefly at the FastCGI redefinition of standard I/O.<p>

Java defines standard I/O in the <i>java.System</i> class as follows:<p>

public static InputStream in = new BufferedInputStream(new FileInputStream(FileDescriptor.in), 128);<br>
public static PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.out), 128), true);<br>
public static PrintStream err = new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.err), 128), true);<p>

The File Descriptors <i>in</i>, <i>out</i>, <i>err</i> are constants set to 0, 1 and 2 respectively.<p>

The FastCGI interface redefines <i>java.System in, out</i>, and <i>err</i>
by replacing the File streams with Socket streams and inserting streams
which know how to manage the FastCGI protocol between the Socket streams
and the Buffered streams in the above definitions.
<p>
For those cases where the FCGI application needs to bypass the standard I/O
streams, it can directly access the methods of the FCGI input and output
streams which roughly correspond to the functions in the C <i>fcgiapp</i>
library. These streams can be accessed via the <i>request</i> class variable
in FCGIInterface. Each Request object has instance variables that refer to an
FCGIInputStream, and to two FCGIOutputStreams associated with that request.

<H3><A NAME = "S4"> 4. Environment Variables</A></H3>

Java does not use the  C <i/>environ<i/> list. Nor is there a <i>getenv</i>
command that reads system environment variables. This is intentional for
reasons of portability and security. Java has an internal dictionary of
properties which belongs to the System class. These System properties
are <i>name/value</i> associations that constitute the Java environment.
When a Java application starts up, it reads in a file with default properties.
As we have seen, additional System properties may be inserted by using
the -D <i>Java</i> command argument.<p>

For CGI, where the Java application is invoked from a .cgi script that,
in turn, invokes the Java interpreter, this script could read the environment
and pass the variables to the Java application either by writing a file
or by creating -D options on the fly. Both of these methods are somewhat
awkward.<p>

For FastCGI Java applications, the environment variables are obtained from
the FastCGI web server via <tt>FCGI_PARAMS</tt> records that are sent to the
application at the start of each request. The FastCGI interface stores the
original startup properties, combines these with the properties obtained
from the server, and puts the new set of properties in the System properties
dictionary. The only parameter that has to be specifically added at startup
time is the FCGI_PORT parameter for the Socket creation.  In the future, we
expect that even this parameter won't be needed, since its use is due to an
acknowledged rigidity in the JDK's implementation of sockets.<p>

<H3><A NAME = "S4"> 5. Further examples: EchoFCGI and Echo2FCGI</A></H3>

The next two examples illustrate the points made in the last two sections.
EchoFCGI and Echo2FCGI both echo user input and display the application's
environment variables. EchoFCGI reads the user input from System.in, while
Echo2FCGI reads the user input directly from the intermediate FastCGI input
stream.

<h4>A. EchoFCGI</h4>
<pre>
import FCGIInterface;
import FCGIGlobalDefs;
import java.io.*;

class EchoFCGI {
	
	public static void main (String args[]) {
		int status = 0;
 		while(new FCGIInterface().FCGIaccept()>= 0) {
		System.out.println("Content-type: text/html\n\n");
			System.out.println("&lt;html&gt;");
			System.out.println(
				"&lt;head%gt;&lt;TITLE&gt;FastCGI echo
                                      &lt;/TITLE&gt;&lt;/head&gt;");
			System.out.println("&lt;body&gt;");	
			System.out.println(
                                         "&lt;H2&gt;FastCGI echo&lt;/H2&gt;");
			System.out.println("&lt;H3&gt;STDIN&lt;/H3&gt;");
			for ( int c = 0; c != -1; ) {
				try {
					c = System.in.read();
				} catch(IOException e) {
					System.out.println(
					"&lt;br&gt;&lt;b&gt;SYSTEM EXCEPTION");
					Runtime rt = Runtime.getRuntime();
					rt.exit(status);
					}
				if (c != -1) {	
					System.out.print((char)c);
					}
				}
			System.out.println(
				"&lt;H3&gt;Environment Variables:&lt;/H3&gt;");
	
			System.getProperties().list(System.out);
			System.out.println("&lt;/body&gt;");
			System.out.println("&lt;/html&gt;");
	   		}
		}
  	}
</pre>
<h4>B. Echo2FCGI</h4>
<pre>
import FCGIInterface;
import FCGIGlobalDefs;
import FCGIInputStream;
import FCGIOutputStream;
import FCGIMessage;
import FCGIRequest;
import java.io.*;

class Echo2FCGI {

	public static void main (String args[]) {
		int status = 0;
                FCGIInterface intf = new FCGIInterface();
 		while(intf.FCGIaccept()>= 0) {
		System.out.println("Content-type: text/html\n\n");
			System.out.println("&lt;html&gt;");
			System.out.println(
				"&lt;head&gt;&lt;TITLE&gt;FastCGI echo
                                    &lt;/TITLE&gt;&lt;/head&gt;");
			System.out.println("&lt;body&gt;");			
			System.out.println("&lt;H2&gt;FastCGI echo&lt;/H2&gt;");
			System.out.println("&lt;H3&gt;STDIN:&lt;/H3"&gt;);
			for ( int c = 0; c != -1; ) {
				try {
					c = intf.request.inStream.read();
				} catch(IOException e) {
					System.out.println(
					"&lt;br&gt;&lt;b&gt;SYSTEM EXCEPTION");
					Runtime rt = Runtime.getRuntime();
					rt.exit(status);
					}
				if (c != -1) {	
					System.out.print((char)c);
					}
				}
			System.out.println(
				"&lt;H3&gt;Environment Variables:&lt;/H3&gt;");
	
			System.getProperties().list(System.out);
			System.out.println(&lt;"/body&gt;");
			System.out.println("&lt;/html&gt;");
	   		}
		}
  	}
</pre>
<h4>C. Running these Examples</h4>

<h5>Configuring</h5>

As with TinyFCGI, you need to configure the web server to recognize these
two FastCGI applications. Your configuration now looks like this:<p> 
<pre>
ExternalAppClass java1 -host hostname:portNum
Responder java1 fcgi-devel-kit/examples/TinyFCGI
ExternalAppClass java2 -host hostname:portNumA
Responder java2 fcgi-devel-kit/examples/EchoFCGI
ExternalAppClass java3 -host hostname:porNumB
Responder java3 fcgi-devel-kit/examples/Echo2FCGI
</pre>
<p>
Note that the application classes and port numbers are different for each
application.

<h5>Running</h5>

As with TinyFCGI, you need to run these programs with the -D option
using FCGI_PORT and the appropriate port number.

To get some data for standard input we have created two html pages with
forms that use a POST method. These are echo.html and echo2.html. You must
edit these .html files to expand the path to <i>fcgi-devel-kit/examples</i>
to a full path. Once the appropriate Java program is running, point your browser at the corresponding HTML page, enter some data and select the <i>go_find</i> button.


<H3><A NAME = "S6"> 6. FastCGI Java Classes</A></H3>

The Java FastCGI classes are included in both source and byte code format in
<i>fcgi-devel-kit/java/src</i> and :<i>fcgi-devel-kit/java/classes</i>
respectively. The following is a brief description of these classes:<p>

<dl>
<dt><i>FCGIInterface</i><dd> This class contains the FCGIaccept method called
     by the FastCGI user application. This method sets up the appropriate
     FastCGI environment for communication with the web server and manages
     FastCGI requests.<br>
     
 <dt><i>FCGIInputStream</i><dd> This input stream manages FastCGI
      internal buffers to ensure that the user gets all of the FastCGI
      messages associated with a request. It uses FCGIMessage objects
      to interpret these incoming messages.<br>
      
  <dt><i>FCGIOutputStream</i><dd> This output stream manages FastCGI
       internal buffers to send user data back to the web server
       and to notify the server of various FCGI protocol conditions.
       It uses FCGIMessage objects to format outgoing FastCGI messages.<br>
      
<dt><i>FCGIMessage</i><dd> This is the only class that understands the
     actual structure of the FastCGI messages. It interprets incoming
     FastCGI records and constructs outgoing ones..<br>
     
<dt><i>FCGIRequest</i><dd>This class currently contains data fields
     used by FastCGI to manage user requests.  In a multi-threaded
     version of FastCGI, the role of this class will be expanded.<br>

<dt><i>FCGIGlobalDefs</i><dd>This class contains definitions of FastCGI
     constants.
</dl>
<HR>
<ADDRESS><A HREF="mailto:harris@openmarket.com">Steve Harris // harris@openmarket.com</A></ADDRESS>
