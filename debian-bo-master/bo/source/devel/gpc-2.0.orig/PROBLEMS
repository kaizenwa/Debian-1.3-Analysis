GPC bug list

Last modified: Sat Sep 21 17:08:14 1996
By: Jan-Jaap <j.j.vanderheijde@student.utwente.nl>

The GPC compiler does not yet implement the whole ISO 7185 Pascal
standard, so please take this into account when you consider
using this for any purpose.

See the file version.c to find out the version number of this GPC
(or run gpc -v)

See also section "GPC Bugs" in the Info documentation.

Problems in this GPC version:

OPEN 001 writeln() cannot handle __longlong__, __byte__ etc.


CLOSED   All files are opened in TEXT mode (djggp, possibly EMX, win32)
         rts-file.c -> _p_open()


OPEN 003 Only one directive ('asmname', 'attribute' etc.) per function
         supported.


OPEN 004 All units must be in the current directory.


OPEN 005 This faulty Pascal fragment crashes the compiler:

         program foo;
         var f: file of ;   { <-- error here }
         begin end.


OPEN 006 Signal handling works only for *BSD unix systems.

OPEN 007 (not verified since 2.6.3)
	  High optimization levels do not work properly on the Alpha.
	  Some conformance tests FAIL when compiled with -O6 flag,
	  which means that the compiler generates invalid code. Don't
	  use this flag in the alpha before the problem gets fixed.
	  It might have something to do with automatic inlining, but
	  I have not yet looked at this. -O flag should be ok.
	  (Also take care when using explicit inline functions)

CLOSED    Functions returning string schema types do not work
	  (they are called about three times where they should be called
	   once)

OPEN 009  For some reason the pascal main program does not get lineno
	  stabs -> It is hard to debug it with gdb...

OPEN 010  The modules export everything, not just the stuff in the
	  export interfaces. However, the unexported variables and functions
	  are invisible to modules in other files.

OPEN 011  type checking is mostly what C does, not what Pascal requires,
	  so GPC does not yet implement a strongly typed language.
	  Although correct programs compile, incorrect ones compile also.

OPEN 012  run time errors are not checked.

OPEN 013  the inline set operations have some problems
	  with operations on two sets if the sets do not contain
	  equally many segments.

	  In addition, the set code generated in the alpha causes
	  runtime runtime errors in the generated code.

OPEN 014  (texinfo files under construction)
	  No GPC texinfo file exists yet. See GPC.GUIDE instead.

OPEN 015  Conformant arrays don't yet work (in general).
	  Until they do, this is a LEVEL-0 compiler.

Inconveniences:

	- NEW & DISPOSE optional tag field arguments are ignored
	  (warning given, code works)

	- GDB does not yet understand pascal sets, files or subranges.
	  Now GDB allows you to debug these things, even though it does
	  not yet understand some stabs.

	- PACKED does not pack. (implementation dependent,
	  warning given, code works)

	- Files of integer subranges that would fit in a byte do not;
	  instead they are handled as files of integer.
	  This is especially annoying with "file of 0..255".

Note for debugging:

	- Forward referencing pointers generate DBX style debugging
	  symbols by outputting the .stabs as an unknown pointer
	  and later it just outputs the same .stabs again, but this
	  time it also tells what type the pointer points to.
	  This seems to work for gdb. As of this writing I have
	  not checked what happens with SDB type debugging info.
	  It might be that the pointer is left to be a (void *)
	  pointer, so you have to cast it in order to output
	  the object the pointer points to.

	  Also, I have not tried any other debugger than gdb.
	  If you do, please let me know what happens.

	  I think that GDB does not yet support the kind of .stabs
	  that should be used to do this correctly:
	    .stabs ":t<anumber>=<bnumber>", <whatever>
	  where ANUMBER is the unknown pointer type referenced
	  earlier, and the BNUMBER is the type which ANUMBER
	  actually is. This construct is not required in C.

	- When debugging, please note that the Initial Letter
	  In Each Identifier Is In Upper Case And The Rest
	  Are In Lower Case. If  you wish to call C-routines
	  declare them with the "C" directive, as follows:

		procedure FooBAR(i:integer);c;

	  This makes the external name to be "_foobar"
	  (replace "_" with you machine prefix.)

		Procedure FooBAR(i:Integer); External;

	  Uses external name "_Foobar".

	  It is done like this to reduce name clashes	
	  with libc.a and other possible libraries.

	  All visible GPC runtime system library routines are
	  named "_p_....".

	  The main program gets a name "program_Foo" instead of
	  just "Foo".

------------
