Tue Nov 12 13:17:03 1996 <j.j.vanderheijden@student.utwente.nl>

Changes for GCC version 2.7.2.1 to support the cygwin32 platform, beta16.

Changes in files you can reconstruct with Bison, etags, makeinfo, and
TeX have been omitted.  Some of these files are updated just by
building the compiler.  You can update rest of these files by
executing this command

   make TAGS info dvi -f Makefile.in

in the directory of GCC sources, provided the necessary tools
(etags, makeinfo, TeX and texi2dvi) are installed.

Before applying these diffs, go to the directory gcc-2.7.2.1 and use the
command

    patch -p1

feeding it the following diffs as input.

diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/c-common.c gcc-2.7.2.1/c-common.c
*** gcc-2.7.2.1.orig/c-common.c	Thu Oct 19 23:18:29 1995
--- gcc-2.7.2.1/c-common.c	Tue Nov 12 13:10:08 1996
***************
*** 655,658 ****
--- 655,751 ----
      }
  }
+ 
+ /* CYGNUS LOCAL dje prefix attributes */
+ /* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two
+    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).
+ 
+    The head of the declspec list is stored in DECLSPECS.
+    The head of the attribute list is stored in PREFIX_ATTRIBUTES.
+ 
+    Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of
+    the list elements.  We drop the containing TREE_LIST nodes and link the
+    resulting attributes together the way decl_attributes expects them.  */
+ 
+ void
+ split_specs_attrs (specs_attrs, declspecs, prefix_attributes)
+      tree specs_attrs;
+      tree *declspecs, *prefix_attributes;
+ {
+   tree t, s, a, next, specs, attrs;
+ 
+   /* This can happen in c++ (eg: decl: typespec initdecls ';').  */
+   if (specs_attrs != NULL_TREE
+       && TREE_CODE (specs_attrs) != TREE_LIST)
+     {
+       *declspecs = specs_attrs;
+       *prefix_attributes = NULL_TREE;
+       return;
+     }
+ 
+   /* Remember to keep the lists in the same order, element-wise.  */
+ 
+   specs = s = NULL_TREE;
+   attrs = a = NULL_TREE;
+   for (t = specs_attrs; t; t = next)
+     {
+       next = TREE_CHAIN (t);
+       /* Declspecs have a non-NULL TREE_VALUE.  */
+       if (TREE_VALUE (t) != NULL_TREE)
+ 	{
+ 	  if (specs == NULL_TREE)
+ 	    specs = s = t;
+ 	  else
+ 	    {
+ 	      TREE_CHAIN (s) = t;
+ 	      s = t;
+ 	    }
+ 	}
+       else
+ 	{
+ 	  if (attrs == NULL_TREE)
+ 	    attrs = a = TREE_PURPOSE (t);
+ 	  else
+ 	    {
+ 	      TREE_CHAIN (a) = TREE_PURPOSE (t);
+ 	      a = TREE_PURPOSE (t);
+ 	    }
+ 	}
+     }
+ 
+   /* Terminate the lists.  */
+   if (s != NULL_TREE)
+     TREE_CHAIN (s) = NULL_TREE;
+   if (a != NULL_TREE)
+     TREE_CHAIN (a) = NULL_TREE;
+ 
+   /* All done.  */
+   *declspecs = specs;
+   *prefix_attributes = attrs;
+ }
+ 
+ /* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.
+    This function is used by the parser when a rule will accept attributes
+    in a particular position, but we don't want to support that just yet.
+ 
+    A warning is issued for every ignored attribute.  */
+ 
+ tree
+ strip_attrs (specs_attrs)
+      tree specs_attrs;
+ {
+   tree specs, attrs;
+ 
+   split_specs_attrs (specs_attrs, &specs, &attrs);
+ 
+   while (attrs)
+     {
+       warning ("`%s' attribute ignored",
+ 	       IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));
+       attrs = TREE_CHAIN (attrs);
+     }
+ 
+   return specs;
+ }
+ /* END CYGNUS LOCAL */
  
  /* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/c-decl.c gcc-2.7.2.1/c-decl.c
*** gcc-2.7.2.1.orig/c-decl.c	Fri Oct 27 09:44:43 1995
--- gcc-2.7.2.1/c-decl.c	Tue Nov 12 13:10:09 1996
***************
*** 3352,3359 ****
    int found_tag = 0;
    register tree link;
  
    pending_invalid_xref = 0;
  
!   for (link = declspecs; link; link = TREE_CHAIN (link))
      {
        register tree value = TREE_VALUE (link);
--- 3352,3366 ----
    int found_tag = 0;
    register tree link;
+   tree specs, attrs;
  
    pending_invalid_xref = 0;
  
!   /* CYGNUS LOCAL dje prefix attributes */
!   /* Remove the attributes from declspecs, since they will confuse the
!      following code.  */
!   split_specs_attrs (declspecs, &specs, &attrs);
!   /* END CYGNUS LOCAL */
! 
!   for (link = specs; link; link = TREE_CHAIN (link))
      {
        register tree value = TREE_VALUE (link);
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/c-parse.in gcc-2.7.2.1/c-parse.in
*** gcc-2.7.2.1.orig/c-parse.in	Sat Sep 23 00:08:07 1995
--- gcc-2.7.2.1/c-parse.in	Tue Nov 12 13:10:09 1996
***************
*** 29,36 ****
  
  ifobjc
! %expect 48
  end ifobjc
  ifc
! %expect 34
  
  /* These are the 23 conflicts you should get in parse.output;
--- 29,38 ----
  
  ifobjc
! /* CYGNUS LOCAL dje prefix attributes */
! %expect 62 /* - CYGNUS LOCAL comment these out */
  end ifobjc
  ifc
! /* CYGNUS LOCAL dje prefix attributes */
! %expect 45 /* - CYGNUS LOCAL comment these out */
  
  /* These are the 23 conflicts you should get in parse.output;
***************
*** 186,189 ****
--- 188,195 ----
  %type <ttype> typed_typespecs reserved_typespecquals
  %type <ttype> declmods typespec typespecqual_reserved
+ /* CYGNUS LOCAL dje prefix attributes */
+ %type <ttype> typed_declspecs_no_prefix_attr reserved_declspecs_no_prefix_attr
+ %type <ttype> declmods_no_prefix_attr
+ /* END CYGNUS LOCAL */
  %type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual
  %type <ttype> initdecls notype_initdecls initdcl notype_initdcl
***************
*** 239,243 ****
  
  /* List of types and structure classes of the current declaration.  */
! static tree current_declspecs;
  static tree prefix_attributes = NULL_TREE;
  
--- 245,250 ----
  
  /* List of types and structure classes of the current declaration.  */
! /* CYGNUS LOCAL dje prefix attributes */
! static tree current_declspecs = NULL_TREE;
  static tree prefix_attributes = NULL_TREE;
  
***************
*** 343,351 ****
  fndef:
  	  typed_declspecs setspecs declarator
! 		{ if (! start_function ($1, $3, prefix_attributes,
! 					NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  xdecls
  		{ store_parm_decls (); }
  	  compstmt_or_error
--- 350,359 ----
  fndef:
  	  typed_declspecs setspecs declarator
! 		/* CYGNUS LOCAL dje prefix attributes */
! 		{ if (! start_function (current_declspecs, $3,
! 					prefix_attributes, NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  old_style_parm_decls /* CYGNUS LOCAL dje prefix attributes */
  		{ store_parm_decls (); }
  	  compstmt_or_error
***************
*** 361,369 ****
  		  resume_momentary ($2); }
  	| declmods setspecs notype_declarator
! 		{ if (! start_function ($1, $3, prefix_attributes,
! 					NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  xdecls
  		{ store_parm_decls (); }
  	  compstmt_or_error
--- 369,378 ----
  		  resume_momentary ($2); }
  	| declmods setspecs notype_declarator
! 		/* CYGNUS LOCAL dje prefix attributes */
! 		{ if (! start_function (current_declspecs, $3,
! 					prefix_attributes, NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  old_style_parm_decls /* CYGNUS LOCAL dje prefix attributes */
  		{ store_parm_decls (); }
  	  compstmt_or_error
***************
*** 380,387 ****
  	| setspecs notype_declarator
  		{ if (! start_function (NULL_TREE, $2,
! 					prefix_attributes, NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  xdecls
  		{ store_parm_decls (); }
  	  compstmt_or_error
--- 389,397 ----
  	| setspecs notype_declarator
  		{ if (! start_function (NULL_TREE, $2,
! 					/* CYGNUS LOCAL dje prefix attributes */
!  					prefix_attributes, NULL_TREE, 0))
  		    YYERROR1;
  		  reinit_parse_for_function (); }
! 	  old_style_parm_decls /* CYGNUS LOCAL dje prefix attributes */
  		{ store_parm_decls (); }
  	  compstmt_or_error
***************
*** 862,866 ****
  end ifobjc
  
! xdecls:
  	/* empty */
  	| datadecls
--- 872,876 ----
  end ifobjc
  
! old_style_parm_decls: /* CYGNUS LOCAL dje prefix attributes */
  	/* empty */
  	| datadecls
***************
*** 887,905 ****
  	;
  
  datadecl:
! 	typed_declspecs setspecs initdecls ';'
  		{ current_declspecs = TREE_VALUE (declspec_stack);
  		  prefix_attributes = TREE_PURPOSE (declspec_stack);
  		  declspec_stack = TREE_CHAIN (declspec_stack);
  		  resume_momentary ($2); }
! 	| declmods setspecs notype_initdecls ';'
  		{ current_declspecs = TREE_VALUE (declspec_stack);	
  		  prefix_attributes = TREE_PURPOSE (declspec_stack);
  		  declspec_stack = TREE_CHAIN (declspec_stack);
  		  resume_momentary ($2); }
! 	| typed_declspecs ';'
  		{ shadow_tag_warned ($1, 1);
  		  pedwarn ("empty declaration"); }
! 	| declmods ';'
  		{ pedwarn ("empty declaration"); }
  	;
--- 897,925 ----
  	;
  
+ /* CYGNUS LOCAL dje prefix attributes */
+ /* We don't allow prefix attributes here because they cause reduce/reduce
+    conflicts: we can't know whether we're parsing a function decl with
+    attribute suffix, or function defn with attribute prefix on first old
+    style parm.  */
+ /* END CYGNUS LOCAL */
  datadecl:
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	typed_declspecs_no_prefix_attr setspecs initdecls ';'
  		{ current_declspecs = TREE_VALUE (declspec_stack);
  		  prefix_attributes = TREE_PURPOSE (declspec_stack);
  		  declspec_stack = TREE_CHAIN (declspec_stack);
  		  resume_momentary ($2); }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	| declmods_no_prefix_attr setspecs notype_initdecls ';'
  		{ current_declspecs = TREE_VALUE (declspec_stack);	
  		  prefix_attributes = TREE_PURPOSE (declspec_stack);
  		  declspec_stack = TREE_CHAIN (declspec_stack);
  		  resume_momentary ($2); }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	| typed_declspecs_no_prefix_attr ';'
  		{ shadow_tag_warned ($1, 1);
  		  pedwarn ("empty declaration"); }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	| declmods_no_prefix_attr ';'
  		{ pedwarn ("empty declaration"); }
  	;
***************
*** 931,938 ****
  					      current_declspecs,
  					      declspec_stack);
! 		  current_declspecs = $<ttype>0; 
! 		  prefix_attributes = NULL_TREE; }
  	;
  
  setattrs: /* empty */
  		{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }
--- 951,962 ----
  					      current_declspecs,
  					      declspec_stack);
! 		  /* CYGNUS LOCAL dje prefix attributes */
! 		  split_specs_attrs ($<ttype>0,
! 				     &current_declspecs, &prefix_attributes); }
  	;
  
+ /* CYGNUS LOCAL dje prefix attributes */
+ /* ??? Yuck.  See after_type_declarator.  */
+ /* END CYGNUS LOCAL */
  setattrs: /* empty */
  		{ prefix_attributes = chainon (prefix_attributes, $<ttype>0); }
***************
*** 968,972 ****
  /* Declspecs which contain at least one type specifier or typedef name.
     (Just `const' or `volatile' is not enough.)
!    A typedef'd name following these is taken as a name to be declared.  */
  
  typed_declspecs:
--- 992,998 ----
  /* Declspecs which contain at least one type specifier or typedef name.
     (Just `const' or `volatile' is not enough.)
!    A typedef'd name following these is taken as a name to be declared.
!    Declspecs have a non-NULL TREE_VALUE, attributes do not.  */
! /* CYGNUS LOCAL dje prefix attributes */
  
  typed_declspecs:
***************
*** 986,996 ****
  			     IDENTIFIER_POINTER ($2));
  		  $$ = tree_cons (NULL_TREE, $2, $1); }
  	;
  
! /* List of just storage classes and type modifiers.
     A declaration can start with just this, but then it cannot be used
!    to redeclare a typedef-name.  */
  
  declmods:
  	  TYPE_QUAL
  		{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);
--- 1012,1061 ----
  			     IDENTIFIER_POINTER ($2));
  		  $$ = tree_cons (NULL_TREE, $2, $1); }
+ 	/* CYGNUS LOCAL dje prefix attributes */
+ 	| reserved_declspecs attributes
+ 		{ $$ = tree_cons ($2, NULL_TREE, $1); }
+ 	/* END CYGNUS LOCAL */
  	;
  
! /* CYGNUS LOCAL dje prefix attributes */
! typed_declspecs_no_prefix_attr:
! 	  typespec reserved_declspecs_no_prefix_attr
! 		{ $$ = tree_cons (NULL_TREE, $1, $2); }
! 	| declmods_no_prefix_attr typespec reserved_declspecs_no_prefix_attr
! 		{ $$ = chainon ($3, tree_cons (NULL_TREE, $2, $1)); }
! 	;
! 
! reserved_declspecs_no_prefix_attr:
! 	  /* empty */
! 		{ $$ = NULL_TREE; }
! 	| reserved_declspecs_no_prefix_attr typespecqual_reserved
! 		{ $$ = tree_cons (NULL_TREE, $2, $1); }
! 	| reserved_declspecs_no_prefix_attr SCSPEC
! 		{ if (extra_warnings)
! 		    warning ("`%s' is not at beginning of declaration",
! 			     IDENTIFIER_POINTER ($2));
! 		  $$ = tree_cons (NULL_TREE, $2, $1); }
! 	;
! 
! /* List of just storage classes, type modifiers, and prefix attributes.
     A declaration can start with just this, but then it cannot be used
!    to redeclare a typedef-name.
!    Declspecs have a non-NULL TREE_VALUE, attributes do not.  */
! /* CYGNUS LOCAL dje prefix attributes */
  
  declmods:
+ 	/* CYGNUS LOCAL dje prefix attributes */
+ 	  declmods_no_prefix_attr
+ 		{ $$ = $1; }
+ 	| attributes
+ 		{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE); }
+ 	| declmods declmods_no_prefix_attr
+ 		{ $$ = chainon ($2, $1); }
+ 	| declmods attributes
+ 		{ $$ = tree_cons ($2, NULL_TREE, $1); }
+ 	;
+ 
+ declmods_no_prefix_attr:
+ 	/* END CYGNUS LOCAL */
  	  TYPE_QUAL
  		{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);
***************
*** 998,1005 ****
  	| SCSPEC
  		{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }
! 	| declmods TYPE_QUAL
  		{ $$ = tree_cons (NULL_TREE, $2, $1);
  		  TREE_STATIC ($$) = 1; }
! 	| declmods SCSPEC
  		{ if (extra_warnings && TREE_STATIC ($1))
  		    warning ("`%s' is not at beginning of declaration",
--- 1063,1072 ----
  	| SCSPEC
  		{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	| declmods_no_prefix_attr TYPE_QUAL
  		{ $$ = tree_cons (NULL_TREE, $2, $1);
  		  TREE_STATIC ($$) = 1; }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	| declmods_no_prefix_attr SCSPEC
  		{ if (extra_warnings && TREE_STATIC ($1))
  		    warning ("`%s' is not at beginning of declaration",
***************
*** 1099,1102 ****
--- 1166,1172 ----
  /* Note how the declaration of the variable is in effect while its init is parsed! */
  		{ finish_init ();
+ 		  /* CYGNUS LOCAL dje prefix attributes */
+ 		  /* ??? Why is this here?  */
+ 		  /* END CYGNUS LOCAL */
  		  decl_attributes ($<ttype>5, $3, prefix_attributes);
  		  finish_decl ($<ttype>5, $6, $2); }
***************
*** 1233,1237 ****
  		    }
  		  reinit_parse_for_function (); }
! 	   xdecls
  		{ store_parm_decls (); }
  /* This used to use compstmt_or_error.
--- 1303,1307 ----
  		    }
  		  reinit_parse_for_function (); }
! 	   old_style_parm_decls /* CYGNUS LOCAL dje prefix attributes */
  		{ store_parm_decls (); }
  /* This used to use compstmt_or_error.
***************
*** 1256,1260 ****
  		    }
  		  reinit_parse_for_function (); }
! 	  xdecls
  		{ store_parm_decls (); }
  /* This used to use compstmt_or_error.
--- 1326,1330 ----
  		    }
  		  reinit_parse_for_function (); }
! 	  old_style_parm_decls /* CYGNUS LOCAL dje prefix attributes */
  		{ store_parm_decls (); }
  /* This used to use compstmt_or_error.
***************
*** 1293,1298 ****
--- 1363,1375 ----
  	| '*' type_quals after_type_declarator  %prec UNARY
  		{ $$ = make_pointer_declarator ($2, $3); }
+ 	/* CYGNUS LOCAL dje prefix attributes */
+ 	/* ??? Yuck.  setattrs is a quick hack.  We can't use
+ 	   prefix_attributes because $1 only applies to this
+ 	   declarator.  We assume setspecs has already been done.
+ 	   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple
+ 	   attributes could be recognized here or in `attributes').  */
  	| attributes setattrs after_type_declarator
  		{ $$ = $3; }
+ 	/* END CYGNUS LOCAL */
  	| TYPENAME
  ifobjc
***************
*** 1318,1323 ****
--- 1395,1407 ----
  	| '*' type_quals parm_declarator  %prec UNARY
  		{ $$ = make_pointer_declarator ($2, $3); }
+ 	/* CYGNUS LOCAL dje prefix attributes */
+ 	/* ??? Yuck.  setattrs is a quick hack.  We can't use
+ 	   prefix_attributes because $1 only applies to this
+ 	   declarator.  We assume setspecs has already been done.
+ 	   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple
+ 	   attributes could be recognized here or in `attributes').  */
  	| attributes setattrs parm_declarator
  		{ $$ = $3; }
+ 	/* END CYGNUS LOCAL */
  	| TYPENAME
  	;
***************
*** 1340,1346 ****
  	| notype_declarator '[' ']'  %prec '.'
  		{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }
  	| attributes setattrs notype_declarator
  		{ $$ = $3; }
! 	| IDENTIFIER
  	;
  
--- 1424,1437 ----
  	| notype_declarator '[' ']'  %prec '.'
  		{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }
+ 	/* CYGNUS LOCAL dje prefix attributes */
+ 	/* ??? Yuck.  setattrs is a quick hack.  We can't use
+ 	   prefix_attributes because $1 only applies to this
+ 	   declarator.  We assume setspecs has already been done.
+ 	   setattrs also avoids 5 reduce/reduce conflicts (otherwise multiple
+ 	   attributes could be recognized here or in `attributes').  */
  	| attributes setattrs notype_declarator
  		{ $$ = $3; }
! 	/* END CYGNUS LOCAL */
!  	| IDENTIFIER
  	;
  
***************
*** 1554,1559 ****
  	| '[' ']'  %prec '.'
  		{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }
! 	| attributes setattrs absdcl1
! 		{ $$ = $3; }
  	;
  
--- 1645,1651 ----
  	| '[' ']'  %prec '.'
  		{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }
! 	/* CYGNUS LOCAL dje prefix attributes */
! 	/* ??? It appears we have to support attributes here, however
! 	   using prefix_attributes is wrong.  */
  	;
  
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/dbxcoff.h gcc-2.7.2.1/config/dbxcoff.h
*** gcc-2.7.2.1.orig/config/dbxcoff.h	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/dbxcoff.h	Tue Nov 12 13:10:09 1996
***************
*** 0 ****
--- 1,83 ----
+ /* Definitions needed when using stabs embedded in COFF sections.
+    Copyright (C) 1996 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+ 
+ /* This file may be included by any COFF target which wishes to
+    support -gstabs generating stabs in sections, as produced by gas
+    and understood by gdb.  */
+ 
+ /* Output DBX (stabs) debugging information if doing -gstabs.  */
+ 
+ #undef DBX_DEBUGGING_INFO
+ #define DBX_DEBUGGING_INFO
+ 
+ /* Generate SDB debugging information by default. */
+ 
+ #ifndef PREFERRED_DEBUGGING_TYPE
+ #define PREFERRED_DEBUGGING_TYPE SDB_DEBUG
+ #endif
+ 
+ /* Be function-relative for block and source line stab directives.  */
+ 
+ #undef DBX_BLOCKS_FUNCTION_RELATIVE
+ #define DBX_BLOCKS_FUNCTION_RELATIVE 1
+ 
+ /* but, to make this work, functions must appear prior to line info.  */
+ 
+ #undef DBX_FUNCTION_FIRST
+ #define DBX_FUNCTION_FIRST
+ 
+ /* Generate a blank trailing N_SO to mark the end of the .o file, since
+    we can't depend upon the linker to mark .o file boundaries with
+    embedded stabs.  */
+ 
+ #undef DBX_OUTPUT_MAIN_SOURCE_FILE_END
+ #define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)			\
+   fprintf (FILE,							\
+ 	   "\t.text\n\t.stabs \"\",%d,0,0,Letext\nLetext:\n", N_SO)
+ 
+ /* Like block addresses, stabs line numbers are relative to the
+    current function.  */
+ 
+ #undef ASM_OUTPUT_SOURCE_LINE
+ #define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)			\
+ { if (write_symbols == SDB_DEBUG) {				\
+     fprintf ((FILE), "\t.ln\t%d\n",				\
+ 	     ((sdb_begin_function_line > -1)			\
+ 	      ? (LINE) - sdb_begin_function_line : 1));		\
+   } else if (write_symbols == DBX_DEBUG) {			\
+     static int sym_lineno = 1;					\
+     fprintf (FILE, ".stabn 68,0,%d,.LM%d-",			\
+ 	     LINE, sym_lineno);					\
+     assemble_name (FILE,					\
+ 		   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \
+     fprintf (FILE, "\n.LM%d:\n", sym_lineno);			\
+     sym_lineno += 1;						\
+   } }
+ 
+ /* When generating stabs debugging, use N_BINCL entries.  */
+ 
+ #undef DBX_USE_BINCL
+ #define DBX_USE_BINCL
+ 
+ /* There is no limit to the length of stabs strings.  */
+ 
+ #ifndef DBX_CONTIN_LENGTH
+ #define DBX_CONTIN_LENGTH 0
+ #endif
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/cygwin32.asm gcc-2.7.2.1/config/i386/cygwin32.asm
*** gcc-2.7.2.1.orig/config/i386/cygwin32.asm	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/i386/cygwin32.asm	Tue Nov 12 13:10:09 1996
***************
*** 0 ****
--- 1,32 ----
+ /* stuff needed for libgcc1 on win32. */
+ 
+ #ifdef L_chkstk
+ 
+ 	.global ___chkstk
+ 	.global	__alloca
+ ___chkstk:
+ __alloca:
+ 	pushl  %ecx		/* save temp */
+ 	movl   %esp,%ecx	/* get sp */
+ 	addl   $0x8,%ecx	/* and point to return addr */
+ 
+ probe: 	cmpl   $0x1000,%eax	/* > 4k ?*/
+ 	jb    done		
+ 
+ 	subl   $0x1000,%ecx  		/* yes, move pointer down 4k*/
+ 	orl    $0x0,(%ecx)   		/* probe there */
+ 	subl   $0x1000,%eax  	 	/* decrement count */
+ 	jmp    probe           	 	/* and do it again */
+ 
+ done: 	subl   %eax,%ecx	   
+ 	orl    $0x0,(%ecx)	/* less that 4k, just peek here */
+ 
+ 	movl   %esp,%eax
+ 	movl   %ecx,%esp	/* decrement stack */
+ 
+ 	movl   (%eax),%ecx	/* recover saved temp */
+ 	movl   4(%eax),%eax	/* get return address */
+ 	jmp    *%eax	
+ 
+ 
+ #endif
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/cygwin32.h gcc-2.7.2.1/config/i386/cygwin32.h
*** gcc-2.7.2.1.orig/config/i386/cygwin32.h	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/i386/cygwin32.h	Tue Nov 12 13:10:10 1996
***************
*** 0 ****
--- 1,178 ----
+ /* Operating system specific defines to be used when targeting GCC for
+    hosting on Windows NT 3.x, using a unix style C library and tools.
+ 
+    This is different to the winnt.h file, since that is used
+    to build GCC for use with a windows style library and tool
+    set, winnt.h uses the Microsoft tools to do that.
+ 
+    Copyright (C) 1995 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA. */
+ 
+ 
+ #define YES_UNDERSCORES
+ 
+ #define DBX_DEBUGGING_INFO 
+ #define SDB_DEBUGGING_INFO 
+ #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+ 
+ #include "i386/gas.h"
+ #include "dbxcoff.h"
+ 
+ #ifdef CPP_PREDEFINES
+ #undef CPP_PREDEFINES
+ #endif
+ 
+ #define CPP_PREDEFINES "-Di386 -D_WIN32 \
+   -DPOSIX -D__CYGWIN32__ -DWINNT  -D_X86_=1 -D__STDC__=1\
+   -D__stdcall=__attribute__((__stdcall__)) \
+   -D__cdecl=__attribute__((__cdecl__)) \
+   -Asystem(winnt) -Acpu(i386) -Amachine(i386)"
+ 
+ /* We have to dynamic link to get to the system dlls,
+    and I've put all of libc and libm and the unix stuff into
+    cygwin.dll, the import library is called 'libcygwin.a' */
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "-lcygwin"
+ 
+ /* No need for libgcc, it's in the shared library. */
+ #undef LIBGCC_SPEC
+ #define LIBGCC_SPEC ""
+ 
+ #undef STARTFILE_SPEC
+ #define STARTFILE_SPEC "%{!:crt0%O%s}"
+ 
+ #define SIZE_TYPE "unsigned int"
+ #define PTRDIFF_TYPE "int"
+ #define WCHAR_UNSIGNED 1
+ #define WCHAR_TYPE_SIZE 16
+ #define WCHAR_TYPE "short unsigned int"
+ #undef LONG_DOUBLE_TYPE_SIZE
+ #define LONG_DOUBLE_TYPE_SIZE 64
+ #define HAVE_ATEXIT 1
+ 
+ #undef EXTRA_SECTIONS
+ #define EXTRA_SECTIONS in_ctor, in_dtor
+ 
+ #undef EXTRA_SECTION_FUNCTIONS
+ #define EXTRA_SECTION_FUNCTIONS					\
+   CTOR_SECTION_FUNCTION						\
+   DTOR_SECTION_FUNCTION
+ 
+ #define CTOR_SECTION_FUNCTION					\
+ void								\
+ ctor_section ()							\
+ {								\
+   if (in_section != in_ctor)					\
+     {								\
+       fprintf (asm_out_file, "\t.section .ctor\n");		\
+       in_section = in_ctor;					\
+     }								\
+ }
+ 
+ #define DTOR_SECTION_FUNCTION					\
+ void								\
+ dtor_section ()							\
+ {								\
+   if (in_section != in_dtor)					\
+     {								\
+       fprintf (asm_out_file, "\t.section .dtor\n");		\
+       in_section = in_dtor;					\
+     }								\
+ }
+ 
+ #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)	\
+   do {						\
+     ctor_section ();				\
+     fprintf (FILE, "%s\t", ASM_LONG);		\
+     assemble_name (FILE, NAME);			\
+     fprintf (FILE, "\n");			\
+   } while (0)
+ 
+ #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       	\
+   do {						\
+     dtor_section ();                   		\
+     fprintf (FILE, "%s\t", ASM_LONG);		\
+     assemble_name (FILE, NAME);              	\
+     fprintf (FILE, "\n");			\
+   } while (0)
+ 
+ /* Define this macro if references to a symbol must be treated
+    differently depending on something about the variable or
+    function named by the symbol (such as what section it is in).
+ 
+    On i386, if using PIC, mark a SYMBOL_REF for a non-global symbol
+    so that we may access it directly in the GOT.
+ 
+    On i386 running Windows NT, modify the assembler name with a suffix 
+    consisting of an atsign (@) followed by string of digits that represents
+    the number of bytes of arguments passed to the function, if it has the 
+    attribute STDCALL. */
+ 
+ #ifdef ENCODE_SECTION_INFO
+ #undef ENCODE_SECTION_INFO
+ #define ENCODE_SECTION_INFO(DECL) 					\
+ do									\
+   {									\
+     if (flag_pic)							\
+       {									\
+ 	rtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'		\
+ 		   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));		\
+ 	SYMBOL_REF_FLAG (XEXP (rtl, 0))					\
+ 	  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'			\
+ 	     || ! TREE_PUBLIC (DECL));					\
+       }									\
+     if (TREE_CODE (DECL) == FUNCTION_DECL) 				\
+       if (lookup_attribute ("stdcall",					\
+ 			    TYPE_ATTRIBUTES (TREE_TYPE (DECL))))	\
+         XEXP (DECL_RTL (DECL), 0) = 					\
+           gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (DECL)); 	\
+   }									\
+ while (0)
+ #endif
+ 
+ /* Emit code to check the stack when allocating more that 20
+    bytes in one go. */
+ 
+ #define CHECK_STACK_LIMIT 20
+ 
+ 
+ 
+ /* By default, target has a 80387, uses IEEE compatible arithmetic,
+    and returns float values in the 387 and needs stack probes */
+ #undef TARGET_DEFAULT
+ 
+ #define TARGET_DEFAULT \
+    (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE) 
+ 
+ /* A C statement to output something to the assembler file to switch to section
+    NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or
+    NULL_TREE.  Some target formats do not support arbitrary sections.  Do not
+    define this macro in such cases.  */
+ 
+ #define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME) \
+   fprintf (FILE, "\t.section %s\n", NAME)
+ 
+ /* This is how to output an assembler line
+    that says to advance the location counter
+    to a multiple of 2**LOG bytes.  */
+ 
+ #undef ASM_OUTPUT_ALIGN
+ #define ASM_OUTPUT_ALIGN(FILE,LOG)	\
+     if ((LOG)!=0) fprintf ((FILE), "\t.align %d\n", 1<<(LOG))
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/i386.c gcc-2.7.2.1/config/i386/i386.c
*** gcc-2.7.2.1.orig/config/i386/i386.c	Sun Oct 22 11:13:21 1995
--- gcc-2.7.2.1/config/i386/i386.c	Tue Nov 12 13:10:10 1996
***************
*** 1471,1478 ****
        output_asm_insn (AS2 (mov%L0,%0,%1), xops);
      }
! 
    if (size)
      output_asm_insn (AS2 (sub%L0,%2,%0), xops);
! 
    /* Note If use enter it is NOT reversed args.
       This one is not reversed from intel!!
--- 1471,1494 ----
        output_asm_insn (AS2 (mov%L0,%0,%1), xops);
      }
! /* CYGNUS LOCAL sac/win32 */
! #if defined(CHECK_STACK_LIMIT) 
!   if (size)
!     {
!       if (size < CHECK_STACK_LIMIT)
! 	output_asm_insn (AS2 (sub%L0,%2,%0), xops);
!       else 
! 	{
! 	xops[3] = gen_rtx (REG, SImode, 0);
! 	output_asm_insn (AS2 (mov%L0,%2,%3), xops);
!       
! 	xops[3] = gen_rtx (SYMBOL_REF, Pmode, "_alloca");
! 	output_asm_insn (AS1 (call,%P3), xops);
!       }
!     }
! #else
    if (size)
      output_asm_insn (AS2 (sub%L0,%2,%0), xops);
! #endif
! /* END CYGNUS LOCAL sac/win32 */
    /* Note If use enter it is NOT reversed args.
       This one is not reversed from intel!!
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/i386.h gcc-2.7.2.1/config/i386/i386.h
*** gcc-2.7.2.1.orig/config/i386/i386.h	Fri Sep 22 23:42:57 1995
--- gcc-2.7.2.1/config/i386/i386.h	Tue Nov 12 13:10:10 1996
***************
*** 82,85 ****
--- 82,89 ----
  #define MASK_DEBUG_ARG		000010000000	/* Debug function_arg */   
  
+ /* CYGNUS LOCAL sac/win32 */
+ #define MASK_STACK_PROBE	000020000000    /* Enable stack probing */
+ /* END CYGNUS LOCAL sac/win32 */
+ 
  /* Use the floating point instructions */
  #define TARGET_80387 (target_flags & MASK_80387)
***************
*** 133,136 ****
--- 137,144 ----
  #define TARGET_386	(!TARGET_486) 			/* 80386 */
  
+ /* CYGNUS LOCAL sac/win32 */
+ #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)
+ /* END CYGNUS LOCAL sac/win32 */
+ 
  #define TARGET_SWITCHES							\
  { { "80387",			 MASK_80387 },				\
***************
*** 163,166 ****
--- 171,178 ----
    { "debug-arg",		 MASK_DEBUG_ARG },			\
    { "no-debug-arg",		-MASK_DEBUG_ARG },			\
+ /* CYGNUS LOCAL sac/win32 */						\
+   { "stack-arg-probe",		 MASK_STACK_PROBE },			\
+   { "no-stack-arg-probe",	-MASK_STACK_PROBE },			\
+ /* CYGNUS LOCAL sac/win32 */						\
    SUBTARGET_SWITCHES							\
    { "", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/i386.md gcc-2.7.2.1/config/i386/i386.md
*** gcc-2.7.2.1.orig/config/i386/i386.md	Mon Aug 21 18:27:58 1995
--- gcc-2.7.2.1/config/i386/i386.md	Tue Nov 12 13:10:11 1996
***************
*** 60,63 ****
--- 60,67 ----
  ;; 2  This is a `cos' operation.  The mode of the UNSPEC is MODE_FLOAT.
  ;;    operand 0 is the argument for `cos'.
+ ;; CYGNUS LOCAL sac/win32
+ ;; 3  This is part of a `stack probe' operation.  The mode of the UNSPEC is
+ ;;    always SImode.  operand 0 is the size of the stack allocation.
+ ;; END CYGNUS LOCAL sac/win32
  
  ;; "movl MEM,REG / testl REG,REG" is faster on a 486 than "cmpl $0,MEM".
***************
*** 5774,5775 ****
--- 5778,5829 ----
    return \"repnz\;scas%B2\";
  }")
+ 
+ ;; CYGNUS LOCAL sac/win32
+ (define_insn "adjust_stack_worker"
+   [(unspec:SI [(match_operand:SI 0 "register_operand" "a")] 3)
+    (set (reg:SI 7) (minus:SI (reg:SI 7) (match_dup 0)))
+    (clobber (match_dup 0))]
+   "TARGET_STACK_PROBE"
+   "* return AS1(call,__alloca);")
+ 
+ (define_expand "adjust_stack"
+   [(set (reg:SI 7) (plus:SI (reg:SI 7) (match_operand:SI 0 "general_operand" "")))
+    (use (match_operand:SI 1 "" ""))]
+   "TARGET_STACK_PROBE"
+   "
+ {
+   int up = INTVAL (operands[1]);
+ 
+   if (GET_CODE (operands[0]) == CONST_INT)
+     {
+       int size = INTVAL (operands[0]);
+       if (!up)
+ 	size = - size;
+ 
+       if (size > 0)
+ 	{
+ 	  emit_insn (gen_addsi3 (stack_pointer_rtx,
+ 				 stack_pointer_rtx,
+ 				 GEN_INT (size)));
+ 	}
+       else if (size > -4000)
+ 	{
+ 	  emit_insn (gen_subsi3 (stack_pointer_rtx,
+ 				 stack_pointer_rtx,
+ 				 GEN_INT ( - size)));
+ 	}
+       else 
+ 	{
+ 	  emit_insn (gen_adjust_stack_worker (copy_to_mode_reg (SImode, GEN_INT (-size))));
+ 	}
+     }
+   else 
+     {
+       if (up)
+ 	operands[0] = gen_rtx (NEG, SImode, operands[0]);
+       emit_insn (gen_adjust_stack_worker (copy_to_mode_reg (SImode, operands[0])));
+     }
+   DONE;
+ }")
+ 
+ ;; END CYGNUS LOCAL sac/win32
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/t-cygwin32 gcc-2.7.2.1/config/i386/t-cygwin32
*** gcc-2.7.2.1.orig/config/i386/t-cygwin32	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/i386/t-cygwin32	Tue Nov 12 13:10:11 1996
***************
*** 0 ****
--- 1,8 ----
+ LIBGCC1 = libgcc1-asm.a
+ CROSS_LIBGCC1 = libgcc1-asm.a
+ LIB1ASMSRC = i386/cygwin32.asm
+ LIB1ASMFUNCS = _chkstk
+ 
+ winnt.o: $(srcdir)/config/i386/winnt.c
+ 	$(CC) -I. -I$(srcdir) -I$(srcdir)/config -c $(srcdir)/config/i386/winnt.c
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/winnt.c gcc-2.7.2.1/config/i386/winnt.c
*** gcc-2.7.2.1.orig/config/i386/winnt.c	Thu Jun 15 14:55:05 1995
--- gcc-2.7.2.1/config/i386/winnt.c	Tue Nov 12 13:10:11 1996
***************
*** 45,55 ****
          == void_type_node)
        {
!         tree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));
  
!         while (TREE_VALUE (formal_type) != void_type_node)
!           {
!             total += TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));
!             formal_type = TREE_CHAIN (formal_type);
!           }
        }
  
--- 45,61 ----
          == void_type_node)
        {
! 	tree formal_type = TYPE_ARG_TYPES (TREE_TYPE (decl));
  
! 	while (TREE_VALUE (formal_type) != void_type_node)
! 	  {
! 	    int parm_size
! 	      = TREE_INT_CST_LOW (TYPE_SIZE (TREE_VALUE (formal_type)));
! 	    /* Must round up to include padding.  This is done the same
! 	       way as in store_one_arg.  */
! 	    parm_size = ((parm_size + PARM_BOUNDARY - 1)
! 			 / PARM_BOUNDARY * PARM_BOUNDARY);
! 	    total += parm_size;
! 	    formal_type = TREE_CHAIN (formal_type);
! 	  }
        }
  
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/x-cygwin32 gcc-2.7.2.1/config/i386/x-cygwin32
*** gcc-2.7.2.1.orig/config/i386/x-cygwin32	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/i386/x-cygwin32	Tue Nov 12 13:10:11 1996
***************
*** 0 ****
--- 1,2 ----
+ USE_COLLECT2 =
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config/i386/xm-cygwin32.h gcc-2.7.2.1/config/i386/xm-cygwin32.h
*** gcc-2.7.2.1.orig/config/i386/xm-cygwin32.h	Thu Jan  1 00:00:00 1970
--- gcc-2.7.2.1/config/i386/xm-cygwin32.h	Tue Nov 12 13:10:11 1996
***************
*** 0 ****
--- 1,30 ----
+ /* Configuration for GNU C-compiler for hosting on Windows NT.
+    using a unix style C library.
+    Copyright (C) 1995 Free Software Foundation, Inc.
+ 
+ This file is part of GNU CC.
+ 
+ GNU CC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GNU CC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ 
+ 
+ #define NO_STAB_H
+ 
+ #include "i386/xm-i386.h"
+ 
+ #define HAVE_STRERROR
+ #define HAVE_RUSAGE
+ #define HAVE_FILE_H
+ #define EXECUTABLE_SUFFIX ".exe"
+ 
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/config.sub gcc-2.7.2.1/config.sub
*** gcc-2.7.2.1.orig/config.sub	Thu Jun 15 22:01:49 1995
--- gcc-2.7.2.1/config.sub	Tue Nov 12 13:12:03 1996
***************
*** 642,646 ****
  	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
! 	      | -udi* | -eabi* | -lites* )
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
--- 642,646 ----
  	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
  	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
! 	      | -udi* | -eabi* | -lites* | -cygwin32* | -pe* )
  	# Remember, each alternative MUST END IN *, to match a version number.
  		;;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/configure gcc-2.7.2.1/configure
*** gcc-2.7.2.1.orig/configure	Sun Nov 26 19:39:15 1995
--- gcc-2.7.2.1/configure	Tue Nov 12 13:10:12 1996
***************
*** 1135,1138 ****
--- 1135,1146 ----
  		xmake_file=i386/x-vsta
  		;;
+ 	i[3456]86-*-pe | i[3456]86-*-cygwin32)
+ 		cpu_type=i386
+ 		xm_file=i386/xm-cygwin32.h
+ 		tmake_file=i386/t-cygwin32
+ 		tm_file=i386/cygwin32.h
+ 		xmake_file=i386/x-cygwin32
+ 		extra_objs=winnt.o
+ 		;;
  	i[345]86-*-winnt3*)
  		cpu_type=i386
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/cp/decl.c gcc-2.7.2.1/cp/decl.c
*** gcc-2.7.2.1.orig/cp/decl.c	Mon Oct 23 22:25:44 1995
--- gcc-2.7.2.1/cp/decl.c	Tue Nov 12 13:10:13 1996
***************
*** 12783,12878 ****
    free (p);
  }
- 
- /* FSF LOCAL dje prefix attributes */
- /* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two
-    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).
- 
-    The head of the declspec list is stored in DECLSPECS.
-    The head of the attribute list is stored in PREFIX_ATTRIBUTES.
- 
-    Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of
-    the list elements.  We drop the containing TREE_LIST nodes and link the
-    resulting attributes together the way decl_attributes expects them.  */
- 
- void
- split_specs_attrs (specs_attrs, declspecs, prefix_attributes)
-      tree specs_attrs;
-      tree *declspecs, *prefix_attributes;
- {
-   tree t, s, a, next, specs, attrs;
- 
-   /* This can happen in c++ (eg: decl: typespec initdecls ';').  */
-   if (specs_attrs != NULL_TREE
-       && TREE_CODE (specs_attrs) != TREE_LIST)
-     {
-       *declspecs = specs_attrs;
-       *prefix_attributes = NULL_TREE;
-       return;
-     }
- 
-   /* Remember to keep the lists in the same order, element-wise.  */
- 
-   specs = s = NULL_TREE;
-   attrs = a = NULL_TREE;
-   for (t = specs_attrs; t; t = next)
-     {
-       next = TREE_CHAIN (t);
-       /* Declspecs have a non-NULL TREE_VALUE.  */
-       if (TREE_VALUE (t) != NULL_TREE)
- 	{
- 	  if (specs == NULL_TREE)
- 	    specs = s = t;
- 	  else
- 	    {
- 	      TREE_CHAIN (s) = t;
- 	      s = t;
- 	    }
- 	}
-       else
- 	{
- 	  if (attrs == NULL_TREE)
- 	    attrs = a = TREE_PURPOSE (t);
- 	  else
- 	    {
- 	      TREE_CHAIN (a) = TREE_PURPOSE (t);
- 	      a = TREE_PURPOSE (t);
- 	    }
- 	}
-     }
- 
-   /* Terminate the lists.  */
-   if (s != NULL_TREE)
-     TREE_CHAIN (s) = NULL_TREE;
-   if (a != NULL_TREE)
-     TREE_CHAIN (a) = NULL_TREE;
- 
-   /* All done.  */
-   *declspecs = specs;
-   *prefix_attributes = attrs;
- }
- 
- /* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.
-    This function is used by the parser when a rule will accept attributes
-    in a particular position, but we don't want to support that just yet.
- 
-    A warning is issued for every ignored attribute.  */
- 
- tree
- strip_attrs (specs_attrs)
-      tree specs_attrs;
- {
-   tree specs, attrs;
- 
-   split_specs_attrs (specs_attrs, &specs, &attrs);
- 
-   while (attrs)
-     {
-       warning ("`%s' attribute ignored",
- 	       IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));
-       attrs = TREE_CHAIN (attrs);
-     }
- 
-   return specs;
- }
- /* END FSF LOCAL */
- 
--- 12783,12784 ----
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/cp/g++.c gcc-2.7.2.1/cp/g++.c
*** gcc-2.7.2.1.orig/cp/g++.c	Mon Nov 20 22:08:53 1995
--- gcc-2.7.2.1/cp/g++.c	Tue Nov 12 13:10:13 1996
***************
*** 41,45 ****
  #include <stdio.h>
  #include <sys/types.h>
! #if !defined(_WIN32)
  #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
  #else
--- 41,45 ----
  #include <stdio.h>
  #include <sys/types.h>
! #if ! defined (_WIN32) || defined (__CYGWIN32__)
  #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
  #else
***************
*** 567,571 ****
        fprintf (stderr, "\n");
      }
! #if !defined(OS2) && !defined (_WIN32)
  #ifdef __MSDOS__
    run_dos (gcc, arglist);
--- 567,571 ----
        fprintf (stderr, "\n");
      }
! #if !defined(OS2) && (!defined (_WIN32) || defined (__CYGWIN32__))
  #ifdef __MSDOS__
    run_dos (gcc, arglist);
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/gcc.c gcc-2.7.2.1/gcc.c
*** gcc-2.7.2.1.orig/gcc.c	Tue Sep 12 22:15:11 1995
--- gcc-2.7.2.1/gcc.c	Tue Nov 12 13:10:14 1996
***************
*** 38,47 ****
  #include <errno.h>
  
! #ifndef _WIN32
  #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
- #else
- #include <process.h>
- int __spawnv ();
- int __spawnvp ();
  #endif
  
--- 38,43 ----
  #include <errno.h>
  
! #ifndef NO_SYS_FILE_H
  #include <sys/file.h>   /* May get R_OK, etc. on some systems.  */
  #endif
  
***************
*** 2023,2027 ****
  #endif
  
! #if !defined(__MSDOS__) && !defined(OS2) && !defined(_WIN32)
  
  static int
--- 2019,2024 ----
  #endif
  
! /* include for Unix-like environments but not for Dos-like environments */
! #if !defined(__MSDOS__) && !defined(OS2) &&(defined(__CYGWIN32__) || !defined(_WIN32))
  
  static int
***************
*** 2113,2117 ****
  }
  
! #endif /* not __MSDOS__ and not OS2 and not _WIN32 */
  
  #if defined(OS2)
--- 2110,2114 ----
  }
  
! #endif /* ! __MSDOS__ && ! OS2 && && (__CYGWIN32___ || ! _WIN32) */
  
  #if defined(OS2)
***************
*** 2128,2132 ****
  #endif /* OS2 */
  
! #if defined(_WIN32)
  
  static int
--- 2125,2134 ----
  #endif /* OS2 */
  
! #if defined (_WIN32) && !defined (__CYGWIN32__)
! 
! #include <process.h>
! /* ??? Why are these __spawnv{,p} and not _spawnv{,p}?  */
! extern int __spawnv ();
! extern int __spawnvp ();
  
  static int
***************
*** 2139,2143 ****
    return (search_flag ? __spawnv : __spawnvp) (1, program, argv);
  }
! #endif /* _WIN32 */
  
  
--- 2141,2145 ----
    return (search_flag ? __spawnv : __spawnvp) (1, program, argv);
  }
! #endif /* (__CYGWIN32___ || ! _WIN32) */
  
  
***************
*** 2185,2190 ****
      if (strcmp (argbuf[i], "|") == 0)
        {				/* each command.  */
! #ifdef __MSDOS__
!         fatal ("-pipe not supported under MS-DOS");
  #endif
  	argbuf[i] = 0;	/* termination of command args.  */
--- 2187,2192 ----
      if (strcmp (argbuf[i], "|") == 0)
        {				/* each command.  */
! #if defined (__MSDOS__) || (defined (_WIN32) && ! defined (__CYGWIN32__)) || defined (OS2)
! 	fatal ("-pipe not supported");
  #endif
  	argbuf[i] = 0;	/* termination of command args.  */
***************
*** 2263,2267 ****
          status = pid = commands[i].pid;
  #else
! #ifdef _WIN32
  	pid = cwait (&status, commands[i].pid, WAIT_CHILD);
  #else
--- 2265,2269 ----
          status = pid = commands[i].pid;
  #else
! #if defined (_WIN32) && !defined (__CYGWIN32__)
  	pid = cwait (&status, commands[i].pid, WAIT_CHILD);
  #else
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/getpwd.c gcc-2.7.2.1/getpwd.c
*** gcc-2.7.2.1.orig/getpwd.c	Tue May 16 23:25:04 1995
--- gcc-2.7.2.1/getpwd.c	Tue Nov 12 13:10:14 1996
***************
*** 29,36 ****
  #define GUESSPATHLEN 100
  #endif /* (defined (USG) || defined (VMS)) */
! #ifdef _WIN32
  #include <direct.h>
  #endif
! 
  char *getenv ();
  char *xmalloc ();
--- 29,37 ----
  #define GUESSPATHLEN 100
  #endif /* (defined (USG) || defined (VMS)) */
! /* CYGNUS LOCAL sac/win32 */
! #if defined(_WIN32) && defined(HAVE_DIRECT_H)
  #include <direct.h>
  #endif
! /* END CYGNUS LOCAL sac/win32 */
  char *getenv ();
  char *xmalloc ();
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/toplev.c gcc-2.7.2.1/toplev.c
*** gcc-2.7.2.1.orig/toplev.c	Fri Oct 20 21:56:35 1995
--- gcc-2.7.2.1/toplev.c	Tue Nov 12 13:10:14 1996
***************
*** 36,41 ****
  #include <ctype.h>
  #include <sys/stat.h>
! 
! #ifndef _WIN32
  #ifdef USG
  #undef FLOAT
--- 36,42 ----
  #include <ctype.h>
  #include <sys/stat.h>
! /* CYGNUS LOCAL sac/win32 */
! #if !defined (_WIN32) || defined (HAVE_RUSAGE)
! /* END CYGNUS LOCAL sac/win32 */
  #ifdef USG
  #undef FLOAT
***************
*** 789,793 ****
  get_run_time ()
  {
! #ifndef _WIN32
  #ifdef USG
    struct tms tms;
--- 790,796 ----
  get_run_time ()
  {
! /* CYGNUS LOCAL sac/win32 */
! #if !defined(_WIN32) || defined(HAVE_RUSAGE)
! /* END CYGNUS LOCAL sac/win32 */
  #ifdef USG
    struct tms tms;
***************
*** 809,813 ****
    if (quiet_flag)
      return 0;
! #ifdef _WIN32
    if (clock() < 0)
      return 0;
--- 812,818 ----
    if (quiet_flag)
      return 0;
! /* CYGNUS LOCAL sac/win32 */
! #if defined(_WIN32) && !defined (HAVE_RUSAGE)
! /* END CYGNUS LOCAL sac/win32 */
    if (clock() < 0)
      return 0;
diff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h -x cexp.c -x bi-parser.c -x objc-parse.y -x objc-parse.c -x TAGS -x gcc.?? -x gcc.??s -x gcc.aux -x gcc.info* -x cpp.?? -x cpp.??s -x cpp.aux -x cpp.info* gcc-2.7.2.1.orig/tree.h gcc-2.7.2.1/tree.h
*** gcc-2.7.2.1.orig/tree.h	Mon Sep 25 21:49:40 1995
--- gcc-2.7.2.1/tree.h	Tue Nov 12 13:10:15 1996
***************
*** 1227,1230 ****
--- 1227,1240 ----
  extern tree build_decl_attribute_variant PROTO((tree, tree));
  
+ /* CYGNUS LOCAL dje prefix attributes */
+ /* Split a list of declspecs and attributes into two.  */
+ 
+ extern void split_specs_attrs		PROTO((tree, tree *, tree *));
+ 
+ /* Strip attributes from a list of combined specs and attrs.  */
+ 
+ extern tree strip_attrs			PROTO((tree));
+ /* END CYGNUS LOCAL */
+ 
  /* Return 1 if an attribute and its arguments are valid for a decl or type.  */
  
