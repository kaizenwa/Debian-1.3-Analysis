@node Set types
@chapter Information of the SET_TYPE implementation in GPC.
Juki <jtv@@hut.fi> @*
Last modified: Wed Sep 22 11:47:27 1993

@itemize @bullet
@item
Memory format

@code{Set of T} type nodes are represented as bit vectors,
one bit for each element. The SET_TYPE objects contain
only the bits necessary to represent the set type
PLUS the padding to align the objects to the
nearest word boundary. Thus, there may be unused
bits in front and after the end of otherwise
contiquous bit vector that represents all the elements
of the set.

@item
Sparse sets are not implemented

there is no concept of ``sparse sets'', which I thought
might be nice for things like @code{[ -maxint, maxint ]}
to work. Maybe someone implements this later,
e.g. with a list of set fragments or a list of set
elements.

@item
Negative bounds for sets do not work

Perhaps this could be done by subtracting the
low bound from all set elements before storing
them to bitvectors. (This might cause complications
with set constructors in expressions?)

@item
Set of integer

This is a problem currently. It should be dynamic, but
currently the bounds are always set to 0..255 for an
unlimited integer set.

First aid: implement a switch that specifies the bounds
of such sets. The value should be passed to @code{setop.c}
in some language independend way. (Global variables :-)

@item
Set operations:

With a massive hack attack I converted all set operations
to inline code. It is not perfect yet, but now it
passes all set tests I have. Yet, the code contains
unimplemented parts (see @code{setop.c}).

@item
List of set operations:
@end itemize

@example
CARD_EXPR:      returns the number of set elements currently in the set
                Extended Pascal.

UNION           @var{SetC} := @var{SetA} + @var{SetB}; union of the sets
BIT_OR_EXPR

DIFF            @var{SetC} := @var{SetA} - @var{SetB}; If in A, but not in B.
BIT_ANDTC_EXPR  (and @code{tc_optab} has vanished from gcc-2, so this
                will be done ``@var{SetA} and (not (@var{SetB}))'')

INTERSECTION    @var{SetC} := @var{SetA} * @var{SetB}; If in A and in B
BIT_AND_EXPR

SYMDIFF         @var{SetC} := @var{SetA} >< @var{SetB}; set symmetric difference
BIT_XOR_EXPR    (C if only in A or only in B (Boolean @code{XOR}) 
                Extended Pascal.

SEARCH_EXPR:    in a set iteration, yields each member of the set
                in some implementation dependend order.
                Extended Pascal (this is not yet implemented in gpc).

Rest of the operands result in boolean values.

=, <>           Equality comparisons

<=              @code{LE_EXPR}
                @var{SetA} <= @var{SetB} denotes the inclusion of @var{SetA} in @var{SetB}

>=              Implemented with @code{LE_EXPR}, like above
                @var{SetA} >= @var{SetB} denotes the inclusion of @var{SetB} in @var{SetA}
@end example
