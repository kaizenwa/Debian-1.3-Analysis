This is Info file ./gpc.info, produced by Makeinfo-1.55 from the input
file ./gpc.texi.

   This file documents the use and the internals of the GNU Pascal
compiler.

   Copyright (C) 1988, 1996 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.


File: gpc.info,  Node: Cross-compilation,  Next: Misc,  Prev: Debugging Info,  Up: Target Macros

Cross Compilation and Floating Point
====================================

   While all modern machines use 2's complement representation for
integers, there are a variety of representations for floating point
numbers.  This means that in a cross-compiler the representation of
floating point numbers in the compiled program may be different from
that used in the machine doing the compilation.

   Because different representation systems may offer different amounts
of range and precision, the cross compiler cannot safely use the host
machine's floating point arithmetic.  Therefore, floating point
constants must be represented in the target machine's format.  This
means that the cross compiler cannot use `atof' to parse a floating
point constant; it must have its own special routine to use instead.
Also, constant folding must emulate the target machine's arithmetic (or
must not be done at all).

   The macros in the following table should be defined only if you are
cross compiling between different floating point formats.

   Otherwise, don't define them.  Then default definitions will be set
up which use `double' as the data type, `==' to test for equality, etc.

   You don't need to worry about how many times you use an operand of
any of these macros.  The compiler never uses operands which have side
effects.

`REAL_VALUE_TYPE'
     A macro for the C data type to be used to hold a floating point
     value in the target machine's format.  Typically this would be a
     `struct' containing an array of `int'.

`REAL_VALUES_EQUAL (X, Y)'
     A macro for a C expression which compares for equality the two
     values, X and Y, both of type `REAL_VALUE_TYPE'.

`REAL_VALUES_LESS (X, Y)'
     A macro for a C expression which tests whether X is less than Y,
     both values being of type `REAL_VALUE_TYPE' and interpreted as
     floating point numbers in the target machine's representation.

`REAL_VALUE_LDEXP (X, SCALE)'
     A macro for a C expression which performs the standard library
     function `ldexp', but using the target machine's floating point
     representation.  Both X and the value of the expression have type
     `REAL_VALUE_TYPE'.  The second argument, SCALE, is an integer.

`REAL_VALUE_FIX (X)'
     A macro whose definition is a C expression to convert the
     target-machine floating point value X to a signed integer.  X has
     type `REAL_VALUE_TYPE'.

`REAL_VALUE_UNSIGNED_FIX (X)'
     A macro whose definition is a C expression to convert the
     target-machine floating point value X to an unsigned integer.  X
     has type `REAL_VALUE_TYPE'.

`REAL_VALUE_RNDZINT (X)'
     A macro whose definition is a C expression to round the
     target-machine floating point value X towards zero to an integer
     value (but still as a floating point number).  X has type
     `REAL_VALUE_TYPE', and so does the value.

`REAL_VALUE_UNSIGNED_RNDZINT (X)'
     A macro whose definition is a C expression to round the
     target-machine floating point value X towards zero to an unsigned
     integer value (but still represented as a floating point number).
     x has type `REAL_VALUE_TYPE', and so does the value.

`REAL_VALUE_ATOF (STRING, MODE)'
     A macro for a C expression which converts STRING, an expression of
     type `char *', into a floating point number in the target machine's
     representation for mode MODE.  The value has type
     `REAL_VALUE_TYPE'.

`REAL_INFINITY'
     Define this macro if infinity is a possible floating point value,
     and therefore division by 0 is legitimate.

`REAL_VALUE_ISINF (X)'
     A macro for a C expression which determines whether X, a floating
     point value, is infinity.  The value has type `int'.  By default,
     this is defined to call `isinf'.

`REAL_VALUE_ISNAN (X)'
     A macro for a C expression which determines whether X, a floating
     point value, is a "nan" (not-a-number).  The value has type `int'.
     By default, this is defined to call `isnan'.

   Define the following additional macros if you want to make floating
point constant folding work while cross compiling.  If you don't define
them, cross compilation is still possible, but constant folding will
not happen for floating point values.

`REAL_ARITHMETIC (OUTPUT, CODE, X, Y)'
     A macro for a C statement which calculates an arithmetic operation
     of the two floating point values X and Y, both of type
     `REAL_VALUE_TYPE' in the target machine's representation, to
     produce a result of the same type and representation which is
     stored in OUTPUT (which will be a variable).

     The operation to be performed is specified by CODE, a tree code
     which will always be one of the following: `PLUS_EXPR',
     `MINUS_EXPR', `MULT_EXPR', `RDIV_EXPR', `MAX_EXPR', `MIN_EXPR'.

     The expansion of this macro is responsible for checking for
     overflow.  If overflow happens, the macro expansion should execute
     the statement `return 0;', which indicates the inability to
     perform the arithmetic operation requested.

`REAL_VALUE_NEGATE (X)'
     A macro for a C expression which returns the negative of the
     floating point value X.  Both X and the value of the expression
     have type `REAL_VALUE_TYPE' and are in the target machine's
     floating point representation.

     There is no way for this macro to report overflow, since overflow
     can't happen in the negation operation.

`REAL_VALUE_TRUNCATE (MODE, X)'
     A macro for a C expression which converts the floating point value
     X to mode MODE.

     Both X and the value of the expression are in the target machine's
     floating point representation and have type `REAL_VALUE_TYPE'.
     However, the value should have an appropriate bit pattern to be
     output properly as a floating constant whose precision accords
     with mode MODE.

     There is no way for this macro to report overflow.

`REAL_VALUE_TO_INT (LOW, HIGH, X)'
     A macro for a C expression which converts a floating point value X
     into a double-precision integer which is then stored into LOW and
     HIGH, two variables of type INT.

`REAL_VALUE_FROM_INT (X, LOW, HIGH)'
     A macro for a C expression which converts a double-precision
     integer found in LOW and HIGH, two variables of type INT, into a
     floating point value which is then stored into X.


File: gpc.info,  Node: Misc,  Prev: Cross-compilation,  Up: Target Macros

Miscellaneous Parameters
========================

   Here are several miscellaneous parameters.

`PREDICATE_CODES'
     Define this if you have defined special-purpose predicates in the
     file `MACHINE.c'.  This macro is called within an initializer of an
     array of structures.  The first field in the structure is the name
     of a predicate and the second field is an array of rtl codes.  For
     each predicate, list all rtl codes that can be in expressions
     matched by the predicate.  The list should have a trailing comma.
     Here is an example of two entries in the list for a typical RISC
     machine:

          #define PREDICATE_CODES \
            {"gen_reg_rtx_operand", {SUBREG, REG}},  \
            {"reg_or_short_cint_operand", {SUBREG, REG, CONST_INT}},

     Defining this macro does not affect the generated code (however,
     incorrect definitions that omit an rtl code that may be matched by
     the predicate can cause the compiler to malfunction).  Instead, it
     allows the table built by `genrecog' to be more compact and
     efficient, thus speeding up the compiler.  The most important
     predicates to include in the list specified by this macro are
     thoses used in the most insn patterns.

`CASE_VECTOR_MODE'
     An alias for a machine mode name.  This is the machine mode that
     elements of a jump-table should have.

`CASE_VECTOR_PC_RELATIVE'
     Define this macro if jump-tables should contain relative addresses.

`CASE_DROPS_THROUGH'
     Define this if control falls through a `case' insn when the index
     value is out of range.  This means the specified default-label is
     actually ignored by the `case' insn proper.

`CASE_VALUES_THRESHOLD'
     Define this to be the smallest number of different values for
     which it is best to use a jump-table instead of a tree of
     conditional branches.  The default is four for machines with a
     `casesi' instruction and five otherwise.  This is best for most
     machines.

`WORD_REGISTER_OPERATIONS'
     Define this macro if operations between registers with integral
     mode smaller than a word are always performed on the entire
     register.  Most RISC machines have this property and most CISC
     machines do not.

`LOAD_EXTEND_OP (MODE)'
     Define this macro to be a C expression indicating when insns that
     read memory in MODE, an integral mode narrower than a word, set the
     bits outside of MODE to be either the sign-extension or the
     zero-extension of the data read.  Return `SIGN_EXTEND' for values
     of MODE for which the insn sign-extends, `ZERO_EXTEND' for which
     it zero-extends, and `NIL' for other modes.

     This macro is not called with MODE non-integral or with a width
     greater than or equal to `BITS_PER_WORD', so you may return any
     value in this case.  Do not define this macro if it would always
     return `NIL'.  On machines where this macro is defined, you will
     normally define it as the constant `SIGN_EXTEND' or `ZERO_EXTEND'.

`IMPLICIT_FIX_EXPR'
     An alias for a tree code that should be used by default for
     conversion of floating point values to fixed point.  Normally,
     `FIX_ROUND_EXPR' is used.

`FIXUNS_TRUNC_LIKE_FIX_TRUNC'
     Define this macro if the same instructions that convert a floating
     point number to a signed fixed point number also convert validly
     to an unsigned one.

`EASY_DIV_EXPR'
     An alias for a tree code that is the easiest kind of division to
     compile code for in the general case.  It may be `TRUNC_DIV_EXPR',
     `FLOOR_DIV_EXPR', `CEIL_DIV_EXPR' or `ROUND_DIV_EXPR'.  These four
     division operators differ in how they round the result to an
     integer.  `EASY_DIV_EXPR' is used when it is permissible to use
     any of those kinds of division and the choice should be made on
     the basis of efficiency.

`MOVE_MAX'
     The maximum number of bytes that a single instruction can move
     quickly from memory to memory.

`MAX_MOVE_MAX'
     The maximum number of bytes that a single instruction can move
     quickly from memory to memory.  If this is undefined, the default
     is `MOVE_MAX'.  Otherwise, it is the constant value that is the
     largest value that `MOVE_MAX' can have at run-time.

`SHIFT_COUNT_TRUNCATED'
     A C expression that is nonzero if on this machine the number of
     bits actually used for the count of a shift operation is equal to
     the number of bits needed to represent the size of the object
     being shifted.  When this macro is non-zero, the compiler will
     assume that it is safe to omit a sign-extend, zero-extend, and
     certain bitwise `and' instructions that truncates the count of a
     shift operation.  On machines that have instructions that act on
     bitfields at variable positions, which may include `bit test'
     instructions, a nonzero `SHIFT_COUNT_TRUNCATED' also enables
     deletion of truncations of the values that serve as arguments to
     bitfield instructions.

     If both types of instructions truncate the count (for shifts) and
     position (for bitfield operations), or if no variable-position
     bitfield instructions exist, you should define this macro.

     However, on some machines, such as the 80386 and the 680x0,
     truncation only applies to shift operations and not the (real or
     pretended) bitfield operations.  Define `SHIFT_COUNT_TRUNCATED' to
     be zero on such machines.  Instead, add patterns to the `md' file
     that include the implied truncation of the shift instructions.

     You need not define this macro if it would always have the value
     of zero.

`TRULY_NOOP_TRUNCATION (OUTPREC, INPREC)'
     A C expression which is nonzero if on this machine it is safe to
     "convert" an integer of INPREC bits to one of OUTPREC bits (where
     OUTPREC is smaller than INPREC) by merely operating on it as if it
     had only OUTPREC bits.

     On many machines, this expression can be 1.

     When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for
     modes for which `MODES_TIEABLE_P' is 0, suboptimal code can result.
     If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in
     such cases may improve things.

`STORE_FLAG_VALUE'
     A C expression describing the value returned by a comparison
     operator with an integral mode and stored by a store-flag
     instruction (`sCOND') when the condition is true.  This
     description must apply to *all* the `sCOND' patterns and all the
     comparison operators whose results have a `MODE_INT' mode.

     A value of 1 or -1 means that the instruction implementing the
     comparison operator returns exactly 1 or -1 when the comparison is
     true and 0 when the comparison is false.  Otherwise, the value
     indicates which bits of the result are guaranteed to be 1 when the
     comparison is true.  This value is interpreted in the mode of the
     comparison operation, which is given by the mode of the first
     operand in the `sCOND' pattern.  Either the low bit or the sign
     bit of `STORE_FLAG_VALUE' be on.  Presently, only those bits are
     used by the compiler.

     If `STORE_FLAG_VALUE' is neither 1 or -1, the compiler will
     generate code that depends only on the specified bits.  It can also
     replace comparison operators with equivalent operations if they
     cause the required bits to be set, even if the remaining bits are
     undefined.  For example, on a machine whose comparison operators
     return an `SImode' value and where `STORE_FLAG_VALUE' is defined as
     `0x80000000', saying that just the sign bit is relevant, the
     expression

          (ne:SI (and:SI X (const_int POWER-OF-2)) (const_int 0))

     can be converted to

          (ashift:SI X (const_int N))

     where N is the appropriate shift count to move the bit being
     tested into the sign bit.

     There is no way to describe a machine that always sets the
     low-order bit for a true value, but does not guarantee the value
     of any other bits, but we do not know of any machine that has such
     an instruction.  If you are trying to port GNU CC to such a
     machine, include an instruction to perform a logical-and of the
     result with 1 in the pattern for the comparison operators and let
     us know (*note How to Report Bugs: Bug Reporting.).

     Often, a machine will have multiple instructions that obtain a
     value from a comparison (or the condition codes).  Here are rules
     to guide the choice of value for `STORE_FLAG_VALUE', and hence the
     instructions to be used:

        * Use the shortest sequence that yields a valid definition for
          `STORE_FLAG_VALUE'.  It is more efficient for the compiler to
          "normalize" the value (convert it to, e.g., 1 or 0) than for
          the comparison operators to do so because there may be
          opportunities to combine the normalization with other
          operations.

        * For equal-length sequences, use a value of 1 or -1, with -1
          being slightly preferred on machines with expensive jumps and
          1 preferred on other machines.

        * As a second choice, choose a value of `0x80000001' if
          instructions exist that set both the sign and low-order bits
          but do not define the others.

        * Otherwise, use a value of `0x80000000'.

     Many machines can produce both the value chosen for
     `STORE_FLAG_VALUE' and its negation in the same number of
     instructions.  On those machines, you should also define a pattern
     for those cases, e.g., one matching

          (set A (neg:M (ne:M B C)))

     Some machines can also perform `and' or `plus' operations on
     condition code values with less instructions than the corresponding
     `sCOND' insn followed by `and' or `plus'.  On those machines,
     define the appropriate patterns.  Use the names `incscc' and
     `decscc', respectively, for the the patterns which perform `plus'
     or `minus' operations on condition code values.  See `rs6000.md'
     for some examples.  The GNU Superoptizer can be used to find such
     instruction sequences on other machines.

     You need not define `STORE_FLAG_VALUE' if the machine has no
     store-flag instructions.

`FLOAT_STORE_FLAG_VALUE'
     A C expression that gives a non-zero floating point value that is
     returned when comparison operators with floating-point results are
     true.  Define this macro on machine that have comparison
     operations that return floating-point values.  If there are no
     such operations, do not define this macro.

`Pmode'
     An alias for the machine mode for pointers.  On most machines,
     define this to be the integer mode corresponding to the width of a
     hardware pointer; `SImode' on 32-bit machine or `DImode' on 64-bit
     machines.  On some machines you must define this to be one of the
     partial integer modes, such as `PSImode'.

     The width of `Pmode' must be at least as large as the value of
     `POINTER_SIZE'.  If it is not equal, you must define the macro
     `POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to
     `Pmode'.

`FUNCTION_MODE'
     An alias for the machine mode used for memory references to
     functions being called, in `call' RTL expressions.  On most
     machines this should be `QImode'.

`INTEGRATE_THRESHOLD (DECL)'
     A C expression for the maximum number of instructions above which
     the function DECL should not be inlined.  DECL is a
     `FUNCTION_DECL' node.

     The default definition of this macro is 64 plus 8 times the number
     of arguments that the function accepts.  Some people think a larger
     threshold should be used on RISC machines.

`SCCS_DIRECTIVE'
     Define this if the preprocessor should ignore `#sccs' directives
     and print no error message.

`NO_IMPLICIT_EXTERN_C'
     Define this macro if the system header files support C++ as well
     as C.  This macro inhibits the usual method of using system header
     files in C++, which is to pretend that the file's contents are
     enclosed in `extern "C" {...}'.

`HANDLE_PRAGMA (STREAM)'
     Define this macro if you want to implement any pragmas.  If
     defined, it should be a C statement to be executed when `#pragma'
     is seen.  The argument STREAM is the stdio input stream from which
     the source text can be read.

     It is generally a bad idea to implement new uses of `#pragma'.  The
     only reason to define this macro is for compatibility with other
     compilers that do support `#pragma' for the sake of any user
     programs which already use it.

`VALID_MACHINE_DECL_ATTRIBUTE (DECL, ATTRIBUTES, IDENTIFIER, ARGS)'
     If defined, a C expression whose value is nonzero if IDENTIFIER
     with arguments ARGS is a valid machine specific attribute for DECL.
     The attributes in ATTRIBUTES have previously been assigned to DECL.

`VALID_MACHINE_TYPE_ATTRIBUTE (TYPE, ATTRIBUTES, IDENTIFIER, ARGS)'
     If defined, a C expression whose value is nonzero if IDENTIFIER
     with arguments ARGS is a valid machine specific attribute for TYPE.
     The attributes in ATTRIBUTES have previously been assigned to TYPE.

`COMP_TYPE_ATTRIBUTES (TYPE1, TYPE2)'
     If defined, a C expression whose value is zero if the attributes on
     TYPE1 and TYPE2 are incompatible, one if they are compatible, and
     two if they are nearly compatible (which causes a warning to be
     generated).

`SET_DEFAULT_TYPE_ATTRIBUTES (TYPE)'
     If defined, a C statement that assigns default attributes to newly
     defined TYPE.

`DOLLARS_IN_IDENTIFIERS'
     Define this macro to control use of the character `$' in identifier
     names.  The value should be 0, 1, or 2.  0 means `$' is not allowed
     by default; 1 means it is allowed by default if `-traditional' is
     used; 2 means it is allowed by default provided `-ansi' is not
     used.  1 is the default; there is no need to define this macro in
     that case.

`NO_DOLLAR_IN_LABEL'
     Define this macro if the assembler does not accept the character
     `$' in label names.  By default constructors and destructors in
     G++ have `$' in the identifiers.  If this macro is defined, `.' is
     used instead.

`NO_DOT_IN_LABEL'
     Define this macro if the assembler does not accept the character
     `.' in label names.  By default constructors and destructors in G++
     have names that use `.'.  If this macro is defined, these names
     are rewritten to avoid `.'.

`DEFAULT_MAIN_RETURN'
     Define this macro if the target system expects every program's
     `main' function to return a standard "success" value by default
     (if no other value is explicitly returned).

     The definition should be a C statement (sans semicolon) to
     generate the appropriate rtl instructions.  It is used only when
     compiling the end of `main'.

`HAVE_ATEXIT'
     Define this if the target system supports the function `atexit'
     from the ANSI C standard.  If this is not defined, and
     `INIT_SECTION_ASM_OP' is not defined, a default `exit' function
     will be provided to support C++.

`EXIT_BODY'
     Define this if your `exit' function needs to do something besides
     calling an external function `_cleanup' before terminating with
     `_exit'.  The `EXIT_BODY' macro is only needed if netiher
     `HAVE_ATEXIT' nor `INIT_SECTION_ASM_OP' are defined.

`INSN_SETS_ARE_DELAYED (INSN)'
     Define this macro as a C expression that is nonzero if it is safe
     for the delay slot scheduler to place instructions in the delay
     slot of INSN, even if they appear to use a resource set or
     clobbered in INSN.  INSN is always a `jump_insn' or an `insn'; GNU
     CC knows that every `call_insn' has this behavior.  On machines
     where some `insn' or `jump_insn' is really a function call and
     hence has this behavior, you should define this macro.

     You need not define this macro if it would always return zero.

`INSN_REFERENCES_ARE_DELAYED (INSN)'
     Define this macro as a C expression that is nonzero if it is safe
     for the delay slot scheduler to place instructions in the delay
     slot of INSN, even if they appear to set or clobber a resource
     referenced in INSN.  INSN is always a `jump_insn' or an `insn'.
     On machines where some `insn' or `jump_insn' is really a function
     call and its operands are registers whose use is actually in the
     subroutine it calls, you should define this macro.  Doing so
     allows the delay slot scheduler to move instructions which copy
     arguments into the argument registers into the delay slot of INSN.

     You need not define this macro if it would always return zero.

`MACHINE_DEPENDENT_REORG (INSN)'
     In rare cases, correct code generation requires extra machine
     dependent processing between the second jump optimization pass and
     delayed branch scheduling.  On those machines, define this macro
     as a C statement to act on the code starting at INSN.


File: gpc.info,  Node: RTL,  Next: Machine Desc,  Prev: Passes,  Up: Top

RTL Representation
******************

   Most of the work of the compiler is done on an intermediate
representation called register transfer language.  In this language,
the instructions to be output are described, pretty much one by one, in
an algebraic form that describes what the instruction does.

   RTL is inspired by Lisp lists.  It has both an internal form, made
up of structures that point at other structures, and a textual form
that is used in the machine description and in printed debugging dumps.
The textual form uses nested parentheses to indicate the pointers in
the internal form.

* Menu:

* RTL Objects::       Expressions vs vectors vs strings vs integers.
* Accessors::         Macros to access expression operands or vector elts.
* Flags::             Other flags in an RTL expression.
* Machine Modes::     Describing the size and format of a datum.
* Constants::         Expressions with constant values.
* Regs and Memory::   Expressions representing register contents or memory.
* Arithmetic::        Expressions representing arithmetic on other expressions.
* Comparisons::       Expressions representing comparison of expressions.
* Bit Fields::        Expressions representing bitfields in memory or reg.
* Conversions::       Extending, truncating, floating or fixing.
* RTL Declarations::  Declaring volatility, constancy, etc.
* Side Effects::      Expressions for storing in registers, etc.
* Incdec::            Embedded side-effects for autoincrement addressing.
* Assembler::         Representing `asm' with operands.
* Insns::             Expression types for entire insns.
* Calls::             RTL representation of function call insns.
* Sharing::           Some expressions are unique; others *must* be copied.
* Reading RTL::       Reading textual RTL from a file.


File: gpc.info,  Node: RTL Objects,  Next: Accessors,  Prev: RTL,  Up: RTL

RTL Object Types
================

   RTL uses five kinds of objects: expressions, integers, wide integers,
strings and vectors.  Expressions are the most important ones.  An RTL
expression ("RTX", for short) is a C structure, but it is usually
referred to with a pointer; a type that is given the typedef name `rtx'.

   An integer is simply an `int'; their written form uses decimal
digits.  A wide integer is an integral object whose type is
`HOST_WIDE_INT' (*note Config::.); their written form uses decimal
digits.

   A string is a sequence of characters.  In core it is represented as a
`char *' in usual C fashion, and it is written in C syntax as well.
However, strings in RTL may never be null.  If you write an empty
string in a machine description, it is represented in core as a null
pointer rather than as a pointer to a null character.  In certain
contexts, these null pointers instead of strings are valid.  Within RTL
code, strings are most commonly found inside `symbol_ref' expressions,
but they appear in other contexts in the RTL expressions that make up
machine descriptions.

   A vector contains an arbitrary number of pointers to expressions.
The number of elements in the vector is explicitly present in the
vector.  The written form of a vector consists of square brackets
(`[...]') surrounding the elements, in sequence and with whitespace
separating them.  Vectors of length zero are not created; null pointers
are used instead.

   Expressions are classified by "expression codes" (also called RTX
codes).  The expression code is a name defined in `rtl.def', which is
also (in upper case) a C enumeration constant.  The possible expression
codes and their meanings are machine-independent.  The code of an RTX
can be extracted with the macro `GET_CODE (X)' and altered with
`PUT_CODE (X, NEWCODE)'.

   The expression code determines how many operands the expression
contains, and what kinds of objects they are.  In RTL, unlike Lisp, you
cannot tell by looking at an operand what kind of object it is.
Instead, you must know from its context--from the expression code of
the containing expression.  For example, in an expression of code
`subreg', the first operand is to be regarded as an expression and the
second operand as an integer.  In an expression of code `plus', there
are two operands, both of which are to be regarded as expressions.  In
a `symbol_ref' expression, there is one operand, which is to be
regarded as a string.

   Expressions are written as parentheses containing the name of the
expression type, its flags and machine mode if any, and then the
operands of the expression (separated by spaces).

   Expression code names in the `md' file are written in lower case,
but when they appear in C code they are written in upper case.  In this
manual, they are shown as follows: `const_int'.

   In a few contexts a null pointer is valid where an expression is
normally wanted.  The written form of this is `(nil)'.


File: gpc.info,  Node: Accessors,  Next: Flags,  Prev: RTL Objects,  Up: RTL

Access to Operands
==================

   For each expression type `rtl.def' specifies the number of contained
objects and their kinds, with four possibilities: `e' for expression
(actually a pointer to an expression), `i' for integer, `w' for wide
integer, `s' for string, and `E' for vector of expressions.  The
sequence of letters for an expression code is called its "format".
Thus, the format of `subreg' is `ei'.

   A few other format characters are used occasionally:

`u'
     `u' is equivalent to `e' except that it is printed differently in
     debugging dumps.  It is used for pointers to insns.

`n'
     `n' is equivalent to `i' except that it is printed differently in
     debugging dumps.  It is used for the line number or code number of
     a `note' insn.

`S'
     `S' indicates a string which is optional.  In the RTL objects in
     core, `S' is equivalent to `s', but when the object is read, from
     an `md' file, the string value of this operand may be omitted.  An
     omitted string is taken to be the null string.

`V'
     `V' indicates a vector which is optional.  In the RTL objects in
     core, `V' is equivalent to `E', but when the object is read from
     an `md' file, the vector value of this operand may be omitted.  An
     omitted vector is effectively the same as a vector of no elements.

`0'
     `0' means a slot whose contents do not fit any normal category.
     `0' slots are not printed at all in dumps, and are often used in
     special ways by small parts of the compiler.

   There are macros to get the number of operands, the format, and the
class of an expression code:

`GET_RTX_LENGTH (CODE)'
     Number of operands of an RTX of code CODE.

`GET_RTX_FORMAT (CODE)'
     The format of an RTX of code CODE, as a C string.

`GET_RTX_CLASS (CODE)'
     A single character representing the type of RTX operation that code
     CODE performs.

     The following classes are defined:

    `o'
          An RTX code that represents an actual object, such as `reg' or
          `mem'.  `subreg' is not in this class.

    `<'
          An RTX code for a comparison.  The codes in this class are
          `NE', `EQ', `LE', `LT', `GE', `GT', `LEU', `LTU', `GEU',
          `GTU'.

    `1'
          An RTX code for a unary arithmetic operation, such as `neg'.

    `c'
          An RTX code for a commutative binary operation, other than
          `NE' and `EQ' (which have class `<').

    `2'
          An RTX code for a noncommutative binary operation, such as
          `MINUS'.

    `b'
          An RTX code for a bitfield operation, either `ZERO_EXTRACT' or
          `SIGN_EXTRACT'.

    `3'
          An RTX code for other three input operations, such as
          `IF_THEN_ELSE'.

    `i'
          An RTX code for a machine insn (`INSN', `JUMP_INSN', and
          `CALL_INSN').

    `m'
          An RTX code for something that matches in insns, such as
          `MATCH_DUP'.

    `x'
          All other RTX codes.

   Operands of expressions are accessed using the macros `XEXP',
`XINT', `XWINT' and `XSTR'.  Each of these macros takes two arguments:
an expression-pointer (RTX) and an operand number (counting from zero).
Thus,

     XEXP (X, 2)

accesses operand 2 of expression X, as an expression.

     XINT (X, 2)

accesses the same operand as an integer.  `XSTR', used in the same
fashion, would access it as a string.

   Any operand can be accessed as an integer, as an expression or as a
string.  You must choose the correct method of access for the kind of
value actually stored in the operand.  You would do this based on the
expression code of the containing expression.  That is also how you
would know how many operands there are.

   For example, if X is a `subreg' expression, you know that it has two
operands which can be correctly accessed as `XEXP (X, 0)' and `XINT (X,
1)'.  If you did `XINT (X, 0)', you would get the address of the
expression operand but cast as an integer; that might occasionally be
useful, but it would be cleaner to write `(int) XEXP (X, 0)'.  `XEXP
(X, 1)' would also compile without error, and would return the second,
integer operand cast as an expression pointer, which would probably
result in a crash when accessed.  Nothing stops you from writing `XEXP
(X, 28)' either, but this will access memory past the end of the
expression with unpredictable results.

   Access to operands which are vectors is more complicated.  You can
use the macro `XVEC' to get the vector-pointer itself, or the macros
`XVECEXP' and `XVECLEN' to access the elements and length of a vector.

`XVEC (EXP, IDX)'
     Access the vector-pointer which is operand number IDX in EXP.

`XVECLEN (EXP, IDX)'
     Access the length (number of elements) in the vector which is in
     operand number IDX in EXP.  This value is an `int'.

`XVECEXP (EXP, IDX, ELTNUM)'
     Access element number ELTNUM in the vector which is in operand
     number IDX in EXP.  This value is an RTX.

     It is up to you to make sure that ELTNUM is not negative and is
     less than `XVECLEN (EXP, IDX)'.

   All the macros defined in this section expand into lvalues and
therefore can be used to assign the operands, lengths and vector
elements as well as to access them.


File: gpc.info,  Node: Flags,  Next: Machine Modes,  Prev: Accessors,  Up: RTL

Flags in an RTL Expression
==========================

   RTL expressions contain several flags (one-bit bitfields) that are
used in certain types of expression.  Most often they are accessed with
the following macros:

`MEM_VOLATILE_P (X)'
     In `mem' expressions, nonzero for volatile memory references.
     Stored in the `volatil' field and printed as `/v'.

`MEM_IN_STRUCT_P (X)'
     In `mem' expressions, nonzero for reference to an entire
     structure, union or array, or to a component of one.  Zero for
     references to a scalar variable or through a pointer to a scalar.
     Stored in the `in_struct' field and printed as `/s'.

`REG_LOOP_TEST_P'
     In `reg' expressions, nonzero if this register's entire life is
     contained in the exit test code for some loop.  Stored in the
     `in_struct' field and printed as `/s'.

`REG_USERVAR_P (X)'
     In a `reg', nonzero if it corresponds to a variable present in the
     user's source code.  Zero for temporaries generated internally by
     the compiler.  Stored in the `volatil' field and printed as `/v'.

`REG_FUNCTION_VALUE_P (X)'
     Nonzero in a `reg' if it is the place in which this function's
     value is going to be returned.  (This happens only in a hard
     register.)  Stored in the `integrated' field and printed as `/i'.

     The same hard register may be used also for collecting the values
     of functions called by this one, but `REG_FUNCTION_VALUE_P' is zero
     in this kind of use.

`SUBREG_PROMOTED_VAR_P'
     Nonzero in a `subreg' if it was made when accessing an object that
     was promoted to a wider mode in accord with the `PROMOTED_MODE'
     machine description macro (*note Storage Layout::.).  In this
     case, the mode of the `subreg' is the declared mode of the object
     and the mode of `SUBREG_REG' is the mode of the register that
     holds the object.  Promoted variables are always either sign- or
     zero-extended to the wider mode on every assignment.  Stored in
     the `in_struct' field and printed as `/s'.

`SUBREG_PROMOTED_UNSIGNED_P'
     Nonzero in a `subreg' that has `SUBREG_PROMOTED_VAR_P' nonzero if
     the object being referenced is kept zero-extended and zero if it
     is kept sign-extended.  Stored in the `unchanging' field and
     printed as `/u'.

`RTX_UNCHANGING_P (X)'
     Nonzero in a `reg' or `mem' if the value is not changed.  (This
     flag is not set for memory references via pointers to constants.
     Such pointers only guarantee that the object will not be changed
     explicitly by the current function.  The object might be changed by
     other functions or by aliasing.)  Stored in the `unchanging' field
     and printed as `/u'.

`RTX_INTEGRATED_P (INSN)'
     Nonzero in an insn if it resulted from an in-line function call.
     Stored in the `integrated' field and printed as `/i'.  This may be
     deleted; nothing currently depends on it.

`SYMBOL_REF_USED (X)'
     In a `symbol_ref', indicates that X has been used.  This is
     normally only used to ensure that X is only declared external
     once.  Stored in the `used' field.

`SYMBOL_REF_FLAG (X)'
     In a `symbol_ref', this is used as a flag for machine-specific
     purposes.  Stored in the `volatil' field and printed as `/v'.

`LABEL_OUTSIDE_LOOP_P'
     In `label_ref' expressions, nonzero if this is a reference to a
     label that is outside the innermost loop containing the reference
     to the label.  Stored in the `in_struct' field and printed as `/s'.

`INSN_DELETED_P (INSN)'
     In an insn, nonzero if the insn has been deleted.  Stored in the
     `volatil' field and printed as `/v'.

`INSN_ANNULLED_BRANCH_P (INSN)'
     In an `insn' in the delay slot of a branch insn, indicates that an
     annulling branch should be used.  See the discussion under
     `sequence' below.  Stored in the `unchanging' field and printed as
     `/u'.

`INSN_FROM_TARGET_P (INSN)'
     In an `insn' in a delay slot of a branch, indicates that the insn
     is from the target of the branch.  If the branch insn has
     `INSN_ANNULLED_BRANCH_P' set, this insn should only be executed if
     the branch is taken.  For annulled branches with this bit clear,
     the insn should be executed only if the branch is not taken.
     Stored in the `in_struct' field and printed as `/s'.

`CONSTANT_POOL_ADDRESS_P (X)'
     Nonzero in a `symbol_ref' if it refers to part of the current
     function's "constants pool".  These are addresses close to the
     beginning of the function, and GNU CC assumes they can be addressed
     directly (perhaps with the help of base registers).  Stored in the
     `unchanging' field and printed as `/u'.

`CONST_CALL_P (X)'
     In a `call_insn', indicates that the insn represents a call to a
     const function.  Stored in the `unchanging' field and printed as
     `/u'.

`LABEL_PRESERVE_P (X)'
     In a `code_label', indicates that the label can never be deleted.
     Labels referenced by a non-local goto will have this bit set.
     Stored in the `in_struct' field and printed as `/s'.

`SCHED_GROUP_P (INSN)'
     During instruction scheduling, in an insn, indicates that the
     previous insn must be scheduled together with this insn.  This is
     used to ensure that certain groups of instructions will not be
     split up by the instruction scheduling pass, for example, `use'
     insns before a `call_insn' may not be separated from the
     `call_insn'.  Stored in the `in_struct' field and printed as `/s'.

   These are the fields which the above macros refer to:

`used'
     Normally, this flag is used only momentarily, at the end of RTL
     generation for a function, to count the number of times an
     expression appears in insns.  Expressions that appear more than
     once are copied, according to the rules for shared structure
     (*note Sharing::.).

     In a `symbol_ref', it indicates that an external declaration for
     the symbol has already been written.

     In a `reg', it is used by the leaf register renumbering code to
     ensure that each register is only renumbered once.

`volatil'
     This flag is used in `mem', `symbol_ref' and `reg' expressions and
     in insns.  In RTL dump files, it is printed as `/v'.

     In a `mem' expression, it is 1 if the memory reference is volatile.
     Volatile memory references may not be deleted, reordered or
     combined.

     In a `symbol_ref' expression, it is used for machine-specific
     purposes.

     In a `reg' expression, it is 1 if the value is a user-level
     variable.  0 indicates an internal compiler temporary.

     In an insn, 1 means the insn has been deleted.

`in_struct'
     In `mem' expressions, it is 1 if the memory datum referred to is
     all or part of a structure or array; 0 if it is (or might be) a
     scalar variable.  A reference through a C pointer has 0 because
     the pointer might point to a scalar variable.  This information
     allows the compiler to determine something about possible cases of
     aliasing.

     In an insn in the delay slot of a branch, 1 means that this insn
     is from the target of the branch.

     During instruction scheduling, in an insn, 1 means that this insn
     must be scheduled as part of a group together with the previous
     insn.

     In `reg' expressions, it is 1 if the register has its entire life
     contained within the test expression of some loop.

     In `subreg' expressions, 1 means that the `subreg' is accessing an
     object that has had its mode promoted from a wider mode.

     In `label_ref' expressions, 1 means that the referenced label is
     outside the innermost loop containing the insn in which the
     `label_ref' was found.

     In `code_label' expressions, it is 1 if the label may never be
     deleted.  This is used for labels which are the target of
     non-local gotos.

     In an RTL dump, this flag is represented as `/s'.

`unchanging'
     In `reg' and `mem' expressions, 1 means that the value of the
     expression never changes.

     In `subreg' expressions, it is 1 if the `subreg' references an
     unsigned object whose mode has been promoted to a wider mode.

     In an insn, 1 means that this is an annulling branch.

     In a `symbol_ref' expression, 1 means that this symbol addresses
     something in the per-function constants pool.

     In a `call_insn', 1 means that this instruction is a call to a
     const function.

     In an RTL dump, this flag is represented as `/u'.

`integrated'
     In some kinds of expressions, including insns, this flag means the
     rtl was produced by procedure integration.

     In a `reg' expression, this flag indicates the register containing
     the value to be returned by the current function.  On machines
     that pass parameters in registers, the same register number may be
     used for parameters as well, but this flag is not set on such uses.

