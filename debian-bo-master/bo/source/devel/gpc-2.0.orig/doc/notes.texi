@node GPC notes
@chapter GPC---Gnu Pascal Random Notes

@itemize @bullet
@item
a bison parser for GPC

(the parser is a ISO 7185 standard pascal parser
with extensions (like casts, type of, address of vars,
inline, return, break, continue, otherwise and so on@dots{})

@item
code (glue) that can be used to convert the Pascal way of
defining things to use routines in a modified @code{c-decl.c}.
This mainly does re-ordering of the data structures. The glue
lives in @code{gpc-parser.y} or in @code{gpc-util.c}.

@item
VAR parameters for Pascal routines

Now done with REFERENCE_TYPE. Until the REFERENCE_TYPE is
implemented as in C++, I just get rid of this type as soon
as possible by converting it to POINTER_TYPE in as few places
as possible. Currently affects @code{gpc-parse.y}, 
@code{actualparameterlist()} and @code{default_conversion()}.

@item
redeclaration of standard identifiers (NOT reserved words)
This requires a change in @code{tree.def} sometime in the future;
currently I am mis-using Tiemann's FRIEND_DECL TREECODE
which looks exactly like my KNOWNID_DECL would look like.
So maybe there is no need to add it at all for Pascal.

@item
run time system & routines that generate calls to the rts.
The old one Antti Louko & I originally wrote back in -85
when I ported another Pascal compiler (Pax) to BSD Vax.
Pax compiler is written in Pascal, and it runs on Twenex
and Unix. (Very good error reporting capabilities.)
More info on request.

@item
WITH statement should work properly. No information of
WITH is currently given to the debugger.

@item
variant records

These should work. Added routine find_field() that returns a
chain of TREE_LIST nodes and modified build_component_ref() to
work as follows: When @code{gpc-parse.y} builds a variant record, it
constructs an unnamed RECORD_TYPE containing the possible variant
selector field and an unnamed UNION_TYPE node. @code{When find_field()}
sees unnamed RECORD_TYPE or UNION_TYPE nodes implicitely
propagates to the inner layer of the definition. It then returns
the TREE_LIST chain of this propagation and this is modified to a
series of build(COMPONENT_REF,...) for all propagated RECORD_TYPE
nodes, which the rest of gcc will handle. This does NOT YET check
variant access errors...  When thinking about it, it does not
check very many other things either, so maybe no one will notice
this :-)

@item
Arrays with non-zero lower bound

Required some changes to @code{expr.c.}
@end itemize

