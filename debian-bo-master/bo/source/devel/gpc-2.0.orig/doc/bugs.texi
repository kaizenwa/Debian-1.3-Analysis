@node GPC Bugs
@chapter Known bugs and inconveniences; how to report bugs

@c Last modification by Juki <jtv@@hut.fi>:
@c   Sat Mar 25 21:13:27 1995
@c Last modification by Peter <peter.gerwinski@uni-essen.de>: 
@c   Sun 22. September 1996

The GNU Pascal Compiler (GPC) does not yet implement the whole ISO 10206
Extended Pascal standard, not even the whole ISO 7185 Pascal standard.
It is only partially compatible to Borland Pascal and implements only
some isolated features from the PXSC standard.  Furthermore, there are
@emph{lots} of known bugs which will take a long time to be fixed.  (Any
help welcome!)  Please take this into account when you consider using
GPC for any purpose.

If you encounter a bug with GPC, please check whether it is one of the
known bugs.  If not, report it to the GNU Pascal mailing list
@code{gpc@@hut.fi}.  (But always report it if you solve the problem! ;-)

@c See the file @samp{version.c} to find out the version number of this GPC
@c (or run @code{gpc -v})
@c
@c The GPC version number is documented somewhere else in this
@c documentation. -- PG, 22. Sept. 1996


@section General bugs

@itemize @bullet

@item
High optimization levels do not work properly on the Alpha.  Some
conformance tests @emph{fail} when compiled with @samp{-O6} flag, which
means that the compiler generates invalid code. Don't use this flag in
the Alpha before the problem gets fixed.  It might have something to do
with automatic inlining, but I have not yet looked at this. @samp{-O}
flag should be ok.  (Also take care when using explicit inline
functions.)

@item
Run time errors are not checked.

@item
For some reason the pascal main program does not get lineno stabs, so it
is hard to debug it with @samp{gdb} @dots{}

@item
Modules and Units export everything, not just the stuff in the export
interfaces.  However, the unexported variables and functions are
invisible to modules @emph{in other files}.

@strong{Workaround:}
Put each Module or Unit in its own source file and compile it
separately.

@item
The @code{GPI} mechanism crashes when compiling some Modules, for
example the @code{System} module by Berend de Boer.

@strong{Workaround:}
Include the Unit or Module into the main program's source:
@smallexample
  (*$I MyModule *)

  Program MyProg;

  uses
    MyModule;

  ...
@end smallexample

@item
When @code{gpc} is invoked for linking only, it crashes on some
systems.

@strong{Workaround:} Use @code{gcc} instead of @code{gpc} for
linking:
@smallexample
  gpc -c hello.pas
  gcc -o hello hello.o -lm -lgpc
@end smallexample

@item
Temporary @code{.gpc} files are not removed after compilation.

@item
The inline set operations have some problems with operations on two sets
if the sets do not contain equally many segments.

@item
In addition, the set code generated in the Alpha causes runtime errors
in the generated code.

@item
There are some bugs with mathematical functions.  GPC fails, for
example, the ``Paranoia'' test.

@item
The main program name is not capitalized.  It may clash with libc
identifiers which may be important but invisible for the program, e.g.
@samp{log}.

@end itemize


@section Standard Pascal

@itemize @bullet

@c Functions returning string schema types do not work
@c (they are called about three times where they should be called
@c once)
@c
@c Eliminated. -- PG, July/Aug. 1996

@item
Type checking is mostly what C does, not what Pascal requires, so GPC
does not yet implement a strongly typed language.  Although correct
programs compile, incorrect ones compile also.

@c No GPC texinfo file exists yet. See GPC.GUIDE instead.
@c ;-) -- PG, 4./5. Aug. 1996

@item
Conformant arrays don't yet work (in general).  Until they do, GPC is a
Level-0 Standard Pascal compiler.  

@end itemize


@section Extended Pascal

@itemize @bullet

@item
Schema types are not yet implemented; only String schemas work 
(well @dots{} sometimes).

@item
String schemas as formal value parameters do not work.

@strong{Workaround:}
Pass string types with specified capacity instead, i.e. use
@smallexample
  Type
    WrkString = String ( 80 );

  Procedure Foo ( S: WrkString );
@end smallexample
instead of
@smallexample
  Procedure Foo ( S: String );
@end smallexample

@item
Initialized Strings and structured variables are not yet implemented.

@item
Illegal substrings let crash the compiler rather than triggering an
error message:
@smallexample
  str:='1234567890';
  i:=8; j:=13;
  str:=str[i..j];
@end smallexample

@item
The @samp{Index} function does not work when the pattern is a char:
@smallexample
  Var 
    C: Char;
    S: String ( 80 );
    i: Integer;

  ...

  i:= Index ( s, c );  (* "i" always zero *)
@end smallexample
It works with @samp{Var C: String ( 1 );}

@end itemize


@section Borland Pascal

@xref{Borland Pascal}QuickStart Guide for Borland Pascal users.

@itemize @bullet

@item
Strings are implemented in a completely different way.  They are
not limited to 255 characters with the length being in position
zero, but they are ``Schema types'' which is something more 
complicated.

@item
Most of Borland Pascal's System Unit is not implemented, e.g.
@samp{Byte}, @samp{Pointer}, @samp{LongInt}, @samp{move},
@samp{FillChar}, @samp{BlockRead}, @samp{BlockWrite}, @samp{Assign},
String-related functions, @dots{}

@strong{Workaround:}
Some of the missing data types, procedures and functions are implemented
in a separate compatibility Unit.  Check the @code{contrib} subdirectory
of your GPC distribution.

@item
Initialized Strings are not yet implemented; initialized structured
variables do not yet work in all cases.

@c @item
@c @samp{Case} has no @samp{else}, but @samp{otherwise}.
@c
@c Added "else".  PG, 27 Oct 1996

@item
Chars like @samp{#13} or @samp{^M} do not work.  Use @samp{chr ( 13 )} 
instead.

@c @item
@c Untyped parameters are @samp{Procedure foo ( Var Bar: Void );}, not
@c (yet) @samp{Procedure foo ( Var Bar );}.  When using them, GPC gives
@c a warning; code works.
@c
@c Fixed.  PG, 27 Oct 1996

@item
The inline assember does not follow Borland syntax.

@item
There is no @samp{private} directive for Objects yet.

@item
There are no ``Procedural types'' but @emph{pointers} to procedures
instead.

@item
There is no @samp{Inline} in Borland sense.

@end itemize


@section GNU Extensions

@itemize @bullet

@item
The Run Time System (RTS) does not know about modified types such
as @samp{__byte__} or @samp{__unsigned__ Integer}s or @samp{__long__
Real}s.  Especially, you cannot @samp{writeln} such variables.

@strong{Workaround:} Cast them to their basis type before 
@samp{writeln}, e.g.
@smallexample
  Type
    Extended = __long__ Real;

  Var
    foo: Extended;

  [...]

  writeln ( Real ( foo ) );
@end smallexample

@end itemize


@section Inconveniences

@itemize @bullet

@item
@samp{New} and @samp{Dispose} optional tag field arguments are ignored
(warning given, code works).

@item
@samp{Gdb} does not yet understand pascal sets, files or subranges.  Now
@samp{gdb} allows you to debug these things, even though it does not yet
understand some stabs.

@item
@samp{Packed} does not pack. (Implementation dependent, warning given,
code works.)

@item
Files of integer subranges that would fit in a byte do not; instead they
are handled as files of integer.  This is especially annoying with
@samp{file of 0..255}.

@end itemize


@section Notes for debugging

@itemize @bullet

@item
Forward referencing pointers generate @samp{dbx} style debugging symbols
by outputting the @samp{.stabs} as an unknown pointer and later it just
outputs the same @samp{.stabs} again, but this time it also tells what
type the pointer points to.  This seems to work for @samp{gdb}. As of
this writing I have not checked what happens with @samp{sdb} type
debugging info.  It might be that the pointer is left to be a
@code{(void *)} pointer, so you have to cast it in order to output the
object the pointer points to.

Also, we have not tried any other debugger than @samp{gdb}.  If you do,
please let us know what happens.

I think that GDB does not yet support the kind of @samp{.stabs}
that should be used to do this correctly:

@smallexample
  .stabs ":t@var{anumber}=@var{bnumber}", @var{whatever}
@end smallexample

where @var{anumber} is the unknown pointer type referenced earlier, and
the @var{bnumber} is the type which @var{anumber} actually is.  This
construct is not required in C.

@item
When debugging, please note that the Initial Letter In Each Identifier
Is In Upper Case And The Rest Are In Lower Case.  If you wish to call
C-routines declare them with the ``C'' directive, as follows:

@smallexample
Procedure FooBAR(i:integer);c;
@end smallexample

This makes the external name to be @samp{_foobar}
(replace @code{_} with you machine prefix.)

@smallexample
Procedure FooBAR(i:Integer); External;
@end smallexample

Uses external name @code{_Foobar}.

It is done like this to reduce name clashes	
with @samp{libc.a} and other possible libraries.

@item
All visible GPC runtime system library routines are
named @code{_p_@dots{}}.

@item
However, the main program name is not capitalized.  (This is a kludge;
see above.)

@end itemize
