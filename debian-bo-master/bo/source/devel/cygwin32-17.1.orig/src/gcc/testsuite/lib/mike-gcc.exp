# Copyright (C) 1988, 90-92, 1995, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# This file was derived from mike-g++.exp written by Mike Stump <mrs@cygnus.com>

# Please email any bugs, comments, and/or additions to this file to:
# bug-gcc@prep.ai.mit.edu

#
# mike_cleanup -- remove any files that are created by the testcase
#
proc mike_cleanup { src_code } {
    # We do the existence test first because it's a lot faster and in a
    # large percentage of cases the file won't exist.
    if [file exists [file rootname [file tail $src_code]].o] {
	execute_anywhere "rm -f [file rootname [file tail $src_code]].o"
    }
    if [file exists [file rootname [file tail $src_code]].s] {
	execute_anywhere "rm -f [file rootname [file tail $src_code]].s"
    }
}

#
# prebase -- sets up a Mike Stump (mrs@cygnus.com) style G++ test
#
proc prebase { } {
    global compiler_output
    global not_compiler_output
    global compiler_result
    global not_compiler_result
    global program_output
    global groups
    global run 
    global actions
    global target_regexp
    global CFLAGS
    global ORIG_CFLAGS
    global LIBS
    global ORIG_LIBS

    if ![info exists LIBS] then {
	set LIBS ""
    }
    set compiler_output "^$"
    set not_compiler_output ".*Internal compiler error.*"
    set compiler_result ""
    set not_compiler_result ""
    set program_output ".*PASS.*"
    set groups {}
    set run no
    set actions assemble
    set target_regexp ".*"
    set ORIG_CFLAGS $CFLAGS
    set ORIG_LIBS $LIBS
}

#
# run the test
#
proc postbase  { src_code run groups } {
    global verbose
    global srcdir
    global CFLAGS
    global ORIG_CFLAGS
    global LIBS
    global ORIG_LIBS
    global subdir
    global comp_output
    global exec_output
    global not_compiler_output
    global compiler_output
    global compiler_result
    global not_compiler_result
    global program_output
    global actions
    global target_regexp
    global host_triplet
    global target_triplet
    global tool

    if ![regexp $target_regexp $target_triplet] {
	set CFLAGS $ORIG_CFLAGS
	set LIBS $ORIG_LIBS
	unsupported $subdir/$src_code
	return
    }

    set fail_message $subdir/$src_code
    set pass_message $subdir/$src_code
    
    if [info exists GROUP] then {
	if {[lsearch $groups $GROUP] == -1} then {
	    return
	}
    }

    if [string match $run yes] then {
	set actions run
    }

    case $actions {
      compile
	      { append CFLAGS " -S" }
      assemble
	      { append CFLAGS " -c" }
      run
	      { set run yes }
    }
    
    gcc_start $srcdir/$subdir/$src_code
    set CFLAGS $ORIG_CFLAGS
    set LIBS $ORIG_LIBS
    
    set pass no

    # Delete things like "ld.so warning" messages.
    set comp_output [prune_warnings $comp_output]
    
    if [regexp -- $not_compiler_output $comp_output] then {
	if $verbose>1 then {
	    send_user "\nChecking:\n$not_compiler_output\nto make sure it does not match:\n$comp_output\nbut it does.\n\n"
	} else {
	    send_log "\nCompiler output:\n$comp_output\n\n"
	}
	fail $fail_message
	# The framework doesn't like to see any error remnants,
	# so remove them.
	uplevel {
	    if [info exists errorInfo] then {
		unset errorInfo
	    }
	}
	mike_cleanup $src_code
	return
    }

    # remove any leftover CRs.
    regsub -all -- "\r" $comp_output "" comp_output

    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output

    set unsupported_message [${tool}_check_unsupported_p $comp_output]
    if { $unsupported_message != "" } {
	unsupported "$subdir/$src_code: $unsupported_message"
	mike_cleanup $src_code
	return
    }

    if { $verbose > 1 } {
	send_user "\nChecking:\n$compiler_output\nto see if it matches:\n$comp_output\n"
    } else {
	send_log "\nCompiler output:\n$comp_output\n\n"
    }
    if [regexp -- $compiler_output $comp_output] {
	if $verbose>1 then {
	    send_user "Yes, it matches.\n\n"
	}
	set pass yes
	if [file exists [file rootname [file tail $src_code]].s] {
	    set fd [open [file rootname [file tail $src_code]].s r]
	    set dot_s [read $fd]
	    close $fd
	    if { $compiler_result != "" } {
		verbose "Checking .s file for $compiler_result" 2
		if [regexp -- $compiler_result $dot_s] {
		    verbose "Yes, it matches." 2
		} else {
		    verbose "Nope, doesn't match." 2
		    verbose $dot_s 4
		    set pass no
		}
	    }
	    if { $not_compiler_result != "" } {
		verbose "Checking .s file for not $not_compiler_result" 2
		if ![regexp -- $not_compiler_result $dot_s] {
		    verbose "Nope, not found (that's good)." 2
		} else {
		    verbose "Uh oh, it was found." 2
		    verbose $dot_s 4
		    set pass no
		}
	    }
	}
	if [string match $run yes] {
	    gcc_load ./a.out
            if ![info exists exec_output] {
		mike_cleanup $src_code
                return
            }
	    set loaded yes
#	    execute_anywhere "rm -f ./a.out"
	    if { $verbose > 1 } {
		send_user "Checking:\n$program_output\nto see if it matches:\n$exec_output\n\n"
	    }
	    if ![regexp -- $program_output $exec_output] {
		set pass no
		if { $verbose > 1 } {
		    send_user "Nope, does not match.\n\n"
		}
	    } else {
		if { $verbose > 1 } {
		    send_user "Yes, it matches.\n\n"
		}
	    }
	}
    } else {
	if { $verbose > 1 } {
	    send_user "Nope, does not match.\n\n"
	}
    }
    
    if [string match $pass "yes"] {
	pass $pass_message
    } else {
	fail $fail_message
    }

    execute_anywhere "rm -f ./a.out"
    # The framework doesn't like to see any error remnants,
    # so remove them.
    uplevel {
	if [info exists errorInfo] {
	    unset errorInfo
	}
    }

    mike_cleanup $src_code
}

