# Copyright (C) 1994, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Please email any bugs, comments, and/or additions to this file to:
# bug-gcc@prep.ai.mit.edu

# This file was written by J.T. Conklin. (jtc@cygnus.com)

#
# load support libraries
#
load_lib ${tool}.exp
load_lib remote.exp

# set target variables only if needed
global targetname
global connectmode
global passwd
global env

if ![info exists targetname] then {
    if [info exists env(TARGETNAME)] then {
	set targetname $env(TARGETNAME)
    } else {
	puts stderr "ERROR: Need a name for netware target."
	puts stderr "       Use the --name option"
	exit 1
    }
}


global LD
if ![info exists LD] then {
    set LD [findfile "$rootme/../ld/ld.new" "$rootme/../ld/ld.new" [transform "ld"]]
}

global NLMCONV
if ![info exists NLMCONV] then {
    set NLMCONV [findfile "$rootme/../binutils/nlmconv"]
}

#
# ${tool}_version -- extract and print the version number of gcc/g++
#

proc ${tool}_version {} {
    global tool
    default_${tool}_version
}

#
# ${tool}_start -- compile a program
#

proc ${tool}_start { prog } {
    global tool
    default_${tool}_start $prog
}

#
# ${tool}_load -- load the program and execute it
#
# See default.exp for explanation of arguments and results.
#

proc ${tool}_load { prog } {
    global LD NLMCONV
    global shell_id
    global exec_output
    global tmpdir
    global errorCode
    global shell_prompt
    global targetname

    set exec_output ""

    if $shell_id<0 then {
	verbose -log "$prog not executed because there is no target" 3
	return "untested"
    }

    # 
    set exe [file tail $prog]
    
    # We can't blindly append a suffix to the object name, because the
    # result may not be valid on netware's 8.3 filesystem.
    set nlm "$tmpdir/x.nlm"
    set lnk "$tmpdir/x.lnk"

    # build *.lnk file
    set fd [open $lnk w]
    puts $fd "description \"$exe\""
    puts $fd "screenname \"System Console\""
    puts $fd "module clib.nlm"
    puts $fd "module mathlib.nlm"
    puts $fd "stack 65536"
    puts $fd "debug"
    # FIXME: don't hardcode location of prelude.o
    puts $fd "input /s1/cygnus/dejagnu/i386-netware/lib/prelude.o"
    puts $fd "input $prog"
    puts $fd "output $nlm"
    close $fd

    # run nlmconv
    verbose "Executing: $NLMCONV -l$LD -T$lnk" 1
    catch "exec $NLMCONV -l$LD -T$lnk" output
    if ![string match "" $output] then {
	verbose $output 1
    }
    if ![string match "NONE" $errorCode] {
	verbose -log "Can't link $prog" 3
	return "fail"
    }

    # download
    verbose "Downloading $nlm" 1
    catch "exec cp $nlm /.NetWare/$targetname.nws/sys.nwv/tmp/x.nlm" output
    if ![string match "" $output] then {
	verbose $output 1
	verbose -log "cp failed for $nlm" 3
	return "unresolved"
    }

    # Wait a second for the file to "settle" on the NetWare server.
    # I've encountered unexplained failures without this delay.
#    sleep 1


    # The NetWare remote console expects to be connected to a vt100
    # compatible terminal.  It isn't very efficent, and it seems to
    # send screen repaints for no reason.  So we have to clear the
    # screen as we run each test, otherwise a shell prompt or abort
    # message from a previous test could cause incorrect results.
    send -i $shell_id "CLS\r\n"
    set timeout 1
    expect {
	-i $shell_id -re "$shell_prompt" {
	    exp_continue
	}
    }
    set timeout 10


    # Netware does not support exit status.  The best we can do to
    # detect failures is to look for the "ABNORMAL NLM TERMINATION"
    # message printed by abort().
    set ret 0
    send -i $shell_id "LOAD X.NLM\r\n"
    expect {
	-i $shell_id "ABNORMAL NLM TERMINATION" {
	    set ret 1
	    exp_continue
	}
	-i $shell_id "Unable to find load file" {
	    perror "Couldn't execute program"
	    verbose -log "Couldn't execute program" 3
	    return "unresolved"
	}
	-i $shell_id timeout {
	    perror "Couldn't execute program (timed out)"
	    verbose -log "Couldn't execute program (timed out)" 3
	    return "unresolved"
	}
	-i $shell_id -re "[format "%sLOAD" $shell_prompt]" {
	    exp_continue
	}
	-i $shell_id -re "$shell_prompt" {}
    }

    catch [exec rm -f $lnk]
    catch [exec rm -f $nlm]

    if { $ret == 0 } {
	return "pass"
    } else {
	return "fail"
    }
}

#
# ${tool}_exit -- shutdown the connection
#

proc ${tool}_exit {} {
    global shell_id
    exit_remote_shell $shell_id
}

#
# start the remote shell
# `shell_id' is local to this file.
#

set shell_id -1
if [ istarget "i386-unknown-netware*" ] {
    set shell_prompt "Password:"
    set shell_id [ eval $connectmode "$targetname" ]
    if $shell_id<0 then {
	warning "Couldn't connect to target"
	return -1
    }

    if [string match "" $passwd] then {
	stty -echo
	send_user "Password: "
	expect_user -re "(.*)\n"
	send_user "\n"
	set passwd "$expect_out(1,string)"
	stty echo
    }

    send -i $shell_id "$passwd\n"
    expect {
	-i $shell_id ":" {
	    verbose "Got termtype prompt" 0
	}

	-i $shell_id timeout {
	    warning "Connection timed out"
	    return -1
	}
    }


    set shell_prompt "[string toupper $targetname]:"
    send -i $shell_id "1\n"

    expect {
	-i $shell_id -re "$shell_prompt" {}
	-i $shell_id timeout {
	    warning "Connection timed out"
	    return -1
	}
    }
}
