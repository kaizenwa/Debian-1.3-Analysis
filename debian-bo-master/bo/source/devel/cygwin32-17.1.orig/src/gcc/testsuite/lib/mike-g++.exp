# Copyright (C) 1988, 90-92, 1995, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# This file was written by Mike Stump <mrs@cygnus.com>

# Please email any bugs, comments, and/or additions to this file to:
# bug-g++@prep.ai.mit.edu

# This should have already been loaded by the config file (eg: unix.exp).
#load_lib g++.exp

#
# mike_cleanup -- remove any files that are created by the testcase
#
proc mike_cleanup { src_code output_file assembly_file } {
    # We do the existence test first because it's a lot faster and in a
    # large percentage of cases the file won't exist.
    if [file exists $output_file] {
	execute_anywhere "rm -f $output_file"
    }
    if [file exists $assembly_file] {
	execute_anywhere "rm -f $assembly_file"
    }
}

#
# prebase -- sets up a Mike Stump (mrs@cygnus.com) style G++ test
#
proc prebase { } {
    global compiler_output
    global not_compiler_output
    global compiler_result
    global not_compiler_result
    global program_output
    global groups
    global run 
    global actions
    global target_regexp
    global CXXFLAGS
    global ORIG_CXXFLAGS
    global LIBS
    global ORIG_LIBS

    if ![info exists LIBS] then {
	set LIBS ""
    }
    set compiler_output "^$"
    set not_compiler_output ".*Internal compiler error.*"
    set compiler_result ""
    set not_compiler_result ""
    set program_output ".*PASS.*"
    set groups {}
    set run no
    set actions assemble
    set target_regexp ".*"
    set ORIG_CXXFLAGS $CXXFLAGS
    set ORIG_LIBS $LIBS

    g++_init
}

#
# run the test
#
proc postbase  { src_code run groups } {
    global verbose
    global srcdir
    global CXXFLAGS
    global ORIG_CXXFLAGS
    global LIBS
    global ORIG_LIBS
    global subdir
    global comp_output
    global exec_output
    global not_compiler_output
    global compiler_output
    global compiler_result
    global not_compiler_result
    global program_output
    global actions
    global target_regexp
    global host_triplet
    global target_triplet
    global tool
    global runshlib
    global mathlib
    global tmpdir

    if ![regexp $target_regexp $target_triplet] {
	set CXXFLAGS $ORIG_CXXFLAGS
	set LIBS $ORIG_LIBS
	unsupported $subdir/$src_code
	return
    }

    set fail_message $subdir/$src_code
    set pass_message $subdir/$src_code
    
    if [info exists GROUP] then {
	if {[lsearch $groups $GROUP] == -1} {
	    return
	}
    }

    if ![info exists tmpdir] {
	set tmpdir "/tmp";
    }

    if [string match $run yes] {
        set actions run
    }

    set output_file "$tmpdir/[file tail [file rootname $src_code]]"
    set assembly_file "$output_file"
    append assembly_file ".S"

    # runshlib and mathlib are set in g++_init
    case $actions {
	compile
		{ append CXXFLAGS " -S"
		  append output_file ".S"; }
	assemble
		{ append CXXFLAGS " -c" 
		  append output_file ".o" }
	link
		{ append LIBS "  -lstdc++ $mathlib" ;
		  set output_file "$tmpdir/a.out" }
	run
		{ append LIBS " $runshlib -lstdc++ $mathlib"
		  set output_file "$tmpdir/a.out"
 		  set run yes }
    }
    
    append CXXFLAGS " -o $output_file"
    g++_start $srcdir/$subdir/$src_code
    set CXXFLAGS $ORIG_CXXFLAGS
    set LIBS $ORIG_LIBS
    
    set pass no

    # Delete things like "ld.so warning" messages.
    set comp_output [prune_system_crud $host_triplet $comp_output]
    
    if [regexp -- $not_compiler_output $comp_output] {
	if { $verbose > 1 } {
	    send_user "\nChecking:\n$not_compiler_output\nto make sure it does not match:\n$comp_output\nbut it does.\n\n"
	} else {
	    send_log "\nCompiler output:\n$comp_output\n\n"
	}
	fail $fail_message
	# The framework doesn't like to see any error remnants,
	# so remove them.
	uplevel {
	    if [info exists errorInfo] {
		unset errorInfo
	    }
	}
	mike_cleanup $src_code $output_file $assembly_file
	return
    }
    
    # remove any leftover CRs.
    regsub -all -- "\r" $comp_output "" comp_output

    regsub -all "(^|\n)\[^\n\]*linker input file unused since linking not done" $comp_output "" comp_output
    regsub -all "(^|\n)\[^\n\]*file path prefix \[^\n\]* never used" $comp_output "" comp_output

    set unsupported_message [${tool}_check_unsupported_p $comp_output]
    if { $unsupported_message != "" } {
	unsupported "$subdir/$src_code: $unsupported_message"
	mike_cleanup $src_code $output_file $assembly_file
	return
    }

    if { $verbose > 1 } {
	send_user "\nChecking:\n$compiler_output\nto see if it matches:\n$comp_output\n"
    } else {
	send_log "\nCompiler output:\n$comp_output\n\n"
    }
    if [regexp -- $compiler_output $comp_output] {
	if { $verbose > 1 } {
	    send_user "Yes, it matches.\n\n"
	}
	set pass yes
	if [file exists [file rootname [file tail $src_code]].s] {
	    set fd [open [file rootname [file tail $src_code]].s r]
	    set dot_s [read $fd]
	    close $fd
	    if { $compiler_result != "" } {
		verbose "Checking .s file for $compiler_result" 2
		if [regexp -- $compiler_result $dot_s] {
		    verbose "Yes, it matches." 2
		} else {
		    verbose "Nope, doesn't match." 2
		    verbose $dot_s 4
		    set pass no
		}
	    }
	    if { $not_compiler_result != "" } {
		verbose "Checking .s file for not $not_compiler_result" 2
		if ![regexp -- $not_compiler_result $dot_s] {
		    verbose "Nope, not found (that's good)." 2
		} else {
		    verbose "Uh oh, it was found." 2
		    verbose $dot_s 4
		    set pass no
		}
	    }
	}
	if [string match $run yes] {
	    set status [g++_load $output_file]
	    switch -- $status {
		0 { } # nothing to do, we care what happened with it
		-1 { mike_cleanup $src_code $output_file $assembly_file
		     return }
	    }
	    if ![info exists exec_output] {
		mike_cleanup $src_code $output_file $assembly_file
		return
	    }
	    set loaded yes
#	    execute_anywhere "rm -f $output_file"
	    if { $verbose > 1 } {
		send_user "Checking:\n$program_output\nto see if it matches:\n$exec_output\n\n"
	    }
	    if ![regexp -- $program_output $exec_output] then {
		set pass no
		if { $verbose > 1 } {
		    send_user "Nope, does not match.\n\n"
		}
	    } else {
		if { $verbose > 1 } {
		    send_user "Yes, it matches.\n\n"
		}
	    }
	}
    } else {
	if { $verbose > 1 } {
	    send_user "Nope, does not match.\n\n"
	}
    }
    
    if [string match $pass "yes"] {
	pass $pass_message
    } else {
	fail $fail_message
    }

    execute_anywhere "rm -f $output_file"
    # The framework doesn't like to see any error remnants,
    # so remove them.
    uplevel {
	if [info exists errorInfo] {
	    unset errorInfo
	}
    }

    mike_cleanup $src_code $output_file $assembly_file
}
