# Copyright (C) 1995, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Please email any bugs, comments, and/or additions to this file to:
# bug-gcc@prep.ai.mit.edu

# Get definitions for default_${tool}_version/start plus any other members of
# the supporting cast.
load_lib ${tool}.exp

# For rcp_download, rsh_exec.
load_lib remote.exp

#
# ${tool}_version -- extract and print the version number of gcc (or g++)
#

proc ${tool}_version {} {
    global tool
    default_${tool}_version
}

#
# ${tool}_start -- compile a program
#

proc ${tool}_start { arglist } {
    global tool
    default_${tool}_start $arglist
}

#
# ${tool}_load -- load the program and execute it
#
# See default.exp for explanation of arguments and results.
#
# If REMOTE_LINK is set, it contains a command to use to do the final link
# of the executable on the remote system (eg: cc).  It is assumed that CFLAGS
# contains the appropriate -r flag if necessary.
#

proc ${tool}_load { prog } {
    global exec_output targetname

    if ![file exists $prog] then {
	# We call both here because this should never happen.
	perror "$prog does not exist."
	verbose -log "$prog does not exist." 3
	return "untested"
    }

    if [ isnative ] then {
	set status [catch "exec $prog" exec_output]
    } else { 
	set remotefile "/tmp/[file tail $prog].[pid]"
	if { [rcp_download $prog $targetname:$remotefile] != 0 } {
	    verbose -log "Download of $prog to $targetname failed." 3
	    return "unresolved"
	}
	global REMOTE_LINK
	if [info exists REMOTE_LINK] {
	    set status [rsh_exec $targetname "mv $remotefile $remotefile.o && $REMOTE_LINK $remotefile.o -o $remotefile"]
	    if { [lindex $status 0] != 0 } {
		rsh_exec $targetname "rm -f $remotefile.o $remotefile"
		if { [lindex $status 0] < 0 } {
		    verbose -log "link of $remotefile on $targetname failed, [lindex $status 1]." 3
		    return "unresolved"
		} else {
		    note "link of $remotefile on $targetname failed, [lindex $status 1]."
		    return "fail"
		}
	    }
	    verbose "$prog linked ok" 3
	} else {
	    # rcp's to lynx seem not to get marked executable
	    set status [rsh_exec $targetname "chmod +x $remotefile"]
	    if { [lindex $status 0] != 0 } {
		rsh_exec $targetname "rm -f $remotefile.o $remotefile"
		verbose -log "chmod +x of $prog on $targetname failed." 3
		return "unresolved"
	    }
	}
	set status [rsh_exec $targetname $remotefile]
	rsh_exec $targetname "rm -f $remotefile.o $remotefile"
	if { [lindex $status 0] < 0 } {
	    verbose -log "Couldn't execute $prog, [lindex $status 1]" 3
	    return "unresolved"
	}
	set exec_output [lindex $status 1]
	set status [lindex $status 0]
    }

    verbose "Executed $prog, status $status" 2
    if ![string match "" $exec_output] {
	verbose "$exec_output" 2
    }
    if { $status == 0 } {
	return "pass"
    } else {
	return "fail"
    }
}

#
# ${tool}_exit -- just a stub for gcc/g++
#

proc ${tool}_exit {} {
}

set exe_ext ".exe"
