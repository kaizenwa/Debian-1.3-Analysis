# Makefile for the windows NT unix server
# Copyright (c) 1995, 1996 Cygnus Support.
# All rights reserved.
#
# Redistribution and use in source and binary forms are permitted
# provided that the above copyright notice and this paragraph are
# duplicated in all such forms and that any documentation,
# advertising materials, and other materials related to such
# distribution and use acknowledge that the software was developed
# at Cygnus Support, Inc.  Cygnus Support, Inc. may not be used to
# endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

# This makefile requires GNU make.

VPATH = @srcdir@:@srcdir@/sysdef/@SYSDEF_DIR@::@srcdir@/config/@CONFIG_DIR@
srcdir = @srcdir@
objdir = .

target_alias = @target_alias@
prefix = @prefix@

program_transform_name = @program_transform_name@
exec_prefix = @exec_prefix@
bindir = @bindir@
libdir = @libdir@
tooldir = $(exec_prefix)/$(target_alias)
datadir = @datadir@
infodir = @infodir@
includedir = @includedir@

SHELL = /bin/sh

INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@

CC = @CC@
# FIXME: Which is it, CC or CC_FOR_TARGET?
CC_FOR_TARGET = $(CC)
CFLAGS = @CFLAGS@
CXXFLAGS = @CXXFLAGS@

INCLUDES = -I./msinclude -I$(srcdir)/include -I$(srcdir)

ALL_CFLAGS = $(CFLAGS) $(INCLUDES)
ALL_CXXFLAGS = $(CXXFLAGS) $(INCLUDES)

# For linking mount, etc.  crt0.o isn't accessable in a fresh build.
EXE_LDFLAGS = @EXE_LDFLAGS@

AR = @AR@
AR_FLAGS = qv
RANLIB = @RANLIB@
LD = @LD@
DLLTOOL = @DLLTOOL@

MAKEINFO = makeinfo
@SET_MAKE@
TEXI2DVI = texi2dvi
TEXI2HTML = texi2html

DEP = mkdep

FLAGS_TO_PASS = \
	CC="$(CC)" \
	CFLAGS="$(CFLAGS)" \
	CXXFLAGS="$(CXXFLAGS)" \
	EXE_LDFLAGS="$(EXE_LDFLAGS)" \
	AR="$(AR)" \
	RANLIB="$(RANLIB)" \
	LD="$(LD)" \
	DLLTOOL="$(DLLTOOL)"

DLLNAME=cygwin.dll
LIBNAME=libcygwin.a
DEFFILE=cygwin.def 

LIBC_A=../newlib/libc.a
LIBM_A=../newlib/libm.a

# some things want these from libc, but they have their own static
# data which apps can get to, which is a pain in a dll, so we
# include them directly into the library.

LIBIBERTYOS=../libiberty/getopt.o ../libiberty/getopt1.o

LIBCOS=libccrt0.o libcctype.o libcerr.o libcmain.o $(LIBIBERTYOS)

# Build as many .a files as we have .def files

THEIRLIBS=$(addprefix lib,$(addsuffix .a,$(basename $(notdir $(wildcard @srcdir@/sysdef/@SYSDEF_DIR@/*.def)))))

DOC=faq.txt faq.info readme.txt readme.info

HTMLDOC=faq.html readme.html

UTILS_ALL = utils-all

.PHONY: all
all:  $(DLLNAME) $(THEIRLIBS) $(LIBNAME) $(UTILS_ALL)

info: $(DOC)

info-html: $(DOC) $(HTMLDOC)

install-info: info
        if [ -r readme.info ]; then \
          dir=. ; \
        else \
          dir=$(srcdir) ; \
        fi ; \
        for i in `cd $$dir; echo *.info*` ; do \
                $(INSTALL_DATA) $$dir/$$i $(infodir)/$$i ; \
        done

# texi2html will not be installed at many sites so by default we don't
# try to convert to html

faq.html:$(srcdir)/doc/faq.texinfo $(srcdir)/doc/*.texinfo
	for i in $(srcdir)/doc/*.texinfo ; do \
		sed < $$i -e 's?@file{\([fth]*p://[^}]*\)}?@strong{<A HREF="\1">\1</A>}?' \
	    -e 's?\([.+a-zA-Z0-9-]*@@[.a-zA-Z0-9-]*[a-zA-Z0-9]\)?<A HREF="mailto:\1">\1</A>?' >./`basename $$i` ; done
	-$(TEXI2HTML) -split_chapter  -v ./faq.texinfo
	rm -f *.texinfo
	cp faq_toc.html faq.html

faq.txt:$(srcdir)/doc/faq.texinfo
	$(MAKEINFO)  -I$(srcdir)/doc --no-split --no-headers $< -o - |\
		sed '/^Concept Index/,$$d' > faq.txt

faq.info:$(srcdir)/doc/faq.texinfo
	$(MAKEINFO)  -I$(srcdir)/doc $<

readme.html:$(srcdir)/doc/readme.texinfo
	-$(TEXI2HTML) -I$(srcdir)/doc $< 

readme.txt:$(srcdir)/doc/readme.texinfo
	$(MAKEINFO) --no-split --no-headers $< -o - |\
		sed '/^Concept Index/,$$d' > readme.txt

readme.info:$(srcdir)/doc/readme.texinfo
	$(MAKEINFO) -I$(srcdir)/doc  $<

install: $(THEIRLIBS) $(LIBNAME) $(DLLNAME) real-headers
	for i in $(THEIRLIBS) $(LIBNAME); do \
		$(INSTALL_DATA) $$i $(tooldir)/lib/$$i ; \
	done
	for i in $(DLLNAME); do \
	  $(INSTALL_DATA) $$i $(tooldir)/lib/$$i ; \
	  binname=`t='$(program_transform_name)'; echo "$$i" | sed -e $$t` ; \
	  echo "program_transform_name=$(program_transform_name), i=$$i, binname=$$binname"; \
	  rm -f $(bindir)/$$binname ; \
	  ln $(tooldir)/lib/$$i $(bindir)/$$binname >/dev/null 2>&1 || $(INSTALL_DATA) $$i $(bindir)/$$binname ; \
	done
	for sub in include include/arpa include/asm  \
	   include/cygwin32 include/net include/netinet include/sys ; do \
		for i in $(srcdir)/$$sub/*.h ; do \
		  $(INSTALL_DATA) $$i $(tooldir)/$$sub/`basename $$i` ; \
		done ; \
	done
	rootme=`pwd` ; export rootme ; \
	rootsrc=`(cd $(srcdir) ; pwd)` ; export rootsrc ; \
	cd utils; $(MAKE) install $(FLAGS_TO_PASS)

	# this will only work if you've maked stmp_ms_include below.
	#	if [ -e ms_include/windows.h ] ; then  \
	#		for i in ms_include/*.h ; do \
	#		  $(INSTALL_DATA) $$i $(tooldir)/include ; \
	#		done ; \
	#	fi

.SUFFIXES: .y $(SUFFIXES) .cc .def .a

lib%.a:%.def
	$(DLLTOOL) --as=$(AS) -k --dllname $*.dll --output-lib lib$*.a --def $<

.cc.o:
	$(CC) -c -fno-rtti $(ALL_CXXFLAGS) $<

.c.o:
	$(CC) -c $(ALL_CFLAGS) $<


include $(srcdir)/config/@CONFIG_DIR@/makefrag

LIBGCC=`$(CC_FOR_TARGET) -print-libgcc-file-name`

DLL_IMPORTS = libkernel32.a libuser32.a libgdi32.a libadvapi32.a \
	libcomdlg32.a libwsock32.a glob/libglob.a

DLL_OFILES = $(EXTRA_DLL_OFILES) \
	console.o 		\
	dcrt0.o                 \
	delqueue.o		\
	dirsearch.o 		\
	exceptions.o 		\
	exec.o 			\
	fcntl.o 		\
	fhandler.o 		\
	fork.o 			\
	grp.o 			\
	heap.o	 		\
	hinfo.o			\
	init.o 			\
	ioctl.o 		\
	key.o 			\
	malloc.o		\
	misc.o 			\
	net.o			\
	passwd.o 		\
	path.o 			\
	pinfo.o			\
	pipe.o 			\
	registry.o  		\
	resource.o 		\
	select.o 		\
	shared.o		\
	signal.o 		\
	smallprint.o 		\
	spawn.o			\
	strace.o 		\
	strerror.o		\
	stubs.o 		\
	syscalls.o 		\
	sysconf.o 		\
	syslog.o		\
	termios.o		\
	times.o			\
	uinfo.o 		\
	uname.o			\
	wait.o 

# we build our own import library to get at the winsock functions
# by different names.


#libmywinsock.a:mywinsock.def
#	$(DLLTOOL) --as=$(AS) -k --dllname wsock32.dll --output-lib libmywinsock.a --def $<

#libwinsock.a:wsock32.def
#	$(DLLTOOL) --as=$(AS) -k --dllname wsock32.dll --output-lib libwinsock.a --def $<

glob/libglob.a: glob/glob.c glob/fnmatch.c
	rootme=`pwd` ; export rootme ; \
	rootsrc=`(cd $(srcdir) ; pwd)` ; export rootsrc ; \
	cd glob; $(MAKE) libglob.a $(FLAGS_TO_PASS)

.PHONY: utils-all
utils-all: $(LIBNAME)
	rootme=`pwd` ; export rootme ; \
	rootsrc=`(cd $(srcdir) ; pwd)` ; export rootsrc ; \
	cd utils; $(MAKE) all $(FLAGS_TO_PASS)

test.exe:test.c $(LIBNAME) libcc t0.o libcfork.o libcctype.o 
	$(CC) -c $<		 
	$(CC) -o test.exe test.o -L. $(LIBNAME) ./libkernel32.a

$(LIBNAME):$(DEFFILE)  $(LIBCOS)
	$(DLLTOOL) --as=$(AS) --dllname $(DLLNAME) --def $(DEFFILE)  --output-lib temp.a
	$(AR) rcv temp.a $(LIBCOS)
	mv temp.a $(LIBNAME)

LD_STUFF= --dll -o $(DLLNAME)  $(DLL_OFILES) $(DLL_IMPORTS) $(LIBC_A) $(LIBM_A) $(LIBM_A) -e @DLL_ENTRY@ $(LIBGCC) 

DLL_STUFF=--as=$(AS) --dllname $(DLLNAME) --def $(DEFFILE) --base-file base --output-exp win.exp 

$(DLLNAME):$(DLL_OFILES) $(DEFFILE)  $(DLL_IMPORTS) $(LIBC_A) $(LIBM_A) Makefile 
	$(LD) --base-file=base  $(LD_STUFF)
	$(DLLTOOL) $(DLL_STUFF)
	$(LD) --base-file=base  win.exp $(LD_STUFF)
	$(DLLTOOL) $(DLL_STUFF)
	$(LD)  win.exp $(LD_STUFF)



clean:
	-rm -f *.o *.dll *.a *.exp junk base

maintainer-clean realclean: clean 
	@echo "This command is intended for maintainers to use;"
	@echo "it deletes files that may require special tools to rebuild."

# cygwin.din is here because we need cygwin.def to be rebuilt if cygwin.din
# changes, and it's the configure script that generates cygwin.def from
# cygwin.din.
Makefile: Makefile.in cygwin.din config.status configure
	$(SHELL) config.status

config.status: configure
	$(SHELL) config.status --recheck


#orig:
#	mkdir -p msinclude
#	for i in $(MSSRC)/*.h ; do \
#		tr -d "\r" <$$i >msinclude/`basename $$i`; done

# Stuff to build headers for cygwin32 from the Microsoft WIN32SK headers.
# If you don't have a Microsoft SDK, then you can rebuild the dll with
# just the headers provided in include, but you won't be able to make
# much more than that.
#
# If you do have a Microsoft SDK, set this name to point to the directory
# which contains the headers (My linux machine is dual boot, and C: is under
# /dosc, so this works for me)

SDK_H=/dosc/mstools/h

real-headers: # $(srcdir)/mspatches/*.patch
	if [ -f $(SDK_H)/windows.h ] ; then 	\
		mkdir -p ms_include ; 		\
		for i in $(SDK_H)/*.h ; do 	\
			tr -d "\r" < $$i >ms_include/`basename $$i` ; \
			if [ -e $(srcdir)/mspatches/`basename $$i.patch` ] ; then \
				patch -d ms_include $$i <$(srcdir)/mspatches/`basename $$i`.patch ; \
			fi ; \
		done ; \
	fi 
	touch real-headers

make-diffs:
	mkdir -p msorig
	for i in $(SDK_H)/*.h ; do \
		tr -d "\r" <$$i >msorig/`basename $$i`; done
	for i in msorig/*.h ; do \
		echo $$i ; \
		diff  -e $$i ms_include/`basename $$i` >t ; \
		if [ -s t ] ; then cp t $(srcdir)/mspatches/`basename $$i.patch` ; fi ; done

# .h file dependencies
# This is overkill, but it's better than the previous situation.
# The next step is to remove the unnecessary dependencies, and add the
# missing ones.

WINSUP_H = winsup.h fhandler.h syscalls.h

console.o: $(WINSUP_H)
dcrt0.o: $(WINSUP_H) exceptions.h version.h
delqueue.o: $(WINSUP_H) delqueue.h
dirsearch.o: $(WINSUP_H)
exceptions.o: $(WINSUP_H) exceptions.h
exec.o: $(WINSUP_H)
fcntl.o: $(WINSUP_H)
fhandler.o: $(WINSUP_H)
fork.o: $(WINSUP_H)
heap.o: $(WINSUP_H)
hinfo.o: $(WINSUP_H)
init.o: $(WINSUP_H)
ioctl.o: $(WINSUP_H)
key.o: $(WINSUP_H)
libccrt0.o: $(WINSUP_H) version.h
libcerr.o: $(WINSUP_H)
libcfork.o: $(WINSUP_H)
libcmain.o: $(WINSUP_H)
malloc.o: $(WINSUP_H)
net.o: $(WINSUP_H)
passwd.o: $(WINSUP_H)
path.o: $(WINSUP_H) path.h
pinfo.o: $(WINSUP_H)
pipe.o: $(WINSUP_H)
registry.o: $(WINSUP_H) registry.h version.h
resource.o: $(WINSUP_H)
select.o: $(WINSUP_H)
shared.o: $(WINSUP_H)
signal.o: $(WINSUP_H)
spawn.o: $(WINSUP_H)
strace.o: $(WINSUP_H)
strerror.o: $(WINSUP_H)
syscalls.o: $(WINSUP_H)
sysconf.o: $(WINSUP_H)
syslog.o: $(WINSUP_H)
termios.o: $(WINSUP_H)
times.o: $(WINSUP_H)
udata.o: $(WINSUP_H)
uinfo.o: $(WINSUP_H)
wait.o: $(WINSUP_H)
