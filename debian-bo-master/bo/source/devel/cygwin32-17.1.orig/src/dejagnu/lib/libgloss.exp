# Copyright (C) 92, 93, 94, 95, 1996 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 

# Please email any bugs, comments, and/or additions to this file to:
# bug-dejagnu@prep.ai.mit.edu

# This file was written by Rob Savoye. (rob@cygnus.com)

# this contains a list of gcc options and their respective directories.
set multilibs ""
set gccpath   ""

#
# Find the linker script for the current target. Returns a string
# suitable to pass to $CC or $CXX to use a liblgoss based linker script,
# or NULL if there is no support.
#
proc libgloss_script { } {
    global srcdir
    global target_cpu
    global LDFLAGS
    global CFLAGS
    global CXXFLAGS
    global MULTIPASS
    global target_info

    # sanity check
    if ![info exists LDFLAGS] {
	set LDFLAGS ""
    }
    if ![info exists CFLAGS] {
	set CFLAGS ""
    }

     if ![info exists CXXFLAGS] {
	set CXXFLAGS ""
    }

    # find the linker script. first we look at the config
    # data and hope to find it all ready for us to use. if
    # that fails, then look in the various config variables that
    # get set in the global site.exp file.
    set tmp ""
    catch {append tmp $target_info(target,cflags)}
    catch {append tmp $target_info(target,cxxflags)}
    catch {append tmp $target_info(target,ldflags)}
    catch {append tmp $MULTIPASS}
    set found 0
    foreach i "$LDFLAGS $CFLAGS $CXXFLAGS $tmp" {
	if [regexp -- "-T\[a-z0-9\]*\.ld" $i] {
	    verbose "Found a -T<foo> linker script option ($i)" 3
	    incr found
	}
	if [regexp -- "-m\[a-z0-9\]*" $i] {
	    incr found
	    verbose "Found a -m<foo> option ($i)" 3
	}
	if { $found > 0 } {
	    return ""
	}
    }
    if [info exists target_info(target,name)] {
	set script $target_info(target,name).ld
    } else {
	if [regexp -- "-T.*\.ld" ${LDFLAGS} script] {
	    string trimleft ${script} "-T"
	}
	if [regexp -- "-T.*\.ld" ${CFLAGS} script] {
	    string trimleft ${script} "-T"
	}
	if [regexp -- "-T.*\.ld" ${CXXFLAGS} script] {
	    string trimleft ${script} "-T"
	}
    }

    if ![info exists script] {
	warning "Couldn't find the linker script name for target"
	return ""
    }
    
    # if we're on a remote host, we can't search for the file, so use the
    # linker script in the path.
    if [is3way] {
	return "-T${script}"
    }
    
    # search for the general directories
    foreach i ".. ../.. ../../.. ../../../.." {
	verbose "Looking for a ${srcdir}/${i}/libgloss/${target_cpu}/${script}" 2
	if [file exists ${srcdir}/$i/libgloss/${target_cpu}/${script} ] {
	    verbose "Found ${srcdir}/${i}/libgloss/${target_cpu}/${script}." 3
	    return "-T${srcdir}/${i}/libgloss/${target_cpu}/${script}"
	}
    }

    # we didn't find the script, so we have to hope it's installed
    if { $script == "" } {
	warning "Couldn't find the linker script name for target"
	return ""
    } else {
	return "-T${script}"
    }
}

#
# Find all the pieces of libgloss for testing the GNU development tools
# needed to use $CC or $CXX. It returns a string suitable to pass to 
# $CC or $CXX to get a fully linked binary for the target. This usually means
# setting the -L and -B paths correctly.
#
proc libgloss_flags { } {
    global target_alias
    global target_cpu
    global srcdir
    global base_dir
    global LDFLAGS
    global CFLAGS
    global CXXFLAGS
    global MULTIPASS
    global target_info

    # libgloss doesn't work native
    if [isnative] {
	return ""
    }

    # if we're on a remote host, we can't search for the file, so we can only
    # use an installed compiler, so we don't add any paths here.
    if [is3way] {
	return ""
    }
    
    set gccpath "[get_multilibs]"

    # map the target_cpu to the proper libgloss directory. unfortunately, these
    # directory names are hardcoded into libgloss.
    switch -glob -- $target_cpu {
	"sparclite" {
	    set cpu sparc
	}
	"hppa*" {
	    set cpu pa
	}
	default {
	    set cpu $target_cpu
	}
    }

    # look for the libgloss srcdir sp we can find the linker scripts
    foreach i ".. ../.. ../../.. ../../../.." {
	if [file exists ${srcdir}/$i/libgloss/$cpu ] {
	    verbose "Found ${srcdir}/$i/libgloss/$cpu." 2
	    set gloss_srcdir "${srcdir}/$i/libgloss/$cpu"
	}
    }

    # set the proper paths for gcc if the target subdir exists, else assume we
    # have no libgloss support for this target.
    if [file exists $gccpath/libgloss/$cpu] {
	verbose "Libgloss path is $gccpath/libgloss/$cpu" 2
	return "-B$gccpath/libgloss/$cpu/ -L$gccpath/libgloss/$cpu -L$gloss_srcdir"
    } else {
	verbose "No libgloss support for this target." 2
	return ""
    }
}

#
# Find the C libraries
#
proc newlib_flags { } {
    global target_alias
    global target_cpu
    global srcdir
    global base_dir
    global LDFLAGS
    global CFLAGS
    global CXXFLAGS
    global MULTIPASS
    global target_info

    # libgloss doesn't work native
    if [isnative] {
	return ""
    }

    # if we're on a remote host, we can't search for the file, so we can only
    # use an installed compiler, so we don't add any paths here.
    if [is3way] {
	return ""
    }

    set gccpath "[get_multilibs]"

    verbose "Looking for $gccpath/newlib"
    if [file exists $gccpath/newlib] {
	verbose "Newlib path is $gccpath/newlib"
	return "-B$gccpath/newlib/ -L$gccpath/newlib -I$gccpath/newlib/targ-include"
    } else {
	verbose "No newlib support for this target"
    }
}

#
# Find all the pieces of libgloss for testing the GNU development tools
# needed to use $LD. This gets fun cause we have to guess the name of the
# BSP for this target. If returns a string suitable to pass to LD to get
# a fully linked binary for the target. It also sets two global variables,
# CRT0 is the path to the startup file, and
# BSP is the path to the support library.
#
proc libgloss_ld {} {
#proc gloss_ld {} {
    global target_cpu
    global srcdir
    global base_dir
    global CRT0
    global BSP

    # libgloss doesn't work native
    if [isnative] {
	return ""
    }

#    set ldflags ""
    # search for the general directories
    foreach i ".. ../.. ../../.. ../../../.." {
	if ![info exists gloss_srcdir] {
	    if [file exists ${srcdir}/$i/libgloss/${target_cpu} ] {
		verbose "Found ${srcdir}/$i/libgloss/${target_cpu}." 3
		set gloss_srcdir "$i/libgloss/${target_cpu}"
	    }
	}
 	if ![info exists gloss_objdir] {
	    if [file exists ${base_dir}/$i/libgloss/${target_cpu} ] {
		verbose "Found ${base_dir}/$i/libgloss/${target_cpu}." 3
		set gloss_objdir "$i/libgloss/${target_cpu}"
		append ldflags " -L${gloss_objdir} "
	    }
	}
    }

    # find the crt0
    if [file exists ${gloss_objdir}/crt0.o] {
	verbose "Found ${base_dir}/$i/libgloss/${target_cpu}." 3
	set CRT0 "$i/libgloss/${target_cpu}"
	append ldflags " ${gloss_objdir}/crt0.o "
    } else {
	perror "No crt0.o built for this target"
    }
    
    # find the BSP (currently an object, it may become an archive soon)
    foreach i "[list_targets]" {
	if [info exists target_info($i,name}] {
	    if [file exists ${gloss_objdir}/${target_info}($i,name).o ] {
		set BSP "${target_info}($i,name).o"
		append ldflags " -lc -l ${target_info}($i,name).o -lc "
	    }
	}
    }
    if [expr ![info exists gloss_srcdir] || ![info exists gloss_srcdir]] {
	warning "No libgloss support in build tree"
	return ""
    } else {
	return "${ldflags}"
    }
}

#
# Get the list of directories and -m options for gcc. This is kinda bogus that
# generic testing software needs support for gcc hardwired in, but to make testing
# the GNU tools work right, there didn't seem to be any other way.
#
proc get_multilibs { } {
    global CC
    global CXX
    global LDFLAGS
    global CFLAGS
    global CXXFLAGS
    global MULTIPASS
    global target_info
    global base_dir
    global target_alias

    # sanity check
    if ![info exists LDFLAGS] {
	set LDFLAGS ""
    }
    if ![info exists CFLAGS] {
	set CFLAGS ""
    }

     if ![info exists CXXFLAGS] {
	set CXXFLAGS ""
    }

    # libgloss doesn't work native
    if [isnative] {
	return ""
    }

    # get the compiler. strip off the options and other stuff that choke exec.
    if [info exists CXX] {
	set compiler $CXX
    } else {
	set compiler $CC
    }
    regexp "/.* " $compiler compiler
    set compiler [string trimright $compiler " "]

    # extract the options and their directory names as know by gcc
    foreach i "[exec $compiler  --print-multi-lib]" {
	set opts ""
	set dir ""
	regexp -- "\[a-z0-9/\.-\]*;" $i dir
	set dir [string trimright $dir "\;@"]
	regexp -- "\;@*\[\@a-z0-9/\.-\]*" $i opts
	set opts [split [string trimleft $opts "\;@"] "@"]
	lappend multilibs "$dir {$opts }"
    }

   # if we're on a remote host, we can't search for the file, so we can only
    # use an installed compiler, so we don't add any paths here.
    if [is3way] {
	return ""
    }
    
    # search for the top level multilib directory
    foreach i ".. ../.. ../../.. ../../../.." {
	if [file exists ${base_dir}/${i}/${target_alias} ] {
	    set multitop "${base_dir}/${i}/${target_alias}"
	    verbose "Top level multilib dir is $multitop"
	    break
	}
    }
    
    # make a list of -m<foo> options from the various compiler config variables
    set tmp ""
    set opts ""
    set moptions ""
    set gccpath ""
#    catch {append tmp $target_info(target,cflags)}
#    catch {append tmp $target_info(target,cxxflags)}
#    catch {append tmp $target_info(target,ldflags)}
#    catch {append tmp $MULTIPASS}
    foreach i "$LDFLAGS $CFLAGS CXXFLAGS" {
	if [regexp -- "^-m\[a-z0-9\]*" $i] {
	    verbose "Found a -m<foo> option ($i)" 3
	    lappend opts "[string trim $i " -"]"
	}
    }

    # compare the lists of gcc options with the list of support multilibs
    verbose "Supported multilibs are: $multilibs" 3
    foreach i "$multilibs" {
	set hits 0
	# get just the options list from the multilibs list
	set moptions [lindex $i 1]
	foreach j "$moptions" {
	    # see if all the -m<foo> options match any of the multilibs
	    verbose "Looking in $i for $j" 3
	    if [regexp "$j" $opts] {
		incr hits
	    }
	}

	if { $hits == [llength $opts] } {
	    verbose "Got a hit, adding [lindex $i 0] to gcc path" 2
	    set gccpath "[lindex $i 0]"
	    break
	}
    }

    if [file exists $multitop/$gccpath] {
	verbose "GCC path is $multitop/$gccpath" 3
	return "$multitop/$gccpath"
    } else {
	verbose "GCC path is $multitop" 3
	return "$multitop"
    }
}
