This is Info file mercury_library.info, produced by Makeinfo-1.63 from
the input file library.texi.

START-INFO-DIR-ENTRY
* Mercury Library: (mercury_library). The Mercury Library Reference Manual
END-INFO-DIR-ENTRY

   This file documents the Mercury standard library.

   Copyright (C) 1995 University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: mercury_library.info,  Node: list,  Next: map,  Prev: library,  Up: Top

list
****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % Module `list' - defines the list type, and various utility predicates
     % that operate on lists.
     %
     % Main author: fjh.
     % Stability: medium to high.
     %
     %--------------------------------------------------%
     
     :- module list.
     :- import_module int.
     
     :- interface.
     
     %--------------------------------------------------%
     
     	% The definition of the type `list(T)':
     	%	A list is either an empty list, denoted `[]',
     	%	or an element `Head' of type `T' followed by a tail `Tail'
     	%	of type `list(T)', denoted `[Head | Tail]'.
     	%
     
     % :- type list(T) ---> [] ; [T | list(T)].
     
     	% The definition of `list(T)' is actually in mercury_builtin.m because
     	% the implementation of type_to_term/3 and term_to_type/3 means
     	% that it has to be.
     
     %--------------------------------------------------%
     
     	% Some declarations for complicated modes using lists.
     	% Partially instantiated mode aren't fully implemented yet,
     	% so don't try to use these.
     
     :- inst list_skel(I) = bound(([] ; [I | list_skel(I)])).
     :- inst list_skel = list_skel(free).
     
     :- inst non_empty_list = bound([ground | ground]).
     
     :- mode in_list_skel :: list_skel -> list_skel.
     :- mode out_list_skel :: free -> list_skel.
     :- mode list_skel_out :: list_skel -> ground.
     
     	% These more verbose versions are deprecated.
     	% They exist only for backwards compatibility,
     	% and will be removed in a future release.
     :- mode input_list_skel :: in_list_skel.
     :- mode output_list_skel :: out_list_skel.
     :- mode list_skel_output :: list_skel_out.
     
     	% These modes are particularly useful for passing round lists
     	% of higher order terms, since they have complicated insts
     	% which are not correctly approximated by "ground".
     :- mode list_skel_in(I) :: list_skel(I) -> list_skel(I).
     :- mode list_skel_out(I) :: free -> list_skel(I).
     
     %--------------------------------------------------%
     
     	% Standard append predicate:
     	% list__append(Start, End, List) is true iff
     	% `List' is the result of concatenating `Start' and `End'.
     	%
     :- pred list__append(list(T), list(T), list(T)).
     :- mode list__append(di, di, uo) is det.
     :- mode list__append(in, in, out) is det.
     :- mode list__append(in, in, in) is semidet.	% implied
     :- mode list__append(in, out, in) is semidet.
     :- mode list__append(out, out, in) is multi.
     %	The following mode is semidet in the sense that it doesn't
     %	succeed more than once - but it does create a choice-point,
     %	which means it's inefficient and that the compiler can't deduce
     %	that it is semidet.  Use list__remove_prefix instead.
     % :- mode list__append(out, in, in) is semidet.
     
     	% list__remove_suffix(List, Suffix, Prefix):
     	%	The same as list__append(Prefix, Suffix, List) except that
     	%	this is semidet whereas list__append(out, in, in) is nondet.
     :- pred list__remove_suffix(list(T), list(T), list(T)).
     :- mode list__remove_suffix(in, in, out) is semidet.
     
     	% list__merge(L1, L2, L):
     	%	L is the result of merging L1 and L2.
     	%	L1 and L2 must be sorted.
     :- pred list__merge(list(T), list(T), list(T)).
     :- mode list__merge(in, in, out) is det.
     
     	% list__merge_and_remove_dups(L1, L2, L):
     	%	L is the result of merging L1 and L2 and eliminating
     	%	any duplicates.
     	%	L1 and L2 must be sorted.
     :- pred list__merge_and_remove_dups(list(T), list(T), list(T)).
     :- mode list__merge_and_remove_dups(in, in, out) is det.
     
     	% list__remove_adjacent_dups(L0, L) :
     	%	L is the result of replacing every sequence of duplicate
     	%	elements in L0 with a single such element.
     :- pred list__remove_adjacent_dups(list(T), list(T)).
     :- mode list__remove_adjacent_dups(in, out) is det.
     
     	% list__remove_dups(L0, L) :
     	%	L is the result of deleting the second and subsequent
     	%	occurrences of every element that occurs twice in L.
     :- pred list__remove_dups(list(T), list(T)).
     :- mode list__remove_dups(in, out) is det.
     
     	% list__member(Elem, List) :
     	%	True iff `List' contains `Elem'.
     :- pred list__member(T, list(T)).
     :- mode list__member(in, in) is semidet.
     :- mode list__member(out, in) is nondet.
     
     	% list__member(Elem, List, SubList) :
     	%	True iff `List' contains `Elem', and `SubList' is
     	%	a suffix of `List' beginning with `Elem'.
     	%	Same as `SubList = [Elem | _], list__append(_, SubList, List)'.
     	%
     :- pred list__member(T, list(T), list(T)).
     :- mode list__member(out, in, out) is nondet.
     
     	% list__length(List, Length) :
     	%	True iff `Length' is the length of `List', i.e. if
     	%	`List' contains `Length' elements.
     	%
     :- pred list__length(list(_T), int).
     :- mode list__length(in, out) is det.
     % :- mode list__length(in, in) is semidet.	% implied
     	% XXX The current mode checker can't handle this mode
     % :- mode list__length(input_list_skel, out) is det.
     
     	% list__same_length(ListA, ListB) :
     	%	True iff `ListA' and `ListB' have the same length,
     	%	i.e. iff they both contain the same number of elements.
     	%
     :- pred list__same_length(list(T1), list(T2)).
     :- mode list__same_length(in, output_list_skel) is det.
     :- mode list__same_length(output_list_skel, in) is det.
     :- mode list__same_length(in, in) is semidet.
     	% XXX The current mode checker can't handle these modes
     % :- mode list__same_length(input_list_skel, output_list_skel) is det.
     % :- mode list__same_length(output_list_skel, input_list_skel) is det.
     
     	% list__split_list(Len, List, Start, End):
     	%	splits `List' into a prefix `Start' of length `Len',
     	%	and a remainder `End'.
     	%	See also: list__take, list__drop.
     	%
     :- pred list__split_list(int, list(T), list(T), list(T)).
     :- mode list__split_list(in, in, out, out) is semidet.
     
     	% list__take(Len, List, Start):
     	%	`Start' is the first `Len' elements of `List'.
     	%	See also: list__split_list.
     	%
     :- pred list__take(int, list(T), list(T)).
     :- mode list__take(in, in, out) is semidet.
     
     	% list__drop(Len, List, End):
     	%	`End' is the remainder of `List' after removing the
     	%	first `Len' elements.
     	%	See also: list__split_list.
     	%
     :- pred list__drop(int, list(T), list(T)).
     :- mode list__drop(in, in, out) is semidet.
     
     	% list__insert(Elem, List0, List):
     	%	`List' is the result of inserting `Elem' somewhere in `List0'.
     	%	Same as `list__delete(List, Elem, List0)'.
     	%
     :- pred list__insert(T, list(T), list(T)).
     :- mode list__insert(in, in, in) is semidet.
     :- mode list__insert(in, out, in) is nondet.
     :- mode list__insert(out, out, in) is nondet.
     :- mode list__insert(in, in, out) is multi.
     
     	% list__delete(List, Elem, Remainder):
     	%	True iff `Elem' occurs in `List', and
     	%	`Remainder' is the result of deleting one occurrence of
     	%	`Elem' from `List'.
     	%
     :- pred list__delete(list(T), T, list(T)).
     :- mode list__delete(in, in, in) is semidet.
     :- mode list__delete(in, in, out) is nondet.
     :- mode list__delete(in, out, out) is nondet.
     :- mode list__delete(out, in, in) is multi.
     
     	% list__delete_first(List0, Elem, List) is true iff Elem occurs in List0
     	% and List is List0 with the first occurence of Elem removed
     	%
     :- pred list__delete_first(list(T), T, list(T)).
     :- mode list__delete_first(in, in, out) is semidet.
     
     	% list__delete_all(List0, Elem, List) is true iff List is List0 with
     	% all occurences of Elem removed
     	%
     :- pred list__delete_all(list(T), T, list(T)).
     :- mode list__delete_all(di, in, uo) is det.
     :- mode list__delete_all(in, in, out) is det.
     
     	% list__delete_elems(List0, Elems, List) is true iff List is List0 with
     	% all occurences of all elements of Elems removed
     	%
     :- pred list__delete_elems(list(T), list(T), list(T)).
     :- mode list__delete_elems(in, in, out) is det.
     
     	% list__replace(List0, D, R, List) is true iff List is List0
     	% with an occurence of D replaced with R.
     	%
     :- pred list__replace(list(T), T, T, list(T)).
     :- mode list__replace(in, in, in, in) is semidet.
     :- mode list__replace(in, in, in, out) is nondet.
     
     	% list__replace_first(List0, D, R, List) is true iff List is List0
     	% with the first occurence of D replaced with R.
     	%
     :- pred list__replace_first(list(T), T, T, list(T)).
     :- mode list__replace_first(in, in, in, out) is semidet.
     
     	% list__replace_all(List0, D, R, List) is true iff List is List0
     	% with all occurences of D replaced with R.
     	%
     :- pred list__replace_all(list(T), T, T, list(T)).
     :- mode list__replace_all(in, in, in, out) is det.
     
     	% list__sort_and_remove_dups(List0, List):
     	%	List is List0 sorted with duplicates removed.
     	%
     :- pred list__sort_and_remove_dups(list(T), list(T)).
     :- mode list__sort_and_remove_dups(in, out) is det.
     
     	% list__sort(List0, List):
     	%	List is List0 sorted.
     	%
     :- pred list__sort(list(T), list(T)).
     :- mode list__sort(in, out) is det.
     
     	% list__reverse(List, Reverse):
     	%	`Reverse' is a list containing the same elements as `List'
     	%	but in reverse order.
     	%
     :- pred list__reverse(list(T), list(T)).
     :- mode list__reverse(in, out) is det.
     
     	% list__perm(List0, List):
     	%	True iff `List' is a permutation of `List0'.
     	%
     :- pred	list__perm(list(T), list(T)).
     :- mode list__perm(in, out) is nondet.
     
     	% list__nth_member_search(List, Elem, Position):
     	%	Elem is the Position'th member of List.
     	%
     :- pred list__nth_member_search(list(T), T, int).
     :- mode list__nth_member_search(in, in, out) is semidet.
     
     	% list__index*(List, Position, Elem):
     	%	These predicates select an element in a list from it's
     	%	position.  The `index0' preds consider the first element
     	%	element to be element number zero, whereas the `index1' preds
     	%	consider the first element to be element number one.
     	%	The `_det' preds call error/1 if the index is out of
     	%	range, whereas the semidet preds fail if the index is out of
     	%	range.
     	%
     :- pred list__index0(list(T)::in, int::in, T::out) is semidet.
     :- pred list__index1(list(T)::in, int::in, T::out) is semidet.
     :- pred list__index0_det(list(T)::in, int::in, T::out) is det.
     :- pred list__index1_det(list(T)::in, int::in, T::out) is det.
     
     	% list__zip(ListA, ListB, List):
     	%	List is the result of alternating the elements
     	%	of ListA and ListB.  When one of the lists goes to empty,
     	% 	the remainder of the nonempty list is appended.
     	%
     :- pred list__zip(list(T), list(T), list(T)).
     :- mode list__zip(in, in, out) is det.
     
     	% list__duplicate(Count, Elem, List) is true iff List is a list
     	% containing Count duplicate copies of Elem.
     	%
     :- pred list__duplicate(int, T, list(T)).
     :- mode list__duplicate(in, in, out) is det.
     
     	% list__condense(ListOfLists, List):
     	%	`List' is the result of concatenating all the
     	%	elements of `ListOfLists'.
     	%
     :- pred list__condense(list(list(T)), list(T)).
     :- mode list__condense(in, out) is det.
     
     	% list__chunk(List, ChunkSize, Chunks):
     	%	Takes a list `List' and breaks it into a list of lists `Chunks',
     	%	such that the length of each list in `Chunks' is at most
     	%	`ChunkSize.  (More precisely, the length of each list in
     	%	`Chunks' other than the last one is exactly `ChunkSize',
     	%	and the length of the last list in `Chunks' is between one
     	%	and `ChunkSize'.)
     	%
     :- pred list__chunk(list(T), int, list(list(T))).
     :- mode list__chunk(in, in, out) is det.
     
     	% list__sublist(SubList, FullList) is true
     	%	if one can obtain SubList by starting with FullList
     	%	and deleting some of its elements.
     :- pred list__sublist(list(T), list(T)).
     :- mode list__sublist(in, in) is semidet.
     
     	% list__all_same(List) is true
     	% 	if all elements of the list are the same
     :- pred list__all_same(list(T)).
     :- mode list__all_same(in) is semidet.
     
     	% list__last(List, Last) is true
     	%	if Last is the last element of List.
     :- pred list__last(list(T), T).
     :- mode list__last(in, out) is semidet.
     
     %--------------------------------------------------%
     %
     % The following group of predicates use higher-order terms to simplify
     % various list processing tasks. They implement pretty much standard
     % sorts of operations provided by standard libraries for functional languages.
     %
     % Most of this code was originally by philip, modified and reformatted
     % by conway.
     %
     %--------------------------------------------------%
     :- import_module std_util.
     
     	% list__map(T, L, M) uses the closure T
     	% to transform the elements of L into the elements of L.
     :- pred list__map(pred(X, Y), list(X), list(Y)).
     :- mode list__map(pred(in, out) is det, in, out) is det.
     :- mode list__map(pred(in, out) is semidet, in, out) is semidet.
     :- mode list__map(pred(in, out) is multi, in, out) is multi.
     :- mode list__map(pred(in, out) is nondet, in, out) is nondet.
     
     	% list__foldl(Pred, List, Start, End) calls Pred with each
     	% element of List (working left-to-right) and an accumulator
     	% (with the initial value of Start), and returns the final
     	% value in End.
     :- pred list__foldl(pred(X, Y, Y), list(X), Y, Y).
     :- mode list__foldl(pred(in, di, uo) is det, in, di, uo) is det.
     :- mode list__foldl(pred(in, in, out) is det, in, in, out) is det.
     :- mode list__foldl(pred(in, in, out) is semidet, in, in, out) is semidet.
     
     	% list__foldr(Pred, List, Start, End) calls Pred with each
     	% element of List (working right-to-left) and an accumulator
     	% (with the initial value of Start), and returns the final
     	% value in End.
     :- pred list__foldr(pred(X, Y, Y), list(X), Y, Y).
     :- mode list__foldr(pred(in, in, out) is det, in, in, out) is det.
     :- mode list__foldr(pred(in, in, out) is semidet, in, in, out) is semidet.
     
     	% list__filter(Pred, List, TrueList) takes a closure with one
     	% input argument and for each member of List `X', calls the closure.
     	% Iff call(Pred, X) is true, then X is included in TrueList.
     :- pred list__filter(pred(X), list(X), list(X)).
     :- mode list__filter(pred(in) is semidet, in, out) is det.
     
     	% list__filter(Pred, List, TrueList, FalseList) takes a closure with one
     	% input argument and for each member of List `X', calls the closure.
     	% Iff call(Pred, X) is true, then X is included in TrueList.
     	% Iff call(Pred, X) is false, then X is included in FalseList.
     :- pred list__filter(pred(X), list(X), list(X), list(X)).
     :- mode list__filter(pred(in) is semidet, in, out, out) is det.
     
     	% list__filter_map(Transformer, List, TrueList) takes a predicate
     	% with one input argument and one output argument. It is called
     	% with each element of List. If a call succeeds, then the output is
     	% included in TrueList.
     :- pred list__filter_map(pred(X, Y), list(X), list(Y)).
     :- mode list__filter_map(pred(in, out) is semidet, in, out) is det.
     
     	% list__sort(Compare, Unsorted, Sorted) is true iff Sorted is a
     	% list containing the same elements as Unsorted, where Sorted is
     	% a sorted list, wrt the ordering defined by the predicate term
     	% Compare.
     	% (implementation due to Philip Dart)
     :- pred list__sort(pred(X, X, comparison_result), list(X), list(X)).
     :- mode list__sort(pred(in, in, out) is det, in, out) is det.
     
     	% list__merge(Compare, As, Bs, Sorted) is true iff Sorted is a
     	% list containing the elements of As and Bs in the order implied
     	% by their sorted merge. The ordering of elements is defined by
     	% the higher order comparison predicate Compare.
     	% (implementation due to Philip Dart)
     :- pred list__merge(pred(X, X, comparison_result), list(X), list(X), list(X)).
     :- mode list__merge(pred(in, in, out) is det, in, in, out) is det.
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: map,  Next: math,  Prev: list,  Up: Top

map
***

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: map.m.
     % Main author: fjh, conway.
     % Stability: high.
     %
     % This file provides the 'map' ADT.
     % A map (also known as a dictionary or an associative array) is a collection
     % of (Key,Data) pairs which allows you to look up any Data item given the
     % Key.
     %
     % The implementation is using balanced binary trees, as provided by
     % tree234.m.  Virtually all the predicates in this file just
     % forward the work to the corresponding predicate in tree234.m.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module map.
     :- interface.
     :- import_module set, list, std_util, assoc_list, require.
     
     %--------------------------------------------------%
     
     :- type map(_K, _V).
     
     %--------------------------------------------------%
     
     	% Initialize an empty map.
     :- pred map__init(map(_,_)).
     :- mode map__init(uo) is det.
     
     	% Check whether a map is empty.
     :- pred map__is_empty(map(_,_)).
     :- mode map__is_empty(in) is semidet.
     
     	% Check whether map contains key
     :- pred map__contains(map(K,_V), K).
     :- mode map__contains(in, in) is semidet.
     
     :- pred map__member(map(K,V), K, V).
     :- mode map__member(in, out, out) is nondet.
     
     	% Search map for key.
     :- pred map__search(map(K,V), K, V).
     :- mode map__search(in, in, in) is semidet.	% implied
     :- mode map__search(in, in, out) is semidet.
     
     	% Search map for key, but abort if search fails.
     :- pred map__lookup(map(K,V), K, V).
     :- mode map__lookup(in, in, in) is semidet.	% implied
     :- mode map__lookup(in, in, out) is det.
     
     	% Search map for data.
     :- pred map__inverse_search(map(K,V), V, K).
     :- mode map__inverse_search(in, in, out) is nondet.
     
     	% Insert a new key and corresponding value into a map.
     	% Fail if the key already exists.
     :- pred map__insert(map(K,V), K, V, map(K,V)).
     :- mode map__insert(in, in, in, out) is semidet.
     
     	% Insert a new key and corresponding value into a map.
     	% Abort if the key already exists.
     :- pred map__det_insert(map(K,V), K, V, map(K,V)).
     :- mode map__det_insert(in, in, in, out) is det.
     
     	% Apply map__det_insert to key - value pairs from corresponding lists.
     :- pred map__det_insert_from_corresponding_lists(map(K,V), list(K),
     						list(V), map(K,V)).
     :- mode map__det_insert_from_corresponding_lists(in, in, in, out) is det.
     
     	% Update the value corresponding to a given key
     	% Fail if the key doesn't already exist.
     :- pred map__update(map(K,V), K, V, map(K,V)).
     :- mode map__update(in, in, in, out) is semidet.
     
     	% Update the value corresponding to a given key
     	% Abort if the key doesn't already exist.
     :- pred map__det_update(map(K,V), K, V, map(K,V)).
     :- mode map__det_update(in, in, in, out) is det.
     
     	% Update value if the key is already present, otherwise
     	% insert new key and value.
     :- pred map__set(map(K,V), K, V, map(K,V)).
     :- mode map__set(di, di, di, uo) is det.
     :- mode map__set(in, in, in, out) is det.
     
     	% Given a map, return a list of all the keys in the map
     :- pred map__keys(map(K, _V), list(K)).
     :- mode map__keys(in, out) is det.
     
     	% Given a map, return a list of all the data values in the map
     :- pred map__values(map(_K, V), list(V)).
     :- mode map__values(in, out) is det.
     
     	% convert a map to an association list
     :- pred map__to_assoc_list(map(K,V), assoc_list(K,V)).
     :- mode map__to_assoc_list(in, out) is det.
     
     	% convert an association list to a map
     :- pred map__from_assoc_list(assoc_list(K,V), map(K,V)).
     :- mode map__from_assoc_list(in, out) is det.
     
     	% convert a sorted association list to a map
     :- pred map__from_sorted_assoc_list(assoc_list(K,V), map(K,V)).
     :- mode map__from_sorted_assoc_list(in, out) is det.
     
     	% delete a key-value pair from a map
     	% if the key is not present, leave the map unchanged
     :- pred map__delete(map(K,V), K, map(K,V)).
     :- mode map__delete(di, in, uo) is det.
     :- mode map__delete(in, in, out) is det.
     
     	% apply map__delete/3 to a list of keys
     :- pred map__delete_list(map(K,V), list(K), map(K,V)).
     :- mode map__delete_list(di, in, uo) is det.
     :- mode map__delete_list(in, in, out) is det.
     
     	% delete a key-value pair from a map and return the value.
     	% fail if the key is not present
     :- pred map__remove(map(K,V), K, V, map(K,V)).
     :- mode map__remove(in, in, out, out) is semidet.
     
     	% delete a key-value pair from a map and return the value.
     	% abort if the key is not present
     :- pred map__det_remove(map(K,V), K, V, map(K,V)).
     :- mode map__det_remove(in, in, out, out) is det.
     
     	% Count the number of elements in the map.
     :- pred map__count(map(K, V), int).
     :- mode map__count(in, out) is det.
     
     	% Convert a pair of lists (which must be of the same length)
     	% to a map.
     :- pred map__from_corresponding_lists(list(K), list(V), map(K, V)).
     :- mode map__from_corresponding_lists(in, in, out) is det.
     
     	% For map__merge(MapA, MapB, Map), MapA and MapB must
     	% not both contain the same key.
     :- pred map__merge(map(K, V), map(K, V), map(K, V)).
     :- mode map__merge(in, in, out) is det.
     
     	% For map__overlay(MapA, MapB, Map), if MapA and MapB both
     	% contain the same key, then Map will map that key to
     	% the value from MapB.  In otherwords, MapB takes precedence
     	% over MapA.
     :- pred map__overlay(map(K,V), map(K,V), map(K,V)).
     :- mode map__overlay(in, in, out) is det.
     
     	% map__select takes a map and a set of keys and returns
     	% a map containing the keys in the set and their corresponding
     	% values.
     :- pred map__select(map(K,V), set(K), map(K,V)).
     :- mode map__select(in, in, out) is det.
     
     	% Given a list of keys, produce a list of their corresponding
     	% values in a specified map.
     :- pred map__apply_to_list(list(K), map(K, V), list(V)).
     :- mode map__apply_to_list(in, in, out) is det.
     
     	% Declaratively, a NOP.
     	% Operationally, a suggestion that the implemention
     	% optimize the representation of the map in the expectation
     	% of a number of lookups but few or no modifications.
     :- pred map__optimize(map(K, V), map(K, V)).
     :- mode map__optimize(in, out) is det.
     
     	% Remove the smallest item from the map, fail if
     	% the map is empty.
     :- pred map__remove_smallest(map(K, V), K, V, map(K, V)).
     :- mode map__remove_smallest(in, out, out, out) is semidet.
     
     %--------------------------------------------------%
     
     :- import_module tree234.
     
     :- type map(K,V)	==	tree234(K,V).
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: math,  Next: mercury_builtin,  Prev: map,  Up: Top

math
****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: math.m
     % Main author: bromage
     % Stability: high (but as yet no Prolog implementation)
     %
     % Higher mathematical operations.  (The basics are in float.m.)
     % The predicates in this module are not yet implemented in Prolog.
     %
     % Domain errors are currently handled by a program abort.  This is
     % because Mercury currently does not have exceptions built in.
     % Exception-handling would be nice, but it's kind of low on the
     % priority scale.
     %
     %--------------------------------------------------%
     
     :- module math.
     :- interface.
     :- import_module float.
     
     %--------------------------------------------------%
     % Mathematical constants
     
     	% Pythagoras' number
     :- pred math__pi(float).
     :- mode math__pi(out) is det.
     
     	% Base of natural logarithms
     :- pred math__e(float).
     :- mode math__e(out) is det.
     
     %--------------------------------------------------%
     % "Next integer" operations
     
     	% math__ceiling(X, Ceil) is true if Ceil is the smallest integer
     	% not less than X.
     :- pred math__ceiling(float, float).
     :- mode math__ceiling(in, out) is det.
     
     	% math__floor(X, Floor) is true if Floor is the largest integer
     	% not greater than X.
     :- pred math__floor(float, float).
     :- mode math__floor(in, out) is det.
     
     	% math__round(X, Round) is true if Round is the integer
     	% closest to X.  If X has a fractional value of 0.5, it
     	% is rounded up.
     :- pred math__round(float, float).
     :- mode math__round(in, out) is det.
     
     	% math__truncate(X, Trunc) is true if Trunc is the integer
     	% closest to X such that |Trunc| =< |X|.
     :- pred math__truncate(float, float).
     :- mode math__truncate(in, out) is det.
     
     %--------------------------------------------------%
     % Power/logarithm operations
     
     	% math__sqrt(X, Sqrt) is true if Sqrt is the positive square
     	% root of X.
     	%
     	% Domain restriction: X >= 0
     :- pred math__sqrt(float, float).
     :- mode math__sqrt(in, out) is det.
     
     	% math__pow(X, Y, Res) is true if Res is X raised to the
     	% power of Y.
     	%
     	% Domain restriction: X >= 0 and (X = 0 implies Y > 0)
     :- pred math__pow(float, float, float).
     :- mode math__pow(in, in, out) is det.
     
     	% math__exp(X, Exp) is true if Exp is X raised to the
     	% power of e.
     :- pred math__exp(float, float).
     :- mode math__exp(in, out) is det.
     
     	% math__ln(X, Log) is true if Log is the natural logarithm
     	% of X.
     	%
     	% Domain restriction: X > 0
     :- pred math__ln(float, float).
     :- mode math__ln(in, out) is det.
     
     	% math__log10(X, Log) is true if Log is the logarithm to
     	% base 10 of X.
     	%
     	% Domain restriction: X > 0
     :- pred math__log10(float, float).
     :- mode math__log10(in, out) is det.
     
     	% math__log2(X, Log) is true if Log is the logarithm to
     	% base 2 of X.
     	%
     	% Domain restriction: X > 0
     :- pred math__log2(float, float).
     :- mode math__log2(in, out) is det.
     
     	% math__log(B, X, Log) is true if Log is the logarithm to
     	% base B of X.
     	%
     	% Domain restriction: X > 0 and B > 0 and B \= 1
     :- pred math__log(float, float, float).
     :- mode math__log(in, in, out) is det.
     
     %--------------------------------------------------%
     % Trigonometric operations
     
     	% math__sin(X, Sin) is true if Sin is the sine of X.
     :- pred math__sin(float, float).
     :- mode math__sin(in, out) is det.
     
     	% math__cos(X, Cos) is true if Cos is the cosine of X.
     :- pred math__cos(float, float).
     :- mode math__cos(in, out) is det.
     
     	% math__tan(X, Tan) is true if Tan is the tangent of X.
     :- pred math__tan(float, float).
     :- mode math__tan(in, out) is det.
     
     	% math__asin(X, ASin) is true if ASin is the inverse
     	% sine of X, where ASin is in the range [-pi/2,pi/2].
     	%
     	% Domain restriction: X must be in the range [-1,1]
     :- pred math__asin(float, float).
     :- mode math__asin(in, out) is det.
     
     	% math__acos(X, ACos) is true if ACos is the inverse
     	% cosine of X, where ACos is in the range [0, pi].
     	%
     	% Domain restriction: X must be in the range [-1,1]
     :- pred math__acos(float, float).
     :- mode math__acos(in, out) is det.
     
     	% math__atan(X, ATan) is true if ATan is the inverse
     	% tangent of X, where ATan is in the range [-pi/2,pi/2].
     :- pred math__atan(float, float).
     :- mode math__atan(in, out) is det.
     
     	% math__atan2(Y, X, ATan) is true if ATan is the inverse
     	% tangent of Y/X, where ATan is in the range [-pi,pi].
     :- pred math__atan2(float, float, float).
     :- mode math__atan2(in, in, out) is det.
     
     %--------------------------------------------------%
     % Hyperbolic functions
     
     	% math__sinh(X, Sinh) is true if Sinh is the hyperbolic
     	% sine of X.
     :- pred math__sinh(float, float).
     :- mode math__sinh(in, out) is det.
     
     	% math__cosh(X, Cosh) is true if Cosh is the hyperbolic
     	% cosine of X.
     :- pred math__cosh(float, float).
     :- mode math__cosh(in, out) is det.
     
     	% math__tanh(X, Tanh) is true if Tanh is the hyperbolic
     	% tangent of X.
     :- pred math__tanh(float, float).
     :- mode math__tanh(in, out) is det.
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: mercury_builtin,  Next: multi_map,  Prev: math,  Up: Top

mercury_builtin
***************

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: mercury_builtin.m.
     % Main author: fjh.
     % Stability: low.
     
     % This file is automatically imported into every module.
     % It is intended for things that are part of the language,
     % but which are implemented just as normal user-level code
     % rather than with special coding in the compiler.
     
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module mercury_builtin.
     :- interface.
     
     %--------------------------------------------------%
     
     % TYPES.
     
     % The types `character', `int', `float', and `string',
     % and the types `pred', `pred(T)', `pred(T1, T2)', `pred(T1, T2, T3)', ...
     % are builtin and are implemented using special code in the
     % type-checker.  (XXX TODO: report an error for attempts to redefine
     % these types.)
     
     % The type c_pointer can be used by predicates which use the C interface.
     :- type c_pointer.
     
     %--------------------------------------------------%
     
     % INSTS.
     
     % The standard insts `free', `ground', and `bound(...)' are builtin
     % and are implemented using special code in the parser and mode-checker.
     
     % So are the standard unique insts `unique', `unique(...)',
     % `mostly_unique', `mostly_unique(...)', and `clobbered'.
     % The name `dead' is allowed as a synonym for `clobbered'.
     
     :- inst dead = clobbered.
     
     % The not yet properly supported `any' inst used for the
     % constraint solver interface is also builtin.
     
     % Higher-order predicate insts `pred(<modes>) is <detism>' are also builtin.
     
     %--------------------------------------------------%
     
     % MODES.
     
     % The standard modes.
     
     :- mode unused :: (free -> free).
     :- mode output :: (free -> ground).
     :- mode input :: (ground -> ground).
     
     :- mode in :: (ground -> ground).
     :- mode out :: (free -> ground).
     
     :- mode in(Inst) :: (Inst -> Inst).
     :- mode out(Inst) :: (free -> Inst).
     :- mode di(Inst) :: (Inst -> clobbered).
     
     % Unique modes.  These are still not fully implemented.
     
     % unique output
     :- mode uo :: free -> unique.
     
     % unique input
     :- mode ui :: unique -> unique.
     
     % destructive input
     :- mode di :: unique -> clobbered.
     
     % "Mostly" unique modes (unique except that that may be referenced
     % again on backtracking).
     
     % mostly unique output
     :- mode muo :: free -> mostly_unique.
     
     % mostly unique input
     :- mode mui :: mostly_unique -> mostly_unique.
     
     % mostly destructive input
     :- mode mdi :: mostly_unique -> mostly_clobbered.
     
     % Higher-order predicate modes are builtin.
     
     %--------------------------------------------------%
     
     % PREDICATES.
     
     % copy/2 is used to make a `unique' copy of a data structure,
     % so that you can use destructive update.
     % At the moment it doesn't actually do any copying, since we
     % haven't implemented destructive update yet and so there is no need.
     
     :- pred copy(T, T).
     :- mode copy(ui, uo) is det.
     :- mode copy(in, uo) is det.
     
     % We define !/0 (and !/2 for dcgs) to be equivalent to `true'.  This is for
     % backwards compatibility with Prolog systems.  But of course it only works
     % if all your cuts are green cuts.
     
     :- pred ! is det.
     
     :- pred !(T, T).
     :- mode !(di, uo) is det.
     :- mode !(in, out) is det.
     
     % In addition, the following predicate-like constructs are builtin:
     %
     %	:- pred (T = T).
     %	:- pred (T \= T).
     %	:- pred (pred , pred).
     %	:- pred (pred ; pred).
     %	:- pred (\+ pred).
     %	:- pred (not pred).
     %	:- pred (pred -> pred).
     %	:- pred (if pred then pred).
     %	:- pred (if pred then pred else pred).
     %	:- pred (pred => pred).
     %	:- pred (pred <= pred).
     %	:- pred (pred <=> pred).
     %
     %	(pred -> pred ; pred).
     %	some Vars pred
     %	all Vars pred
     %	call/N
     
     %--------------------------------------------------%
     
     	% unify(X, Y) is true iff X = Y.
     :- pred unify(T::in, T::in) is semidet.
     
     :- type comparison_result ---> (=) ; (<) ; (>).
     
     	% compare(Res, X, Y) binds Res to =, <, or >
     	% depending on whether X is =, <, or > Y in the
     	% standard ordering.
     :- pred compare(comparison_result, T, T).
     :- mode compare(uo, ui, ui) is det.
     :- mode compare(uo, ui, in) is det.
     :- mode compare(uo, in, ui) is det.
     :- mode compare(uo, in, in) is det.
     
     	% The following three predicates can convert values of any
     	% type to the type `term' and back again.
     	% However, they are not yet implemented.
     
     :- pred term_to_type(term :: in, T :: out) is semidet.
     
     :- pred det_term_to_type(term :: in, T :: out) is det.
     
     :- pred type_to_term(T :: in, term :: out) is det.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: multi_map,  Next: ops,  Prev: mercury_builtin,  Up: Top

multi_map
*********

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: multi_map.m.
     % Main author: dylan.  Based on map.m, by fjh, conway.
     % Stability: low.
     %
     % This file provides the 'multi_map' ADT.
     % A map (also known as a dictionary or an associative array) is a collection
     % of (Key,Data) pairs which allows you to look up any Data item given the
     % Key.  A multi_map is similar, though allows a one to many relationship
     % between keys and data.
     %
     % This is implemented almost as a special case of map.m.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module multi_map.
     :- interface.
     :- import_module map, list, int, std_util.
     
     %--------------------------------------------------%
     
     :- type multi_map(Key, Data)	==	map(Key, list(Data)).
     
     %--------------------------------------------------%
     
     	% Initialize an empty multi_map.
     :- pred multi_map__init(multi_map(_,_)).
     :- mode multi_map__init(uo) is det.
     
     	% Check whether a multi_map is empty.
     :- pred multi_map__is_empty(multi_map(_,_)).
     :- mode multi_map__is_empty(in) is semidet.
     
     	% Check whether multi_map contains key
     :- pred multi_map__contains(multi_map(K,_V), K).
     :- mode multi_map__contains(in, in) is semidet.
     
     :- pred multi_map__member(multi_map(K,V), K, V).
     :- mode multi_map__member(in, out, out) is nondet.
     
     	% Search multi_map for given key.
     :- pred multi_map__search(multi_map(K,V), K, list(V)).
     :- mode multi_map__search(in, in, out) is semidet.
     
     	% Search multi_map for given key.
     :- pred multi_map__nondet_search(multi_map(K,V), K, V).
     :- mode multi_map__nondet_search(in, in, out) is nondet.
     
     	% Search multi_map for key, but abort if search fails.
     :- pred multi_map__lookup(multi_map(K,V), K, list(V)).
     :- mode multi_map__lookup(in, in, out) is det.
     
     	% Search multi_map for key.
     :- pred multi_map__nondet_lookup(multi_map(K,V), K, V).
     :- mode multi_map__nondet_lookup(in, in, out) is nondet.
     
     	% Search multi_map for data.
     :- pred multi_map__inverse_search(multi_map(K,V), V, K).
     :- mode multi_map__inverse_search(in, in, out) is nondet.
     
     	% Insert a new key and corresponding value into a multi_map.
     	% Fail if the key already exists.
     :- pred multi_map__insert(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__insert(in, in, in, out) is semidet.
     
     	% Insert a new key and corresponding value into a multi_map.
     	% Abort if the key already exists.
     :- pred multi_map__det_insert(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__det_insert(in, in, in, out) is det.
     
     	% Update (add) the value corresponding to a given key
     	% Fail if the key doesn't already exist.
     :- pred multi_map__update(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__update(in, in, in, out) is semidet.
     
     	% Update (add) the value corresponding to a given key
     	% Abort if the key doesn't already exist.
     :- pred multi_map__det_update(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__det_update(in, in, in, out) is det.
     
     	% Update (replace) the value corresponding to a given key
     	% Abort if the key doesn't already exist.
     :- pred multi_map__det_replace(multi_map(K,V), K, list(V), multi_map(K,V)).
     :- mode multi_map__det_replace(in, in, in, out) is det.
     
     	% Update (add) value if the key is already present, otherwise
     	% insert new key and value.
     :- pred multi_map__set(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__set(in, in, in, out) is det.
     
     	% Given a multi_map, return a list of all the keys in the multi_map
     :- pred multi_map__keys(multi_map(K, _V), list(K)).
     :- mode multi_map__keys(in, out) is det.
     
     	% Given a multi_map, return a list of all the data values in the
     	% multi_map
     :- pred multi_map__values(multi_map(_K, V), list(V)).
     :- mode multi_map__values(in, out) is det.
     
     	% convert a multi_map to an association list
     :- pred multi_map__to_assoc_list(multi_map(K,V), assoc_list(K,list(V))).
     :- mode multi_map__to_assoc_list(in, out) is det.
     
     	% convert an association list to a multi_map
     :- pred multi_map__from_assoc_list(assoc_list(K,list(V)), multi_map(K,V)).
     :- mode multi_map__from_assoc_list(in, out) is det.
     
     	% convert a sorted association list to a multi_map
     :- pred multi_map__from_sorted_assoc_list(assoc_list(K, list(V)),
     			multi_map(K, V)).
     :- mode multi_map__from_sorted_assoc_list(in, out) is det.
     
     	% delete a key and data from a multi_map
     	% if the key is not present, leave the multi_map unchanged
     :- pred multi_map__delete(multi_map(K,V), K, multi_map(K,V)).
     :- mode multi_map__delete(in, in, out) is det.
     
     	% delete a data value from a key in a multi_map
     	% if the key is not present, leave the multi_map unchanged
     :- pred multi_map__delete(multi_map(K,V), K, V, multi_map(K,V)).
     :- mode multi_map__delete(in, in, in, out) is det.
     
     	% delete a key-value pair from a multi_map and return the value.
     	% fail if the key is not present
     :- pred multi_map__remove(multi_map(K,V), K, list(V), multi_map(K,V)).
     :- mode multi_map__remove(in, in, out, out) is semidet.
     
     	% delete a key-value pair from a multi_map and return the value.
     	% abort if the key is not present
     :- pred multi_map__det_remove(multi_map(K,V), K, list(V), multi_map(K,V)).
     :- mode multi_map__det_remove(in, in, out, out) is det.
     
     	% Count the number of elements (keys) in the multi_map.
     :- pred multi_map__count(multi_map(K, V), int).
     :- mode multi_map__count(in, out) is det.
     
     	% Count the number of data elements in the multi_map.
     :- pred multi_map__all_count(multi_map(K, V), int).
     :- mode multi_map__all_count(in, out) is det.
     
     	% Convert a pair of lists (which must be of the same length)
     	% to a multi_map.
     :- pred multi_map__from_corresponding_lists(list(K), list(V), multi_map(K, V)).
     :- mode multi_map__from_corresponding_lists(in, in, out) is det.
     
     	% Convert a pair of lists (which must be of the same length)
     	% to a multi_map.
     :- pred multi_map__from_corresponding_list_lists(list(K), list(list(V)),
     				multi_map(K, V)).
     :- mode multi_map__from_corresponding_list_lists(in, in, out) is det.
     
     	% For multi_map__merge(MultiMapA, MultiMapB, MultiMap).
     :- pred multi_map__merge(multi_map(K, V), multi_map(K, V), multi_map(K, V)).
     :- mode multi_map__merge(in, in, out) is det.
     
     	% multi_map__select takes a multi_map and a set of keys and returns
     	% a multi_map containing the keys in the set and their corresponding
     	% values.
     :- pred multi_map__select(multi_map(K,V), set(K), multi_map(K,V)).
     :- mode multi_map__select(in, in, out) is det.
     
     	% Given a list of keys, produce a list of their values in a
     	% specified multi_map.
     :- pred multi_map__apply_to_list(list(K), multi_map(K, V), list(V)).
     :- mode multi_map__apply_to_list(in, in, out) is det.
     
     	% Declaratively, a NOP.
     	% Operationally, a suggestion that the implemention
     	% optimize the representation of the multi_map in the expectation
     	% of a number of lookups but few or no modifications.
     :- pred multi_map__optimize(multi_map(K, V), multi_map(K, V)).
     :- mode multi_map__optimize(in, out) is det.
     
     	% Remove the smallest item from the multi_map, fail if
     	% the multi_map is empty.
     :- pred multi_map__remove_smallest(multi_map(K, V), K, list(V),
     			multi_map(K, V)).
     :- mode multi_map__remove_smallest(in, out, out, out) is semidet.
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: ops,  Next: parser,  Prev: multi_map,  Up: Top

ops
***

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % file: ops.m.
     % main author: fjh.
     % stability: low.
     %
     % Here's where we maintain the table of current operators.
     %
     % XXX In the current implementation the table is fixed and cannot be
     % modified at run-time.
     %
     %--------------------------------------------------%
     
     :- module ops.
     :- interface.
     
     :- type ops__specifier
     	--->	fx ; fy ; xf ; yf ; xfx ; yfx ; xfy ; fxx ; fxy ; fyx.
     
     :- type ops__assoc
     	--->	x ; y.
     
     :- type ops__class
     	--->	infix(ops__assoc, ops__assoc)
     	;	prefix(ops__assoc)
     	;	binary_prefix(ops__assoc, ops__assoc)
     	;	postfix(ops__assoc).
     
     :- type ops__table.
     
     :- type ops__priority == int.
     
     	% create an ops_table with the standard Mercury operators.
     :- pred ops__init_op_table(ops__table).
     :- mode ops__init_op_table(uo) is det.
     
     	% check whether a string is the name of an infix operator,
     	% and if it is, return its precedence and associativity.
     :- pred ops__lookup_infix_op(ops__table, string, int, ops__assoc, ops__assoc).
     :- mode ops__lookup_infix_op(in, in, out, out, out) is semidet.
     
     	% check whether a string is the name of a prefix operator,
     	% and if it is, return its precedence and associativity.
     :- pred ops__lookup_prefix_op(ops__table, string, int, ops__assoc).
     :- mode ops__lookup_prefix_op(in, in, out, out) is semidet.
     
     	% check whether a string is the name of a binary prefix operator,
     	% and if it is, return its precedence and associativity.
     :- pred ops__lookup_binary_prefix_op(ops__table, string,
     					int, ops__assoc, ops__assoc).
     :- mode ops__lookup_binary_prefix_op(in, in, out, out, out) is semidet.
     
     	% check whether a string is the name of a postfix operator,
     	% and if it is, return its precedence and associativity.
     :- pred ops__lookup_postfix_op(ops__table, string, int, ops__assoc).
     :- mode ops__lookup_postfix_op(in, in, out, out) is semidet.
     
     	% check whether a string is the name of an operator
     :- pred ops__lookup_op(ops__table, string).
     :- mode ops__lookup_op(in, in) is semidet.
     
     	% convert an ops__specifer (e.g. `xfy') to an ops__class
     	% (e.g. `infix(x, y)').
     :- pred ops__op_specifier_to_class(ops__specifier, ops__class).
     :- mode ops__op_specifier_to_class(in, out) is det.
     % :- mode ops__op_specifier_to_class(out, in) is semidet.
     
     %--------------------------------------------------%

