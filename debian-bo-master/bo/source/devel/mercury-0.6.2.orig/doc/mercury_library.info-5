This is Info file mercury_library.info, produced by Makeinfo-1.63 from
the input file library.texi.

START-INFO-DIR-ENTRY
* Mercury Library: (mercury_library). The Mercury Library Reference Manual
END-INFO-DIR-ENTRY

   This file documents the Mercury standard library.

   Copyright (C) 1995 University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: mercury_library.info,  Node: set_ordlist,  Next: set_unordlist,  Prev: set_bbbtree,  Up: Top

set_ordlist
***********

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: set_ordlist.m.
     % Main authors: conway, fjh.
     % Stability: medium.
     
     % This file contains a `set' ADT.
     % Sets are implemented here as sorted lists without duplicates.
     
     %--------------------------------------------------%
     
     :- module set_ordlist.
     :- interface.
     :- import_module bool, list, std_util.
     
     :- type set_ordlist(_T).
     
     	% `set_ordlist__list_to_set(List, Set)' is true iff `Set' is the set
     	% containing only the members of `List'.
     
     :- pred set_ordlist__list_to_set(list(T), set_ordlist(T)).
     :- mode set_ordlist__list_to_set(in, out) is det.
     
     	% `set_ordlist__sorted_list_to_set(List, Set)' is true iff `Set' is
     	% the set containing only the members of `List'.  `List' must be sorted.
     
     :- pred set_ordlist__sorted_list_to_set(list(T), set_ordlist(T)).
     :- mode set_ordlist__sorted_list_to_set(in, out) is det.
     
     	% `set_ordlist__to_sorted_list(Set, List)' is true iff `List' is the
     	% list of all the members of `Set', in sorted order.
     
     :- pred set_ordlist__to_sorted_list(set_ordlist(T), list(T)).
     :- mode set_ordlist__to_sorted_list(in, out) is det.
     
     	% `set_ordlist__init(Set)' is true iff `Set' is an empty set.
     
     :- pred set_ordlist__init(set_ordlist(_T)).
     :- mode set_ordlist__init(uo) is det.
     
     	% `set_ordlist__singleton_set(Set, Elem)' is true iff `Set' is the set
     	% containing just the single element `Elem'.
     
     :- pred set_ordlist__singleton_set(set_ordlist(T), T).
     :- mode set_ordlist__singleton_set(in, out) is semidet.
     :- mode set_ordlist__singleton_set(out, in) is det.
     
     	% `set_ordlist__equal(SetA, SetB)' is true iff
     	% `SetA' and `SetB' contain the same elements.
     
     :- pred set_ordlist__equal(set_ordlist(T), set_ordlist(T)).
     :- mode set_ordlist__equal(in, in) is semidet.
     
     	% `set_ordlist__empty(Set)' is true iff `Set' is an empty set.
     
     :- pred set_ordlist__empty(set_ordlist(_T)).
     :- mode set_ordlist__empty(in) is semidet.
     
     	% `set_ordlist__subset(SetA, SetB)' is true iff `SetA' is a subset of
     	% `SetB'.
     
     :- pred set_ordlist__subset(set_ordlist(T), set_ordlist(T)).
     :- mode set_ordlist__subset(in, in) is semidet.
     
     	% `set_ordlist__superset(SetA, SetB)' is true iff `SetA' is a
     	% superset of `SetB'.
     
     :- pred set_ordlist__superset(set_ordlist(T), set_ordlist(T)).
     :- mode set_ordlist__superset(in, in) is semidet.
     
     	% `set_ordlist__member(X, Set)' is true iff `X' is a member of `Set'.
     
     :- pred set_ordlist__member(T, set_ordlist(T)).
     :- mode set_ordlist__member(in, in) is semidet.
     :- mode set_ordlist__member(out, in) is nondet.
     
     	% `set_ordlist__is_member(X, Set, Result)' returns
     	% `Result = yes' iff `X' is a member of `Set'.
     
     :- pred set_ordlist__is_member(T, set_ordlist(T), bool).
     :- mode set_ordlist__is_member(in, in, out) is det.
     
     	% `set_ordlist__insert(Set0, X, Set)' is true iff `Set' is the union
     	% of `Set0' and the set containing only `X'.
     
     :- pred set_ordlist__insert(set_ordlist(T), T, set_ordlist(T)).
     :- mode set_ordlist__insert(di, di, uo) is det.
     :- mode set_ordlist__insert(in, in, out) is det.
     
     	% `set_ordlist__insert_list(Set0, Xs, Set)' is true iff `Set' is the
     	% union of `Set0' and the set containing only the members of `Xs'.
     
     :- pred set_ordlist__insert_list(set_ordlist(T), list(T), set_ordlist(T)).
     :- mode set_ordlist__insert_list(in, in, out) is det.
     
     	% `set_ordlist__delete(Set0, X, Set)' is true iff `Set' is the
     	% relative complement of `Set0' and the set containing only `X', i.e.
     	% if `Set' is the set which contains all the elements of `Set0'
     	% except `X'.
     
     :- pred set_ordlist__delete(set_ordlist(T), T, set_ordlist(T)).
     % :- mode set_ordlist__delete(di, in, uo) is det.
     :- mode set_ordlist__delete(in, in, out) is det.
     
     	% `set_ordlist__delete_list(Set0, Xs, Set)' is true iff `Set' is the
     	% relative complement of `Set0' and the set containing only the members
     	% of `Xs'.
     
     :- pred set_ordlist__delete_list(set_ordlist(T), list(T), set_ordlist(T)).
     :- mode set_ordlist__delete_list(in, in, out) is det.
     
     	% `set_ordlist__remove(Set0, X, Set)' is true iff `Set0' contains `X',
     	% and `Set' is the relative complement of `Set0' and the set
     	% containing only `X', i.e.  if `Set' is the set which contains
     	% all the elements of `Set0' except `X'.
     
     :- pred set_ordlist__remove(set_ordlist(T), T, set_ordlist(T)).
     :- mode set_ordlist__remove(in, in, out) is semidet.
     
     	% `set_ordlist__remove_list(Set0, Xs, Set)' is true iff Xs does not
     	% contain any duplicates, `Set0' contains every member of `Xs',
     	% and `Set' is the relative complement of `Set0' and the set
     	% containing only the members of `Xs'.
     
     :- pred set_ordlist__remove_list(set_ordlist(T), list(T), set_ordlist(T)).
     :- mode set_ordlist__remove_list(in, in, out) is semidet.
     
     	% `set_ordlist__remove_least(Set0, X, Set)' is true iff `X' is the
     	% least element in `Set0', and `Set' is the set which contains all the
     	% elements of `Set0' except `X'.
     
     :- pred set_ordlist__remove_least(set_ordlist(T), T, set_ordlist(T)).
     :- mode set_ordlist__remove_least(in, out, out) is semidet.
     
     	% `set_ordlist_union(SetA, SetB, Set)' is true iff `Set' is the union
     	% of `SetA' and `SetB'. The efficiency of the union operation is
     	% O(card(SetA)+card(SetB)) and is not sensitive to the argument
     	% ordering.
     
     :- pred set_ordlist__union(set_ordlist(T), set_ordlist(T),
     							set_ordlist(T)).
     :- mode set_ordlist__union(in, in, out) is det.
     
     	% `set_ordlist__power_union(A, B)' is true iff `B' is the union of
     	% all the sets in `A'
     
     :- pred set_ordlist__power_union(set_ordlist(set_ordlist(T)),
     							set_ordlist(T)).
     :- mode set_ordlist__power_union(in, out) is det.
     
     	% `set_ordlist__intersect(SetA, SetB, Set)' is true iff `Set' is the
     	% intersection of `SetA' and `SetB'. The efficiency of the intersection
     	% operation is not influenced by the argument order.
     
     :- pred set_ordlist__intersect(set_ordlist(T), set_ordlist(T),
     							set_ordlist(T)).
     :- mode set_ordlist__intersect(in, in, out) is det.
     :- mode set_ordlist__intersect(in, in, in) is semidet.
     
     	% `set_ordlist__power_intersect(A, B)' is true iff `B' is the
     	% intersection of all the sets in `A'
     
     :- pred set_ordlist__power_intersect(set_ordlist(set_ordlist(T)),
     							set_ordlist(T)).
     :- mode set_ordlist__power_intersect(in, out) is det.
     
     	% `set_ordlist__difference(SetA, SetB, Set)' is true iff `Set' is the
     	% set containing all the elements of `SetA' except those that
     	% occur in `SetB'
     
     :- pred set_ordlist__difference(set_ordlist(T), set_ordlist(T),
     							set_ordlist(T)).
     :- mode set_ordlist__difference(in, in, out) is det.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: set_unordlist,  Next: stack,  Prev: set_ordlist,  Up: Top

set_unordlist
*************

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: set_unordlist.m.
     % Main authors: conway, fjh.
     % Stability: medium.
     
     % This file contains a `set' ADT.
     % Sets are implemented here as unsorted lists, which may contain duplicates.
     
     %--------------------------------------------------%
     
     :- module set_unordlist.
     :- interface.
     :- import_module bool, list, std_util.
     
     :- type set_unordlist(_T).
     
     	% `set_unordlist__list_to_set(List, Set)' is true iff `Set' is the set
     	% containing only the members of `List'.
     
     :- pred set_unordlist__list_to_set(list(T), set_unordlist(T)).
     :- mode set_unordlist__list_to_set(in, out) is det.
     
     	% `set_unordlist__sorted_list_to_set(List, Set)' is true iff `Set' is
     	% the set containing only the members of `List'.  `List' must be sorted.
     
     :- pred set_unordlist__sorted_list_to_set(list(T), set_unordlist(T)).
     :- mode set_unordlist__sorted_list_to_set(in, out) is det.
     
     	% `set_unordlist__to_sorted_list(Set, List)' is true iff `List' is the
     	% list of all the members of `Set', in sorted order.
     
     :- pred set_unordlist__to_sorted_list(set_unordlist(T), list(T)).
     :- mode set_unordlist__to_sorted_list(in, out) is det.
     
     	% `set_unordlist__init(Set)' is true iff `Set' is an empty set.
     
     :- pred set_unordlist__init(set_unordlist(_T)).
     :- mode set_unordlist__init(uo) is det.
     
     	% `set_unordlist__singleton_set(Set, Elem)' is true iff `Set' is the set
     	% containing just the single element `Elem'.
     
     :- pred set_unordlist__singleton_set(set_unordlist(T), T).
     :- mode set_unordlist__singleton_set(in, out) is semidet.
     :- mode set_unordlist__singleton_set(out, in) is det.
     
     	% `set_unordlist__equal(SetA, SetB)' is true iff
     	% `SetA' and `SetB' contain the same elements.
     
     :- pred set_unordlist__equal(set_unordlist(T), set_unordlist(T)).
     :- mode set_unordlist__equal(in, in) is semidet.
     
     	% `set_unordlist__empty(Set)' is true iff `Set' is an empty set.
     
     :- pred set_unordlist__empty(set_unordlist(_T)).
     :- mode set_unordlist__empty(in) is semidet.
     
     	% `set_unordlist__subset(SetA, SetB)' is true iff `SetA' is a subset of
     	% `SetB'.
     
     :- pred set_unordlist__subset(set_unordlist(T), set_unordlist(T)).
     :- mode set_unordlist__subset(in, in) is semidet.
     
     	% `set_unordlist__superset(SetA, SetB)' is true iff `SetA' is a
     	% superset of `SetB'.
     
     :- pred set_unordlist__superset(set_unordlist(T), set_unordlist(T)).
     :- mode set_unordlist__superset(in, in) is semidet.
     
     	% `set_unordlist__member(X, Set)' is true iff `X' is a member of `Set'.
     
     :- pred set_unordlist__member(T, set_unordlist(T)).
     :- mode set_unordlist__member(in, in) is semidet.
     :- mode set_unordlist__member(out, in) is nondet.
     
     	% `set_unordlist__is_member(X, Set, Result)' returns
     	% `Result = yes' iff `X' is a member of `Set'.
     
     :- pred set_unordlist__is_member(T, set_unordlist(T), bool).
     :- mode set_unordlist__is_member(in, in, out) is det.
     
     	% `set_unordlist__insert(Set0, X, Set)' is true iff `Set' is the union
     	% of `Set0' and the set containing only `X'.
     
     :- pred set_unordlist__insert(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist__insert(di, di, uo) is det.
     :- mode set_unordlist__insert(in, in, out) is det.
     
     	% `set_unordlist__insert_list(Set0, Xs, Set)' is true iff `Set' is the
     	% union of `Set0' and the set containing only the members of `Xs'.
     
     :- pred set_unordlist__insert_list(set_unordlist(T), list(T), set_unordlist(T)).
     :- mode set_unordlist__insert_list(in, in, out) is det.
     
     	% `set_unordlist__delete(Set0, X, Set)' is true iff `Set' is the
     	% relative complement of `Set0' and the set containing only `X', i.e.
     	% if `Set' is the set which contains all the elements of `Set0'
     	% except `X'.
     
     :- pred set_unordlist__delete(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist__delete(di, in, uo) is det.
     :- mode set_unordlist__delete(in, in, out) is det.
     
     	% `set_unordlist__delete_list(Set0, Xs, Set)' is true iff `Set' is the
     	% relative complement of `Set0' and the set containing only the members
     	% of `Xs'.
     
     :- pred set_unordlist__delete_list(set_unordlist(T), list(T), set_unordlist(T)).
     :- mode set_unordlist__delete_list(in, in, out) is det.
     
     	% `set_unordlist__remove(Set0, X, Set)' is true iff `Set0' contains `X',
     	% and `Set' is the relative complement of `Set0' and the set
     	% containing only `X', i.e.  if `Set' is the set which contains
     	% all the elements of `Set0' except `X'.
     
     :- pred set_unordlist__remove(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist__remove(in, in, out) is semidet.
     
     	% `set_unordlist__remove_list(Set0, Xs, Set)' is true iff Xs does not
     	% contain any duplicates, `Set0' contains every member of `Xs',
     	% and `Set' is the relative complement of `Set0' and the set
     	% containing only the members of `Xs'.
     
     :- pred set_unordlist__remove_list(set_unordlist(T), list(T), set_unordlist(T)).
     :- mode set_unordlist__remove_list(in, in, out) is semidet.
     
     	% `set_unordlist__remove_least(Set0, X, Set)' is true iff `X' is the
     	% least element in `Set0', and `Set' is the set which contains all the
     	% elements of `Set0' except `X'.
     
     :- pred set_unordlist__remove_least(set_unordlist(T), T, set_unordlist(T)).
     :- mode set_unordlist__remove_least(in, out, out) is semidet.
     
     	% `set_unordlist_union(SetA, SetB, Set)' is true iff `Set' is the union
     	% of `SetA' and `SetB'.  If the sets are known to be of different
     	% sizes, then for efficiency make `SetA' the larger of the two.
     
     :- pred set_unordlist__union(set_unordlist(T), set_unordlist(T),
     							set_unordlist(T)).
     :- mode set_unordlist__union(in, in, out) is det.
     
     	% `set_unordlist__power_union(A, B)' is true iff `B' is the union of
     	% all the sets in `A'
     
     :- pred set_unordlist__power_union(set_unordlist(set_unordlist(T)),
     							set_unordlist(T)).
     :- mode set_unordlist__power_union(in, out) is det.
     
     	% `set_unordlist__intersect(SetA, SetB, Set)' is true iff `Set' is the
     	% intersection of `SetA' and `SetB'.
     
     :- pred set_unordlist__intersect(set_unordlist(T), set_unordlist(T),
     							set_unordlist(T)).
     :- mode set_unordlist__intersect(in, in, out) is det.
     
     	% `set_unordlist__power_intersect(A, B)' is true iff `B' is the
     	% intersection of all the sets in `A'
     
     :- pred set_unordlist__power_intersect(set_unordlist(set_unordlist(T)),
     							set_unordlist(T)).
     :- mode set_unordlist__power_intersect(in, out) is det.
     
     	% `set_unordlist__difference(SetA, SetB, Set)' is true iff `Set' is the
     	% set containing all the elements of `SetA' except those that
     	% occur in `SetB'
     
     :- pred set_unordlist__difference(set_unordlist(T), set_unordlist(T),
     							set_unordlist(T)).
     :- mode set_unordlist__difference(in, in, out) is det.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: stack,  Next: std_util,  Prev: set_unordlist,  Up: Top

stack
*****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: stack.m.
     % Main author: fjh.
     % Stability: high.
     
     % This file contains a `stack' ADT.
     % Stacks are implemented here using lists.
     
     %--------------------------------------------------%
     
     :- module stack.
     :- interface.
     :- import_module int, std_util, list.
     
     :- type stack(_T).
     
     	% `stack__init(Stack)' is true iff `Stack' is an empty stack.
     
     :- pred stack__init(stack(_T)).
     :- mode stack__init(out) is det.
     
     	% `stack__is_empty(Stack)' is true iff `Stack' is an empty stack.
     
     :- pred stack__is_empty(stack(_T)).
     :- mode stack__is_empty(in) is semidet.
     
     	% `stack__is_full(Stack)' is intended to be true iff `Stack'
     	% is a stack whose capacity is exhausted.  This
     	% implement allows arbitrary-sized stacks, so stack__is_full
     	% always fails.
     
     :- pred stack__is_full(stack(_T)).
     :- mode stack__is_full(in) is semidet.
     
     	% `stack__push(Stack0, Elem, Stack)' is true iff `Stack' is
     	% the stack which results from pushing `Elem' onto the top
     	% of `Stack0'.
     
     :- pred stack__push(stack(T), T, stack(T)).
     :- mode stack__push(in, in, out) is det.
     
     	% `stack__push_list(Stack0, Elems, Stack)' is true iff `Stack'
     	% is the stack which results from pushing the elements of the
     	% list `Elems' onto the top of `Stack0'.
     
     :- pred stack__push_list(stack(T), list(T), stack(T)).
     :- mode stack__push_list(in, in, out) is det.
     
     	% `stack__top(Stack, Elem)' is true iff `Stack' is a non-empty
     	% stack whose top element is `Elem'.
     
     :- pred stack__top(stack(T), T).
     :- mode stack__top(in, out) is semidet.
     
     	% `stack__pop(Stack0, Elem, Stack)' is true iff `Stack0' is
     	% a non-empty stack whose top element is `Elem', and `Stack'
     	% the stack which results from popping `Elem' off `Stack0'.
     
     :- pred stack__pop(stack(T), T, stack(T)).
     :- mode stack__pop(in, out, out) is semidet.
     
     	% `stack__pop_det' is like `stack__pop' except that it will
     	% call error/1 rather than failing if given an empty stack.
     
     :- pred stack__pop_det(stack(T), T, stack(T)).
     :- mode stack__pop_det(in, out, out) is det.
     
     	% `stack__depth(Stack, Depth)' is true iff `Stack' is a stack
     	% containing `Depth' elements.
     
     :- pred stack__depth(stack(_T), int).
     :- mode stack__depth(in, out) is det.
     :- mode stack__depth(in, in) is semidet. % implied
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: std_util,  Next: store,  Prev: stack,  Up: Top

std_util
********

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: std_util.m.
     % Main author: fjh.
     % Stability: medium to high.
     
     % This file is intended for all the useful standard utilities
     % that don't belong elsewhere, like <stdlib.h> in C.
     %
     % It contains the predicates solutions/2, semidet_succeed/0, semidet_fail/0;
     % the types univ, unit, maybe(T), pair(T1, T2); and some predicates which
     % operate on those types.
     
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module std_util.
     
     :- interface.
     
     :- import_module list, set.
     
     %--------------------------------------------------%
     
     % The universal type.
     % Note that the current NU-Prolog implementation of univ_to_type
     % is buggy in that it always succeeds, even if the types didn't
     % match, so until this gets implemented correctly, don't use
     % univ_to_type unless you are sure that the types will definely match.
     
     :- type univ.
     
     :- pred type_to_univ(T, univ).
     :- mode type_to_univ(di, uo) is det.
     :- mode type_to_univ(in, out) is det.
     :- mode type_to_univ(out, in) is semidet.
     
     :- pred univ_to_type(univ, T).
     :- mode univ_to_type(in, out) is semidet.
     :- mode univ_to_type(out, in) is det.
     
     %--------------------------------------------------%
     
     % The "maybe" type.
     
     :- type maybe(T) ---> yes(T) ; no.
     
     %--------------------------------------------------%
     
     % The "unit" type - stores no information at all.
     
     :- type unit		--->	unit.
     
     %--------------------------------------------------%
     
     % The "pair" type.  Useful for many purposes.
     
     :- type pair(T1, T2)	--->	(T1 - T2).
     :- type pair(T)		==	pair(T,T).
     
     %--------------------------------------------------%
     
     % solutions/2 collects all the solutions to a predicate and
     % returns them as a list in sorted order, with duplicates removed.
     % solutions_set/2 returns them as a set.
     % unsorted_solutions/2 returns them as an unsorted list with possible
     % duplicates; since there are an infinite number of such lists,
     % this must be called from a context in which only a single solution
     % is required.
     
     :- pred solutions(pred(T), list(T)).
     :- mode solutions(pred(out) is multi, out) is det.
     :- mode solutions(pred(out) is nondet, out) is det.
     
     :- pred solutions_set(pred(T), set(T)).
     :- mode solutions_set(pred(out) is multi, out) is det.
     :- mode solutions_set(pred(out) is nondet, out) is det.
     
     :- pred unsorted_solutions(pred(T), list(T)).
     :- mode unsorted_solutions(pred(out) is multi, out) is cc_multi.
     :- mode unsorted_solutions(pred(out) is nondet, out) is cc_multi.
     
     %--------------------------------------------------%
     
     	% maybe_pred(Pred, X, Y) takes a closure Pred which transforms an
     	% input semideterministically. If calling the closure with the input
     	% X succeeds, Y is bound to `yes(Z)' where Z is the output of the
     	% call, or to `no' if the call fails.
     :- pred maybe_pred(pred(T1, T2), T1, maybe(T2)).
     :- mode maybe_pred(pred(in, out) is semidet, in, out) is det.
     
     %--------------------------------------------------%
     
     	% `semidet_succeed' is exactly the same as `true', except that
     	% the compiler thinks that it is semi-deterministic.  You can
     	% use calls to `semidet_succeed' to suppress warnings about
     	% determinism declarations which could be stricter.
     	% Similarly, `semidet_fail' is like `fail' except that its
     	% determinism is semidet rather than failure, and
     	% `cc_multi_equal(X,Y)' is the same as `X=Y' except that it
     	% is cc_multi rather than det.
     
     :- pred semidet_succeed is semidet.
     
     :- pred semidet_fail is semidet.
     
     :- pred cc_multi_equal(T::in, T::out) is cc_multi.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: store,  Next: string,  Prev: std_util,  Up: Top

store
*****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: store.m.
     % Main author: fjh.
     % Stability: low.
     %
     % This module is not stable: it is highly likely that the interface
     % will change in future releases.  For the time being, we recommend
     % that you do not use this module.
     %
     % This file provides facilities for manipulating stores.
     % A store is a set of nodes, each of which may contain a value of
     % any type, and which are identified by node_ids.
     %
     % Currently stores are implemented as maps from node_ids to values,
     % where node_ids are just integers, but we should re-implement this
     % for unique stores using addresses as ids.
     %
     % Graphs may be used to implement cyclic data structures such as
     % circular linked lists, etc.
     %
     % Theoretical problem: we would like to allow heterogenous stores,
     % with types store and node_id(T) instead of store(T) and node_id(T).
     % This would be completely type-safe as far as the user of the stores
     % is concerned, but it isn't possible to implement it except as a builtin.
     % Stores are a pretty fundamental type, so it might make sense to do so,
     % but I'm still not sure whether this would cause any theoretical problems.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module store.
     :- interface.
     
     :- type store(T).
     :- type node_id(T).
     
     	% initialize a store
     :- pred store__init(store(_T)).
     :- mode store__init(out) is det.
     
     	% create a new node with the specified value
     :- pred store__new_node(store(T), T, node_id(T), store(T)).
     :- mode store__new_node(in, in, out, out) is det.
     
     	% replace the value stored in a given node
     :- pred store__set_node(store(T), node_id(T), T, store(T)).
     :- mode store__set_node(in, in, in, out) is det.
     
     	% lookup the value stored in a given node
     :- pred store__lookup_node(store(T), node_id(T), T).
     :- mode store__lookup_node(in, in, out) is det.
     
     % Axioms:
     %	% (also determinism of store__init, store__new_node, store__set_node)
     %
     %	all [G,V,N]
     %	    (
     %		store__new_node(G, V, N) =>
     %		    (
     %			store__lookup(G, N, V),
     %			all [V2] store_lookup(G, N, V2) => V2 = V
     %		    )
     %	    ).
     %	all [G,V,N]
     %	    (
     %		store__new_node(G, V, N) =>
     %		    (
     %			store__lookup(G, N, V),
     %			all [V2] store_lookup(G, N, V2) => V2 = V
     %		    )
     %	    ).
     %  etc.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: string,  Next: swi_builtin,  Prev: store,  Up: Top

string
******

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     :- module string.
     
     % Main authors: fjh, dylan.
     % Stability: medium to high.
     
     % This modules provides basic string handling facilities.
     
     % Beware that char_to_string/2 won't work with NU-Prolog 1.5.33 because
     % of a NU-Prolog bug (fixed in NU-Prolog 1.5.35).
     
     %--------------------------------------------------%
     
     :- interface.
     :- import_module list, char, int, float, require, std_util.
     
     :- pred string__length(string, int).
     :- mode string__length(in, out) is det.
     	% Determine the length of a string.
     	% An empty string has length zero.
     
     :- pred string__append(string, string, string).
     :- mode string__append(in, in, in) is semidet.	% implied
     :- mode string__append(in, out, in) is semidet.
     :- mode string__append(in, in, out) is det.
     :- mode string__append(out, out, in) is multidet.
     %	Append two strings together.
     %
     %       The following mode is semidet in the sense that it doesn't
     %       succeed more than once - but it does create a choice-point,
     %       which means it's inefficient and that the compiler can't deduce
     %       that it is semidet.  Use string__remove_suffix instead.
     % :- mode string__append(out, in, in) is semidet.
     
     :- pred string__remove_suffix(string, string, string).
     :- mode string__remove_suffix(in, in, out) is semidet.
     %	string__remove_suffix(String, Suffix, Prefix):
     %       The same as string__append(Prefix, Suffix, List) except that
     %       this is semidet whereas string__append(out, in, in) is nondet.
     
     :- pred string__prefix(string, string).
     :- mode string__prefix(in, in) is semidet.
     :- mode string__prefix(in, out) is multidet.
     	% string__prefix(String, Prefix) is true iff Prefix is a
     	% prefix of String.  Same as string__append(Prefix, _, String).
     
     :- pred string__char_to_string(character, string).
     :- mode string__char_to_string(in, out) is det.
     :- mode string__char_to_string(out, in) is semidet.
     %	string__char_to_string(Char, String).
     %		Converts a character (single-character atom) to a string
     %		or vice versa.
     
     :- pred string__int_to_string(int, string).
     :- mode string__int_to_string(in, out) is det.
     %	Convert an integer to a string.
     
     :- pred string__int_to_base_string(int, int, string).
     :- mode string__int_to_base_string(in, in, out) is det.
     %	string__int_to_base_string(Int, Base, String):
     %	Convert an integer to a string in a given Base (between 2 and 36).
     
     :- pred string__float_to_string(float, string).
     :- mode string__float_to_string(in, out) is det.
     %	Convert an float to a string.
     
     :- pred string__first_char(string, character, string).
     :- mode string__first_char(in, in, in) is semidet.	% implied
     :- mode string__first_char(in, out, in) is semidet.	% implied
     :- mode string__first_char(in, in, out) is semidet.	% implied
     :- mode string__first_char(in, out, out) is semidet.
     :- mode string__first_char(out, in, in) is det.
     %	string__first_char(String, Char, Rest) is true iff
     %		Char is the first character of String, and Rest is the
     %		remainder.
     
     :- pred string__replace(string, string, string, string).
     :- mode string__replace(in, in, in, out) is semidet.
     % 	string__replace replaces the first occurence of the second string in
     % 	the first string with the third string to give the fourth string.
     % 	It fails if the second string does not occur in the first.
     
     :- pred string__replace_all(string, string, string, string).
     :- mode string__replace_all(in, in, in, out) is det.
     % 	string__replace_all replaces any occurences of the second string in
     % 	the first string with the third string to give the fourth string.
     
     :- pred string__to_lower(string, string).
     :- mode string__to_lower(in, out) is det.
     :- mode string__to_lower(in, in) is semidet.		% implied
     %	Converts a string to lowercase.
     
     :- pred string__to_upper(string, string).
     :- mode string__to_upper(in, out) is det.
     :- mode string__to_upper(in, in) is semidet.		% implied
     %	Converts a string to uppercase.
     
     :- pred string__capitalize_first(string, string).
     :- mode string__capitalize_first(in, out) is det.
     %	Convert the first character (if any) of a string to uppercase.
     
     :- pred string__uncapitalize_first(string, string).
     :- mode string__uncapitalize_first(in, out) is det.
     %	Convert the first character (if any) of a string to lowercase.
     
     :- pred string__to_char_list(string, list(character)).
     :- mode string__to_char_list(in, out) is det.
     
     :- pred string__from_char_list(list(character), string).
     :- mode string__from_char_list(in, out) is det.
     :- mode string__from_char_list(out, in) is semidet.
     	% XXX second mode should be det too
     	% (but this turns out to be tricky to implement)
     
     :- pred string__to_int(string, int).
     :- mode string__to_int(in, out) is semidet.
     % 	Convert a string to an int.  The string must contain only digits,
     % 	optionally preceded by a plus or minus sign.  If the string does
     % 	not match this syntax, string__to_int fails.
     
     :- pred string__base_string_to_int(int, string, int).
     :- mode string__base_string_to_int(in, in, out) is semidet.
     % 	Convert a string in the specified base (2-36) to an int.  The
     % 	string must contain only digits in the specified base, optionally
     % 	preceded by a plus or minus sign.  For bases > 10, digits 10 to 35
     % 	are repesented by the letters A-Z or a-z.  If the string does not
     % 	match this syntax, the predicate fails.
     
     :- pred string__to_float(string, float).
     :- mode string__to_float(in, out) is semidet.
     %	Convert a string to an float. If the string is not
     %	a syntactically correct float literal, string__to_float fails.
     
     :- pred string__is_alpha(string).
     :- mode string__is_alpha(in) is semidet.
     	% True if string contains only alphabetic characters (letters).
     
     :- pred string__is_alpha_or_underscore(string).
     :- mode string__is_alpha_or_underscore(in) is semidet.
     	% True if string contains only alphabetic characters and underscores.
     
     :- pred string__is_alnum_or_underscore(string).
     :- mode string__is_alnum_or_underscore(in) is semidet.
     	% True if string contains only letters, digits, and underscores.
     
     :- pred string__pad_left(string, character, int, string).
     :- mode string__pad_left(in, in, in, out) is det.
     %	string__pad_left(String0, PadChar, Width, String):
     %	insert `PadChar's at the left of `String0' until it is at least
     %	as long as `Width', giving `String'.
     
     :- pred string__pad_right(string, character, int, string).
     :- mode string__pad_right(in, in, in, out) is det.
     %	string__pad_right(String0, PadChar, Width, String):
     %	insert `PadChar's at the right of `String0' until it is at least
     %	as long as `Width', giving `String'.
     
     :- pred string__duplicate_char(character, int, string).
     :- mode string__duplicate_char(in, in, out) is det.
     %	string__duplicate_char(Char, Count, String):
     %	construct a string consisting of `Count' occurrences of `Char'
     %	in sequence.
     
     :- pred string__index(string, int, character).
     :- mode string__index(in, in, out) is semidet.
     %	string__index(String, Index, Char):
     %	`Char' is the (`Index' + 1)-th character of `String'.
     %	Fails if `Index' is out of range (negative, or greater than or
     %	equal to the length of `String').
     
     :- pred string__index_det(string, int, character).
     :- mode string__index_det(in, in, out) is det.
     %	string__index_det(String, Index, Char):
     %	`Char' is the (`Index' + 1)-th character of `String'.
     %	Calls error/1 if `Index' is out of range (negative, or greater than or
     %	equal to the length of `String').
     
     :- pred string__split(string, int, string, string).
     :- mode string__split(in, in, out, out) is det.
     %	string__split(String, Count, LeftSubstring, RightSubstring):
     %	`LeftSubstring' is the left-most `Count' characters of `String',
     %	and `RightSubstring' is the remainder of `String'.
     %	(If `Count' is out of the range [0, length of `String'], it is
     %	treated as if it were the nearest end-point of that range.)
     
     :- pred string__left(string, int, string).
     :- mode string__left(in, in, out) is det.
     %	string__left(String, Count, LeftSubstring):
     %	`LeftSubstring' is the left-most `Count' characters of `String'.
     %	(If `Count' is out of the range [0, length of `String'], it is
     %	treated as if it were the nearest end-point of that range.)
     
     :- pred string__right(string, int, string).
     :- mode string__right(in, in, out) is det.
     %	string__right(String, Count, RightSubstring):
     %	`RightSubstring' is the right-most `Count' characters of `String'.
     %	(If `Count' is out of the range [0, length of `String'], it is
     %	treated as if it were the nearest end-point of that range.)
     
     :- pred string__substring(string, int, int, string).
     :- mode string__substring(in, in, in, out) is det.
     %	string__substring(String, Start, Count, Substring):
     %	`Substring' is first the `Count' characters in what would
     %	remain of `String' after the first `Start' characters were
     %	removed.
     %	(If `Start' is out of the range [0, length of `String'], it is
     %	treated as if it were the nearest end-point of that range.
     %	If `Count' is out of the range [0, length of `String' - `Start'], it is
     %	treated as if it were the nearest end-point of that range.)
     
     :- pred string__append_list(list(string), string).
     :- mode string__append_list(in, out) is det.
     :- mode string__append_list(out, in) is multidet.
     %	Append a list of strings together.
     
     :- pred string__hash(string, int).
     :- mode string__hash(in, out) is det.
     %	Compute a hash value for a string.
     
     :- pred string__sub_string_search(string, string, int).
     :- mode string__sub_string_search(in, in, out) is semidet.
     %	string__sub_string_search(String, SubString, Index).
     %	`Index' is the position in `String' where the first occurrence of
     %	`SubString' begins.
     %	Do a brute-force search in the first string for the second string.
     %	XXX Note: not the most efficient algorithm.
     
     :- pred string__format(string, list(string__poly_type), string).
     :- mode string__format(in, in, out) is det.
     %
     %	A function similar to sprintf() in C.
     %
     %	For example,
     %		string__format("%s %i %c %f\n",
     %			[s("Square-root of"), i(2), c('='), f(1.41)], String)
     %	will return
     %		String = "Square-root of 2 = 1.41\n".
     %
     %	All the normal options available in C are supported, ie Flags [0+-# ],
     %	a field width (or *), '.', precision (could be a '*'), and a length
     %	modifier (currently ignored).
     %
     %	Valid conversion character types are {dioxXucsfeEgGp%}.  %n is not
     %	supported.  string__format will not return the length of the string.
     %
     %	conv	var	output form.		effect of '#'.
     %	char.	type.
     %
     %	d	int	signed integer
     %	i	int	signed integer
     %	o	int	signed octal		with '0' prefix
     %	x,X	int	signed hex		with '0x', '0X' prefix
     %	u	int	unsigned integer
     %	c	char	character
     %	s	string	string
     %	f	float	rational number		with '.', if precision 0
     %	e,E	float	[-]m.dddddE+-xx		with '.', if precision 0
     %	g,G	float	either e or f		with trailing zeros.
     %	p	int	integer
     %
     %	An option of zero will cause any padding to be zeros rather than spaces.
     %	A '-' will cause the output to be right-justified in its 'space'.
     %	A '+' forces a sign to be printed.  This is not sensible for string and
     %	character output.  A ' ' causes a space to be printed before a thing
     %	if there is no sign there.  The other option is the '#', which
     %	modifies the output string's format.  These options are normally put
     %	directly after the '%'.
     %
     %
     %	Note:
     %		%#.0e, %#.0E won't print a '.' before the 'e' ('#' ignored).
     %
     %		Extra precision (as `0's) may be added to floats if the
     %		precision value asks for this - IE numbers may come out more
     %		accurate than when they were typed.  A precision value of more
     %		than 15 will not find more accuracy, as
     %		string__f_float_to_string only generates 15 significant figures.
     %
     %		If a width or precision is specified, without a `.', a number
     %		is assumed to be a width and a `*' is assumed to be a precision.
     %		It is always better to include a `.' to remove ambiguity.  This
     %		interpretation is non-standard and may change.
     %
     %		Numbers are truncated by a precision value, not rounded off.
     %
     
     %--------------------------------------------------%
     
     :- type string__poly_type --->
     			f(float)
     		;	i(int)
     		;	s(string)
     		;	c(char).
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: swi_builtin,  Next: swi_lib,  Prev: string,  Up: Top

swi_builtin
***********

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU General
     % Public License - see the file COPYING in the Mercury distribution.
     %--------------------------------------------------%
     %
     % Main author: fjh.
     %
     % Note that SWI-Prolog support is not complete.
     % SWI-Prolog is so slow anyway, why bother?
     %
     %--------------------------------------------------%
     
     % Declare the appropriate operators.
     
     :- op(1199, fx, (module)).
     :- op(1199, fx, (end_module)).
     
     :- op(1199, fx, (export_module)).
     :- op(1199, fx, (export_sym)).
     :- op(1199, fx, (export_pred)).
     :- op(1199, fx, (export_cons)).
     :- op(1199, fx, (export_type)).
     :- op(1199, fx, (export_adt)).
     :- op(1199, fx, (export_op)).
     
     :- op(1199, fx, (import_module)).
     :- op(1199, fx, (import_sym)).
     :- op(1199, fx, (import_pred)).
     :- op(1199, fx, (import_cons)).
     :- op(1199, fx, (import_type)).
     :- op(1199, fx, (import_adt)).
     :- op(1199, fx, (import_op)).
     
     :- op(1199, fx, (use_module)).
     :- op(1199, fx, (use_sym)).
     :- op(1199, fx, (use_pred)).
     :- op(1199, fx, (use_cons)).
     :- op(1199, fx, (use_type)).
     :- op(1199, fx, (use_adt)).
     :- op(1199, fx, (use_op)).
     
     :- op(1199, fx, (rule)).
     
     :- op(1199, fx, (type)).
     :- op(1199, fx, (pred)).
     :- op(1199, fx, (mode)).
     :- op(1199, fx, (inst)).
     :- op(1179, xfy, (--->)).
     :- op(1175, xfx, (::)).
     
     :- op(900, xfx, (when)).
     :- op(740, xfy, (or)).
     :- op(720, xfy, (and)).
     
     % Prevent warnings about undefined predicates
     % when the interpreter tries to execute the new declarations.
     
     :- assert(rule(_)).
     
     :- assert(type(_)).
     :- assert(pred(_)).
     :- assert(mode(_)).
     :- assert(inst(_)).
     
     :- assert(module(_)).
     :- assert(end_module(_)).
     :- assert(interface).
     :- assert(implementation).
     
     :- assert(import_module(_)).
     :- assert(import_sym(_)).
     :- assert(import_pred(_)).
     :- assert(import_cons(_)).
     :- assert(import_type(_)).
     :- assert(import_adt(_)).
     :- assert(import_op(_)).
     
     :- assert(export_module(_)).
     :- assert(export_sym(_)).
     :- assert(export_pred(_)).
     :- assert(export_cons(_)).
     :- assert(export_type(_)).
     :- assert(export_adt(_)).
     :- assert(export_op(_)).
     
     :- assert(use_module(_)).
     :- assert(use_sym(_)).
     :- assert(use_pred(_)).
     :- assert(use_cons(_)).
     :- assert(use_type(_)).
     :- assert(use_adt(_)).
     :- assert(use_op(_)).
     
     :- assert(external(_)).
     
     :- assert(when(_,_)).
     
     %--------------------------------------------------%

