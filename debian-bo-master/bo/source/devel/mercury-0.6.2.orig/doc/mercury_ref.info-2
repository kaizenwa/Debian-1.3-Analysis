This is Info file mercury_ref.info, produced by Makeinfo-1.63 from the
input file reference_manual.texi.

START-INFO-DIR-ENTRY
* Mercury: (mercury_ref).        The Mercury Language Reference Manual
END-INFO-DIR-ENTRY

   This file documents the Mercury programming language.

   Copyright (C) 1995 University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: mercury_ref.info,  Node: Determinism categories,  Next: Determinism checking and inference,  Up: Determinism

Determinism categories
======================

   For each mode of a predicate or function, we categorise that mode
according to how many times it can succeed, and whether or not it can
fail before producing its first solution.

   * If all possible calls to a particular mode of a predicate or
     function have exactly one solution, then that mode is
     "deterministic" (`det').

   * If all possible calls to a particular mode of a predicate or
     function either have no solutions or have one solution, then that
     mode is "semideterministic" (`semidet').

   * If all possible calls to a particular mode of a predicate or
     function have at least one solution but may have more, then that
     mode is "multisolution" (`multi').

   * If some possible calls to a particular mode of a predicate or
     function have no solution but other calls may have more than one
     solution, then that mode is "nondeterministic" (`nondet').

   * If all possible calls to a particular mode of a predicate or
     function fail without producing a solution, then that mode has a
     determinism of `failure'.

   * If all possible calls to a particular mode of a predicate or
     function lead to a runtime error, i.e. neither succeed nor fail,
     then that mode has a determinism of `erroneous'.

   The determinism annotation `erroneous' is used on the library
predicate `error/1', but apart from that those last two determinism
annotations are generally not needed.

   To summarize:

                     Maximum number of solutions
     Can fail?       0               1               > 1
     no              erroneous       det             multi
     yes             failure         semidet         nondet

   The determinism of each mode of a predicate or function is indicated
by an annotation on the mode declaration.  For example:

     :- pred append(list(T), list(T), list(T)).
     :- mode append(in, in, out) is det.
     :- mode append(out, out, in) is multi.
     :- mode append(in, in, in) is semidet.
     
     :- func length(list(T)) = int.
     :- mode length(in) = out is det.
     :- mode length(in(list_skel)) = out is det.
     :- mode length(in) = in is semidet.

   An annotation of `det' or `multidet' is an assertion that for every
value each of the inputs, there exists at least one value of the
outputs for which the predicate is true, or (in the case of functions)
for which the function term is equal to the result term.  Conversely,
an annotation of `det' or `semidet' is an assertion that for every
value each of the inputs, there exists at most one value of the outputs
for which the predicate is true, or (in the case of functions) for
which the function term is equal to the result term.  These assertions
are called the "mode-determinism assertions"; they can play a role in
the semantics, because in certain circumstances they may allow an
implementation to perform optimizations that would not otherwise be
allowed, such as optimizing away a goal with no outputs even though it
might infinitely loop.

   If the mode of the predicate is given in the `:- pred' declaration
rather than in a separate `:- mode' declaration, then the determinism
annotation goes on the `:- pred' declaration (and similarly for
functions).  In particular, this is necessary if a predicate does not
have any argument variables.  For example:

     :- pred loop(int::in) is erroneous.
     loop(X) :- loop(X).
     
     :- pred p is det.
     p.
     
     :- pred q is failure.
     q :- fail.

   If there is no mode declaration for a function, then the default
mode for that function is considered to have been declared as `det'.
If you want to write a partial function, i.e. one whose determinism is
`semidet', then you must explicitly declare the mode and determinism.

   The determinism categories form this lattice:

                  erroneous
                   /     \
               failure   det
                  \     /   \
                  semidet  multi
                      \     /
                       nondet

   The higher up this lattice a determinism category is, the more the
compiler knows about the number of solutions of predicates of that
determinism.


File: mercury_ref.info,  Node: Determinism checking and inference,  Next: Replacing compile-time checking with run-time checking,  Prev: Determinism categories,  Up: Determinism

Determinism checking and inference
==================================

   The determinism of goals is inferred from the determinism of their
component parts, according to the rules below.  The inferred
determinism of a procedure is just the inferred determinism of the
procedure's body.

   For procedures that are local to a module, the determinism
annotations may be omitted; in that case, their determinism will be
inferred.  (To be precise, the determinism of procedures without a
determinism annotation is defined as the least fixpoint of the
transformation which, given an initial assignment of the determinism
`det' to all such procedures, applies those rules to infer a new
determinism assignment for those procedures.)

   It is an error to omit the determinism annotation for procedures
that are exported from their containing module.

   If a determinism annotation is supplied for a procedure, the
declared determinism is compared against the inferred determinism.  If
the declared determinism is greater than or not comparable to the
inferred determinism (in the partial ordering above), it is an error.
If the declared determinism is less than the inferred determinism, it
is not an error, but the implementation may issue a warning.

   The determinism category of each goal is inferred according to the
following rules.  These rules work with the two components of
determinism category: whether the goal can fail without producing a
solution, and the maximum number of solutions of the goal (0, 1, or
more).  If the inference process below reports that a goal can succeed
more than once, but the goal generates no outputs that are visible from
outside the goal, the final determinism of the goal will be based on
the goal succeeding at most once, since the compiler will implicitly
prune away any duplicate solutions.

Calls
     The determinism category of a call is the determinism declared or
     inferred for the called mode of the called procedure.

Unifications
     The determinism of a unification is either `det', `semidet', or
     `failure', depending on its mode.

     A unification that assigns the value of one variable to another is
     deterministic.  A unification that constructs a structure and
     assigns it to a variable is also deterministic.  A unification
     that tests whether a variable has a given top function symbol is
     semideterministic, unless the compiler knows the top function
     symbol of that variable, in which case its determinism is either
     det or failure depending on whether the two function symbols are
     the same or not.  A unification that tests two variables for
     equality is semideterministic, unless the compiler knows that the
     two variables are aliases for one another, in which case the
     unification is deterministic, or unless the compiler knows that
     the two variables have different function symbols in the same
     position, in which case the unification has a determinism of
     failure.

     The compiler knows the top function symbol of a variable if the
     previous part of the predicate definition contains a unification
     of the variable with a function symbol, or if the variable's type
     has only one function symbol.

Conjunctions
     The determinism of the empty conjunction (the goal `true') is
     `det'.  The conjunction `(A, B)' can fail if either A or B can
     fail.  The conjunction can succeed at most zero times if either A
     or B can succeed at most zero times.  The conjunction can succeed
     more than once if either A or B can succeed more than once and
     both A and B can succeed at least once.  (If e.g. A can succeed at
     most zero times, then even if B can succeed many times the maximum
     number of solutions of the conjunction is still zero.) Otherwise,
     i.e. if both A and B succeed at most once, the conjunction can
     succeed at most once.

Switches
     A disjunction is a *switch* if each disjunct has near its start a
     unification that tests the same bound variable against a different
     function symbol.  For example, consider the common pattern

          (
                  L = [], empty(Out)
          ;
                  L = [H|T], nonempty(H, T, Out)
          )

     If L is input to the disjunction, then the disjunction is a switch
     on L.

     A switch can fail if the various arms of the switch do not cover
     all the function symbols in the type of the switched-on variable,
     or if the code in some arms of the switch can fail, bearing in
     mind that in each arm of the switch, the unification that tests
     the switched-on variable against the function symbol of that arm
     is considered to be deterministic.  A switch can succeed several
     times if some arms of the switch can succeed several times,
     possibly because there are multiple disjuncts that test the
     switched-on variable against the same function symbol.  A switch
     can succeed at most zero times only if all arms of the switch can
     succeed at most zero times.

Disjunctions
     The determinism of the empty disjunction (the goal `fail') is
     `failure'.  A disjunction `(A ; B)' that is not a switch can fail
     if both A and B can fail.  It can succeed at most zero times if
     both A and B can succeed at most zero times.  It can succeed at
     most once if one of A and B can succeed at most once and the other
     can succeed at most zero times.  Otherwise, i.e. if either A or B
     can succeed more than once, or if both A and B can succeed at
     least once, it can succeed more than once.

If-then-else
     If the condition of an if-then-else cannot fail, the if-then-else
     is equivalent to the conjunction of the condition and the "then"
     part, and its determinism is computed accordingly.  Otherwise, an
     if-then-else can fail if either the "then" part or the "else" part
     can fail.  It can succeed at most zero times if the "else" part
     can succeed at most zero times and if at least one of the
     condition and the "then" part can succeed at most zero times.  It
     can succeed more than once if any one of the condition, the "then"
     part and the "else" part can succeed more than once.

Negations
     If the determinism of the negated goal is `erroneous', then the
     determinism of the negation is `erroneous'.  If the determinism of
     the negated goal is `failure', the determinism of the negation is
     `det'.  If the determinism of the negated goal is `det' or `multi',
     the determinism of the negation is `failure'.  Otherwise, the
     determinism of the negation is `semidet'.


File: mercury_ref.info,  Node: Replacing compile-time checking with run-time checking,  Next: Interfacing nondeterministic code with the real world,  Prev: Determinism checking and inference,  Up: Determinism

Replacing compile-time checking with run-time checking
======================================================

   Note that "perfect" determinism inference is an undecidable problem,
because it requires solving the halting problem.  (For instance, in the
following example

     :- pred p(T, T).
     :- mode p(in, out) is det.
     
     p(A, B) :-
             (
                     something_complicated(A, B)
             ;
                     B = A
             ).

`p/0' can have more than one solution only if `something_complicated'
can succeed.) Sometimes, the rules specified by the Mercury language
for determinism inference will infer a determinism that is not as
precise as you would like.  However, it is generally easy to overcome
such problems.  The way to do this is to replace the compiler's static
checking with some manual run-time checking.  For example, if you know
that a particular goal should never fail, but the compiler infers that
goal to be `semidet', you can check at runtime that the goal does
succeed, and if it fails, call the library predicate `error/1'.

     :- pred q(T, T).
     :- mode q(in, out) is det.
     
     q(A, B) :-
             ( goal_that_should_never_fail(A, B0) ->
                     B = B0
             ;
                     error("goal_that_should_never_fail failed!")
             ).

The predicate `error/1' has determinism `erroneous', which means the
compiler knows that it will never succeed or fail, so the inferred
determinism for the body of `q/2' is `det'.  (Checking assumptions like
this is good coding style anyway.  The small amount of up-front work
that Mercury requires is paid back in reduced debugging time.)
Mercury's mode analysis knows that computations with determinism
erroneous can never succeed, which is why it does not require the
"else" part to generate a value for `B'.  The introduction of the new
variable `B0' is necessary because the condition of an if-then-else is
a negated context, and can export the values it generates only to the
"then" part of the if-then-else, not directly to the surrounding
computation.  (If the surrounding computations had direct access to
values generated in conditions, they might access them even if the
condition failed.)


File: mercury_ref.info,  Node: Interfacing nondeterministic code with the real world,  Next: Committed choice nondeterminism,  Prev: Replacing compile-time checking with run-time checking,  Up: Determinism

Interfacing nondeterministic code with the real world
=====================================================

   Normally, attempting to call a `nondet' or `multi' mode of a
predicate from a predicate declared as `semidet' or `det' will cause a
determinism error.  So how can we call nondeterministic code from
deterministic code?  There are several alternative possibilities.

   If you just want to see if a nondeterministic goal is satisfiable or
not, without needing to know what variable bindings it produces, then
there is no problem - determinism analysis considers `nondet' and
`multi' goals with no non-local output variables to be `semidet' and
`det' respectively.

   If you want to use the values of output variables, then you need to
ask yourself which one of possibly many solutions to a goal do you want?
If you want all of them, you need to use the predicate `solutions/2' in
the standard library module `std_util', which collects all of the
solutions to a goal into a list - see *Note Higher-order::.

   If you just want one solution and don't care which, the calling
predicate should be declared `nondet' or `multi'.  The nondeterminism
should then be propagated up the call tree to the point at which it can
be pruned.  In Mercury, pruning can be achieved in several ways.

   The first way is the one mentioned above: if a goal has no non-local
output variables then the implementation will only attempt to satisfy
the goal once.  Any potential duplicate solutions will be implicitly
pruned away.

   The second way is to rely on the fact that the implementation will
only seek a single solution to `main/2', so alternative solutions to
`main/2' (and hence also to `nondet' or `multi' predicates called
directly or indirectly from `main/2') are implicitly pruned away.  This
is one way to achieve "don't care" style nondeterminism in Mercury.

   The other situation in which you may want pruning and committed
choice style nondeterminism is when you know that all the solutions
returned will be equivalent.  For example, you might want to count the
elements in a set by removing them one at a time.  Removing an
unspecified element from a set is a nondeterministic operation, but no
matter which order you remove them, the computed size of the set should
be the same.

   We may eventually extend Mercury to allow users to write

     unique [X] Goal

as a special quantifier, meaning "there exists a unique `X' for which
`Goal' is true".  This would allow the implementation to prune
alternative solutions for `Goal' if `X' was the only output variable of
`Goal'.

   We would also like to allow users to specify a user-defined
equivalence relation as the equality relation for user-defined types,
so that the `unique' quantifier could be used to express more general
forms of equivalence.  For example, if you define a set type which
represents sets as unsorted lists, you would want to define a
user-defined equivalence relation for that type, which could sort the
lists before comparing them.  The `unique' quantifier could then be
used for sets even though the lists used to represent the sets might
not be in the same order in every solution.

   However, the current implementation does not yet support either the
`unique' quantifier or user-defined equivalence relations.


File: mercury_ref.info,  Node: Committed choice nondeterminism,  Prev: Interfacing nondeterministic code with the real world,  Up: Determinism

Committed choice nondeterminism
===============================

   In addition to the determinism annotations described earlier, there
are "committed choice" versions of `multi' and `nondet', called
`cc_multi' and `cc_nondet'.  These can be used instead of `multi' or
`nondet' if all calls to that mode of the predicate occur in a context
in which only one solution is needed.

   Such single-solution contexts are determined as follows.

   * The program entry point `main/2' is in a single-solution context.

   * Any goal with no output variables is in a single-solution context.

   * If a conjunction is in a single-solution context, then the
     right-most conjunct is in a single-solution context, and if the
     right-most conjunct cannot fail, then rest of the conjunction is
     also in a single-solution context.

   * If an if-then-else is in a single-solution context, then the
     "then" part and the "else" part are in single-solution contexts,
     and if the "then" part cannot fail, then condition of the
     if-then-else is also in a single-solution context.

   The compiler will check that all calls to a committed-choice mode of
a predicate do indeed occur in a single-solution context.

   There are two reasons to use committed choice determinism
annotations.  One reason is for efficiency: committed choice
annotations allow the compiler to generate much more efficient code.
The other reason is for doing I/O, which is allowed only in `det' or
`cc_multi' predicates, not in `multi' predicates.

   It would be nice to be able to declare a mode of a predicate as both
`multi' and `cc_multi', and have the compiler call the appropriate one
depending on whether the call comes from a single-solution context or
not.  However, the current implementation does not yet support this.


File: mercury_ref.info,  Node: Higher-order,  Next: Modules,  Prev: Determinism,  Up: Top

Higher-order programming
************************

   Mercury supports higher-order functions and predicates with currying,
closures, and lambda expressions.  (To be pedantic, it would be more
accurate to say that Mercury supports higher-order procedures: in
Mercury, when you construct a higher-order predicate term, you only get
one mode of a predicate or function; if you want multiple modes, you
must pass multiple higher-order procedures.)

* Menu:

* Creating higher-order terms::
* Calling higher-order terms::
* Higher-order modes::


File: mercury_ref.info,  Node: Creating higher-order terms,  Next: Calling higher-order terms,  Up: Higher-order

Creating higher-order terms
===========================

   To create a higher-order predicate or function term, you can use a
lambda expression, or, if the predicate or function has only one mode,
you can just use its name.  For example, if you have declared a
predicate

     :- pred sum(list(int), int).
     :- mode sum(in, out) is det.

the following three unifications have the same effect:

     X = lambda([List::in, Length::out] is det, sum(List, Length))
     Y = (pred(List::in, Length::out) is det :- sum(List, Length))
     Z = sum

   In the above example, the type of `X', `Y', and `Z' is
`pred(list(int), int)', which means a predicate of two arguments of
types `list(int)' and `int' respectively.  [The syntax using `lambda'
is supported to enable programs to work in both Mercury and Prolog,
because the syntax using `pred' and `:-' can't be easily emulated in
Prolog.  When we have implemented better debugging environments for
Mercury, the syntax using `lambda' will be deprecated.]

   Similarly, given

     :- func scalar_product(int, list(int)) = list(int).
     :- mode scalar_product(in, in) = out is det.

the following three unifications have the same effect:

     X = (func(Num, List) = NewList :- NewList = scalar_product(Num, List))
     Y = (func(Num::in, List::in) = (NewList::out) is det
             :- NewList = scalar_product(Num, List))
     Z = sum_func

   In the above example, the type of `X', `Y', and `Z' is `func(int,
list(int)) = list(int)', which means a function of two arguments, whose
types are `int' and `list(int)', with a return type of `int'.  As with
`:- func' declarations, if the modes and determinism of the function
are omitted in a higher-order function term, then the modes default to
`in' for the arguments, `out' for the function result, and the
determinism defaults to `det'.

   If the predicate or function has more than one mode, you must use an
explicit lambda expression to specify which mode you want.

   You can also create higher-order predicate terms by "currying", i.e.
specifying the first few arguments to a predicate or function, but
leaving the remaining arguments unspecified.  For example, the
unification

     Sum123 = sum([1,2,3])

binds `Sum123' to a higher-order predicate term of type `pred(int)'.
Similarly, the unification

     Double = scalar_product(2)

binds `Double' to a higher-order function term of type `func(list(int))
= list(int)'.


File: mercury_ref.info,  Node: Calling higher-order terms,  Next: Higher-order modes,  Prev: Creating higher-order terms,  Up: Higher-order

Calling higher-order terms
==========================

   Once you have created a higher-order predicate term (sometimes known
as a closure), the next thing you want to do is to call it.  For
predicates, you use the builtin goal call/N:

`call(Closure)'
`call(Closure1, Arg1)'
`call(Closure2, Arg1, Arg2)'
...
     A higher-order predicate call.  `call(Closure)' just calls the
     specified higher-order predicate term.  The other forms append the
     specified arguments onto the argument list of the closure before
     calling it.

   For example, the goal

     call(Sum123, Result)

would bind `Result' to the sum of `[1, 2, 3]', i.e. to 6.

   For functions, you use the builtin expression apply/N:

`apply(Closure1, Arg1)'
`apply(Closure2, Arg1, Arg2)'
...
     A higher-order function application.  Such a term denotes the
     result of invoking the specified higher-order function term with
     the specified arguments.

   For example, given the definition of `Double' above, the goal

     List = apply(Double, [1, 2, 3])

would be equivalent to

     List = scalar_product(2, [1, 2, 3])

and so for a suitable implementation of the function `scalar_product/2'
this would bind `List' to `[2, 4, 6]'.

   One extremely useful higher-order predicate in the Mercury standard
library is `solutions/2', which has the following declaration:

     :- pred solutions(pred(T), list(T)).
     :- mode solutions(pred(out) is nondet, out) is det.

   The term which you pass to `solutions/2' is a higher-order predicate
term.  You can pass the name of a one-argument predicate, or you can
pass a several-argument predicate with all but one of the arguments
supplied (a closure).  The declarative semantics of `solutions/2' can
be defined as follows:

     solutions(Pred, List) is true iff
             all [X] (call(Pred, X) <=> list__member(X, List))
             and List is sorted.

where `call(Pred, X)' is a call to the standard library predicate
`call/2' which invokes the higher-order predicate term `Pred' with
argument `X', and where `list__member/2' is the standard library
predicate for list membership.  In other words, `solutions(Pred, List)'
finds all the values of `X' for which `call(Pred, X)' is true, collects
these solutions in a list, sorts the list, and returns that list as its
result.  Here's an example: the standard library defines a predicate
`list__perm(List0, List)'

     :- pred list__perm(list(T), list(T)).
     :- mode list__perm(in, out) is nondet.

which succeeds iff List is a permutation of List0.  Hence the following
call to solutions

     solutions(list__perm([3,1,2]), L)

should return all the possible permutations of the list `[3,1,2]' in
sorted order:

     L = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]].


File: mercury_ref.info,  Node: Higher-order modes,  Prev: Calling higher-order terms,  Up: Higher-order

Higher-order modes
==================

   In Mercury, the mode and determinism of a higher-order predicate or
function term are part of that term's *inst*, not its *type*.  This
allows a single higher-order predicate to work on argument predicates
of different modes and determinism, which is particularly useful for
library predicates such as `list__map' and `list__foldl'.

   The language contains builtin `inst' values

     pred is DETERMINISM
     pred(MODE) is DETERMINISM
     pred(MODE1, MODE2) is DETERMINISM
     ...
     func(MODE1) = MODE is DETERMINISM
     func(MODE1, MODE2) = MODE is DETERMINISM
     ...

   These insts represent the instantiation state of variables bound to
higher-order predicate and function terms with the appropriate mode and
determinism.  For example, `pred(out) is det' represents the instantion
state of being bound to a higher-order predicate term which is `det'
and accepts one output argument; the term `sum([1,2,3])' from the
example above is one such higher-order predicate term which matches
this instantiation state.

   As a convenience, the language also contains builtin `mode' values
of the same name (and they are what we have been using in the examples
up to now).  These modes map from the corresponding `inst' to itself.
It is as if they were defined by

     :- mode (pred is DETERMINISM) :: in(pred is DETERMINISM).
     :- mode (pred(INST) is DETERMINISM) ::
         in(pred(INST) is DETERMINISM).
     ...

using the parametric inst `in/1' mentioned in *Note Modes:: which maps
an inst to itself.

   If you want to define a predicate which returns a higher-order
predicate term, you would use a mode such as `free -> pred(...) is ...',
or `out(pred(...) is ...)'.  For example:

     :- pred foo(pred(int)).
     :- mode foo(free -> pred(out) is det) is det.
     
     foo(sum([1,2,3])).

   Note that in Mercury it is an error to attempt to unify two
higher-order terms.  This is because equivalence of higher-order terms
is undecidable in the general case.

   For example, given the definition of `foo' above, the goal

             foo(lambda([X::out] is det, X = 6))

is illegal.  If you really want to compare higher-order predicates for
equivalence, you must program it yourself; for example, the above goal
could legally be written as

             P = lambda([X::out] is det, X = 6),
             foo(Q),
             all [X] (call(P, X) <=> call(Q, X)).

   Note that the compiler will only catch direct attempts at
higher-order unifications; indirect attempts (via polymorphic
predicates, for example `(list__append([], [P], [Q])' may result in an
error at run-time rather than at compile-time.


File: mercury_ref.info,  Node: Modules,  Next: Semantics,  Prev: Higher-order,  Up: Top

Modules
*******

   The Mercury module system is simple and straightforward.  Each
module must start with a `module' declaration, specifying the name of
the module.  An `interface' declaration specifies the start of the
module's interface section: this section contains declarations for the
types, data constructors, instantiation states, modes, functions and
predicates exported by this module.  Mercury provides support for
abstract data types, since the definition of a type may be kept hidden,
with only the type name being exported.  An `implementation'
declaration specifies the start of the module's implementation section.
Any entities declared in this section are local to the module and
cannot be used by other modules.  The implementation section must of
course contain definitions for all abstract data types, functions and
predicates exported by the module, as well for all local types,
functions and predicates.  The module may optionally end with an
`end_module' declaration.

   If a module wishes to make use of entities exported by other modules,
then it must explicitly import those modules using one or more
`import_module' declarations.  These declarations may occur either in
the interface or the implementation section.  If the imported entities
are used in the interface section, then the corresponding
`import_module' declaration must also be in the interface section.  If
the imported entities are only used in the implementation section, the
`import_module' declaration should be in the implementation section.

   Declarations, predicate calls, types, modes and insts can be
explicitly module qualified using the `:' operator, i.e. `module:name'.
This is useful both for readability and for resolving name conflicts.

   Certain optimizations require information or source code for
predicates defined in other modules to be as effective as possible. At
the moment, inlining and higher-order specialization are the only
optimizations that the Mercury compiler can perform across module
boundaries.

   One module must export a predicate `main', which must be declared as
either

     :- pred main(io__state::di, io__state::uo) is det.

or

     :- pred main(io__state::di, io__state::uo) is cc_multi.

(or any declaration equivalent to one of the two above).

   For example, here is the definition of a simple module for managing
queues:

     :- module queue.
     :- interface.
     
     % Declare an abstract data type.
     
     :- type queue(T).
     
     % Declare some predicates which operate on the abstract data type.
     
     :- pred empty_queue(queue(T)).
     :- mode empty_queue(out) is det.
     :- mode empty_queue(in) is semidet.
     
     :- pred put(queue(T), T, queue(T)).
     :- mode put(in, in, out) is det.
     
     :- pred get(queue(T), T, queue(T)).
     :- mode get(in, out, out) is semidet.
     
     :- implementation.
     
     % Queues are implemented as lists. We need the `list' module
     % for the declaration of the type list(T), with its constructors
     % '[]'/0 % and '.'/2, and for the declaration of the predicate
     % list__append/3.
     
     :- import_module list.
     
     % Define the queue ADT.
     
     :- type queue(T) == list(T).
     
     % Declare the exported predicates.
     
     empty_queue([]).
     
     put(Queue0, Elem, Queue) :-
              list__append(Queue0, [Elem], Queue).
     
     get([Elem | Queue], Elem, Queue).
     
     :- end_module queue.

   Mercury has a standard library which includes modules for lists,
stacks, queues, priority queues, sets, bags (multi-sets), maps
(dictionaries), random number generation, input/output and filename and
directory handling.  See the Mercury Library Reference Manual for
details.

   The Mercury standard library has a standard naming convention in
which every entity exported by a module is prefixed by the module name
and two underscores.  We have found this convention improves the
readability and maintainability of our code, and so we recommend that
you follow it in your code too. (Eventually, these names will be
converted to names of the form `module:name'; this will allow you to
omit the prefix in places where it does not improve readability. A tool
for the automatic conversion of existing programs will be provided when
this change occurs.)


File: mercury_ref.info,  Node: Semantics,  Next: Pragmas,  Prev: Modules,  Up: Top

Semantics
*********

   A legal Mercury program is one that complies with the syntax, type,
mode, determinism, and module system rules specified in earlier
chapters.  If a program does not comply with those rules, the compiler
must report an error.

   For each legal Mercury program, there is an associated predicate
calculus theory whose language is specified by the type declarations in
the program and whose axioms are the completion of the clauses for all
predicates in the program, plus the usual equality axioms extended with
the completion of the equations for all functions in the program, plus
axioms corresponding to the mode-determinism assertions (*note
Determinism::.), plus axioms specifying the semantics of library
predicates and functions.  The declarative semantics of a legal Mercury
program is specified by this theory.

   Mercury implementations must be sound: the answers they compute must
be true in every model of the theory.  Mercury implementations are not
required to be complete: they may fail to compute an answer in finite
time, or they may exhaust the resource limitations of the execution
environment, even though an answer is provable in the theory.  However,
there are certain minimum requirements that they must satisfy with
respect to completeness.

   There is an operational semantics of Mercury programs called the
"strict sequential" operational semantics.  In this semantics, the
program is executed top-down, starting from `main/2', and function
calls within a goal, conjunctions and disjunctions are all executed in
depth-first left-to-right order.  Conjunctions and function calls are
"minimally" reordered as required by the modes: the order is determined
by selecting the first mode-correct sub-goal (conjunct or function
call), executing that, then selecting the first of the remaining
sub-goals which is now mode-correct, executing that, and so on.  (There
is no interleaving of different individual conjuncts or function calls,
however; the sub-goals are reordered, not split and interleaved.)
Function application is strict, not lazy.

   Mercury implementations are required to provide a method of
processing Mercury programs which is equivalent to the strict sequential
operational semantics.

   There is another operational semantics of Mercury programs called
the "strict commutative" operational semantics.  This semantics is
equivalent to the strict sequential operation semantics except that
there is no requirement that function calls, conjunctions and
disjunctions be executed left-to-right; they may be executed in any
order.  (The order may even be different each time a particular goal is
entered.)

   As well as providing the strict sequential operational semantics,
Mercury implementations may optionally provide additional
implementation-defined operational semantics, provided that any such
implementation-defined operational semantics are at least as complete
as the strict commutative operational semantics.  An
implementation-defined semantics is "at least as complete" as the
strict commutative semantics if and only if the implementation-defined
semantics guarantees to compute an answer in finite time for any
program for which an answer would be computed in finite time for all
possible executions under the strict commutative semantics (i.e. for
all possible orderings of conjuctions and disjunctions).

   Thus, to summarize, there are in fact a variety of different
operational semantics for Mercury.  In one of them, the strict
sequential semantics, there is no nondeterminism - the behaviour is
always specified exactly.  Programs are executed top-down using SLDNF
(or something equivalent), mode analysis does "minimal" reordering (in
a precisely defined sense), function calls, conjunctions and
disjunctions are executed depth-first left-to-right, and function
evaluation is strict.  All implementations are required to support the
strict sequential semantics, so that a program which works on one
implementation using this semantics will be guaranteed to work on any
other implementation.  However, implementations are also allowed to
support other operational semantics, which may have non-determinism, so
long as they are sound with respect to the declarative semantics, and
so long as they meet a minimum level of completeness (they must be at
least as complete as the strict commutative semantics, in the sense
that every program which terminates for all possible orderings must
must also terminate in any implementation-defined operational
semantics).

   This compromise allows Mercury to be used in several different ways.
Programmers who care more about ease of programming and portability
than about efficiency can use the strict sequential semantics, and can
then be guaranteed that if their program works on one correct
implementation, it will work on all correct implementations.  Compiler
implementors who want to write optimizing implementations that do lots
of clever code reorderings and other high-level transformations or that
want to offer parallelizing implementations which take maximum
advantage of parallelism can define different semantic models.
Programmers who care about efficiency more than portability can write
code for these implementation-defined semantic models.  Programmers who
care about efficiency *and* portability can achieve this by writing
code for the commutative semantics.  Of course, this is not quite as
easy as using the strict sequential semantics, since it is in general
not sufficient to test your programs on just one implementation if you
are to be sure that it will be able to use the maximally efficient
operational semantics on any implementation.  However, if you do write
code which works for all possible executions under commutative
semantics (i.e. for all possible orderings of conjunctions and
disjunctions), then you can be guaranteed that it will work correctly
on every implementation, under every possible implementation-defined
semantics.

   The University of Melbourne Mercury implementation will offer eight
different semantics, which will be selected with different combinations
of the `--no-reorder-conj', `--no-reorder-disj', and `--fully-strict'
options.  (The `--fully-strict' option will prevent the compiler from
improving completeness by optimizing away infinite loops or calls to
`error/1'.)  The default semantics will be the commutative semantics.
Enabling all of these options will give you the the strict sequential
semantics.  Enabling just some of them will give you a semantics
somewhere in between.  (At the time of writing, however, these options
had not been implemented.)

   Future implementations of Mercury may wish to offer other
operational semantics.  For example, they may wish to provide semantics
in which function evaluation is lazy, rather than strict; semantics
with a guaranteed fair search rule; and so forth.


File: mercury_ref.info,  Node: Pragmas,  Prev: Semantics,  Up: Top

Pragmas
*******

   There are several uses for `pragma' declarations:

* Menu:

* C interface::                 The C interface allows C code to be called
                                from Mercury code, and vice versa.
* Inlining::                    Calls to Mercury predicates can be inlined
                                by the compiler to improve efficiency.

* Obsolescence::		Library developers can declare old versions
				of predicates or functions to be obsolete.
* Source file name::		The `source_file' pragma and
				`#LINE' directives provide support
				for preprocessors and other tools that
				generate Mercury code.


File: mercury_ref.info,  Node: C interface,  Next: Inlining,  Up: Pragmas

C interface
===========

* Menu:

* Calling C code::                      How to call C code whenever there is
                                        a call to a Mercury predicate.
* Including C headers::                 Using functions with prototypes from a
                                        non-standard header file.
* Including C code::                    Including definitions of C
					functions in your Mercury code.
* Linking with C object files::         Linking with C object files and
                                        libraries.
* Passing data to and from C::          Exchanging simple data types between
                                        Mercury and C.
* Using C pointers::                    Maintaining a reference to C data
                                        structures in Mercury code.


File: mercury_ref.info,  Node: Calling C code,  Next: Including C headers,  Up: C interface

Calling C code
--------------

   A declaration of the form

     :- pragma c_code(recursive, PRED(VAR1::MODE1, VAR2::MODE2, ...), C_CODE).

results in any calls to PRED with variables in modes (MODE1, MODE2,
...) being replaced by the C code given in C_CODE.

   If there is a `pragma c_code' declaration for a mode of a predicate,
then that mode of the predicate must be deterministic, there must not be
any clauses for that predicate, and there must be a `pragma c_code'
goal for every mode of the predicate.

   For example, the following piece of code gives a predicate,
`c_write_string/3', which has a similar effect to the Mercury library
predicate `io__write_string/3':

     :- pred c_write_string(string, io__state, io__state).
     :- mode c_write_string(in, di, uo) is det.
     
     :- pragma c_code(recursive, c_write_string(S::in, IO0::di, IO::uo),
             "puts(S); IO = IO0;").

   If the C code does not recursively invoke Mercury code, as in the
above example, then you can use a declaration of the form

     :- pragma c_code(non_recursive, PRED(VAR1::MODE1, VAR2::MODE2, ...), C_CODE).

   This allows the compiler to use a more efficient calling convention.
(If you use this form, and the C code *does* invoke Mercury code, then
the behaviour is undefined -- your program may misbehave or crash.)


File: mercury_ref.info,  Node: Including C headers,  Next: Including C code,  Prev: Calling C code,  Up: C interface

Including C headers
-------------------

   Any macros, function prototypes, or other C declarations that are
used in `c_code' pragmas must be included using a `c_header_code'
declaration of the form

     :- pragma c_header_code(HEADERCODE).

HEADERCODE can be a C `#include' line, for example

     :- pragma c_header_code("#include <math.h>")

or

     :- pragma c_header_code("#include ""tcl.h""").

or it may contain any C declarations, for example

     :- pragma c_header_code("
             extern int errno;
             #define SIZE 200
             struct Employee {
                     char name[SIZE];
             }
     	extern int bar;
     	extern void foo(void);
     ").

   Mercury automatically includes certain headers such as `<stdio.h>',
but you should not rely on this, as the set of headers which Mercury
automatically includes is subject to change.


File: mercury_ref.info,  Node: Including C code,  Next: Linking with C object files,  Prev: Including C headers,  Up: C interface

Including C code
----------------

   Definitions of C functions or global variables may be included using
a declaration of the form

     :- pragma c_code(CODE).

   For example,

     :- pragma c_code("
     	int bar = 42;
     	void foo(void) {}
     ").

   Such code is copied verbatim into the generated C file.


File: mercury_ref.info,  Node: Linking with C object files,  Next: Passing data to and from C,  Prev: Including C code,  Up: C interface

Linking with C object files
---------------------------

   To link an existing object file or library into the Mercury
executable, set the `Mmake' variable `MLLIBS' in the `Mmake' file in
the directory in which you are working.  For example add the following
line to the `Mmake' file:

     MLLIBS = my_functions.o -L/usr/local/contrib/lib -lfancy_library

   As illustrated by the example, the values for `MLLIBS' are similar to
those taken by the Unix linker.


File: mercury_ref.info,  Node: Passing data to and from C,  Next: Using C pointers,  Prev: Linking with C object files,  Up: C interface

Passing data to and from C
--------------------------

   For each of the Mercury types `int', `float', `char', and `string',
there is a C typedef for the corresponding type in C: `Integer',
`Float', `Char', and `String' respectively.

   In the current implementation, `Integer' is a typedef for an
integral type whose size is the same size as a pointer; `Float' is a
typedef for `double' (unless the program and the Mercury library was
compiled with `-DUSE_SINGLE_PREC_FLOAT', in which case it is a typedef
for `float'); `Char' is a typedef for `char'; and `String' is a typedef
for `Char *'.

   Mercury variables of type `int', `float', `char', or `string' are
passed to and from C as C variables whose type is given by the
corresponding typedef.  Mercury variables of any other type are passed
as a `Word', which in the current implementation is a typedef for an
unsigned type whose size is the same size as a pointer.

   Mercury lists can be manipulated by C code using the following
macros, which are defined by the Mercury implementation.

     list_is_empty(list)     /* test if a list is empty */
     list_head(list)         /* get the head of a list */
     list_tail(list)         /* get the tail of a list */
     list_empty()            /* create an empty list */
     list_cons(head,tail)    /* construct a list with the given head and tail */

   The `list_cons' macro should only be used in C code called using the
`non_recursive' calling convention.


File: mercury_ref.info,  Node: Using C pointers,  Prev: Passing data to and from C,  Up: C interface

Using C pointers
----------------

   The inbuilt Mercury type `c_pointer' can be used to pass C pointers
between C functions which are called from Mercury.  For example:

     :- module pointer_example.
     
     :- interface.
     
     :- type complicated_c_structure.
     
     % Initialise the abstract C structure that we pass around in Mercury.
     :- pred initialise_complicated_structure(complicated_c_structure::uo) is det.
     
     % Perform a calculation on the C structure.
     :- pred do_calculation(int::in, complicated_structure::di,
             complicated_structure::uo) is det.
     
     :- implementation.
     
     % Our C structure is implemented as a c_pointer.
     :- type complicated_c_structure == c_pointer.
     
     :- pragma c_header_code("
             extern struct foo *init_struct(void);
             extern struct foo *perform_calculation(int, struct foo *);
     ");
     
     :- pragma c_code(recursive, initialise_complicated_structure(Structure::uo),
             "Structure = init_struct();").
     
     :- pragma c_code(recursive,
     	do_calculation(Value::in, Structure0::di, Structure::uo,
             "Structure = perform_calculation(Value, Structure0);").


File: mercury_ref.info,  Node: Inlining,  Next: Obsolescence,  Prev: C interface,  Up: Pragmas

Inlining
========

   A declaration of the form

     :- pragma inline(NAME/ARITY).

is a hint to the compiler that all calls to the predicate(s) or
function(s) with name NAME and arity ARITY should be inlined.

   The current Mercury implementation is smart enough to inline many
simple predicates even without this hint.  However, in the current
Mercury implementation, cross-module inlining is not yet supported, so
if a predicate for which there is an `inline' pragma is called from a
module other than the one it is defined in, the compiler will ignore
the hint.


File: mercury_ref.info,  Node: Obsolescence,  Next: Source file name,  Prev: Inlining,  Up: Pragmas

Obsolescence
============

   A declaration of the form

     :- pragma obsolete(NAME/ARITY).

declares that the predicate(s) or function(s) with name NAME and arity
ARITY are "obsolete": it instructs the compiler to issue a warning
whenever the named predicate(s) or function(s) are used.

   `pragma obsolete' declarations are intended for use by library
developers, to allow gradual (rather than abrupt) evolution of library
interfaces.  If a library developer changes the interface of a library
predicate, they should leave the old version of that predicate in the
library, but mark it as obsolete using a `pragma obsolete' declaration,
and document how library users should modify their code to suit the new
interface.  The users of the library will then get a warning if they
use obsolete features, and can consult the library documentation to
determine how to fix their code.  Eventually, when the library
developer deems that users have had sufficient warning, they can remove
the old version entirely.

