This is Info file mercury_library.info, produced by Makeinfo-1.63 from
the input file library.texi.

START-INFO-DIR-ENTRY
* Mercury Library: (mercury_library). The Mercury Library Reference Manual
END-INFO-DIR-ENTRY

   This file documents the Mercury standard library.

   Copyright (C) 1995 University of Melbourne.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: mercury_library.info,  Node: swi_lib,  Next: term,  Prev: swi_builtin,  Up: Top

swi_lib
*******

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU General
     % Public License - see the file COPYING in the Mercury distribution.
     %--------------------------------------------------%
     
     % Various predicates for SWI-Prolog compatibility.
     
     %--------------------------------------------------%
     
     nuprolog :-
     	fail.
     
     compound(X) :-
     	functor(X, _, _).
     
     putprop(Atom, Key, Property) :-
     	retractall(property(Atom, Key, _)),
     	assert(property(Atom, Key, Property)).
     getprop(Atom, Key, Property) :-
     	property(Atom, Key, Property).
     remprop(Atom, Key) :-
     	retractall(property(Atom, Key, _Property)).
     
     currentInput(X) :-
     	current_input(X).
     
     currentOutput(X) :-
     	current_output(X).
     
     flushOutput(X) :-
     	flush_output(X).
     
     setInput(X) :-
     	set_input(X).
     
     setOutput(X) :-
     	set_output(X).
     
     lineCount(X,Y) :-
     	line_count(X,Y).
     
     eof(end_of_file).
     
     member(Element, List, SubList) :-
     	SubList = [Element | _],
     	append(_, SubList, List).
     
     	% define =/3 for DCGs
     =(A, A, A).
     
     system(Command, Status) :-
     	name(Com, Command),
     	shell(Com, Status).
     
     %--------------------------------------------------%
     
     % Various hacks to get things to work
     
     random__random(R, X, X1) :-
     	X1 is X + 1,
     	bit_reverse(X1, R).
     
     bit_reverse(A, B) :-
     	A0 is A /\ 255,
     	A1 is (A >> 8) /\ 255,
     	A2 is (A >> 16) /\ 255,
     	bit_rev(A0, B2),
     	bit_rev(A1, B1),
     	bit_rev(A2, B0),
     	B is (B2 << 16) + (B1 << 8) + B0.
     
     /*
     bit_rev(A, B) :-
     	A0 is A /\ 1,
     	A1 is (A >> 1) /\ 1,
     	A2 is (A >> 2) /\ 1,
     	A3 is (A >> 3) /\ 1,
     	A4 is (A >> 4) /\ 1,
     	A5 is (A >> 5) /\ 1,
     	A6 is (A >> 6) /\ 1,
     	A7 is (A >> 7) /\ 1,
     	B is (A0 << 7) + (A1 << 6) + (A2 << 5) + (A3 << 4) + (A4 << 3) +
     		(A5 << 2) + (A6 << 1) + A7.
     */
     bit_rev(0, 0).
     bit_rev(1, 128).
     bit_rev(2, 64).
     bit_rev(3, 192).
     bit_rev(4, 32).
     bit_rev(5, 160).
     bit_rev(6, 96).
     bit_rev(7, 224).
     bit_rev(8, 16).
     bit_rev(9, 144).
     bit_rev(10, 80).
     bit_rev(11, 208).
     bit_rev(12, 48).
     bit_rev(13, 176).
     bit_rev(14, 112).
     bit_rev(15, 240).
     bit_rev(16, 8).
     bit_rev(17, 136).
     bit_rev(18, 72).
     bit_rev(19, 200).
     bit_rev(20, 40).
     bit_rev(21, 168).
     bit_rev(22, 104).
     bit_rev(23, 232).
     bit_rev(24, 24).
     bit_rev(25, 152).
     bit_rev(26, 88).
     bit_rev(27, 216).
     bit_rev(28, 56).
     bit_rev(29, 184).
     bit_rev(30, 120).
     bit_rev(31, 248).
     bit_rev(32, 4).
     bit_rev(33, 132).
     bit_rev(34, 68).
     bit_rev(35, 196).
     bit_rev(36, 36).
     bit_rev(37, 164).
     bit_rev(38, 100).
     bit_rev(39, 228).
     bit_rev(40, 20).
     bit_rev(41, 148).
     bit_rev(42, 84).
     bit_rev(43, 212).
     bit_rev(44, 52).
     bit_rev(45, 180).
     bit_rev(46, 116).
     bit_rev(47, 244).
     bit_rev(48, 12).
     bit_rev(49, 140).
     bit_rev(50, 76).
     bit_rev(51, 204).
     bit_rev(52, 44).
     bit_rev(53, 172).
     bit_rev(54, 108).
     bit_rev(55, 236).
     bit_rev(56, 28).
     bit_rev(57, 156).
     bit_rev(58, 92).
     bit_rev(59, 220).
     bit_rev(60, 60).
     bit_rev(61, 188).
     bit_rev(62, 124).
     bit_rev(63, 252).
     bit_rev(64, 2).
     bit_rev(65, 130).
     bit_rev(66, 66).
     bit_rev(67, 194).
     bit_rev(68, 34).
     bit_rev(69, 162).
     bit_rev(70, 98).
     bit_rev(71, 226).
     bit_rev(72, 18).
     bit_rev(73, 146).
     bit_rev(74, 82).
     bit_rev(75, 210).
     bit_rev(76, 50).
     bit_rev(77, 178).
     bit_rev(78, 114).
     bit_rev(79, 242).
     bit_rev(80, 10).
     bit_rev(81, 138).
     bit_rev(82, 74).
     bit_rev(83, 202).
     bit_rev(84, 42).
     bit_rev(85, 170).
     bit_rev(86, 106).
     bit_rev(87, 234).
     bit_rev(88, 26).
     bit_rev(89, 154).
     bit_rev(90, 90).
     bit_rev(91, 218).
     bit_rev(92, 58).
     bit_rev(93, 186).
     bit_rev(94, 122).
     bit_rev(95, 250).
     bit_rev(96, 6).
     bit_rev(97, 134).
     bit_rev(98, 70).
     bit_rev(99, 198).
     bit_rev(100, 38).
     bit_rev(101, 166).
     bit_rev(102, 102).
     bit_rev(103, 230).
     bit_rev(104, 22).
     bit_rev(105, 150).
     bit_rev(106, 86).
     bit_rev(107, 214).
     bit_rev(108, 54).
     bit_rev(109, 182).
     bit_rev(110, 118).
     bit_rev(111, 246).
     bit_rev(112, 14).
     bit_rev(113, 142).
     bit_rev(114, 78).
     bit_rev(115, 206).
     bit_rev(116, 46).
     bit_rev(117, 174).
     bit_rev(118, 110).
     bit_rev(119, 238).
     bit_rev(120, 30).
     bit_rev(121, 158).
     bit_rev(122, 94).
     bit_rev(123, 222).
     bit_rev(124, 62).
     bit_rev(125, 190).
     bit_rev(126, 126).
     bit_rev(127, 254).
     bit_rev(128, 1).
     bit_rev(129, 129).
     bit_rev(130, 65).
     bit_rev(131, 193).
     bit_rev(132, 33).
     bit_rev(133, 161).
     bit_rev(134, 97).
     bit_rev(135, 225).
     bit_rev(136, 17).
     bit_rev(137, 145).
     bit_rev(138, 81).
     bit_rev(139, 209).
     bit_rev(140, 49).
     bit_rev(141, 177).
     bit_rev(142, 113).
     bit_rev(143, 241).
     bit_rev(144, 9).
     bit_rev(145, 137).
     bit_rev(146, 73).
     bit_rev(147, 201).
     bit_rev(148, 41).
     bit_rev(149, 169).
     bit_rev(150, 105).
     bit_rev(151, 233).
     bit_rev(152, 25).
     bit_rev(153, 153).
     bit_rev(154, 89).
     bit_rev(155, 217).
     bit_rev(156, 57).
     bit_rev(157, 185).
     bit_rev(158, 121).
     bit_rev(159, 249).
     bit_rev(160, 5).
     bit_rev(161, 133).
     bit_rev(162, 69).
     bit_rev(163, 197).
     bit_rev(164, 37).
     bit_rev(165, 165).
     bit_rev(166, 101).
     bit_rev(167, 229).
     bit_rev(168, 21).
     bit_rev(169, 149).
     bit_rev(170, 85).
     bit_rev(171, 213).
     bit_rev(172, 53).
     bit_rev(173, 181).
     bit_rev(174, 117).
     bit_rev(175, 245).
     bit_rev(176, 13).
     bit_rev(177, 141).
     bit_rev(178, 77).
     bit_rev(179, 205).
     bit_rev(180, 45).
     bit_rev(181, 173).
     bit_rev(182, 109).
     bit_rev(183, 237).
     bit_rev(184, 29).
     bit_rev(185, 157).
     bit_rev(186, 93).
     bit_rev(187, 221).
     bit_rev(188, 61).
     bit_rev(189, 189).
     bit_rev(190, 125).
     bit_rev(191, 253).
     bit_rev(192, 3).
     bit_rev(193, 131).
     bit_rev(194, 67).
     bit_rev(195, 195).
     bit_rev(196, 35).
     bit_rev(197, 163).
     bit_rev(198, 99).
     bit_rev(199, 227).
     bit_rev(200, 19).
     bit_rev(201, 147).
     bit_rev(202, 83).
     bit_rev(203, 211).
     bit_rev(204, 51).
     bit_rev(205, 179).
     bit_rev(206, 115).
     bit_rev(207, 243).
     bit_rev(208, 11).
     bit_rev(209, 139).
     bit_rev(210, 75).
     bit_rev(211, 203).
     bit_rev(212, 43).
     bit_rev(213, 171).
     bit_rev(214, 107).
     bit_rev(215, 235).
     bit_rev(216, 27).
     bit_rev(217, 155).
     bit_rev(218, 91).
     bit_rev(219, 219).
     bit_rev(220, 59).
     bit_rev(221, 187).
     bit_rev(222, 123).
     bit_rev(223, 251).
     bit_rev(224, 7).
     bit_rev(225, 135).
     bit_rev(226, 71).
     bit_rev(227, 199).
     bit_rev(228, 39).
     bit_rev(229, 167).
     bit_rev(230, 103).
     bit_rev(231, 231).
     bit_rev(232, 23).
     bit_rev(233, 151).
     bit_rev(234, 87).
     bit_rev(235, 215).
     bit_rev(236, 55).
     bit_rev(237, 183).
     bit_rev(238, 119).
     bit_rev(239, 247).
     bit_rev(240, 15).
     bit_rev(241, 143).
     bit_rev(242, 79).
     bit_rev(243, 207).
     bit_rev(244, 47).
     bit_rev(245, 175).
     bit_rev(246, 111).
     bit_rev(247, 239).
     bit_rev(248, 31).
     bit_rev(249, 159).
     bit_rev(250, 95).
     bit_rev(251, 223).
     bit_rev(252, 63).
     bit_rev(253, 191).
     bit_rev(254, 127).
     bit_rev(255, 255).
     
     bimap__search(bimap(O, C), K, V) :-
     	( nonvar(K) ->
     		map__search(O, K, V),
     		map__search(C, V, K)
     	; nonvar(V) ->
     		map__search(C, V, K),
     		map__search(O, K, V)
     	;
     		error("bimap__search")
     	).
     
     portray(Stream, Term) :-
     	currentOutput(S),
     	setOutput(Stream),
     	( portray(Term) -> true ; print(Term) ),
     	setOutput(S).
     
     code_info__current_store_map(Map) -->
             code_info__get_store_map(Maps0),
             { stack__top(Maps0, Map0) },
             !,
             { Map = Map0 }.
     code_info__current_store_map(_) -->
             { error("No store map on stack") }.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: term,  Next: term_io,  Prev: swi_lib,  Up: Top

term
****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: term.m.
     % Main author: fjh.
     % Stability: medium.
     
     % This file provides a type `term' used to represent Prolog terms,
     % and various predicates to manipulate terms and substitutions.
     
     %--------------------------------------------------%
     
     :- module term.
     :- interface.
     :- import_module int, string, float, list, map.
     
     %--------------------------------------------------%
     
     % The term type is actually defined in mercury_builtin.m.
     
     /*
     :- type term		--->	term__functor(const, list(term), term__context)
     			;	term__variable(var).
     :- type const		--->	term__atom(string)
     			;	term__integer(int)
     			;	term__string(string)
     			;	term__float(float).
     
     :- type var.
     :- type var_supply.
     
     */
     %--------------------------------------------------%
     
     :- pred term__vars(term, list(var)).
     :- mode term__vars(in, out) is det.
     %	term__vars(Term, Vars)
     %		Vars is the list of variables contained in Term, in the order
     %		obtained by traversing the term depth first, left-to-right.
     
     :- pred term__vars_2(term, list(var), list(var)).
     :- mode term__vars_2(in, in, out) is det.
     %		As above, but with an accumulator.
     
     :- pred term__vars_list(list(term), list(var)).
     :- mode term__vars_list(in, out) is det.
     %	term__vars_list(TermList, Vars)
     %		Vars is the list of variables contained in TermList, in the
     %		order obtained by traversing the list of terms depth-first,
     %		left-to-right.
     
     :- pred term__contains_var(term, var).
     :- mode term__contains_var(in, in) is semidet.
     :- mode term__contains_var(in, out) is nondet.
     %	term__contains_var(Term, Var)
     %		True if Term contains Var. (On backtracking returns all the
     %		variables contained in Term.)
     
     :- pred term__contains_var_list(list(term), var).
     :- mode term__contains_var_list(in, in) is semidet.
     :- mode term__contains_var_list(in, out) is nondet.
     %	term__contains_var_list(TermList, Var)
     %		True if TermList contains Var. (On backtracking returns all the
     %		variables contained in Term.)
     
     :- type substitution == map(var, term).
     
     :- pred term__unify(term, term, substitution, substitution).
     :- mode term__unify(in, in, in, out) is semidet.
     %	term__unify(Term1, Term2, Bindings0, Bindings)
     %		unify (with occur check) two terms with respect to a set
     %	 	of bindings and possibly update the set of bindings
     
     :- pred term__substitute(term, var, term, term).
     :- mode term__substitute(in, in, in, out) is det.
     %	term__substitute(Term0, Var, Replacement, Term) :
     %		replace all occurrences of Var in Term0 with Replacement,
     %		and return the result in Term.
     
     :- pred term__substitute_list(list(term), var, term, list(term)).
     :- mode term__substitute_list(in, in, in, out) is det.
     %		as above, except for a list of terms rather than a single term
     
     :- pred term__substitute_corresponding(list(var), list(term), term, term).
     :- mode term__substitute_corresponding(in, in, in, out) is det.
     %       term__substitute_corresponding(Vars, Repls, Term0, Term).
     %		replace all occurrences of variables in Vars with
     %		the corresponding term in Repls, and return the result in Term.
     %		If Vars contains duplicates, or if Vars is not the same
     %	        length as Repls, the behaviour is undefined and probably
     %		harmful.
     
     :- pred term__substitute_corresponding_list(list(var), list(term), list(term),
     						list(term)).
     :- mode term__substitute_corresponding_list(in, in, in, out) is det.
     %       term__substitute_corresponding_list(Vars, Repls, TermList0, TermList).
     %		As above, except applies to a list of terms rather than a
     %		single term.
     
     :- pred term__apply_rec_substitution(term, substitution, term).
     :- mode term__apply_rec_substitution(in, in, out) is det.
     %	term__apply_rec_substitution(Term0, Substitution, Term) :
     %		recursively apply substitution to Term0 until
     %		no more substitions can be applied, and then
     %		return the result in Term.
     
     :- pred term__apply_rec_substitution_to_list(list(term), substitution,
     						list(term)).
     :- mode term__apply_rec_substitution_to_list(in, in, out) is det.
     
     :- pred term__apply_substitution(term, substitution, term).
     :- mode term__apply_substitution(in, in, out) is det.
     %	term__apply_substitution(Term0, Substitution, Term) :
     %		apply substitution to Term0 and return the result in Term.
     
     :- pred term__apply_substitution_to_list(list(term), substitution, list(term)).
     :- mode term__apply_substitution_to_list(in, in, out) is det.
     %	term__apply_substitution_to_list(TermList0, Substitution, TermList) :
     %		as above, except for a list of terms rather than a single term
     
     
     :- pred term__occurs(term, var, substitution).
     :- mode term__occurs(in, in, in) is semidet.
     %	term__occurs(Term0, Var, Substitution) :
     %		true iff Var occurs in the term resulting after
     %		applying Substitution to Term0.
     
     :- pred term__occurs_list(list(term), var, substitution).
     :- mode term__occurs_list(in, in, in) is semidet.
     %		as above, except for a list of terms rather than a single term
     
     :- pred term__relabel_variable(term, var, var, term).
     :- mode term__relabel_variable(in, in, in, out) is det.
     %	term__relabel_variable(Term0, OldVar, NewVar, Term) :
     %		replace all occurences of OldVar in Term0 with
     %		NewVar and put the result in Term.
     
     :- pred term__relabel_variables(list(term), var, var, list(term)).
     :- mode term__relabel_variables(in, in, in, out) is det.
     %	term__relabel_variables(Terms0, OldVar, NewVar, Terms) :
     %		same as term__relabel_variable but for a list of terms.
     
     :- pred term__apply_variable_renaming(term, map(var, var), term).
     :- mode term__apply_variable_renaming(in, in, out) is det.
     % 		same as term__relabel_variable, except relabels
     % 		multiple variables. If a variable is not in the
     % 		map, it is not replaced.
     
     :- pred term__apply_variable_renaming_to_list(list(term), map(var, var),
     							 list(term)).
     :- mode term__apply_variable_renaming_to_list(in, in, out) is det.
     %		applies term__apply_variable_renaming to a list of terms.
     
     
     :- pred term__is_ground(term, substitution).
     :- mode term__is_ground(in, in) is semidet.
     %	term__is_ground(Term, Bindings) is true iff no variables contained
     %		in Term are non-ground in Bindings.
     
     :- pred term__is_ground(term).
     :- mode term__is_ground(in) is semidet.
     %	term__is_ground(Term, Bindings) is true iff Term contains no
     %		variables.
     
     :- pred term__compare(comparison_result, term, term, substitution).
     :- mode term__compare(out, in, in, in) is semidet.
     %	term__compare(Comparison, Term1, Term2, Bindings) is true iff
     %		there is a binding of Comparison to <, =, or > such
     %		that the binding holds for the two ground terms Term1
     %		and Term2 with respect to the bindings in Bindings.
     %		Fails if Term1 or Term2 is not ground (with respect to
     %		the bindings in Bindings).
     
     %--------------------------------------------------%
     /*
     
     These are now in mercury_builtin.m to avoid module qualification
     conflicts with type var.
     
     
     	% To manage a supply of variables, use the following 2 predicates.
     	% (We might want to give these a unique mode later.)
     
     :- pred term__init_var_supply(var_supply).
     :- mode term__init_var_supply(out) is det.
     :- mode term__init_var_supply(in) is semidet. % implied
     %	term__init_var_supply(VarSupply) :
     %		returns a fresh var_supply for producing fresh variables.
     
     :- pred term__create_var(var_supply, var, var_supply).
     :- mode term__create_var(in, out, out) is det.
     %	term__create_var(VarSupply0, Variable, VarSupply) :
     %		create a fresh variable (var) and return the
     %		updated var_supply.
     
     :- pred term__var_to_int(var, int).
     :- mode term__var_to_int(in, out) is det.
     %		Convert a variable to an int.
     %		Different variables map to different ints.
     %		Other than that, the mapping is unspecified.
     */
     
     %--------------------------------------------------%
     
     	% Given a term context, return the source line number.
     
     :- pred term__context_line(term__context, int).
     :- mode term__context_line(in, out) is det.
     
     	% Given a term context, return the source file.
     
     :- pred term__context_file(term__context, string).
     :- mode term__context_file(in, out) is det.
     
     	% Used to initialize the term context when reading in
     	% (or otherwise constructing) a term.
     	% Unify_proc__generate_du_type_to_term_clauses
     	% requires the use of an initialized term__context. It
     	% directly constructs an initialized term__context
     	% without calling term__context_init to avoid the
     	% prob of including the term module in everything.
     
     % :- pred term__context_init(term__context).
     % :- mode term__context_init(out) is det.
     
     :- pred term__context_init(string, int, term__context).
     :- mode term__context_init(in, in, out) is det.
     
     	% Convert a list of terms which are all vars into a list
     	% of vars.  Abort (call error/1) if the list contains
     	% any non-variables.
     
     :- pred term__term_list_to_var_list(list(term), list(var)).
     :- mode term__term_list_to_var_list(in, out) is det.
     
     	% Convert a list of terms which are all vars into a list
     	% of vars (or vice versa).
     
     :- pred term__var_list_to_term_list(list(var), list(term)).
     :- mode term__var_list_to_term_list(in, out) is det.
     :- mode term__var_list_to_term_list(out, in) is semidet.
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: term_io,  Next: time,  Prev: term,  Up: Top

term_io
*******

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: term_io.m.
     % Main author: fjh.
     % Stability: medium to high.
     %
     % This file encapsulates all the term I/O.
     % This exports predicates to read and write terms in the
     % nice ground representation provided in term.m.
     %
     %--------------------------------------------------%
     
     :- module term_io.
     :- interface.
     :- import_module io, int, float, string, list, varset, term, char.
     
     % External interface: exported predicates
     
     /***** not yet implemented
     :- type op_type ---> fx; fy; xf; yf; xfx; xfy; yfx; fxx; fxy; fyx; fyy.
     :- pred term_io__op(int, op_type, string, io__state, io__state).
     :- mode term_io__op(in, in, in, di, uo) is det.
     %	term_io__op(Prec, Type, OpName, IOState0, IOState1).
     %		Define an operator as per Prolog op/3 for future calls to
     %		term_io__read_term.
     
     :- type op_details ---> op(int, op_type, string).
     :- pred term_io__current_ops(list(op_details), io__state, io__state).
     :- mode term_io__current_ops(out, di, uo) is det.
     %		Return a list containing all the current operator definitions.
     %		Does not modify the io__state.
     *****/
     
     :- type read_term ---> eof ; error(string, int) ; term(varset, term).
     :- pred term_io__read_term(read_term, io__state, io__state).
     :- mode term_io__read_term(out, di, uo) is det.
     
     %	term_io__read_term(Result, IO0, IO1).
     %		Read a term from standard input. Similar to NU-Prolog
     %		read_term/2, except that resulting term is in the ground
     %		representation. Binds Result to either `eof',
     %		`term(VarSet, Term)', or `error(Message, LineNumber)'.
     
     :- pred term_io__write_term(varset, term, io__state, io__state).
     :- mode term_io__write_term(in, in, di, uo) is det.
     %		Writes a term to standard output.
     
     :- pred term_io__write_term_nl(varset, term, io__state, io__state).
     :- mode term_io__write_term_nl(in, in, di, uo) is det.
     %		As above, except it appends a period and new-line.
     
     :- pred term_io__write_constant(const, io__state, io__state).
     :- mode term_io__write_constant(in, di, uo) is det.
     %		Writes a constant (integer, float, or atom) to stdout.
     
     :- pred term_io__write_variable(var, varset, io__state, io__state).
     :- mode term_io__write_variable(in, in, di, uo) is det.
     %		Writes a variable to stdout.
     
     :- pred term_io__quote_string(string, io__state, io__state).
     :- mode term_io__quote_string(in, di, uo) is det.
     	% Given a string S, write S in double-quotes, with characters
     	% escaped if necessary, to stdout.
     
     :- pred term_io__quote_atom(string, io__state, io__state).
     :- mode term_io__quote_atom(in, di, uo) is det.
     	% Given an atom-name A, write A, enclosed in single-quotes if necessary,
     	% with characters escaped if necessary, to stdout.
     
     :- pred term_io__quote_char(character, io__state, io__state).
     :- mode term_io__quote_char(in, di, uo) is det.
     	% Given a character C, write C in single-quotes,
     	% escaped if necessary, to stdout.
     
     :- pred term_io__quote_single_char(character, io__state, io__state).
     :- mode term_io__quote_single_char(in, di, uo) is det.
     	% Given a character C, write C, escaped if necessary, to stdout.
     	% The character is not enclosed in quotes.
     
     %--------------------------------------------------%
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: time,  Next: tree234,  Prev: term_io,  Up: Top

time
****

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: time.m.
     % Main author: zs.
     % Stability: medium to high.
     
     % This module contains predicates that deal with the CPU time requirements
     % of (various parts of) the program.
     
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module time.
     
     :- interface.
     
     % Declaratively, `report_stats' is the same as `true'.
     % It has the side-effect of reporting some memory and time usage statistics
     % to stdout. (Technically, every Mercury implementation must offer
     % a mode of invocation which disables this side-effect.)
     
     :- pred report_stats is det.
     
     % benchmark_det(Pred, In, Out, Repeats, Time) is for benchmarking the
     % det predicate Pred. We call Pred with the input In and the output Out,
     % and return Out so that the caller can check the correctness of the
     % benchmarked predicate. Since most systems do not have good facilities
     % for measuring small times, the Repeats parameter allows the caller to
     % specify how many times Pred should be called inside the timed interval.
     % The number of milliseconds required to execute Pred with input In this
     % many times is returned as Time.
     
     :- pred benchmark_det(pred(T1, T2), T1, T2, int, int).
     :- mode benchmark_det(pred(in, out) is det, in, out, in, out) is det.
     
     % benchmark_nondet(Pred, In, Count, Repeats, Time) is for benchmarking
     % the nondet predicate Pred. benchmark_nondet is similar to benchmark_det,
     % but since solutions/2 is not yet available in all grades, it can't
     % return the list of solutions, so it returns the count of solutions
     % as the next best thing. The number of milliseconds required to generate
     % all solutions of Pred with input In Repeats times is returned as Time.
     
     :- pred benchmark_nondet(pred(T1, T2), T1, int, int, int).
     :- mode benchmark_nondet(pred(in, out) is nondet, in, out, in, out) is det.


File: mercury_library.info,  Node: tree234,  Next: uniq_array,  Prev: time,  Up: Top

tree234
*******

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % tree234 - implements a map (dictionary) using 2-3-4 trees.
     % main author: conway.
     % stability: medium.
     
     % See map.m for documentation.
     
     %--------------------------------------------------%
     
     :- module tree234.
     
     :- interface.
     
     :- import_module list, std_util, assoc_list.
     
     :- type tree234(K, V).
     
     :- pred tree234__init(tree234(K, V)).
     :- mode tree234__init(uo) is det.
     
     :- pred tree234__member(tree234(K, V), K, V).
     :- mode tree234__member(in, out, out) is nondet.
     
     :- pred tree234__search(tree234(K, V), K, V).
     :- mode tree234__search(in, in, out) is semidet.
     
     :- pred tree234__lookup(tree234(K, V), K, V).
     :- mode tree234__lookup(in, in, out) is det.
     
     :- pred tree234__insert(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234__insert(in, in, in, out) is semidet.
     
     :- pred tree234__set(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234__set(di, di, di, uo) is det.
     :- mode tree234__set(di_tree234, in, in, uo_tree234) is det.
     :- mode tree234__set(in, in, in, out) is det.
     
     :- pred tree234__delete(tree234(K, V), K, tree234(K, V)).
     :- mode tree234__delete(di, in, uo) is det.
     :- mode tree234__delete(di_tree234, in, uo_tree234) is det.
     :- mode tree234__delete(in, in, out) is det.
     
     :- pred tree234__remove(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234__remove(di, in, uo, uo) is semidet.
     :- mode tree234__remove(di_tree234, in, out, uo_tree234) is semidet.
     :- mode tree234__remove(in, in, out, out) is semidet.
     
     :- pred tree234__remove_smallest(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234__remove_smallest(di, uo, uo, uo) is semidet.
     :- mode tree234__remove_smallest(di_tree234, out, out, uo_tree234) is semidet.
     :- mode tree234__remove_smallest(in, out, out, out) is semidet.
     
     :- pred tree234__keys(tree234(K, V), list(K)).
     :- mode tree234__keys(in, out) is det.
     
     :- pred tree234__values(tree234(K, V), list(V)).
     :- mode tree234__values(in, out) is det.
     
     :- pred tree234__update(tree234(K, V), K, V, tree234(K, V)).
     :- mode tree234__update(in, in, in, out) is semidet.
     
     	% count the number of elements in a tree
     :- pred tree234__count(tree234(K, V), int).
     :- mode tree234__count(in, out) is det.
     
     :- pred tree234__assoc_list_to_tree234(assoc_list(K, V), tree234(K, V)).
     :- mode tree234__assoc_list_to_tree234(in, out) is det.
     
     :- pred tree234__tree234_to_assoc_list(tree234(K, V), assoc_list(K, V)).
     :- mode tree234__tree234_to_assoc_list(in, out) is det.
     
     %--------------------------------------------------%
     %--------------------------------------------------%


File: mercury_library.info,  Node: uniq_array,  Next: varset,  Prev: tree234,  Up: Top

uniq_array
**********

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     
     % File: uniq_array.m
     % Main author: fjh
     % Stability: VERY LOW
     
     % This module provides dynamically-sized one-dimensional arrays.
     % Array indices start at zero.
     
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module uniq_array.
     :- interface.
     :- import_module int, list.
     
     :- type uniq_array(T).
     
     	% XXX the current Mercury compiler doesn't support `ui' modes,
     	% so to work-around that problem, we currently don't use
     	% unique modes in this module.
     
     % :- inst uniq_array(I) = unique(unique_array(I)).
     :- inst uniq_array(I) = bound(unique_array(I)).
     :- inst uniq_array == uniq_array(ground).
     :- inst uniq_array_skel == uniq_array(free).
     
     :- mode uniq_array_di == di(uniq_array).
     :- mode uniq_array_uo == out(uniq_array).
     :- mode uniq_array_ui == in(uniq_array).
     
     	% uniq_array__make_empty_array(Array) creates an array of size zero
     	% with bounds from 0 to 0.
     
     :- pred uniq_array__make_empty_array(uniq_array(T)).
     :- mode uniq_array__make_empty_array(uniq_array_uo) is det.
     
     	% uniq_array__init(Size, Init, Array) creates a uniq_array
     	% with bounds from 0 to Size-1, with each element initialized to Init.
     :- pred uniq_array__init(int, T, uniq_array(T)).
     :- mode uniq_array__init(in, in, uniq_array_uo) is det.
     
     	% uniq_array__max returns the upper bound of the array
     :- pred uniq_array__max(uniq_array(_T), int).
     :- mode uniq_array__max(uniq_array_ui, out) is det.
     :- mode uniq_array__max(in, out) is det.
     
     	% uniq_array__size returns the length of the array,
     	% i.e. upper bound + 1.
     :- pred uniq_array__size(uniq_array(_T), int).
     :- mode uniq_array__size(uniq_array_ui, out) is det.
     :- mode uniq_array__size(in, out) is det.
     
     	% uniq_array__in_bounds checks whether an index is in the bounds
     	% of a uniq_array
     :- pred uniq_array__in_bounds(uniq_array(_T), int).
     :- mode uniq_array__in_bounds(uniq_array_ui, in) is semidet.
     :- mode uniq_array__in_bounds(in, in) is semidet.
     
     	% uniq_array__lookup returns the Nth element of a uniq_array.
     	% It is an error if the index is out of bounds.
     :- pred uniq_array__lookup(uniq_array(T), int, T).
     :- mode uniq_array__lookup(uniq_array_ui, in, out) is det.
     :- mode uniq_array__lookup(in, in, out) is det.
     
     	% uniq_array__semidet_lookup returns the Nth element of a uniq_array.
     	% It fails if the index is out of bounds.
     :- pred uniq_array__semidet_lookup(uniq_array(T), int, T).
     :- mode uniq_array__semidet_lookup(uniq_array_ui, in, out) is semidet.
     :- mode uniq_array__semidet_lookup(in, in, out) is semidet.
     
     	% uniq_array__set sets the nth element of a uniq_array, and returns the
     	% resulting uniq_array (good opportunity for destructive update ;-).
     	% It is an error if the index is out of bounds.
     :- pred uniq_array__set(uniq_array(T), int, T, uniq_array(T)).
     :- mode uniq_array__set(uniq_array_di, in, in, uniq_array_uo) is det.
     
     	% uniq_array__semidet_set sets the nth element of a uniq_array,
     	% and returns the resulting uniq_array.
     	% It fails if the index is out of bounds.
     :- pred uniq_array__semidet_set(uniq_array(T), int, T, uniq_array(T)).
     :- mode uniq_array__semidet_set(uniq_array_ui, in, in, uniq_array_uo)
     				is semidet.
     
     	% uniq_array__slow_set sets the nth element of a uniq_array,
     	% and returns the resulting uniq_array.  The initial array is not
     	% required to be unique, so the implementation may not be able to use
     	% destructive update.
     	% It is an error if the index is out of bounds.
     :- pred uniq_array__slow_set(uniq_array(T), int, T, uniq_array(T)).
     :- mode uniq_array__slow_set(uniq_array_di, in, in, uniq_array_uo) is det.
     :- mode uniq_array__slow_set(in, in, in, uniq_array_uo) is det.
     
     	% uniq_array__semidet_slow_set sets the nth element of a uniq_array,
     	% and returns the resulting uniq_array.  The initial array is not
     	% required to be unique, so the implementation may not be able to use
     	% destructive update.
     	% It fails if the index is out of bounds.
     :- pred uniq_array__semidet_slow_set(uniq_array(T), int, T, uniq_array(T)).
     :- mode uniq_array__semidet_slow_set(uniq_array_ui, in, in, uniq_array_uo)
     				is semidet.
     :- mode uniq_array__semidet_slow_set(in, in, in, uniq_array_uo) is semidet.
     
     	% uniq_array__copy(Array0, Array):
     	% Makes a new unique copy of a uniq_array.
     :- pred uniq_array__copy(uniq_array(T), uniq_array(T)).
     :- mode uniq_array__copy(uniq_array_ui, uniq_array_uo) is det.
     :- mode uniq_array__copy(in, uniq_array_uo) is det.
     
     	% uniq_array__resize(Array0, Size, Init, Array):
     	% The uniq_array is expanded or shrunk to make it fit
     	% the new size `Size'.  Any new entries are filled
     	% with `Init'.
     :- pred uniq_array__resize(uniq_array(T), int, T, uniq_array(T)).
     :- mode uniq_array__resize(uniq_array_di, in, in, uniq_array_uo) is det.
     
     	% uniq_array__from_list takes a list (of nonzero length),
     	% and returns a uniq_array containing those elements in
     	% the same order that they occured in the list.
     :- pred uniq_array__from_list(list(T), uniq_array(T)).
     :- mode uniq_array__from_list(in, uniq_array_uo) is det.
     
     	% uniq_array__to_list takes a uniq_array and returns a list containing
     	% the elements of the uniq_array in the same order that they
     	% occurred in the uniq_array.
     :- pred uniq_array__to_list(uniq_array(T), list(T)).
     :- mode uniq_array__to_list(uniq_array_ui, out) is det.
     
     	% uniq_array__fetch_items takes a uniq_array and a lower and upper
     	% index, and places those items in the uniq_array between these
     	% indices into a list.  It is an error if either index is
     	% out of bounds.
     :- pred uniq_array__fetch_items(uniq_array(T), int, int, list(T)).
     :- mode uniq_array__fetch_items(in, in, in, out) is det.
     
     	% uniq_array__bsearch takes a uniq_array, an element to be found
     	% and a comparison predicate and returns the position of
     	% the element in the uniq_array.  Assumes the uniq_array is in sorted
     	% order.  Fails if the element is not present.  If the
     	% element to be found appears multiple times, the index of
     	% the first occurrence is returned.
     	% call/N currently does not allow output arguments to come
     	% before input arguments, so you can't just pass compare/3
     	% in here. :-(
     :- pred uniq_array__bsearch(uniq_array(T), T, pred(T, T, comparison_result),
     		maybe(int)).
     :- mode uniq_array__bsearch(uniq_array_ui, in, pred(in, in, out) is det,
     		out) is det.
     :- mode uniq_array__bsearch(in, in, pred(in, in, out) is det, out) is det.
     
     %--------------------------------------------------%


File: mercury_library.info,  Node: varset,  Prev: uniq_array,  Up: Top

varset
******

     %--------------------------------------------------%
     % Copyright (C) 1995 University of Melbourne.
     % This file may only be copied under the terms of the GNU Library General
     % Public License - see the file COPYING.LIB in the Mercury distribution.
     %--------------------------------------------------%
     %
     % File: varset.m.
     % Main author: fjh.
     % Stability: low.
     %
     % This file provides facilities for manipulating collections of
     % variables and terms.
     % It provides the 'varset' ADT. A varset is a set of variables.
     % (These variables are object-level variables, and are represented
     % as ground terms, so it might help to think of them as "variable ids"
     % rather than variables.)
     % Associated with each variable there can be both a name and a value (binding).
     % [But at the moment, the rest of the code is only using varsets to store
     % names, not values.]
     %
     % There may be some design flaws in the relationship between varset.m,
     % term.m, and graph.m.  Once we have implemented unique modes and
     % destructive assignment, we will need to rethink the design;  we may
     % end up modifying these modules considerably, or we may end up
     % making new single-threaded versions of these modules.
     %
     %--------------------------------------------------%
     %--------------------------------------------------%
     
     :- module varset.
     :- interface.
     :- import_module string, term.
     
     :- type varset.
     
     	% construct an empty varset.
     :- pred varset__init(varset).
     :- mode varset__init(out) is det.
     
     	% check whether a varset is empty.
     :- pred varset__is_empty(varset).
     :- mode varset__is_empty(in) is semidet.
     
     	% create a new variable
     :- pred varset__new_var(varset, var, varset).
     :- mode varset__new_var(in, out, out) is det.
     
     	% create multiple new variables
     :- pred varset__new_vars(varset, int, list(var), varset).
     :- mode varset__new_vars(in, in, out, out) is det.
     
     	% delete an old variable
     :- pred varset__delete_var(varset, var, varset).
     :- mode varset__delete_var(in, in, out) is det.
     
     	% delete a list of old variables
     :- pred varset__delete_vars(varset, list(var), varset).
     :- mode varset__delete_vars(in, in, out) is det.
     
     	% return a list of all the variables in a varset
     :- pred varset__vars(varset, list(var)).
     :- mode varset__vars(in, out) is det.
     
     	% set the name of a variable
     	% (if there is already a variable with the same name "Foo",
     	% then try naming it "Foo'", or "Foo''", or "Foo'''", etc. until
     	% an unused name is found.)
     :- pred varset__name_var(varset, var, string, varset).
     :- mode varset__name_var(in, in, in, out) is det.
     
     	% lookup the name of a variable;
     	% create one if it doesn't have one using V_ as a prefix
     :- pred varset__lookup_name(varset, var, string).
     :- mode varset__lookup_name(in, in, out) is det.
     
     	% lookup the name of a variable;
     	% create one if it doesn't have one using the specified prefix
     :- pred varset__lookup_name(varset, var, string, string).
     :- mode varset__lookup_name(in, in, in, out) is det.
     
     	% lookup the name of a variable;
     	% fail if it doesn't have one
     :- pred varset__search_name(varset, var, string).
     :- mode varset__search_name(in, in, out) is semidet.
     
     	% bind a value to a variable
     	% (will overwrite any existing binding).
     :- pred varset__bind_var(varset, var, term, varset).
     :- mode varset__bind_var(in, in, in, out) is det.
     
     	% bind a set of terms to a set of variables.
     :- pred varset__bind_vars(varset, substitution, varset).
     :- mode varset__bind_vars(in, in, out) is det.
     
     	% lookup the value of a variable
     :- pred varset__search_var(varset, var, term).
     :- mode varset__search_var(in, in, out) is semidet.
     
     	% get the bindings for all the bound variables.
     :- pred varset__lookup_vars(varset, substitution).
     :- mode varset__lookup_vars(in, out) is det.
     
     	% Combine two different varsets, renaming apart:
     	% varset__merge(VarSet0, NewVarSet, Terms0, VarSet, Terms) is
     	% true iff VarSet is the varset that results from joining
     	% VarSet0 to a suitably renamed version of NewVarSet,
     	% and Terms is Terms0 renamed accordingly.
     	% (Any bindings in NewVarSet are ignored.)
     
     :- pred varset__merge(varset, varset, list(term), varset, list(term)).
     :- mode varset__merge(in, in, in, out, out) is det.
     
     	% As above, except return the substitution directly
     	% rather than applying it to a list of terms.
     
     :- pred varset__merge_subst(varset, varset, varset, substitution).
     :- mode varset__merge_subst(in, in, out, out) is det.
     
     	% get the bindings for all the bound variables.
     :- pred varset__get_bindings(varset, substitution).
     :- mode varset__get_bindings(in, out) is det.
     
     	% set the bindings for all the bound variables.
     :- pred varset__set_bindings(varset, substitution, varset).
     :- mode varset__set_bindings(in, in, out) is det.
     
     	% Create a map from names to variables.
     	% Each name is mapped to only one variable, even if a name is
     	% shared by more than one variable. Therefore this predicate
     	% is only really useful if it is already known that no two
     	% variables share the same name.
     :- pred varset__create_name_var_map(varset, map(string, var)).
     :- mode varset__create_name_var_map(in, out) is det.
     
     	% Return an association list giving the name of each variable.
     	% Every variable has an entry in the returned association list,
     	% even if it shares its name with another variable.
     :- pred varset__var_name_list(varset, assoc_list(var, string)).
     :- mode varset__var_name_list(in, out) is det.
     
     	% Given a list of variable and varset in which some variables have
     	% no name but some other variables may have the same name,
     	% return another varset in which every variable has a unique name.
     	% If necessary, names will have suffixes added on the end;
     	% the second argument gives the suffix to use.
     :- pred varset__ensure_unique_names(list(var), string, varset, varset).
     :- mode varset__ensure_unique_names(in, in, in, out) is det.
     
     %--------------------------------------------------%


