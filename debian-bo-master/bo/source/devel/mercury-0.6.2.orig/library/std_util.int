:- module std_util.
:- interface.
:- import_module list, set.
:- type (std_util:univ).
:- pred std_util:type_to_univ(T, (std_util:univ)).
:- mode std_util:type_to_univ(mercury_builtin:di, mercury_builtin:uo) is det.
:- mode std_util:type_to_univ(mercury_builtin:in, mercury_builtin:out) is det.
:- mode std_util:type_to_univ(mercury_builtin:out, mercury_builtin:in) is semidet.
:- pred std_util:univ_to_type((std_util:univ), T).
:- mode std_util:univ_to_type(mercury_builtin:in, mercury_builtin:out) is semidet.
:- mode std_util:univ_to_type(mercury_builtin:out, mercury_builtin:in) is det.
:- type (std_util:maybe(T))
	--->	yes(T)
	;	no.
:- type (std_util:unit)
	--->	unit.
:- type (std_util:pair(T1, T2))
	--->	'-'(T1, T2).
:- type (std_util:pair(T)) == (std_util:pair(T, T)).
:- pred std_util:solutions((pred T), (mercury_builtin:list(T))).
:- mode std_util:solutions((pred(mercury_builtin:out) is multi), mercury_builtin:out) is det.
:- mode std_util:solutions((pred(mercury_builtin:out) is nondet), mercury_builtin:out) is det.
:- pred std_util:solutions_set((pred T), (set:set(T))).
:- mode std_util:solutions_set((pred(mercury_builtin:out) is multi), mercury_builtin:out) is det.
:- mode std_util:solutions_set((pred(mercury_builtin:out) is nondet), mercury_builtin:out) is det.
:- pred std_util:unsorted_solutions((pred T), (mercury_builtin:list(T))).
:- mode std_util:unsorted_solutions((pred(mercury_builtin:out) is multi), mercury_builtin:out) is cc_multi.
:- mode std_util:unsorted_solutions((pred(mercury_builtin:out) is nondet), mercury_builtin:out) is cc_multi.
:- pred std_util:maybe_pred(pred(T1, T2), T1, (std_util:maybe(T2))).
:- mode std_util:maybe_pred((pred(mercury_builtin:in, mercury_builtin:out) is semidet), mercury_builtin:in, mercury_builtin:out) is det.
:- pred std_util:semidet_succeed is semidet.
:- pred std_util:semidet_fail is semidet.
:- pred std_util:cc_multi_equal(T, T).
:- mode std_util:cc_multi_equal(mercury_builtin:in, mercury_builtin:out) is cc_multi.
