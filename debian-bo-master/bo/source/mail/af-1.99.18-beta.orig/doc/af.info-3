This is Info file af.info, produced by Makeinfo version 1.67 from the
input file af.texi.

START-INFO-DIR-ENTRY
* Af: (af).                     An advanced mail reader and composer.
END-INFO-DIR-ENTRY

   This file documents Af, an advanced mail reader and composer with a
user interface similar to that of GNU Emacs.

   Copyright (C) 1996 Malc Arnold, Kay Dekker.  Derived in parts from
the GNU Emacs Manual, Eleventh Edition, Copyright (C) 1985, 1986, 1987,
1993, 1994, 1995 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "Distribution" and "GNU General Public
License" are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "Distribution" may be
included in a translation approved by the author instead of in the
original English, and the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: af.info,  Node: Sending Mail,  Next: M-x,  Prev: Minibuffer,  Up: Top

Composing and Sending Mail
**************************

   Af allows you to compose and send mail as well as read it.  There are
several different commands to send mail, each of which sends mail in a
slightly different way.

   Af composes messages in three stages.  First you are prompted for any
details needed for the message, such as the addresses to send it to.
Then af starts an editor, so that you can edit the message.  Finally,
you are prompted for what to do with the message (its "disposition").

* Menu:

* Sending Commands::	        The different commands to send mail.
* Initial Details::	        The details af may ask for when sending mail.
* Editing Mail::                Details of editing your mail message.
* Final Disposition::           Your options after editing the message.
* Composition Variables::       Variables which affect composing messages.
* Aliases::                     Convenient abbreviations for addresses.


File: af.info,  Node: Sending Commands,  Next: Initial Details,  Up: Sending Mail

Commands for Sending Mail
=========================

   There are five commands for sending mail in af.  These commands are
all similar in use, but conceptually different.

`M-m or M-s'
     Send a message to one or more people.  This allows you to compose
     and send a mail message (`send-mail').

`M-r'
     Reply to the current message.  This lets you compose and send mail
     to whoever the current message is from (`send-reply').

`C-M-r'
     Group reply to the current message.  This lets you compose and
     send mail to whoever the message is from, and all the addresses
     listed in the `To:' header.  Copies are sent to the addresses
     listed in the `Cc:' header (`group-reply-to-message').

`M-f'
     "Forwarding" allows you to compose an annotated copy of the current
     message and send it to one or more people.  (`forward-message').

`M-b'
     "Bouncing" means sending an exact copy of the current message to
     one or more addresses, making it appear that the copy you send
     them is from the person who sent the message to you
     (`bounce-message').  You will not normally edit the text of the
     message.


File: af.info,  Node: Initial Details,  Next: Editing Mail,  Prev: Sending Commands,  Up: Sending Mail

Initial Details for Composing Mail
==================================

   Depending on how you are sending mail, and how you have configured
af, you will be prompted for several things when you begin composing a
mail message.  Normally af will only prompt for `To:' and `Subject:',
but here are all the possible questions:

`To:'
     The addresses you want send the mail to.

`Subject:'
     A brief description of what the message is about.

`Cc:'
     Any mail addresses to send additional copies of the message to.

`Bcc:'
     Any mail addresses to send "blind copies" of the mail to.  These
     addresses will not be listed in the headers of the message when it
     is sent.

`Signature file'
     Which signature file (*note Signatures::.) do you want to include
     at the end of the message.

`Copy message (y/n)'
     If you are replying to a message, you can copy the text of of the
     original message into the initial text of the reply.  This is
     called "quoting".


File: af.info,  Node: Editing Mail,  Next: Final Disposition,  Prev: Initial Details,  Up: Sending Mail

Editing the Mail Message
========================

   When you first edit a message you will normally see either a blank
file or the text of the original message with each line prefixed with
`> '.  You can then use your editor as usual to compose the text of the
message.  When you save the message, your `.signature' file will be
appended to the message, separated by a line containing `--'.

   When you edit a message for the second time (or if you have
configured af to do so), the headers of the message are inserted into
the file you edit, separated by a blank line, and your signature will
be visible at the end of the file.  You can edit the headers with your
editor, and af will process the changes when you exit the editor;
reporting any problems to typeout.  You can create headers by adding
them into the header section of the file, or delete them by deleting
them from the file.

   You should be very careful when editing a message's headers.  If you
accidentally insert a blank line before the headers, then af will not
find them when you exit the editor, and will therefore think that you
have deleted them all.  This can normally be fixed by editing the file
again, and removing the offending text from the start of the file.


File: af.info,  Node: Final Disposition,  Next: Composition Variables,  Prev: Editing Mail,  Up: Sending Mail

Options After Editing the Message
=================================

   When you finish editing a message and exit the editor, af will
display a summary of the message's headers and prompt you with

     Send, Edit, Check spelling, List or Forget?

   It is a *very* good idea to check the headers that af displays, to
make sure that you are sending the message to the people you think you
are, that the subject is appropriate, and so on.  Your options at this
point are:

`Send'
     Confirm the message, and give it to the system for delivery.

`Edit'
     Edit the message again, this time inserting the headers and any
     signature into the text for you to edit.

`Check spelling'
     Run an interactive spelling checker on the body of the message
     (but not the headers).  This option may not be available on
     systems where there isn't an interactive spelling checker
     installed.

`List'
     List the message to typeout, exactly as it will be given to the
     system for delivery.  This can be useful for checking a message,
     as it is much quicker than starting up an editor.

`Forget'
     Cancel the message and exit mail composition.  There is no way to
     recover a message that you have "forgotten".


File: af.info,  Node: Composition Variables,  Next: Aliases,  Prev: Final Disposition,  Up: Sending Mail

Variables Related to Composing Mail
===================================

   There are a number of configuration variables related to composing
and sending mail.  Here is a summary of each variable and its effects:

`addresses-to-ignore'
     Contains mail addresses which are to be ignored in group replies,
     typically your mail addresses on this and other machines.  Default
     is unset.

`ask-bcc'
     If set to `true', then af will prompt for addresses to send blind
     copies to whenever you send mail.  Default is `false'.

`ask-cc'
     If set to `true', then af will prompt for addresses to send copies
     to whenever you send mail.  Default is `false'.

`auto-fold-headers'
     If set to `false', then af will not automagically fold long header
     lines onto several lines.  Default is `true'.

`copy-on-reply'
     If set to `false', af will never quote the text of the original
     message in the initial text of a reply.  If set to `true' af will
     always quote the original message.  If set to `ask' then you will
     be asked each time you reply to a message.  Defaults to `ask'.

`copy-preface'
     If set, the value is inserted before any text copied into the body
     of a replying or forwarding message.  Any conversion characters in
     the value are expanded to their full value.  A good value for this
     variable might be `On %D, %o wrote:'.  Default is unset.

`copy-prefix'
     The prefix for lines of text copied into an outgoing message when
     replying or forwarding a message.  Defaults to `> '.

`edit-initial-headers'
     It set to `true', headers will be placed into the file to edit the
     first time you edit a message.  When set to `accept', headers will
     not be displayed for editing, but any valid headers typed at the
     start of the message will be accepted.  Defaults to `false'.

`edit-initial-signature'
     When set to `true', any signature will be placed into the editor
     the first time you edit a message.  Defaults to `false'.

`edit-reply-address'
     When set to `true', allows editing of the destination address when
     replying to mail.  It is intended for use by people at sites with
     inadequate mail configurations.  Defaults to `false'.

`editor'
     The program to use to edit messages.  Defaults to the value of the
     `VISUAL' or `EDITOR' environment variable.

`headers-to-copy'
     A colon separated list of header names which should be included in
     text copied into an outgoing message when replying to or forwarding
     a message.  Default is unset (no headers are copied).

`multiple-reply-warning'
     If set to `true', then af will prompt for confirmation if you try
     to reply to a message that you have already replied to.  Defaults
     to `false'.

`organization'
     If set, the the value is inserted into an `Organization:' header
     in the outgoing message.  Defaults to the value of the
     `ORGANIZATION' environment variable.

`outbound-folder'
     Gives the name of a folder in which to store a copy of all messages
     sent with af.  The messages are stored with headers (except for a
     `Message-ID:') in the named folder, immediately after being sent.
     Default is unset (don't save messages).

`outbound-threshold'
     Gives the maximum number of lines in a message body which should be
     silently saved to the `outbound-folder'.  Af will prompt for
     confirmation that a message longer than this limit is to be saved.
     If set to 0 then all outbound messages will be saved regardless
     of length.  Default is 100 lines.

`preserve-cc-in-group-reply'
     If set to `true', any `Cc:' header on a message is duplicated in
     an outgoing group-reply to that message, so that recipients of a
     carbon-copy will also receive the reply.  Default is `true'.

`real-name'
     Your real name, for inclusion in `From:' headers.  Defaults to the
     value of the `NAME' environment variable, or your details stored in
     the file `/etc/passwd'.

`reply-address'
     Contains a mail address which forms a `Reply-To:' header in all
     messages you send, so that replies to those messages will be sent
     to the address you specify.  Default is unset.

`signature-file'
     The name of your signature file.  If the value begins with `ask:',
     then you will be prompted for the signature file to use, with any
     value after the `ask:' being used as a default.  Defaults to
     `.signature' in your home directory.

`signature-separator'
     A string which will be printed on a line between the body of an
     outgoing message and any automatically-included signature.  If not
     set, then no separator line is printed.  Defaults to `--'.

`spell-checker'
     The program to use to interactively spell-check the body of a
     message before you send it.  Defaults to `ispell -x' if `ispell' is
     installed on your system, or unset otherwise.


File: af.info,  Node: Aliases,  Prev: Composition Variables,  Up: Sending Mail

Defining and Using Mail Aliases
===============================

   Af will let you set "mail aliases".  These are short mnemonic names
which stand for mail addresses or groups of mail addresses.  Like many
other mail programs, af expands aliases when they occur in the `To:',
`From:', `Cc:', `Bcc:', and `Reply-to:' headers.

   The easiest way to define a mail alias within af is with `C-x C-a'
(`set-alias').  Af will prompt for the alias and then the real name and
the full address of the alias, defaulted from the From: header of the
current message.  If the alias already exists, af will prompt for
confirmation that you want to change the alias.  (1)

   `C-x C-a' sets the alias internally; but it also writes the alias to
the file `.afalias' in your home directory.  This file is read whenever
af starts up, so your aliases will be available next time you run af.
You can also edit your `.afalias' file directly; each line should
either be blank, be a comment beginning with `;', or look like:

     ALIAS:REAL NAME:ADDRESSES

ALIAS is the name of the alias; REAL NAME is the real name of the
person or group the alias represents, and ADDRESSES stands for one or
more mail addresses for ALIAS to expand into.  Separate multiple
addresses with spaces or (preferably) commas.  You can make an address
list span more than one line by starting the second and subsequent
lines with a space or tab, in the same way as mail headers are split
over several lines of text.

   For instance, to make `afbugs' stand for `af-bug@csv.warwick.ac.uk'
put in the these lines:

     ; Set up the af-bug mailing list as an alias
     afbug:Af Bug Mailing List:af-bug@csv.warwick.ac.uk

   Af expands aliases as soon as you finish editing the mail file, so
you can check that the alias expanded properly by looking at the list of
headers that af shows you when it prompts for the disposition of the
mail.

   ---------- Footnotes ----------

   (1)  If you edit your `.afalias' file, you will find that the old
version of the alias will be commented out rather than deleted when you
change it.  This can be useful if you accidentally overwrite an
important alias.


File: af.info,  Node: M-x,  Next: Help,  Prev: Sending Mail,  Up: Top

Running Commands by Name
************************

   The af commands that are used often or that must be quick to type are
bound to keys--short sequences of characters--for convenient use.
Other af commands that do not need to be brief are not bound to keys; to
run them, you must refer to them by name.

   A command name is, by convention, made up of one or more words,
separated by hyphens; for example, `af-version' or `list-commands'.
The use of English words makes the command name easier to remember than
a key made up of obscure characters, even though it is more characters
to type.

   The way to run a command by name is to start with `M-x', type the
command name, and finish it with <RET>.  `M-x' uses the minibuffer to
read the command name.  <RET> exits the minibuffer and runs the
command.  The string `M-x' appears at the beginning of the minibuffer
as a "prompt" to remind you to enter the name of a command to be run.
*Note Minibuffer::, for full information on the features of the
minibuffer.

   Note that `next-line' is the same command that you invoke with the
key `C-n'.  You can run any af command by name using `M-x', whether or
not any keys are bound to it.

   If you type `C-g' while the command name is being read, you cancel
the `M-x' command and get out of the minibuffer, ending up at top level.

   To pass a numeric argument to the command you are invoking with
`M-x', specify the numeric argument before the `M-x'.  `M-x' passes the
argument along to the command it runs.  The argument value appears in
the prompt while the command name is being read.

   Normally, when describing a command that is run by name, we omit the
<RET> that is needed to terminate the name.  Thus we might speak of
`M-x af-version' rather than `M-x af-version <RET>'.  We mention the
<RET> only when there is a need to emphasise its presence, such as when
we show the command together with following arguments.

   `M-x' works by running the command `execute-extended-command', which
is responsible for reading the name of another command and invoking it.


File: af.info,  Node: Help,  Next: Handling Messages,  Prev: M-x,  Up: Top

Help
****

   Af provides extensive help features accessible through the command
`C-h' (`help-command').  `C-h' is a prefix key that is used only for
documentation-printing commands.  The characters that you can type
after `C-h' are called "help options".  One help option is <C-h>; that
is how you ask for help about using `C-h'.  To cancel, type `C-g'.

   `C-h C-h' displays a list of the possible help options.  Typing
`C-h' again displays a longer list of the options, each with a brief
description.

* Menu:

* Key Help::		Asking what a key does in af.
* Name Help::		Asking about a things via their names.
* List Help::           Asking for lists of things.
* Apropos::		Asking what pertains to a given topic.
* Misc Help::		Other help commands.


File: af.info,  Node: Key Help,  Next: Name Help,  Up: Help

Documentation for a Key
=======================

   The most basic `C-h' options are `C-h c' (`describe-key-briefly')
and `C-h k' (`describe-key').  `C-h c KEY' prints in the echo area the
name of the command that KEY is bound to.  For example, `C-h c C-n'
prints `next-line'.  Since command names are chosen to describe what
the commands do, this is a good way to get a very brief description of
what KEY does.

   `C-h k KEY' is similar but gives more information: it displays the
documentation string of the command as well as its name.  This is too
big for the echo area, so typeout is used for the display.


File: af.info,  Node: Name Help,  Next: List Help,  Prev: Key Help,  Up: Help

Help by Command, Mode or Variable Name
======================================

   `C-h f' (`describe-function') reads the name of an af command,
keyboard macro or afl function using the minibuffer, then displays that
function's documentation string to typeout.  For example,

     C-h f delete-message <RET>

displays the documentation of `delete-message'.  This is the only way
to get the documentation of a command that is not bound to any key (one
which you would normally run using `M-x').

   `C-h v' (`describe-variable') is like `C-h f' but describes
configuration variables instead of commands and functions (*note
Variables::.).

   `C-h m' (`describe-mode') is also like `C-h f' but describes major
and minor modes rather than commands and functions (*note Major
Modes::.).


File: af.info,  Node: List Help,  Next: Apropos,  Prev: Name Help,  Up: Help

Help for Lists of Things
========================

   `C-h b' (`list-bindings') displays the current key bindings active
in af to typeout.  The global bindings are shown first, and then those
for each of the major modes.  This be quite a long list, but might be
useful as a wall chart.

   `C-h d' (`list-commands') lists all of af's commands, with their
bindings, to typeout.  Bindings which only take effect in mail mode are
listed in square brackets (eg `[<M-s>]').  Bindings for typeout mode
only are listed in braces (eg `{<C-f>}').  Bindings that are
minibuffer-specific are listed in parentheses (eg `(<SPC>)').

   `C-h C-f' lists all of the afl functions to typeout.  Only those
functions which are not also commands are listed.  This is quite a
short list at present (*note Afl::.).

   `C-h C-k' `list-kbd-macros' lists all of the named keyboard macros,
with their values, to typeout (*note Keyboard Macros::.).

   `C-h C-v' lists all of the af configuration variables, with their
values, to typeout (*note Variables::.).

   `C-h C-a' (`list-aliases') lists all the mail aliases you have
defined to typeout, along with their values (*note Aliases::.).


File: af.info,  Node: Apropos,  Next: Misc Help,  Prev: List Help,  Up: Help

Apropos
=======

   A more sophisticated sort of question to ask is, "What is relevant
for working with messages?"  To ask this question, type `C-h a message
<RET>', which displays a list of all command, function, keyboard macro
and variable names that contain `message', including `open-message',
`print-message', and so on.  The bindings for each command is listed
with that command, in the same format as list-bindings (*note List
Help::.).  Similarly the values of keyboard macros and variables are
listed.  The `a' in `C-h a' stands for `Apropos'; `C-h a' runs the
command `command-apropos'.

   Because `C-h a' looks only for things whose names contain the string
which you specify, you must use ingenuity in choosing the string.  If
you are looking for commands for reading messages and `C-h a
read-message <RET>' doesn't reveal any, don't give up.  Try just
`read', or just `message'.  Be persistent.  Also note that you can use
a regular expression as the argument, for more flexibility (*note Regex
Syntax::.).

   Here is a set of arguments to give to `C-h a' that covers many
classes of af commands, since there are strong conventions for naming
the standard af commands.  By giving you a feel for the naming
conventions, this set should also serve to aid you in developing a
technique for picking `apropos' strings.

     char, line, word, region, list, buffer, window, file, mode,
     beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, case, set, what,
     view, describe, default, print, page, message, send.


File: af.info,  Node: Misc Help,  Prev: Apropos,  Up: Help

Other Help Commands
===================

   `C-h i' (`info') runs the Info program, which is used for browsing
through structured documentation files.  The entire af manual is
available within Info.  Type `h' after entering Info to run a tutorial
on using Info.

   If something surprising happens, and you are not sure what commands
you typed, use `C-h l' (`view-lossage').  `C-h l' prints the last 100
command characters you typed in.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

   Af has numerous major modes, each of which redefines keys and alters
the behaviour of some commands.  `C-h j' (`describe-major-mode') prints
documentation on the current major mode to typeout.

   The other `C-h' options display assorted useful information.  `C-h
n' (`view-af-news') displays information on recent changes to af.  `C-h
C-w' (`display-no-warranty') displays details on the complete absence
of warranty for af.  `C-h C-c' (`describe-copying') displays the
conditions you must obey in distributing copies of af.


File: af.info,  Node: Handling Messages,  Next: Mark and Region,  Prev: Help,  Up: Top

More Ways to Handle Messages
****************************

   You can use af to handle messages in more sophisticated ways than by
simply displaying them; You can save messages to folders, print a
hardcopy of them, pipe them into commands, and more.

   Most commands that deal with a single message also have similar
commands which deal with a set of messages, selected either by using
the mark and region (*note Mark and Region::.), or with tags (*note
Tags::.).  These similar commands will be covered later.

* Menu:

* Saving Messages::	Saving a message to a folder.
* Printing Messages::	Printing a hardcopy of a message.
* Piping Messages::     Passing messages to a shell command.
* Other Message::       Other message-handling commands.
* Shell Commands::      Executing shell commands from within af.


File: af.info,  Node: Saving Messages,  Next: Printing Messages,  Up: Handling Messages

Saving Messages
===============

   Af allows you to "save" messages by copying them to folders.  One
way to save a message to a folder is to use `M-+' (`save-message').  Af
will prompt you for the folder name, offering a default based on the
sender's mail address (*note Folders::.).  The message will be appended
to the folder you specify, so any messages already in the folder will
be left unchanged.

   When the message is saved to a folder, the original copy is not
deleted.  an `S' will appear in the system tags of the message, so that
you know you have saved it.

   `M-+' can take a numeric argument, in which case it only saves the
body of the message, not the headers.  Obviously the file containing a
saved copy of the message shouldn't be read with af; it isn't a mail
folder.  Saving the body of a message can be useful when the body is
input for some other program (such as a patch file).

   If you save only the body of a MIME message, then af will use the
command listed in the `mime-saver' variable to save the message, to
ensure that the message mode is properly decoded before writing it to
the file.


File: af.info,  Node: Printing Messages,  Next: Piping Messages,  Prev: Saving Messages,  Up: Handling Messages

Printing Messages
=================

   Af allows you to print a hardcopy of a message to a spooler.  The
program to use to print hard copies of mail is defined by the
`print-command' variable for ordinary text messages, or the
`mime-printer' variable for MIME messages.

   To print a hardcopy of a message, use `C-p' (`print-message').  Af
will usually prompt you to confirm that you want a hardcopy of the
message; this feature can be turned off by setting the variable
`confirm-print' to `false'.  After you print the message, a `P' will
appear in the system tags of the message, to remind you that you have
printed it.

   Normally, only mail headers not listed in the
`headers-not-displayed' variable will be printed when you print a
message.  A positive numeric argument makes af print all the message's
headers, while a negative argument makes af skip all headers, and only
print the body of the message.


File: af.info,  Node: Piping Messages,  Next: Other Message,  Prev: Printing Messages,  Up: Handling Messages

Piping Messages
===============

   Af allows you to "pipe" a message into the standard input of a
system command.  To do this use `M-|' (`pipe-message').  Af will prompt
for the command to pipe the message into, and then execute the command.
Any output from the command will be displayed on the screen.  Once the
command has completed, af will wait for you to press a key before
continuing; giving you a chance to read any output from the command.

   Normally, only mail headers not listed in the
`headers-not-displayed' variable will be piped into the command.  A
positive numeric argument makes af pass all the message's headers to the
command.  A negative argument makes af skip all headers, and only pass
the body of the message to the command.


File: af.info,  Node: Other Message,  Next: Shell Commands,  Prev: Piping Messages,  Up: Handling Messages

Other Message-Handling Commands
===============================

   Af is able to process "mail digests"; mail messages which themselves
contain one or more mail messages.  If you receive a mail digest, you
can use `M-x explode-digest' to "explode" the digest back into the
messages it contains.

   The exploded messages are placed after the digest in the buffer.  The
mark is set on the first exploded message, and point lies after the
last; making it convenient to handle them after exploding the digest.

   Af will allow you to edit a message in a folder with `C-x C-e'
(`edit-message').  Af will save the message to a temporary file and
execute an editor to edit the file.  When you finish editing, af will
read back the temporary file, and update its internal copy of the
message.  When you save the buffer, the modified message will be written
to the folder.

   With an argument, `C-x C-e' will only pass the body of the message to
the editor.


File: af.info,  Node: Shell Commands,  Prev: Other Message,  Up: Handling Messages

Running Shell Commands from Af
==============================

   Af has commands for running inferior shell processes, displaying the
result to typeout or letting the inferior process take control of the
terminal.

`M-! CMD <RET>'
     Run the shell command line CMD and display the output to typeout
     (`shell-command-to-typeout').

`C-x ! CMD <RET>'
     Start an inferior shell to run the command line CMD.  The inferior
     shell will take control of the terminal until it exits.
     (`shell-command')

`M-x shell'
     Run an inferior shell interactively under af.  The inferior shell
     will take control of the terminal until it exits (`shell').


File: af.info,  Node: Mark and Region,  Next: Tags,  Prev: Handling Messages,  Up: Top

The Mark and the Region
***********************

   Many af commands operate on an arbitrary contiguous part of the
current buffer.  To specify the text for such a command to operate on,
you set "the mark" at one end of it, and move point to the other end.
The text between point and the mark is called "the region".

   You can move point or the mark to adjust the boundaries of the
region.  It doesn't matter which one is set first chronologically, or
which one comes earlier in the buffer.  Once the mark has been set, it
remains where you put it until you set it again at another place.  Each
af buffer has its own mark, so that when you return to a buffer that had
been selected previously, it has the same mark it had before.

   Many commands that insert messages (or text in the minibuffer), such
as `C-y' (`yank') and `C-x i' (`insert-file'), position point and the
mark at opposite ends of the inserted text, so that the region contains
the text just inserted.

* Menu:

* Setting the Mark::	Commands to set the mark.
* Using the Region::	Ways you can operate on the region.
* Typeout Region::      Things you can do with the region in typeout.
* Minibuffer Region::   Region operations in the minibuffer.


File: af.info,  Node: Setting the Mark,  Next: Using the Region,  Up: Mark and Region

Setting the Mark
================

   There are two commands to set the mark in a buffer.  These commands
work identically in mail buffers, typeout, and the minibuffer.

`C-<SPC> or C-@ or M-<SPC>'
     Set the mark where point is (`set-mark-command').

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

   For example, suppose you wish to save part of a mail buffer to a
folder, using the `C-x +' (`save-region') command, which operates on
the messages in the region.  You can first go to the beginning of the
messages to be saved, type `C-<SPC>' to put the mark there, move to the
end, and then type `C-x +'.  Or, you can set the mark at the end of the
text, move to the beginning, and then type `C-x +'.

   The most common way to set the mark is with the `C-<SPC>' command
(`set-mark-command').  This sets the mark where point is.  Then you can
move point away, leaving the mark behind.

   Af doesn't show you where the mark is located.  You have to remember.
The usual solution to this problem is to set the mark and then use it
soon, before you forget where it is.  Alternatively, you can see where
the mark is with the command `C-x C-x' (`exchange-point-and-mark')
which puts the mark where point was and point where the mark was.  The
extent of the region is unchanged, but point is now at the previous
position of the mark.

   `C-x C-x' is also useful when you are satisfied with the position of
point but want to move the mark; do `C-x C-x' to put point at that end
of the region, and then move it.  A second use of `C-x C-x', if
necessary, puts the mark at the new position with point back at its
original position.

   There is no such character as `C-<SPC>' in ASCII; when you type
<SPC> while holding down <CTRL>, what you get on most ordinary
terminals is the character `C-@'.  This key is actually bound to
`set-mark-command'.  But unless you are unlucky enough to have a
terminal where typing `C-<SPC>' does not produce `C-@', you might as
well think of this character as `C-<SPC>'.  If you are on a terminal
where `C-<SPC>' doesn't work, you could use `M-<SPC>' instead; it is
also bound to `set-mark-command'.


File: af.info,  Node: Using the Region,  Next: Typeout Region,  Prev: Setting the Mark,  Up: Mark and Region

Operating on the Region
=======================

   Once you have a region in a mail buffer, here are some of the
commands that operate on the region.  Note that these commands all have
the word `region' in their names.

`C-w'
     Kill the messages in the region (`kill-region').  *Note Killing
     and Yanking::.

`M-w'
     Copy the region into the kill buffer as if it had been killed
     (`copy-region-as-kill'). *Note Killing and Yanking::.

`C-x + FOLDER <RET>'
     Save the messages in the region into FOLDER (`save-region').  This
     command handles the argument in the same way as `M-+'
     (`save-message'). *Note Saving Messages::.

`C-x p'
     Print a hardcopy of all the messages in the region
     (`print-region').  This command handles the argument in the same
     way as `M-p' (`print-message'). *Note Printing Messages::.

`C-x | COMMAND <RET>'
     Pipe the messages in the region into a single instance of the shell
     command COMMAND (`pipe-region').  Again, this command handles the
     argument in the same way as `M-|' (`pipe-message') *Note Piping
     Messages::.


File: af.info,  Node: Typeout Region,  Next: Minibuffer Region,  Prev: Using the Region,  Up: Mark and Region

Using the Region in Typeout
===========================

   Typeout is only used to display text, and not to edit or delete
anything.  For that reason, there are no commands which operate on the
region available in typeout.  It is still possible to set the mark in
the typeout buffer; but the only thing you can do with it is to use
`C-x C-x' (`exchange-point-and-mark') to move back to the mark.


File: af.info,  Node: Minibuffer Region,  Prev: Typeout Region,  Up: Mark and Region

Using the Region in the Minibuffer
==================================

   The minibuffer supports the mark and region, but only a subset of the
commands which are available in a mail buffer to process the region.
Since the minibuffer deals with text rather than messages, the region
delimits a block of text in the minibuffer.

   Just like any other buffer, the minibuffer has its own mark.  The
mark is not preserved between uses of the minibuffer, or when you move
between minibuffer history entries, so you will usually need to set the
mark in the minibuffer before you use it.

   There are two commands which operate on the region in the minibuffer:

`C-w'
     Delete the text in the region (`kill-region').  *Note Minibuffer
     Kills::.

`M-w'
     Copy the text in the region into the kill buffer as if it had been
     killed (`copy-region-as-kill').  *Note Minibuffer Kills::.


File: af.info,  Node: Tags,  Next: Killing and Yanking,  Prev: Mark and Region,  Up: Top

Tags
****

   The region allows you to conveniently process blocks of messages, but
what if you want to handle an arbitrary set of messages?  Af uses tags
to let you mark a set of messages and process them quickly.

   Tags are only available in mail buffers; they wouldn't make any sense
in the minibuffer or the mail buffer.

* Menu:

* Tag Concepts::        An introduction to af's tags.
* Setting Tags::        How to set and remove tags.
* Using Tags::          How you can process tagged messages.


File: af.info,  Node: Tag Concepts,  Next: Setting Tags,  Up: Tags

Tag Concepts
============

   A "tag" is a single-character mark which is set on a message.  A
message can have any number of tags set on it.  There are two types of
tags: "system tags" which are automatically set by af for various
reasons, and "user tags" which you can set and unset yourself.  You
cannot set or remove system tags, but you can use them in exactly the
same ways as you can user tags.

   There are many commands which operate on tagged messages; and you can
use either single tags or a combination of them to specify a set of
messages to operate on.  Tags are central to advanced use of af; they
provide a way for you to easily set up a set of messages, which you can
then work with in several ways.

* Menu:

* System Tags::         Tags which reflect a message's status.
* User Tags::           Tags which you can set and unset yourself.
* Tag Lists::           Format of lists of tags to (un)set.
* Tag Expressions::     Expressions you can use to select messages.


File: af.info,  Node: System Tags,  Next: User Tags,  Up: Tag Concepts

System Tags
-----------

   The system tags are all upper-case letters, which give information on
the status of messages.  The possible system tags are:

`D'
     The message has been marked for deletion with `M-x delete-message'.

`E'
     Af found an error in the message's headers when the folder was
     visited.  This is not normally critical, but you may not be able
     to reply to the message; or it may even (rarely) indicate a
     corrupted folder.

`F'
     You have forwarded or bounced the message (*note Sending Mail::.).

`M'
     The message is in MIME format; and isn't plain text that you can
     display on your terminal.  When you read the message the command
     given in the `mime-pager' variable will be used to display it.
     The exact meaning of this tag may change as af's MIME support
     improves.

`N'
     The message is new; the message has arrived since last time you
     visited the folder and hasn't yet been read.

`O'
     The message is old but unread.  The message was present last time
     you visited the folder, but you haven't read it yet.

`P'
     A hardcopy of the message has been printed to a spooler.

`R'
     You have replied to the message (*note Sending Mail::.).

`S'
     The message has been saved to a folder.


File: af.info,  Node: User Tags,  Next: Tag Lists,  Prev: System Tags,  Up: Tag Concepts

User Tags
---------

   The user tags you can use are the lower case letters, and `+'.  `+'
is sometimes called the "default tag", since it is the default whenever
you are asked about tags.

   Normally, the user tags are considered transient, and are lost when
you exit af.  If you would like to keep some or all of the tags across
mail reading sessions, then you can set the variable `persistent-tags'
to the tags you would like to be preserved.  For example, setting the
value of `persistent-tags' to `aeiou', would mean that the user tags
`a', `e', `i', `o', and `u' will be preserved whenever you save a
folder, but the other tags will be lost.  You cannot make the default
tag (`+') persistent.


File: af.info,  Node: Tag Lists,  Next: Tag Expressions,  Prev: User Tags,  Up: Tag Concepts

Tag Lists
---------

   Whenever you are setting or removing tags, af will expect you to
enter a "tag list".  Tag lists consist of one or more user tags, which
may be separated by spaces.  For example, `abcd' and `a b c d', both
specify a list of four tags, `a', `b', `c', and `d'.

   Whenever you are prompted for a tag list, you can just hit return to
use the default tag (`+').


File: af.info,  Node: Tag Expressions,  Prev: Tag Lists,  Up: Tag Concepts

Tag Expressions
---------------

   When you are using tags to define a set of messages to apply some
command to, you will be expected to enter a "tag expression".  That tag
expression is then compared to the tags of each message in the buffer,
and the command will operate on the message if the expression is true
for that message.  We often refer to the messages which match a tag
expression as the "tagset".

   Tag expressions are made up of sub-expressions, which may be system
or user tags.  You can use operators to combine subexpressions, and
build arbitrarily complex expressions.  Any tag will evaluate to true
if the message being checked has that tag set, false otherwise.  The
possible operators are, in decreasing precedence:

`( ... )'
     Override any precedence, and force the contents of the parentheses
     to be evaluated as a unit.  `(a)' is equivalent to `a'.

`!'
     Logical not; true if the expression it precedes is false.  `!a' is
     true if `a' is not set.

`&'
     Logical and; true if both sides of the expression are true. `a & b'
     is true if both `a' and `b' are set.

`^'
     Logical exclusive-or; true if only one side of the expression is
     true.  `a ^ b' is true if either `a' or `b' is set, but not both.

`|'
     Logical or; true if either side of the expression is true.  `a | b'
     is true if either `a' or `b' is set, or if both are set.

   Here are some examples of tag expressions, with their meanings.

     a & b | c & d

True if `a' and `b' are both set, or `c' and `d' are both set.

     a & (b | c) & d

True if `a', `d', and either `b' or `c' are set.

     a & !b

True if `a' is set and `b' is not set.

     a & !(b | c)

True if `a' is set and neither of `b' or `c' are set.


File: af.info,  Node: Setting Tags,  Next: Using Tags,  Prev: Tag Concepts,  Up: Tags

Setting and Removing Tags
=========================

`C-t t TAGS <RET>'
     Set TAGS on the current message (`tag-message').

`C-t u TAGS <RET>'
     Remove TAGS from the current message (`untag-message').

`C-t r TAGS <RET>'
     Remove TAGS from all the messages in the buffer (`remove-tag').

`M-x tag-thread TAGS <RET>'
   To tag the current message, use `C-t t'.  You will be prompted for
the tags to set; simply type in the tag list to set.  The tags in the
list will be added to those already set on the message.

   To remove one or more tags from the current message use `C-t u'.
You will be prompted for the tags to remove.  The tags you specify will
be removed from the message's tags.

   To remove one or more tags from all the messages in the buffer, use
`C-t r'.  You will be prompted for the tags to remove.  The tags you
specify will be removed from all the messages in the buffer.

   The experimental command `M-x tag-thread TAGS <RET>' tags all the
messages in a "thread" of conversation, a set of messages which are all
sent as replies to other related messages.  (This is similar to the
concept of threading found in most news readers.)  This command works,
but at the moment there are too many mail composers which don't include
references to messages when they generate a reply, so that the threads
are often broken by replies which af can't detect as a part of the
thread.  It is probably best not to use this command for the moment,
unless you can be sure that all the participants are using a mail
composer that does include references to messages in replies.

   There is also a command to set tags on messages which match search
criteria.  *Note Search and Tag::.


File: af.info,  Node: Using Tags,  Prev: Setting Tags,  Up: Tags

Using Tags
==========

   Once you have tagged messages in the region, you can use single tags
or tag expressions to operate on them.  Here are some of the ways in
which you can operate on tagged messages:

`C-t C-k TAG-EXPR <RET>'
     Kill the messages in the tagset defined by TAG-EXPR
     (`kill-tagset').  *Note Killing and Yanking::.

`C-t w TAG-EXPR <RET>'
     Copy the messages in the tagset into the kill buffer as if they
     had been killed (`copy-tagset-as-kill'). *Note Killing and
     Yanking::.

`C-t + TAG-EXPR <RET> FOLDER <RET>'
     Save the messages in the tagset into FOLDER (`save-tagset').  This
     command handles the argument in the same way as `M-+'
     (`save-message'). *Note Saving Messages::.

`C-t p TAG-EXPR <RET>'
     Print a hardcopy of all the messages in the tagset
     (`print-tagset').  This command handles the argument in the same
     way as `M-p' (`print-message'). *Note Printing Messages::.

`C-t | TAG-EXPR <RET> FOLDER <RET>'
     Pipe the messages in the tagset into a single instance of the shell
     command COMMAND (`pipe-tagset').  Again, this command handles the
     argument in the same way as `M-|' (`pipe-message') *Note Piping
     Messages::.


File: af.info,  Node: Killing and Yanking,  Next: Searching,  Prev: Tags,  Up: Top

Killing and Yanking
*******************

   "Killing" means erasing messages (or text in the minibuffer) and
copying them into the "kill ring", from which it can be retrieved by
"yanking" it.  Some systems use the terms "cutting" and "pasting" for
these operations.

   The commonest way of moving or copying messages within af is to kill
them, and later yank them elsewhere one or more times.  This is very
safe because af remembers several recent kills, not just the last one.
It is versatile, because the many commands for killing messages can also
be used for moving them.

   Af has only one kill ring for all mail buffers, so you can kill
messages in one buffer and yank them in another buffer.  The minibuffer
has a separate kill ring for storing text.

   All commands which delete messages from the buffer save it in the
kill ring (even `delete-message' when you save the folder) so that you
can move or copy it to other parts of the buffer.  These commands are
known as "kill" commands.

* Menu:

* Killing::             Details of killing and copying messages.
* Yanking::             How to yank messages you have killed.
* Appending Kills::     Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.
* Minibuffer Kills::    Killing and yanking text in the minibuffer.


File: af.info,  Node: Killing,  Next: Yanking,  Up: Killing and Yanking

Killing Messages
================

   There are two ways to add messages to the kill ring; killing and
copying.  "Killing" means deleting messages and adding them to the kill
ring, while "copying" means copying messages to the kill ring without
deleting them.

   There are commands to kill a single message (*note Deleting
Messages::.), commands to kill or copy the region (*note Using the
Region::.), and commands to kill or copy a tagset (*note Using Tags::.).


File: af.info,  Node: Yanking,  Next: Appending Kills,  Prev: Killing,  Up: Killing and Yanking

Yanking Messages
================

   All killed messages are recorded in the "kill ring", a list of
blocks of messages that have been killed.  There is only one kill ring,
shared by all mail buffers, so you can kill messages in one buffer and
yank them in another buffer.  This is the usual way to move messages
from one folder to another (*Note Saving Messages::, for another way).

   The command `C-y' (`yank') reinserts the most recently killed
messages.  It leaves the cursor at the end of the text.  It sets the
mark at the beginning of the text (*note Mark and Region::.).

   `C-y' can take a numeric argument, in which case it select an
earlier kill to yank, rather than the last (*note Earlier Kills::.).


File: af.info,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Yanking,  Up: Killing and Yanking

Appending Kills
===============

   Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their messages into
a single entry, so that a single `C-y' yanks all the messages as a
unit, just as they were before they were killed.

   Thus, if you want to yank messages as a unit, you need not kill all
of them with one command; you can keep killing line after line, until
you have killed them all, and you can still get them all back at once.

   Commands that kill forward from point add the messages onto the end
of the previous killed messages.  Commands that kill backward from point
add them onto the beginning.  This way, any sequence of mixed forward
and backward kill commands puts all the killed messages into one entry
without rearrangement.  Numeric arguments do not break the sequence of
appending kills.


File: af.info,  Node: Earlier Kills,  Next: Minibuffer Kills,  Prev: Appending Kills,  Up: Killing and Yanking

Yanking Earlier Kills
=====================

   To recover killed messages that are no longer the most recent kill,
use the `M-y' command (`yank-pop').  It takes the messages previously
yanked and replaces them with the messages from an earlier kill.  So,
to recover the messages of the next-to-the-last kill, first use `C-y'
to yank the last kill, and then use `M-y' to replace it with the
previous kill.  `M-y' is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
moves it to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the messages you are looking for are brought into the buffer,
you can stop doing `M-y' commands and it will stay there.  They are a
copy of the kill ring entry, so altering them in the buffer does not
change what's in the ring.  As long as no new killing is done, the
"last yank" pointer remains at the same place in the kill ring, so
repeating `C-y' will yank another copy of the same previous kill.

   If you know how many `M-y' commands it would take to find the
messages you want, you can yank those messages in one step using `C-y'
with a numeric argument.  `C-y' with an argument restores the text the
specified number of entries back in the kill ring.  Thus, `C-u 2 C-y'
gets the next to the last block of killed messages.  It is equivalent
to `C-y M-y'.  `C-y' with a numeric argument starts counting from the
"last yank" pointer, and sets the "last yank" pointer to the entry that
it yanks.

   The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed messages are
saved.

