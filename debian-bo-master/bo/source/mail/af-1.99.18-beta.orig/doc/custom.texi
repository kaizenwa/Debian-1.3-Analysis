@c This is part of the af manual.
@c Copyright (C) 1996, 1997 Malc Arnold, Emma Kemm, Kay Dekker.
@c Derived in parts from the GNU Emacs Manual, Eleventh Edition,
@c Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995 Free Software Foundation, Inc.
@c See file af.texi for copying conditions.

@node Customisation, Startup Files, Windows, Top
@chapter Customisation
@cindex customisation

This chapter talks about various topics relevant to adapting the
behavior of af in minor ways.  All kinds of customisation affect only
the particular af session that you do them in.  They are completely lost
when you kill af, and have no effect on other af sessions you may run
later.  The only way an af session can affect anything outside of it is
by writing a file; in particular, the only way to make a customisation
`permanent' is to put something in your @file{.afrc} file to do the
customisation in each session.  (@pxref{Startup Files}).

You can easily customise af in several different ways:

@table @asis
@item Setting Variables
Af has many @dfn{configuration variables}, which you can set to alter
the behaviour of certain commands.  (@pxref{Variables}).
@item Keyboard Macros
Keyboard macros allow you to combine af commands to create new ones.
Keyboard macros are not very powerful, but they are a very simple way to
add new commands to af.
@item Binding Keys
You can change which commands are bound to which keys, so you can change
the effect of a keypress.
@item Afl
You will also eventually be able to write powerful functions in af's
extension language afl.  This is not yet supported.
@end table

@node Startup Files, Emulation, Customisation, Top
@section The Startup File, @file{~/.afrc}
@cindex @file{.afrc}
@cindex af startup file
@cindex key rebinding, permanent
@cindex rebinding keys, permanently
@cindex startup file

When af is started, it normally loads an afl program from the file
@file{.afrc} in your home directory.  We call this file your
@dfn{Startup file} because it is read when you start af.  You can use
the command line switches @samp{-n} and @samp{-l} to tell af whether
to load a startup file, and which one (@pxref{Entering Af}).

Your site may also have a @dfn{global startup file}; this is named
@file{afrc.afl}, if it exists.  The af distribution contains no such
library; your site may create one for local customisations.  If this
library exists, it is loaded whenever you start af; and then your own
startup file, if any, is loaded.

@findex write-configuration
By far the simplest way to create a startup file is for af to write one
for you.  The command @kbd{M-x write-configuration} will prompt you for
a file name (defaulting to @file{~/.afrc}), and then write an afl
program into that file.  When you run that program (by loading the
file), it will recreate any changed variables or key bindings, or any
new keymaps or named keyboard macros that were in existence when you
ran @kbd{M-x write-configuration}.

You can use @kbd{M-x write-configuration} to create a startup file, and
then modify that file with an editor; it is a text file.  This is also
a good way to become familiar with afl.

@node Emulation, Variables, Startup Files, Top
@section Emulation
@cindex emulating other mail readers
@cindex other mail readers

Af can be programmed to emulate (more or less) several other mail
readers.  The commands to do this are stored in several afl libraries
(@pxref{Afl}).  Note that the only way to turn an emulation off once
you've loaded it is to exit af and start again.

The emulations aren't in any way intended to be true emulations of the
mail readers.  The intent is to let people who are already used to some
other mail reader get started with af quickly, by making most of the
common keys do what they expect.

To set up af to work like another mail reader there must be an emulation
library for the mail reader.  To load the library for (as an example)
@code{elm}, type type @kbd{M-x load-library @key{RET} elm @key{RET}}.

The available emulations are:

@table @code
@item elm
Reconfigures af to do a fairly close emulation of @code{elm}.
@item mush
Not a perfect emulation by any means, but enough to get people used
to @code{mush} started.
@item pine
A close enough emulation to satisfy advanced @sc{pine} users.  Doesn't
hold your hand @strong{nearly} enough for many of @sc{pine}'s target
users.
@item ream
Not too far from the target, anyone who's used to using @code{ream} will
probably find this emulation helpful.
@item vm
Silly though it seems, the @code{@sc{vm}} emulator is quite different
from af's normal personality.  If you've been using the @code{@sc{vm}}
package under Emacs to read mail, then this library may help.
@end table

@node Variables, Keyboard Macros, Emulation, Top
@section Variables
@cindex variables
@cindex configuration variables

Af presents two interfaces to its variables:  The underlying system
which is used by Afl (@pxref{Afl}), or a simpler system which af uses
to allow users to handle configuration variables.

A @dfn{variable} is a symbol which has a value.  The symbol's name is
also called the name of the variable.  Variable names usually consist of
words separated by hyphens.  Af's configuration variables can each hold
a specified kind of value.  Sometimes this is a simple type such as a
number, or a string, but sometimes a variable will require a more
complex value, such as the formats for the screen display.

To examine the value of a single configuration variable, use @kbd{C-h v}
(@code{describe-variable}), which reads a variable name using the
minibuffer, with completion.  It displays both the value of and the
documentation for the variable.  If you want to see the values of all
the configuration variables, then use @kbd{C-h C-v}
(@code{list-variables}), which lists all the configuration variables and
their values to typeout.

@kindex C-x a
@findex set-variable
The most convenient way to set a specific variable is with @kbd{C-x a}
(@code{set-variable}).  This reads the variable name with the minibuffer
(with completion), and then reads a new value using the minibuffer a
second time.  For example,

@example
C-x a ask-cc @key{RET} true @key{RET}
@end example

@noindent
sets @code{ask-cc} to true.

Whenever you use @kbd{C-x a}, the value of the variable will be checked
when you enter it.  You can't break af by changing variables, although
you can make it behave very strangely if you set some variables to odd
values.

When a variable's description says that it contains a list of items,
then @kbd{C-x a} will expect the items in the list to be separated by
colons.  If you set the variable by afl of course, then you would use
a list object as the value (@pxref{Afl}).  For example

@example
C-x a viewable-charsets @key{RET} us-ascii:iso-8859-1 @key{RET}
@end example

@noindent
set the value of @code{viewable-charsets} to the list containing
@samp{us-ascii} and @samp{iso-8859-1}.

It is usually worth using @kbd{C-h v} (@code{describe-variable}) to
check the on-line help for a variable you intend to change; often the
description is far more detailed than is given in this manual.

@node Keyboard Macros, Key Bindings, Variables, Top
@section Keyboard Macros

@cindex defining keyboard macros
@cindex keyboard macro
A @dfn{keyboard macro} is a command defined by the user to stand for
another sequence of keys.  For example, if you discover that you are
about to type @kbd{C-t t a RET C-n} forty times, you can speed your work
by defining a keyboard macro to do @kbd{C-t t a RET C-n} and calling it
with a repeat count of forty.

@table @kbd
@item C-x (
Start defining a keyboard macro (@code{start-kbd-macro}).
@item C-x )
End the definition of a keyboard macro (@code{end-kbd-macro}).
@item C-x e
Execute the most recent keyboard macro (@code{call-last-kbd-macro}).
@item C-u C-x (
Re-execute last keyboard macro, then add more keys to its definition.
@item C-x q
When this point is reached during macro execution, ask for confirmation
(@code{kbd-macro-query}).
@item M-x name-last-kbd-macro
Give a command name (for the duration of the session) to the most
recently defined keyboard macro.
@end table

Keyboard macros differ from ordinary af commands in that they are
written in the af command language rather than in C or afl.  This makes
it easier for the novice to write them, and makes them more convenient
as temporary hacks.  However, the af command language is not powerful
enough as a programming language to be useful for writing anything
intelligent or general (Neither is afl yet, but that will change).

You define a keyboard macro while executing the commands which are the
definition.  Put differently, as you define a keyboard macro, the
definition is being executed for the first time.  This way, you can see
what the effects of your commands are, so that you don't have to figure
them out in your head.  When you are finished, the keyboard macro is
defined and also has been, in effect, executed once.  You can then do
the whole thing over again by invoking the macro.

@menu
* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Keyboard macros that do different things each use.
@end menu

@node Basic Kbd Macro
@subsection Basic Use

@kindex C-x (
@kindex C-x )
@kindex C-x e
@findex start-kbd-macro
@findex end-kbd-macro
@findex call-last-kbd-macro
To start defining a keyboard macro, type the @kbd{C-x (} command
(@code{start-kbd-macro}).  From then on, your keys continue to be
executed, but also become part of the definition of the macro.
@samp{Def} appears in the mode line to remind you of what is going on.
When you are finished, the @kbd{C-x )} command (@code{end-kbd-macro})
terminates the definition (without becoming part of it!).  For example,

@example
C-x ( M-+ +foobar RET C-n C-x )
@end example

@noindent
defines a macro to save the current message to the folder @file{+foobar},
and then move down a line.

The macro thus defined can be invoked again with the @kbd{C-x e} command
(@code{call-last-kbd-macro}), which may be given a repeat count as a
numeric argument to execute the macro many times.  @kbd{C-x )} can also
be given a repeat count as an argument, in which case it repeats the
macro that many times right after defining it, but defining the macro
counts as the first repetition (since it is executed as you define it).
Therefore, giving @kbd{C-x )} an argument of 4 executes the macro
immediately 3 additional times.  An argument of zero to @kbd{C-x e} or
@kbd{C-x )} means repeat the macro indefinitely (until it gets an error
or you type @kbd{C-g}).

If you wish to repeat an operation at regularly spaced places in the
text, define a macro and include as part of the macro the commands to
move to the next place you want to use it.  For example, if you want to
change each line, you should position point at the start of a line, and
define a macro to change that line and leave point at the start of the
next line.  Then repeating the macro will operate on successive lines.

After you have terminated the definition of a keyboard macro, you can
add to the end of its definition by typing @kbd{C-u C-x (}.  This is
equivalent to plain @kbd{C-x (} followed by retyping the whole
definition so far.  As a consequence it re-executes the macro as
previously defined.

@node Save Kbd Macro
@subsection Naming Keyboard Macros

@cindex saving keyboard macros
@findex name-last-kbd-macro
If you wish to save a keyboard macro for longer than until you define
the next one, you must give it a name using @kbd{M-x name-last-kbd-macro}.
This reads a name as an argument using the minibuffer and defines that
name to execute the macro.  Defining the macro in this way makes it a
valid command name for calling with @kbd{M-x} or for binding a key to
with @code{global-set-key} (@pxref{Keymaps}).  If you specify a name
that has a prior definition other than another keyboard macro, an error
message is printed and nothing is changed.

@node Kbd Macro Query
@subsection Executing Macros with Variations

@kindex C-x q
@findex kbd-macro-query
Using @kbd{C-x q} (@code{kbd-macro-query}), you can make a macro ask
you each time around whether to make a change.  While defining the
macro, type @kbd{C-x q} at the point where you want the query to occur.
During macro definition, the @kbd{C-x q} does nothing, but when you run
the macro later, @kbd{C-x q} asks you interactively whether to continue.

The valid responses are @kbd{@key{SPC}} to continue, and @kbd{@key{RET}}
to skip the rest of this repetition of the macro and start right away
with the next repetition.  @kbd{@key{ESC}} means to skip the rest of
this repetition and cancel further repetitions.  @kbd{C-l} redraws the
screen and asks you again for a character to say what to do.

@node Key Bindings, Afl, Keyboard Macros, Top
@section Customising Key Bindings
@cindex key bindings

This section describes @dfn{key bindings} which map keys to commands,
and the @dfn{keymaps} which record key bindings.  It also explains how
to customise key bindings.

@menu
* Keymaps::             An introduction to keymaps.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major modes have their own keymaps.
* Rebinding::           How to redefine one key's meaning.
@end menu

@node Keymaps
@subsection Keymaps
@cindex keymap

The bindings between key sequences and command functions are recorded in
data structures called @dfn{keymaps}.  Af has many of these, each used
on particular occasions.

Recall that a @dfn{key sequence} (@dfn{key}, for short) is a sequence of
key presses that have a meaning as a unit.  A key sequence gets its
meaning from its @dfn{binding}, which says what command it runs.  The
function of keymaps is to record these bindings.

@cindex global keymap
The @dfn{global} keymap is the most important keymap because it is
always in effect.  The global keymap defines keys which are common to
most or all of the major modes.  Each major mode has its own keymap
which overrides the global definitions of some keys.

For example, the key @kbd{C-n} move to the next line because the global
keymap binds it to the command @code{next-line}.  Commands to rebind
keys, such as @kbd{M-x global-set-key}, actually work by storing the new
binding in the proper place in the keymaps.  @xref{Rebinding}.

Meta characters work differently; af translates each Meta character into
a pair of characters starting with @key{ESC}.  When you type the
character @kbd{M-r} in a key sequence, af replaces it with
@kbd{@key{ESC} r}.  A meta key comes in as a single key press, but
becomes two events for purposes of key bindings.  The reason for this is
historical; most older terminals didn't support a meta key.

A keymap records definitions for single characters.  Interpreting a key
sequence of multiple characters involves a chain of keymaps.  The first
keymap gives a definition for the first character; this definition is
another keymap, which is used to look up the second character in the
sequence, and so on.

@findex list-keymaps
You can find out what keymaps are defined in af with the command
@kbd{M-x list-keymaps}.  This lists the keymaps, with the prefix keys
they handle, to typeout.

@node Prefix Keymaps
@subsection Prefix Keymaps

A prefix key such as @kbd{C-x} or @key{ESC} has its own keymap, which
holds the definition for the character that immediately follows that
prefix.

The definition of a prefix key is usually the keymap to use for looking
up the following event.  Thus, the binding of @kbd{C-x} is the keymap
@code{control-x-prefix}, the keymap for @kbd{C-x} commands.  The
definitions of @kbd{C-c}, @kbd{C-t}, @kbd{C-x}, @kbd{C-h} and @key{ESC}
as prefix keys appear in the global map, so these prefix keys are always
available.

@cindex user prefix keymap
The @kbd{C-c} prefix has been assigned as a "user prefix".  By default,
nothing will be bound in the @kbd{C-c} keymap; it is reserved for your
own key bindings.  There is a separate @kbd{C-c} prefix keymap for each
of af's major modes.  @xref{Local Keymaps}.

@node Local Keymaps
@subsection Local Keymaps
@cindex local keymap

So far we have explained the ins and outs of the global map.  Major
modes customise af by providing their own key bindings in
@dfn{local keymaps}.  For example, minibuffer mode overrides the
printable characters to bind them to the command
@code{self-insert-command}, so that the characters insert themselves
into the minibuffer at point.

A local keymap can locally redefine a key as a prefix key by defining it
as a prefix keymap.  If the key is also defined globally as a prefix,
then its local and global definitions (both keymaps) effectively
combine: both of them are used to look up the character that follows the
prefix key.  Thus, if the mode's local keymap defines @kbd{C-x} as
another keymap, and that keymap defines @kbd{C-z} as a command, this
provides a local meaning for @kbd{C-x C-z}.  This does not affect other
sequences that start with @kbd{C-x}; if those sequences don't have their
own local bindings, their global bindings remain in effect.

Another way to think of this is that af handles a multi-event key
sequence by looking in several keymaps, one by one, for a binding of the
whole key sequence.  First it checks the minor mode keymaps for minor
modes that are enabled, then it checks the major mode's keymap, and then
it checks the global keymap.  This is not precisely how key lookup
works, but it's good enough for understanding ordinary circumstances.

Designing af keymaps is made more complicated because several commands
will only work in one or two of the major modes.  You should be careful
using global bindings; local bindings will usually achieve what you
want, and are less confusing to work with.

@node Rebinding
@subsection Changing Key Bindings Interactively
@cindex key rebinding, this session
@cindex rebinding keys, this session
@cindex rebinding keys, this session

The way to redefine an af key is to change its entry in a keymap.
You can change the global keymap, in which case the change is effective in
all major modes (except those that have their own overriding local
definitions for the same key).  Or you can change the current buffer's
local map, which affects all buffers using the same major mode.

@findex global-set-key
@findex global-unset-key
@findex local-set-key
@findex local-unset-key
@findex typeout-set-key
@findex typeout-unset-key
@findex minibuffer-set-key
@findex minibuffer-unset-key
@findex make-keymap
@table @kbd
@item M-x global-set-key @key{RET} @var{key} @var{cmd} @key{RET}
Define @var{key} globally to run @var{cmd}.
@item M-x global-unset-key @key{RET} @var{key}
Make @var{key} undefined in the global map.
@item M-x local-set-key @key{RET} @var{key} @var{cmd} @key{RET}
Define @var{key} locally (in the major mode now in effect) to run
@var{cmd}.
@item M-x local-unset-key @key{RET} @var{key}
Make @var{key} undefined locally (in the major mode now in effect).
@item M-x typeout-set-key @key{RET} @var{key} @var{cmd} @key{RET}
Define @var{key} to run @var{cmd} in the typeout keymap.
@item M-x typeout-unset-key @key{RET} @var{key}
Make @var{key} undefined in the typeout map.
@item M-x minibuffer-set-key @key{RET} @var{key} @var{cmd} @key{RET}
Define @var{key} to run @var{cmd} in the minibuffer keymap.
@item M-x minibuffer-unset-key @key{RET} @var{key}
Make @var{key} undefined in the minibuffer map.
@item M-x make-keymap @key{RET} @var{map} @key{RET}
Create a new keymap @var{map}, which you can then use to add your own
prefix keys.
@end table

For example, suppose you like to execute commands in a subshell, instead
of suspending af and executing commands in your login shell.  Normally,
@kbd{C-z} is bound to the function @code{suspend-af}, but you can change
@kbd{C-z} to invoke a subshell by binding it to @code{shell} as
follows:

@example
M-x global-set-key @key{RET} C-z shell @key{RET}
@end example

@noindent
@code{global-set-key} reads the command name after the key.   After you
press the key, a message like this appears so that you can confirm that
you are binding the key you want:

@example
Set key C-z to command: 
@end example

You can rebind a key that contains more than one character in the same
way.  Af keeps reading the key to rebind until it is a complete key
(that is, not a prefix key).  Thus, if you type @kbd{C-f} for @var{key},
that's the end; the minibuffer is entered immediately to read @var{cmd}.
But if you type @kbd{C-x}, another character is read; if that is
@kbd{4}, another character is read, and so on.  For example,

@example
M-x global-set-key @key{RET} C-x 4 $ scroll-other-window @key{RET}
@end example

@noindent
redefines @kbd{C-x 4 $} to run the command scroll-other-window.

The commands @code{typeout-set-key} and @code{minibuffer-set-key} are
a convenience; they bind keys in the typeout or minibuffer keymaps
rather than the global or local maps.

You can remove the global definition of a key with
@code{global-unset-key}.  This makes the key @dfn{undefined}; if you
type it, af will just beep.  Similarly, @code{local-unset-key} makes a
key undefined in the current major mode keymap, which makes the global
definition (or lack of one) come back into effect in that major mode.

If you have redefined (or undefined) a key and you subsequently wish to
retract the change, undefining the key will not do the job---you need to
redefine the key with its standard definition.  The documentation of
keys in this manual also lists their command names.

If you want to define a new prefix key, you will need to create a new
keymap to handle the prefix key.  To do this, use the command @kbd{M-x
make-keymap}, which will prompt you for the name of the keymap to
create.  If you specify a name that already has a definition an error
message is printed and nothing is changed.

@vindex meta-prefix-char
@vindex quit-char
There are two variables which can be important when you are binding
keys.  The variable @code{meta-prefix-char} names the character which is
used as a prefix when you type a metacharacter at the keyboard.  If you
change the binding of @key{ESC}, then you should change the value of
@code{meta-prefix-char} to reflect this.  Similarly, the variable
@code{quit-char} names the character which is used to quit from confirm
prompts, and similar; so it should probably reflect the usual binding
of @code{keyboard-quit} in the keymaps.

@node Afl, Glossary, Key Bindings, Top
@chapter Afl
@cindex afl
@cindex extension language
@cindex Lisp

Afl is the af @dfn{extension language}, a simple programming language
which allows you to write files containing af commands.  Afl is similar
to the Lisp programming language, so Lisp programmers should find afl
easy to learn.  Afl should be simple enough that it is easy for other
programmers to learn.

Afl is designed for programmers to use, although once a programmer has
written an afl program anyone should be able to use that program.

@menu
* Afl Concepts::        An introduction to afl.
* Data Types::          Data types used in afl.
* Primitives::          The predefined afl functions.
* Running Afl::         How to run an afl program.
* Afl Examples::        Samples of afl code.
@end menu

@node Afl Concepts
@section Basic Afl Concepts
@cindex objects @r{(afl)}
@cindex afl objects
@cindex afl reader
@cindex afl interpreter
@cindex evaluation
@cindex expressions
@cindex forms
@cindex functions
@cindex special forms

Afl programs are made up of one or more afl @dfn{objects}; pieces of
data used and manipulated by afl programs.  For our purposes, a
@dfn{type} or @dfn{data type} is a set of possible objects.

When you run an afl program, the @dfn{afl reader} is called to read the
textual representations of the afl objects in the program, and convert
them to actual afl objects.  If you try to display an object, the
@dfn{afl printer} is called to generate a @dfn{printed representation}
of the object.

The @dfn{evaluation} of expressions in afl is performed by the
@dfn{afl interpreter}; a program that receives an afl object as input
and computes its @dfn{value as an expression}.  How it does this depends
on the data type of the object.  An afl object that is intended for
evaluation is called an @dfn{expression} or a @dfn{form}.

The most useful type of afl object to evaluate is lists.  When you
evaluate an afl list, the head of the list is evaluated as a function,
and then the remaining items in the list are passed as arguments to the
function.  Arguments are always evaluated in left-to-right order,
although there are a few functions, known as @dfn{special forms}, which
may not evaluate all of their arguments.  These functions' handling of
arguments will be explained in the function's description.

@node Data Types
@section Afl Data Types

Each data type in afl has a @dfn{read syntax} and a @dfn{printed
representation}.  The read syntax is the way the data type should be
written in an afl program.  The printed representation is the way that
the data type will be displayed by the afl printer.  These may be the
same or different.

@menu
* Comments::            How to insert comments into afl programs.
* Constants::           Constants you can use in afl programs.
* Lists::               Lists of objects of any data type.
* Numbers::             Numeric values.
* Characters::          The representation of characters.
* Strings::             Dealing with strings of characters.
* Symbols::             Objects which hold values.
@end menu

@node Comments
@subsection Comments

A @dfn{comment} is text that is written in a program only for the sake
of humans that read the program, and that has no effect on the meaning
of the program.  In afl, a semicolon (@samp{;}) starts a comment if it
is not within a string or character constant.  The comment continues to
the end of line.  The afl reader discards comments; they do not become
part of the afl objects which represent the program.

@node Constants
@subsection Special Constants
@cindex @code{nil} @r{(afl)}
@cindex false @r{(afl)}
@cindex @code{t} @r{(afl)}
@cindex true @r{(afl)}
@cindex @code{a} @r{(afl)}
@cindex ask @r{(afl)}
@cindex accept @r{(afl)}

In afl, the symbol @code{nil} is overloaded with three meanings: it
is a symbol with the name @samp{nil}; it is the logical truth value
@var{false}; and it is the empty list---the list of zero elements.
When used as a variable, @code{nil} always has the value @code{nil}.

As far as the afl reader is concerned, @samp{()} and @samp{nil} are
identical: they stand for the same object, the symbol @code{nil}.  The
different ways of writing the symbol are intended entirely for human
readers.  After the afl reader has read either @samp{()} or @samp{nil},
there is no way to determine which representation was actually written
by the programmer.

In contexts where a truth value is expected, any non-@code{nil} value
is considered to be @var{true}.  However, @code{t} is the preferred way
to represent the truth value @var{true}.  When you need to choose a
value which represents @var{true}, and there is no other basis for
choosing, use @code{t}.  The symbol @code{t} always has value @code{t}.

For convenience, the constant @code{a} is defined to be the value
@samp{ask} or @samp{accept} in af's tristate configuration variables.
This is the preferred way to set, for example, the variable
@code{copy-on-reply} to @samp{ask}.

In afl, @code{nil}, @code{t} and @code{a}, are special symbols that
always evaluate to themselves.  This is so that you do not need to quote
them to use them as constants in a program.  An attempt to change their
values results in an error.

@node Lists
@subsection Lists
@cindex lists @r{(afl)}

A list of objects of any data type (including lists).  A list is
read or printed as a set of objects enclosed in parentheses; for
example @samp{(a b c)}, or @samp{(a b (c d e) f)}.

Lists are evaluated by evaluating the symbol at their head as a
function. The remaining objects are evaluated (unless the function is a
special form), and passed as arguments to the function.

@node Numbers
@subsection Numbers
@cindex numbers @r{(afl)}

Af only supports integer numbers.  A number is read or printed as an
optional sign, followed by one or more digits; for example @samp{42}, or
@samp{-999}.

There is a system-defined limit to the maximum value of a number,
usually 32 bits.  Larger values will be truncated to fit within these
bounds, which will leave them with unexpected values.

Numbers always evaluate to themselves.

@node Characters
@subsection Characters
@cindex characters @r{(afl)}

In afl, characters are interchangeable with numbers, and are always
printed as a number.  They can be read either as a number, or as a
question mark followed by the character; for example @samp{?a}.  If the
character is not a normal alphanumeric one, then it is often necessary
to prefix it with a backslash '\' to make sure it is treated as a
character.  If the character is '\' then you need a second '\' to quote
it; for example. @samp{?\\}.

You can write the characters Control-g, backspace, tab, newline,
vertical tab, formfeed, return, and escape as @samp{?\a}, @samp{?\b},
@samp{?\t}, @samp{?\n}, @samp{?\v}, @samp{?\f}, @samp{?\r}, and
@samp{?\e}, respectively.

Rather than quoting a control character with @samp{\}, another read
syntax may be used.  If a character is a backslash followed by a caret
and another non-control character, then it represents the control
character.  For example, @samp{?\^I} is read syntax for the character
@kbd{C-i}.  You may also use @samp{C-} rather than @samp{^}, so
@samp{\C-i} is also read syntax for @kbd{C-i}.

A @dfn{meta character} is one that has the top bit set, and can be typed
with a meta key on some keyboards.  Read syntax for metacharacters is
@samp{?\M-} followed by the character.  This may be combined with
control character read sequence, hence @samp{?\C-\M-i} is read syntax
for @kbd{C-M-i}.

Finally, the most general read syntax for characters is a question mark
followed by a backslash and the numeric value of the character in octal
(up to three digits are allowed).  So @samp{?\001} is read syntax for
the character @kbd{C-a}.

An invalid control or meta character sequence (such as @samp{?\C-\^a} or
@samp{?\C-1}) will be flagged as an error by the afl reader.

As with numbers, there is a system-defined limit to the maximum value of
a character, usually 8 bits.  Larger values will be truncated to fit
within these bounds, which will leave them with unexpected values.

Characters always evaluate to themselves.

@node Strings
@subsection Strings

The read syntax and printed representation of afl strings is the string
enclosed in double quotes; for example @samp{"A string"}.  All the
special ways of writing characters can be used within strings.  In
addition, a backslash followed by a newline is ignored within a string,
so strings can be broken to fit on the screen better; for example:

@example
"This string is broken here \
by a \\\\n sequence"
@end example

@noindent
would be read as @samp{This string is broken here by a \\n sequence}.

Strings always evaluate to themselves.

@node Symbols
@subsection Symbols

A symbol name can contain any characters you require.  Any use of the
characters @samp{'"();?.,\ \t\n} should be quoted with a @samp{\}
character.  If the symbol name looks like a number, then it can be
prefixed with a @samp{\} to force it to be treated as a symbol.  Note
that unlike its use in strings, the @samp{\} simply quotes the next
character in the symbol name.

Evaluating a symbol works differently according to the context in which
the symbol is being evaluated.  An afl symbol can store a variable or a
function, or both.  The afl evaluator will usually look up the value of
the symbol as a variable, but will use the value as a function if the
symbol is at the head of a list.

@node Primitives
@section Afl Primitive Functions

Afl has several @dfn{primitive functions}, which are predefined in af,
and can be called from your afl programs.  In addition, an afl program
can call any af command as a function; af commands are simply functions
that have made provision for interactive use.

The appearance of the keyword @code{&optional} in the parameter list of
a function indicates that the arguments for subsequent parameters may be
omitted (omitted parameters default to @code{nil}).  Do not write
@code{&optional} when you call the function.

The keyword @code{&rest} (which will always be followed by a single
parameter) indicates that any number of arguments can follow.  The value
of the single following parameter will be a list of all these arguments.
Do not write @code{&rest} when you call the function.

@menu
* Quoting::             Protecting forms from evaluation.
* Control::             Functions that alter program flow.
* Configuration::       Functions to configure af.
* Input and Output::    Functions for dealing with externals.
@end menu

@node Quoting
@subsection Quoting Forms
@cindex quoting @r{(afl)}

@table @code
@item (quote @var{form})
Quote @var{form}, protecting it from evaluation.
@end table

@findex quote
Sometimes, you may not want a form to be evaluated, for example the name
of a symbol to assign a value to with @code{set}.  You can prevent a
form from being evaluated by using the special form @code{quote}.  So
@code{(quote list-functions)} expands to the symbol
@code{list-functions}.

Because @code{quote} is used so often, there is a special notation for
it.  Writing @code{'@var{form}} is equivalent to writing @code{(quote
@var{form})}.  So @code{'list-functions} is equivalent to the example
above.

@node Control
@subsection Controlling Program Flow
@cindex conditional code
cindex comparing afl objects
@cindex logical expressions

@table @code
@item (if @var{condition} @var{then} &optional @var{else})
Execute @var{then} if @var{condition} evaluates to non-nil, @var{else}
otherwise.
@item (progn &rest @var{forms})
Evaluates @var{forms} from left to right, returning the value of the
last form evaluated.
@item (equal @var{object1} @var{object2})
Returns @code{t} if @var{object1} and @var{object2} have the same afl
type and contents, @code{nil} otherwise.
@item (and &rest @var{conditions})
Evaluates @var{conditions} until one returns @code{nil}.
Returns the value of the last condition evaluated.
@item (or &rest @var{conditions})
Evaluates @var{conditions} until one returns non-nil.
Returns the value of the last condition evaluated.
@item (not @var{condition})
Returns @code{t} if @var{condition} evaluates to @code{nil}, @code{nil}
otherwise.
@end table

@findex if
To evaluate code only if a condition is true, use
@code{(if @var{condition} @var{true} @var{false})}.  This evaluates
@var{condition}, and then evaluates @var{true} if @var{condition}
returned non-nil, or @var{false} (if specified) otherwise.

@findex progn
You can use @code{progn} to group a set of forms, for example to use in
an @code{if}.  @code{progn} evaluates its arguments from left-to-right,
and returns the value returned by the last argument.

@findex equal
You can compare the value of two afl objects with @code{equal}.  This
will return @code{t} if the two objects have the same afl type and
contents, or @code{nil} otherwise.

@findex and
To combine one or more logical expressions, you can use @code{and},
@code{or}, and @code{not}.  The special form @code{and} evaluates its
arguments from left to right until one of them returns @code{nil}, and
then returns @code{nil}; the remaining arguments are never evaluated.
If no argument returns @code{nil}, then the value returned by the last
argument evaluated is returned.

@findex or
The special form @code{or} is more-or-less the opposite of @code{and};
it evaluates its arguments from left to right until one of them returns
non-nil, and then returns the value the argument returned; the remaining
forms are never evaluated.  If no argument evaluates to non-nil, then
@code{or} returns @code{nil}.

@findex not
To reverse a test use @code{not}.  This returns @code{t} if the argument
evaluates to @code{nil}, or @code{nil} otherwise.

@node Configuration
@subsection Configuring Af From Afl
@cindex setting variables from afl
@cindex configuring af from afl

@table @code
@item (set @var{symbol} @var{value})
Set @var{symbol} to contain @var{value}.
@item (setq @var{symbol} @var{value})
Equivalent to @code{(set '@var{symbol} @var{value})}.
@item (define-key @var{keymap} @var{"key"} @var{value})
Bind key @var{key} in keymap @var{keymap} to @var{value}.
@item (define-kbd-macro @var{macro} @var{"keys"})
Define a keyboard macro @var{macro} to execute @var{keys}.
@end table

@findex set
To set an af configuration variable, use the function @code{set}.  This
sets the variable to the value supplied.  The value will be checked to
make sure that it is a valid value for the variable.

@findex setq
Since @code{set} is a function you will need to quote the symbol to be
set.  For convenience, the special form @code{setq} is equivalent to
@code{set}, but does not evaluate the object which is to be set.
So @code{(setq ask-cc t)} is equivalent to @code{(set 'ask-cc t)}.

@findex define-key
To bind a key in a keymap use @code{(define-key @var{keymap} @var{"key"}
@var{object})}.  This binds @var{key} in keymap @var{keymap} to
@var{object}, which must be a command, a keymap, a keyboard macro, or
@code{nil}.  To find the name of the keymap you want to bind the key in
use the @code{list-keymaps} command.  Since @code{define-key} is a
function you will need to quote @var{keymap} and @var{object}.

@findex define-kbd-macro
To define a new keyboard macro, or redefine an existing one, use the
function @code{(define-kbd-macro @var{macro} @var{"keys"})}.  This
defines @var{macro} to execute @var{keys}.  Since
@code{define-kbd-macro} is a function you will need to quote
@var{macro}.

@node Input and Output
@subsection Interacting With the Environment

@table @code
@item (message &rest @var{forms})
Display the print format of @var{forms} in the echo area.
@item (error &rest @var{forms})
Beep and display @var{forms} in the echo area.
@item (getenv @var{"name"})
Return the value of the environment variable @var{name}, or @code{nil}
if name is not set in the environment.
@end table

@findex message
@findex error
The functions @code{message} and @code{error} display messages or error
messages in the echo area.  While @code{message} returns the forms that
it printed, @code{error} returns an error condition, which will halt the]
execution of the afl program.

@findex getenv
You can extract values from the environment by using
@code{(getenv @var{"variable"})}, which looks up and returns the
definition of @var{variable} in the environment.  This can be very
useful for terminal-dependent customisation of af.

@node Running Afl
@section Running Afl Programs
@cindex libraries
@cindex loading
@cindex load path

@table @kbd
@item M-x load-file @key{RET} @var{file} @key{RET}
Load @var{file} as an afl program.
@item M-x load-library @key{RET} @var{lib} @key{RET}
Search for and load a file @file{@var{lib}} or @file{@var{lib}.afl}.
@end table

Once you have created a file containing af commands (known as an
@dfn{afl program} or @dfn{afl library}, you can @dfn{load} it.  When you
load an afl program, the file is opened, and its contents are passed to
the afl reader.  Once all the file has been read and evaluated, then the
file is closed.  If any form in the file is invalid, or produces an
error, then the afl reader will abort, and the file will be closed.

@findex load-file
The simplest way to load an afl program is to use the the command
@code{load-file}, which loads a named file.  You must specify the full
name of the file.

@findex load-library
@vindex load-path
The @code{load-library} command will search for an afl program in a
set of directories defined by the @code{load-path} variable.  It checks
for the file name with @samp{.afl} appended, as well as the filename
alone.

If you want to modify where af looks for library files, there are two
ways to do so.  You can set the environment variable @code{AFLOADPATH}
to a colon-separated list of directories to search; or you can set the
configuration variable @code{load-path} to the same value.  For example:

@example
(setq load-path '("/usr/lib/af" "/usr/local/lib/af"))
@end example

@noindent
would make af look for afl libraries in the directories
@file{/usr/lib/af} and @file{/usr/local/lib/af}.

@node Afl Examples
@section Examples of Afl Code

Here are a few examples of afl code, with brief explanations.

Load the library @file{ansi.afl} if you are using an @sc{ansi} terminal
(under one of several common names):

@example
(if (or (equal (getenv "TERM") "ansi")
	(equal (getenv "TERM") "xterm")
	(equal (getenv "TERM") "vt100"))
    (load-library "ansi"))
@end example

Set the @code{viewable-charsets} variable to allow displaying the
@code{iso-8859-1} character set if running on an xterm:

@example
(if (equal (getenv "TERM") "xterm")
    (setq viewable-charsets '("iso-8859-1" "us-ascii")))
@end example

Complain if the user isn't running on an xterm:

@example
(if (not (equal (getenv "TERM") "xterm"))
    (error "Must be running on an xterm"))
@end example

Define a keyboard macro to move to the next message from typeout:

@example
(define-kbd-macro 'typeout-next-message "\C-g\C-n\r")
@end example

Bind the above macro to the key @kbd{M-n} in the typeout maps:

@example
(define-key 'typeout-prefix-command "n" 'typeout-next-message)
@end example

@c $Id: custom.texi,v 1.8 1997/03/06 01:29:11 malc Exp $
