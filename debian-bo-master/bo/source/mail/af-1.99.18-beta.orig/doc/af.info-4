This is Info file af.info, produced by Makeinfo version 1.67 from the
input file af.texi.

START-INFO-DIR-ENTRY
* Af: (af).                     An advanced mail reader and composer.
END-INFO-DIR-ENTRY

   This file documents Af, an advanced mail reader and composer with a
user interface similar to that of GNU Emacs.

   Copyright (C) 1996 Malc Arnold, Kay Dekker.  Derived in parts from
the GNU Emacs Manual, Eleventh Edition, Copyright (C) 1985, 1986, 1987,
1993, 1994, 1995 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "Distribution" and "GNU General Public
License" are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "Distribution" may be
included in a translation approved by the author instead of in the
original English, and the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: af.info,  Node: Minibuffer Kills,  Prev: Earlier Kills,  Up: Killing and Yanking

Killing and Yanking in the Minibuffer
=====================================

   The minibuffer is used for editing text rather than handling mail,
so it has it's own kill ring.  Any command which kills more than one
character at a time (the `word' and `line' killing commands) will store
the killed text in the minibuffer kill ring.  You can yank the killed
text back in exactly the same way as killed messages using `C-y'.

   The minibuffer kill commands will append successive kills to the kill
ring, just like the mail buffer kill commands do.  If you use `M-d'
(`delete-word') three times, then the three words you kill will all be
stored in a single kill ring entry; and a single yank will insert them
into the text at point.

   For simplicity, the minibuffer kill ring only has one entry, so you
can't use `M-y' in the minibuffer.  If many people find this a problem,
then it may change at some point in the future.


File: af.info,  Node: Searching,  Next: Sorting,  Prev: Killing and Yanking,  Up: Top

Searching Mail Folders
**********************

   Af has search commands, which allow you to search through the
messages in a buffer and find those which match a regular expression.
You can also search for messages which match a tag expression.

* Menu:

* Regex Search::	Searching for regular expressions.
* Tag Search::          Searching for tagged messages.
* Search and Tag::      Tag all messages which match a regex.
* Regex Syntax::	The syntax of regular expressions.
* Search Case::		Should case be ignored while searching?


File: af.info,  Node: Regex Search,  Next: Tag Search,  Up: Searching

Searching for Regular Expressions
=================================

`C-s REGEX <RET>'
     Search for REGEX (`search-forward').

`C-r REGEX <RET>'
     Search backward for REGEX (`search-backward').

   To do a search on a buffer (whether typeout or a mail buffer), use
`C-s' or `C-r'.  Af will prompt you for the regular expression to
search for, and then the search takes place.  If no messages match the
regular expression then the search will fail with an error.

   A second search immediately after the first, will not match the
current message, so repeated searches will move through all the
messages which match the regular expression.  To make this more
convenient, the search expression is defaulted to the last one you
entered.

   The search commands with a numeric argument will only search the
headers of the messages.  This is often convenient when (for example)
looking for messages which are from a particular person.


File: af.info,  Node: Tag Search,  Next: Search and Tag,  Prev: Regex Search,  Up: Searching

Searching for Tagged Messages
=============================

`C-t C-s TAGEXPR <RET>'
     Search for messages matching TAGEXPR (`tag-search-forward').

`C-t C-r TAGEXPR <RET>'
     Search backward for messages matching TAGEXPR
     (`tag-search-backward').  To search for a message matching a tag
expression use `C-t C-s' or `C-t C-r'.  Af will prompt you for the tag
expression (*note Tag Expressions::.) to search for; and then the
search takes place.  If no messages match the tag expression then the
search will fail with an error.

   Just as with regular expression searches, a second search immediately
after the first, will not match the current message, so repeated
searches will move through all the messages which match the tag
expression.  To make this more convenient, the search expression is
defaulted to the last one you entered.


File: af.info,  Node: Search and Tag,  Next: Regex Syntax,  Prev: Tag Search,  Up: Searching

Tagging Matching Messages
=========================

   As well as just searching for a regular expression and moving point
to the first matching message, af can tag all the messages which match a
regular expression.  To do this use `C-t s' (`search-and-tag').  You
will be prompted for the regular expression to search for, and the tags
to set on the matching messages (*note Setting Tags::.).  Once the
search has finished, af will report how many messages were tagged.

   With a numeric argument this command will only search the headers of
the messages.  This is often convenient when (for example) looking for
messages which are from a particular person or mailing list.


File: af.info,  Node: Regex Syntax,  Next: Search Case,  Prev: Search and Tag,  Up: Searching

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that same character and
nothing else.  The special characters are `$', `^', `.', `*', `+', `?',
`[', `]' and `\'.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does *not* match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regular expressions also match `F' and `O',
but we consider this a generalization of "the same string", rather than
an exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`. (Full stop)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b' which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator, which
     means to match the preceding regular expression repetitively as
     many times as possible.  Thus, `o*' matches any number of `o's
     (including no `o's).

     `*' always applies to the *smallest* possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

`+'
     is a postfix character, similar to `*' except that it must match
     the preceding expression at least once.  So, for example, `ca+r'
     matches the strings `car' and `caaaar' but not the string `cr',
     whereas `ca*r' matches all three strings.

`?'
     is a postfix character, similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' matches `car' or `cr'; nothing else.

`[ ... ]'
     is a "character set", which begins with `[' and is terminated by
     `]'.  In the simplest case, the characters between the two
     brackets are what this set can match.

     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can also include character ranges in a character set, by
     writing two characters with a `-' between them.  Thus, `[a-z]'
     matches any lower-case letter.  Ranges may be intermixed freely
     with individual characters, as in `[a-z$%.]', which matches any
     lower case letter or `$', `%' or `.'.

     Note that the usual regex special characters are not special
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' as the first or last character of the set.  Thus,
     `[]-]' matches both `]' and `-'.

     To include `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters *except* letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (`-' and `]' are not special there).

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' which
     occurs at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `xx*$' matches a string of one `x' or more at the end of a line.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression which matches only `$', and `\[' is a regular
     expression which matches only `[', etc.

     For the most part, `\' followed by any character matches only that
     character.  However, there are several exceptions: two-character
     sequences starting with `\' which have special meanings.  The
     second character in the sequence is always an ordinary character
     on its own.  Here is a table of ``\'' constructs.

    `\{ ... \}'
          is a postfix construct, similar to `*' except that it allows
          you to specify the number of times the preceding expression
          must be matched.  So, for example, `ca\{3\}r' will match only
          the string `caaar'.

          If you add a comma after the number of times the expression
          must be matched, then the expression must be matched at least
          as many times as you specified.  So `ca\{2,\}r' will match
          the strings `caar', `caaar', `caaaar', and so on.

          You can also add a maximum value after the comma, to specify
          a range of values.  So `ca\{1,3\}r' will match only the
          strings `car', `caar' and `caaar'.

    `\|'
          specifies an alternative.  Two regular expressions A and B
          with `\|' in between form an expression that matches anything
          that either A or B matches.

          Thus, `foo\|bar' matches either `foo' or `bar' but no other
          string.

          `\|' applies to the largest possible surrounding expressions.
          Only a surrounding `\( ... \)' grouping can limit the scope
          of `\|'.

    `\( ... \)'
          is a grouping construct that serves three purposes:

            1. To enclose a set of `\|' alternatives for other
               operations.  Thus, `\(foo\|bar\)x' matches either `foox'
               or `barx'.

            2. To enclose a complicated expression for the postfix
               operators `*', `+' and `?' to operate on.  Thus,
               `ba\(na\)*' matches `bananana', etc., with any (zero or
               more) number of `na' strings.

            3. To mark a matched substring for later reference with
               `\N'.

    `\N'
          When you use `\( ... \)' in an expression, you can look for
          another match for the exact same text that was matched inside
          the `\( ... \)'.  The two-character sequence `\N' will match
          the same text as was matched by the Nth use of `\( ... \)'.
          The first nine uses are remembered, and are assigned the
          numbers `1' to `9'.  So `\1' matches the text that was
          matched by the first use of `\( ... \)'.

          For example, `\([a-z]\)\1' matches any two consecutive lower
          case characters.  The `\([a-z]\)' matches any lower case
          character, while the `\1' must match the same character.

          If a use of `\( ... \)' matches more than once, which often
          happens if it is followed by `*' or `+', only the last match
          is stored for use with `\N'.

   Here is a moderately complicated regex, which you might use to find
messages from the af-bug or af-user mailing lists.

     ^From:.*af-\(bug\|user\)@csv.warwick.ac.uk


File: af.info,  Node: Search Case,  Prev: Regex Syntax,  Up: Searching

Searching and Case
==================

   Searches in af normally ignore the case of the text they are
searching through.  Thus, if you specify searching for `foo', then `Foo'
and `foo' are also considered a match.  Regular expressions, and in
particular character sets, are included: `[ab]' would match `a' or `A'
or `b' or `B'.

   If you set the variable `case-fold-search' to `false', then all
letters must match exactly, including case.


File: af.info,  Node: Sorting,  Next: Narrowing,  Prev: Searching,  Up: Top

Sorting Messages
****************

   Af provides commands for sorting some or all of the messages in a
mail buffer.  Each command prompts for a sort order, and then sorts the
selected messages into that order.

`M-x sort-buffer ORDER RET'
     Sort all of the messages in the buffer into ORDER order.

`M-x sort-region ORDER RET'
     Sort the messages in the region into ORDER order.

`M-x sort-tagset ORDER RET'
     Sort the messages in the tagset into ORDER order.  The messages in
     the tagset are sorted correctly, but messages which are not in the
     tagset are not moved at all.

   The sort orders which af understands are:

`(reverse-)address'
     The address of the sender of the message, sorted case-independent.
     Any full name or routing information in the address is ignored.

`(reverse-)date'
     The date the message was sent (or received if the date sent isn't
     known), from oldest to newest (newest to oldest).  The variable
     `show-dates-in-local-time' indicates whether dates should be
     compared as they are, or converted to your local time before they
     are compared (the default).

`(reverse-)lines'
     The number of lines in the message, from smallest to largest
     (largest to smallest).

`(reverse-)mailbox'
     The (reverse) order of the messages in the folder when it was read.
     Messages which were yanked into the buffer after it was read may
     appear anywhere in the buffer.

`(reverse-)sender'
     The full name of the sender of the message, sorted
     case-independent.

`(reverse-)status'
     The system tags of the message (*note System Tags::.).  Messages
     with no system tags are sorted after those that have them.

`(reverse-)subject'
     The subject of the message, sorted alphabetically and
     case-independent.  The prefix 'Re: ' is handled specially in
     subject lines, so that replies to a message will sort immediately
     after (before) the original message.

`(reverse-)tags'
     The user tags of the message (*note User Tags::.).  Messages with
     no user tags are sorted after those that have them.

   When you sort, messages which sort identically will remain in their
original order, so sorting a buffer by date and then subject will result
in the messages being in date order within each subject.  This is often
a good approximation to the "threading" that news readers such as `trn'
do, and is handy for reading mailing lists.

   Af does not sort your folders by default when it reads them.  If you
have a preference for reading buffers in a certain order, then you can
set the configuration variable `initial-buffer-sort' to the sort
ordering you prefer.

   If you are familiar with other mail readers it is worth noting that
af, unlike most other mail readers, saves the messages back to the
folders in whatever order you sort them into.  This can often be
convenient when managing large folders.


File: af.info,  Node: Narrowing,  Next: Folders,  Prev: Sorting,  Up: Top

Narrowing
*********

   "Narrowing" means focusing in on some portion of the buffer, making
the rest temporarily inaccessible.  The portion which you can still get
to is called the "accessible part".  Canceling the narrowing, which
makes the entire buffer once again accessible, is called "widening".
The amount of narrowing in effect in a buffer at any time is called the
buffer's "restriction".

   Narrowing can make it easier to concentrate on a set of messages by
eliminating clutter.  It can also be used to restrict the range of
operation of a search command or repeating keyboard macro.

`C-x n'
     Narrow down to between point and mark (`narrow-to-region').

`C-t n EXPRESSION RET'
     Narrow to the tagset defined by tag-expression
     (`narrow-to-tagset').

`C-x w'
     Widen to make the entire buffer accessible again (`widen').

   When you have narrowed down to a part of the buffer, that part
appears to be all there is.  You can't see the rest, you can't move
into it (motion commands won't go outside the accessible part), you
can't change it in any way.  However, it is not gone, and if you save
the folder all the inaccessible messages will be saved.  The word
`Narrow' appears in the mode line whenever narrowing is in effect.

   One narrowing command is `C-x n' (`narrow-to-region').  It sets the
current buffer's restrictions so that the messages in the region remain
accessible but all messages before or after the region are
inaccessible.  Point and mark do not change.

   Another narrowing command is `C-t n' (`narrow-to-tagset').  It
prompts for a tag expression, and then set the current buffer's
restrictions so that the messages in the tagset remain accessible but
all the other messages are inaccessible.

   The way to cancel narrowing is to widen with `C-x w' (`widen').
This makes all the messages in the buffer accessible again.

   Narrowing can be very useful if you have a set of messages that you
want to deal with independently of any others; such as all the messages
from a mailing list, or from a certain user.  Use `C-t s'
(`search-and-tag') to tag the messages you are interested in, and then
use `C-t n' to narrow the buffer to only the tagged messages.  When you
are done with the messages, use `C-x w' to widen to buffer.

   Another use for narrowing is when you are using tags to kill
messages.  You can use `C-t n' to narrow to the messages you intend to
kill, and then conveniently scan the messages to make sure that you are
happy to kill them all; using `C-t u' to untag any messages that you
decide you want to keep.  Finally you can either kill the tagset with
`C-t C-k' (`kill-tagset'), or set the mark and point at opposite ends
of the buffer and use `C-w' (`kill-region').  When you have finished,
use `C-x w' to widen the buffer.


File: af.info,  Node: Folders,  Next: Buffers,  Prev: Narrowing,  Up: Top

Folder Handling
***************

   The operating system stores data permanently in named "files".  We
refer to files which contain mail messages as "folders".  In general,
the mail messages you process with af come from a folder which will
need to be updated to reflect any changes you make.

   Unlike most mail readers, af can read in and process several folders
simultaneously, which makes it convenient to store messages in several
folders rather than leaving them all in your incoming mailbox.  Af can
actually be used quite conveniently as a small database by using folders
to store related messages.

   By default, af reads in your incoming mailbox when it starts.  You
can also use command-line arguments to tell af to read a different
folder (*note Command Arguments::.).  Or you can tell an existing af to
read another folder and prepare a buffer containing a copy of the
folder's messages.  This is called "visiting" the folder.  Af commands
apply to the messages in the buffer; that is, to the copy inside af.
Your changes appear in the folder itself only when you "save" the buffer
back into the folder.

* Menu:

* File Names::       How to type and edit file name arguments.
* Network Folders::  Af can handle reading folders over a network.
* Visiting::         Visiting a folder prepares af to handle it.
* Pending Folders::  How an af buffer may contain two files.
* Resynchronizing::  Keeping buffers up-to-date with their folders.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Inserting::        You can insert a folder into the buffer.


File: af.info,  Node: File Names,  Next: Network Folders,  Up: Folders

File Names
==========

   Most af commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows
which file name to use for them.)  You enter the file name using the
minibuffer (*note Minibuffer::.).  "Completion" is available, to make
it easier to specify long file names (*note Completion::.).

   Many people prefer to keep all their mail folders in one directory;
any folders saved from Usenet news (news folders) in another, and so
on.  To make this kind of operation more convenient, af interprets
several characters specially if they appear at the start of the file
name.

`~USER'
     USER's home directory, or your home directory if USER is not
     given.  For example `~/foo' is the file `foo' in your home
     directory, while `~malc/foo' is the file `foo' in malc's home
     directory.

`%USER'
     USER's incoming mailbox, or your incoming mailbox if USER is not
     given.  So `%' is the your incoming mailbox, while `%malc' is
     malc's incoming mailbox.  Note that you won't usually have the
     necessary permission to read other people's incoming mailboxes.

`+'
     Your "folder directory", as specified by the variable `folder'.
     This is either extracted from the environment variable `FOLDER', or
     defaulted to `~/Mail'.  So `+af' will usually expand to
     `~/Mail/af'.  You will need to create the directory yourself if you
     plan to use it; af won't create it for you.

`='
     Your "news folder directory", where saved news articles are stored,
     as specified by the variable `news-folder'.  This is either
     extracted from the environment variable `SAVEDIR', or defaulted to
     `~/News'.  So `=Comp.mail.headers' will usually expand to
     `~/News/Comp.mail.headers'.  Normally your news-reader will have
     created this directory for you.

`\'
     A leading `\' in a file name is ignored, but it prevents any
     special meaning being taken from the next character in the
     filename.  To start a file name with a `\', use `\\'.  For example
     `\+af' is the file `+af' in the current directory.

   Af has a "current directory", sometimes referred to as the "working
directory", which is normally the directory you were in when you ran
af.  When you enter a folder name without a directory or a special
prefix, the current directory is used.  If you specify a directory in a
relative fashion, with a name that does not start with either a special
prefix or a slash, it is interpreted with respect to the current
directory.

   For example, if the current directory is `/home/malc/src/af' and you
type just `foo', which does not specify a directory, it is short for
`/home/malc/src/af/foo'.  `../../.afrc' would stand for
`/home/malc/.afrc'.  `new/foo' would stand for the file name
`/home/malc/src/af/new/foo'.

   The command `M-x pwd' prints af's current directory, and the command
`M-x cd' sets it (to a value read using the minibuffer).  Af's current
directory can only be changed by using the `cd' command.


File: af.info,  Node: Network Folders,  Next: Visiting,  Prev: File Names,  Up: Folders

Reading Folders Over a Network
==============================

   Af supports a mail protocol called POP3, which allows you to read a
folder over a network.  This allows people to read mail on a small
machine which doesn't have a mail system itself; you simply connect to
the "POP server" where your mail is stored, and read your mail over the
network.

   Your incoming mailbox may live on a POP server, or you may have a
separate POP3 mailbox somewhere.  To access a POP3 folder use a
filename beginning in a colon.  Two forms of POP3 folder name are
acceptable: `:SERVER' or `:USER@SERVER'.  The first form implies that
the username to use on SERVER is the same one that you are currently
logged in as; the second explicitly specifies the username to use to
connect to the POP server.

   Once af has opened a connection to the POP server, you are prompted
for a password.  The password won't be echoed (for security reasons),
and it won't be stored in the minibuffer history either.  If you don't
know your password then you will need to check with your system
administrator to find out what it is.  The password you use to log in is
often worth trying.

   Once af has read the POP folder (which may like some time; network
connections are often slow), it displays the buffer as normal.  However,
the buffer containing the folder will have the `POP3' minor mode set.
This disallows several af features, notably killing and yanking
messages in the buffer.  The reason for this is that the POP3 protocol
was designed to work well with existing mail readers, and it doesn't
have the functionality to cope with af's method of folder management.
(1)  One way of working around this is to use a pending folder (*note
Pending Folders::.).

   ---------- Footnotes ----------

   (1)  This isn't really POP3's fault; the design of af and of other
mailers is very different in several areas.  The IMAP protocol provides
all the functionality that af needs to work normally, but since it is
nothing like as widely supported as POP3, we decided that POP3 was the
network protocol to support.  For now.


File: af.info,  Node: Visiting,  Next: Pending Folders,  Prev: Network Folders,  Up: Folders

Visiting Files
==============

`C-x C-f'
     Visit a folder (`find-file').

`C-x C-r'
     Visit a folder for viewing, without allowing changes to it
     (`find-file-read-only').

`C-x C-v'
     Visit a different folder instead of the one visited last
     (`find-alternate-file').

`C-x 4 C-f'
     Visit a file, in another window (`find-file-other-window').

   "Visiting" a folder means reading its contents into an af buffer so
you can process them.  Af makes a new buffer for each folder that you
visit.  We say that this buffer is visiting the folder that it was
created to hold.  Af constructs the buffer name from the folder name by
throwing away the directory, keeping just the name proper.  For example,
a file named `/home/malc/Mail/af' would get a buffer named `af'.  If
there is already a buffer with that name, a unique name is constructed
by appending `<2>', `<3>', or so on, using the lowest number that makes
a name that is not already in use.

   Each window's mode line shows the name of the buffer that is being
displayed in that window, so you can always tell what buffer you are
processing.

   The changes you make with af commands are made in the af buffer.
They do not take effect in the folder that you visited, or any place
permanent, until you "save" the buffer.  Saving the buffer means that
af writes the current contents of the buffer into its visited folder.
*Note Saving::.

   If a buffer contains changes that have not been saved, we say the
buffer is "modified".  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line displays
two stars near the left margin to indicate that the buffer is modified.

   If the status of one or more messages in a buffer has changed
(perhaps they were new before you read the folder), but no other
changes have been made, then we say that the buffer is "status
modified".  This is not so important as being modified, but some
information will be lost if the buffer is not changed.  The mode line
displays two plus signs near the left margin to indicate that the
buffer is status modified.

   To visit a folder, use the command `C-x C-f' (`find-file').  Follow
the command with the name of the folder you wish to visit, terminated
by a <RET>.

   The folder name is read using the minibuffer (*note Minibuffer::.),
with defaulting and completion in the standard manner (*note File
Names::.).  While in the minibuffer, you can abort `C-x C-f' by typing
`C-g'.

   If the specified folder does not exist and could not be created, or
cannot be read, then you get an error, with an error message displayed
in the echo area.

   While af is reading the folder, it reports on how many messages it
has read, usually after every five messages read.  You can control how
often af updates the count by setting the variable
`message-count-update'.  Once the folder has been read, af will print a
message like this:

     (Read 15 messages)

This confirms that af has successfully read the folder into a buffer.
The message may also sometimes look like this:

     (Read 15 messages; including 1 with bad headers)

This means that the folder was read successfully, but some of the
messages in the folder had mail headers that af couldn't interpret
properly.  This is not usually critical, but some people prefer to know
about errors in their mailboxes.

   If the variable `first-unread-message' is set to `true'; then af
will move point to the first message in the buffer that you haven't
read, if there are any.  Otherwise you will begin processing the buffer
with point on the first message.

   If you visit a file that is already in af, `C-x C-f' does not make
another copy.  It selects the existing buffer containing that file.

   What if you want to create a new folder?  Just visit it.  Af prints
`(New File)' in the echo area, but in other respects behaves as if you
had visited an existing empty file.  If you make any changes and save
them, the file is created.

   If you visit a file that the operating system won't let you modify,
Af makes the buffer read-only, so that you won't go ahead and make
changes that you'll have trouble saving afterward.  You can make the
buffer writable with `C-x C-q' (`toggle-read-only').

   Occasionally you might want to visit a folder as read-only in order
to protect yourself from entering changes accidentally; do so by
visiting the file with the command `C-x C-r' (`find-file-read-only').

   If you accidentally visit the wrong folder (perhaps you mistyped the
file name), use the `C-x C-v' command (`find-alternate-file') to visit
the file you really wanted.  `C-x C-v' is similar to `C-x C-f', but it
kills the current buffer (after first offering to save it if it is
modified).

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If this command is used when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.


File: af.info,  Node: Pending Folders,  Next: Resynchronizing,  Prev: Visiting,  Up: Folders

Pending Folders
===============

   If you are reading mail via POP3, you may prefer to store your mail
on your local machine, rather than on a POP server.  You can do this
conveniently with af by using a "pending folder", a folder which
contains two folders.  The simplest way of doing this is to set the
variable `pending-folder' to the name of the folder where all your
incoming mail should be stored; say `+mailbox'.  You must set the
`pending-folder' variable in your `.afrc' file, or it will have no
affect (*note Startup Files: Variables.).

   Once the `pending-folder' variable is set, it changes the behaviour
of af when you start without specifying folders to read or addresses to
send mail to.  Instead of reading your incoming mailbox into its own
buffer, it reads the folder specified in the `pending-folder' variable,
and then appends the contents of your incoming mailbox to the buffer.

   The buffer is considered to contain both the "pending folder" and
your incoming mailbox; it will be resynchronised from both, and visiting
either folder will switch to the buffer displaying the pending folder.
When you save the pending folder your incoming mailbox will be cleared,
ready for any new mail.  If you don't save the buffer, both folders are
left untouched.

   One advantage of pending folders is that they are normal disk
folders.  If your incoming mailbox is read via POP3, using a pending
folder will allow you to avoid the limitations of buffers in POP3 mode,
and use all of af's features in the buffer.  Once you've set it up,
using a default pending folder is transparent enough that you'll
probably never notice the difference.

   You can also read a folder into an existing buffer, making the buffer
pending on the folder you read.  To do this use the command `M-x
read-pending-file'.  You will be prompted for the name of the file to
make the buffer pending on.  This has exactly the same effect as using
the `pending-folder' variable.


File: af.info,  Node: Resynchronizing,  Next: Saving,  Prev: Pending Folders,  Up: Folders

Resynchronizing Buffers
=======================

   As we have discussed, buffers are copies of the contents of a folder.
So what can we do to handle new mail arriving in the folder after we
have read it?  The solution to this is "resynchronizing" the buffer, so
that any new messages in the file on disk are incorporated into the
buffer.

   When a buffer is resynchronised, any new messages are appended to the
buffer, and a message will appear in the echo area to let you know that
new messages were read into the buffer.

   Af will check for new messages whenever you try to save a buffer to
disk.  If there are new messages then the buffer is resynchronised, and
the save will fail.

   Af also checks for new mail in each folder you are visiting on a
regular basis.  If any buffers are out of date, then they are
resynchronised.  How often af does this is controlled by the
`resync-time' variable, normally it is done every 600 seconds (10
minutes).

   To manually check for new messages in a buffer's folder, use `C-x r'
(`resync-buffer').  If the buffer needs to be resynchronised, then
point will be set on the first new message.


File: af.info,  Node: Saving,  Next: Reverting,  Prev: Resynchronizing,  Up: Folders

Saving Files
============

   "Saving" a buffer in af means writing its contents back into the
folder that was visited in the buffer.

`C-x C-s'
     Save the current buffer in its visited file (`save-buffer').

`C-x s'
     Save any or all buffers in their visited files
     (`save-some-buffers').

`M-x save-all-buffers'
     Save all modified buffers in their visited files.

`M-~'
     Forget that the current buffer has been changed (`not-modified').

`C-x C-w'
     Save the current buffer in a specified file (`write-file').

   When you wish to save the folder and make your changes permanent,
type `C-x C-s' (`save-buffer').  After saving is finished, `C-x C-s'
displays a message like this:

     (Wrote 12 messages)

If the selected buffer is not modified or status modified (no changes
have been made in it since the buffer was created or last saved), saving
is not really done, because it would have no effect.  Instead, `C-x
C-s' displays a message like this in the echo area:

     (No changes need to be written)

   The command `C-x s' (`save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  These
questions are also asked if you exit af by typing `C-x C-c'.  The
buffer is automatically resynchronised before being saved, and if any
new messages are found the save will be abandoned.

   The command `M-x save-all-buffers' saves all modified buffers.  This
can be dangerous if you have several buffers, since you may not want to
save one of them, so be careful!

   If you have changed a buffer but you do not want to save the changes,
you should take some action to prevent it.  Otherwise, each time you use
`C-x s' or `C-x C-c', you are liable to save this buffer by mistake.
One thing you can do is type `M-~' (`not-modified'), which clears out
the indication that the buffer is modified.  If you do this, none of
the save commands will believe that the buffer needs to be saved.  (`~'
is often used as a mathematical symbol for `not'; thus `M-~' is `not',
metafied.)  Alternatively, you can cancel all the changes made since
the file was visited or saved, by reading the text from the file again.
This is called "reverting".  *Note Reverting::.

   If you wish to mark the buffer as visiting a different folder and
save it right away, use `C-x C-w' (`write-file').  It prompts for the
new folder, marks the buffer as visiting that folder, and saves the
buffer.  If the folder already exists, af will ask for confirmation that
it is ok to overwrite the file with the buffer.


File: af.info,  Node: Reverting,  Next: Inserting,  Prev: Saving,  Up: Folders

Reverting a Buffer
==================

   If you have made extensive changes to a folder and then change your
mind about them, you can get rid of them by reading in the previous
version of the folder.  To do this, use `M-x revert-buffer', which
operates on the current buffer.  Since reverting a buffer
unintentionally could lose a lot of work, you must confirm this command
with `yes'.

   Reverting marks the buffer as "not modified" until another change is
made.


File: af.info,  Node: Inserting,  Prev: Reverting,  Up: Folders

Inserting a Folder
==================

   Sometimes you may want to merge two folders.  An easy way to do this
is to use `C-x i' (`insert-file'), which inserts the contents of the
specified folder into the buffer at point, leaving mark at the start of
the inserted contents and point after them.  The buffer will not be
visiting the folder you inserted, and so will be saved to its original
folder.


File: af.info,  Node: Buffers,  Next: Windows,  Prev: Folders,  Up: Top

Using Multiple Buffers
**********************

   The messages you are processing in af reside in an object called a
"buffer".  Each time you visit a folder, a buffer is created to hold
the messages in the folder.

   At any time, one and only one buffer is "selected".  It is also
called the "current buffer".  Often we say that a command operates on
"the buffer" as if there were only one; but really this means that the
command operates on the selected buffer (most commands do).

   When af has multiple windows, each window has a chosen buffer which
is displayed there, but at any time only one of the windows is selected
and its chosen buffer is the selected buffer.  Each window's mode line
displays the name of the buffer that the window is displaying (*note
Windows::.).

   Each buffer has a name, which can be of any length, and you can
select any buffer by giving its name.  Most buffers are made by
visiting files, and their names are derived from the files' names.  But
you can also create an empty buffer with any name you want.  A newly
started af has a buffer named `*scratch*' which can be used as a
temporary place to store messages.  The distinction between upper and
lower case matters in buffer names.

   Each buffer records individually what folder it is visiting, whether
it is modified, and what major mode and minor modes are in effect in it
(*note Major Modes::.).

* Menu:

* Select Buffer::      Creating a new buffer or reselecting an old one.
* List Buffers::       Getting a list of buffers that exist.
* Kill Buffers::       Killing buffers you no longer need.


File: af.info,  Node: Select Buffer,  Next: List Buffers,  Up: Buffers

Creating and Selecting Buffers
==============================

`C-x b BUFFER <RET>'
     Select or create a buffer named BUFFER (`switch-to-buffer').

`C-x 4 b BUFFER <RET>'
     Similar, but select BUFFER in another window
     (`switch-to-buffer-other-window').

   To select the buffer named BUFNAME, type `C-x b BUFNAME <RET>'.
This runs the command `switch-to-buffer' with argument BUFNAME.  You
can use completion on an abbreviation for the buffer name you want
(*note Completion::.).  An empty argument to `C-x b' specifies the most
recently selected buffer that is not displayed in any window.

   Most buffers are created by visiting files, but you can also create a
buffer explicitly by typing `C-x b BUFNAME <RET>'.  This makes a new,
empty buffer which is not visiting any file, and selects it.  If you
try and save a buffer created in this way, you are asked for the file
name to use.

   Note that `C-x C-f', and any other command for visiting a file, can
also be used to switch to an existing file-visiting buffer.  *Note
Visiting::.


File: af.info,  Node: List Buffers,  Next: Kill Buffers,  Prev: Select Buffer,  Up: Buffers

Listing Existing Buffers
========================

   To display a list of all the buffers that exist, type `C-x C-b'.
Each line in the list shows one buffer's name, major mode and visited
file.  The buffers are listed in the order, most recently visited first.

   `*' or `+' at the beginning of a line indicates the buffer is
modified or status modified.  If several buffers are modified, it may be
time to save some with `C-x s' (*note Saving::.).  `%' indicates a
read-only buffer.  `.' marks the selected buffer.  Here is an example
of a buffer list:

      MR Buffer         Size  Mode           File
      -- ------         ----  ----           ----
     .*  malc             12  Mail           /var/spool/mail/malc
      +  af               21  Mail           /home/malc/Mail/af
         *scratch*         0  Mail


File: af.info,  Node: Kill Buffers,  Prev: List Buffers,  Up: Buffers

Killing Buffers
===============

   If you continue an af session for a while, you may accumulate a large
number of buffers.  You may then find it convenient to "kill" the
buffers you no longer need.  On most operating systems, killing a buffer
releases its space back to the operating system so that other programs
can use it.  Here are some commands for killing buffers:

`C-x k BUFNAME <RET>'
     Kill buffer BUFNAME (`kill-buffer').

`M-x kill-some-buffers'
     Offer to kill each buffer, one by one.

   `C-x k' (`kill-buffer') kills one buffer, whose name you specify in
the minibuffer.  The default, used if you type just <RET> in the
minibuffer, is to kill the current buffer.  If you kill the current
buffer, another buffer is selected; one that has been selected recently
but does not appear in any window now.  If you ask to kill a
file-visiting buffer that is modified, then you must confirm with `yes'
before the buffer is killed.

   The command `M-x kill-some-buffers' asks about each buffer, one by
one.  An answer of `y' means to kill the buffer.  Killing the current
buffer or a buffer containing unsaved changes selects a new buffer or
asks for confirmation just like `kill-buffer'.


File: af.info,  Node: Windows,  Next: Customisation,  Prev: Buffers,  Up: Top

Multiple Windows
****************

   Af can split the screen into two or many windows.  Multiple windows
can display parts of different buffers, or different parts of one
buffer.

* Menu:

* Basic Windows::       Introduction to af windows.
* Using Windows::       How to create and use windows.
* Change Windows::      Deleting windows and changing their sizes.


File: af.info,  Node: Basic Windows,  Next: Using Windows,  Up: Windows

Concepts of Af Windows
======================

   Each Af window displays one Af buffer at any time.  A single buffer
may appear in more than one window; if it does, any changes in its text
are displayed in all the windows where it appears.  But the windows
showing the same buffer can show different parts of it, because each
window has its own value of point.

   At any time, one of the windows is the "selected window"; the buffer
this window is displaying is the current buffer.  The arrow cursor shows
the location of point in this window, but is not visible in any other
window.

   Commands to move point affect the value of point for the selected af
window only.  They do not change the value of point in any other af
window, even one showing the same buffer.  The same is true for commands
such as `C-x b' to change the selected buffer in the selected window;
they do not affect other windows at all.  However, there are other
commands such as `C-x 4 b' that select a different window and switch
buffers in it.

   When multiple windows show the same buffer, they can have different
regions, because they can have different values of point and mark.

   Each window has its own mode line, which displays the buffer name,
modification status, size in messages, and major and minor modes of the
buffer that is displayed in the window.  *Note Mode Line::, for full
details on the mode line.


File: af.info,  Node: Using Windows,  Next: Change Windows,  Prev: Basic Windows,  Up: Windows

Creating and Using Windows
==========================

`C-x 2'
     Split the current window vertically, creating a new window
     (`split-window-vertically').

`C-x o'
     Select the "other" window (`other-window').  That is `o', not zero.

`M-x previous-window RET'
     Select the previous window.

`C-M-v'
     Scroll the next window (`scroll-other-window').

   The command `C-x 2' (`split-window-vertically') breaks the selected
window into two windows, one above the other.  Both windows start out
displaying the same buffer, with the same value of point.  By default
the two windows each get half the height of the window that was split;
a numeric argument specifies how many lines to give to the top window.

   To select a different window, type `C-x o' (`other-window').  That
is an `o', for `other', not a zero.  When there are more than two
windows, this command moves through all the windows from top to bottom.
After the bottommost window, it goes back to the one at the top.  A
numeric argument means to move several steps in the cyclic order of
windows.  A negative argument moves around the cycle in the opposite
order.

   You can also select a different window with `M-x previous window'.
When there are more than two windows, this command moves through all the
windows from bottom to top.  After the topmost window, it goes back to
the one at the bottom.  A numeric argument means to move several steps
in the cyclic order of windows.  A negative argument moves around the
cycle in the opposite order.

   The usual scrolling commands (*note Scrolling::.) apply to the
selected window only, but there is one command to scroll the next
window.  `C-M-v' (`scroll-other-window') scrolls the window that `C-x
o' would select.  It takes arguments, positive and negative, like `C-v'.


File: af.info,  Node: Change Windows,  Prev: Using Windows,  Up: Windows

Deleting and Rearranging Windows
================================

`C-x 0'
     Delete the selected window (`delete-window').  That is a zero.

`C-x 1'
     Delete all windows except the selected window
     (`delete-other-windows').

`C-x ^'
     Make the selected window taller (`enlarge-window').

`M-x shrink-window'
     Make the selected window smaller.

   To delete a window, type `C-x 0' (`delete-window').  (That is a
zero.)  The space occupied by the deleted window is given to an adjacent
window.  Once a window is deleted, its attributes are forgotten; only
restoring a window configuration can bring it back.  Deleting the window
has no effect on the buffer it used to display; the buffer continues to
exist, and you can select it in any window with `C-x b'.

   `C-x 1' (`delete-other-windows') is more powerful than `C-x 0'; it
deletes all the windows except the selected one; the selected window
expands to use the whole screen except for the echo area.

   To readjust the division of space among vertically adjacent windows,
use `C-x ^' (`enlarge-window').  It makes the currently selected window
get one line bigger, or as many lines as is specified with a numeric
argument.  With a negative argument, it makes the selected window
smaller.  The extra screen space given to a window comes from one of
its neighbors.  You cannot enlarge the window if it would make a
neighbouring window less than two lines tall.

   You can also readjust the size of the selected window with `M-x
shrink-window'.  It makes the currently selected window get one line
smaller, or as many lines as is specified with a numeric argument.
With a negative argument, it makes the selected window bigger.  The
extra screen space released by a window is given to of its neighbors.
You cannot shrink the window if it would make the window less than two
lines tall.

