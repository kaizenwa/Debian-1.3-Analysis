This is Info file af.info, produced by Makeinfo version 1.67 from the
input file af.texi.

START-INFO-DIR-ENTRY
* Af: (af).                     An advanced mail reader and composer.
END-INFO-DIR-ENTRY

   This file documents Af, an advanced mail reader and composer with a
user interface similar to that of GNU Emacs.

   Copyright (C) 1996 Malc Arnold, Kay Dekker.  Derived in parts from
the GNU Emacs Manual, Eleventh Edition, Copyright (C) 1985, 1986, 1987,
1993, 1994, 1995 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "Distribution" and "GNU General Public
License" are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "Distribution" may be
included in a translation approved by the author instead of in the
original English, and the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: af.info,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

Characters, Keys and Commands
*****************************

   ASCII consists of 128 character codes.  Some of these codes are
assigned graphic symbols such as `a' and `='; the rest are control
characters, such as `Control-a' (usually written `C-a' for short).
`C-a' gets its name from the fact that you type it by holding down the
<CTRL> key while pressing `a'.

   Some control characters have special names, and special keys you can
type them with: for example, <RET>, <TAB>, <LFD>, <DEL> and <ESC>.  The
space character is usually referred to below as <SPC>, even though
strictly speaking it is a graphic character whose graphic happens to be
blank.

   On ASCII terminals, there are only 32 possible control characters.
These are the control variants of letters and `@[]\^_'.  In addition,
the shift key is meaningless with control characters: `C-a' and `C-A'
are the same character, and af cannot distinguish them.

   One af character set extension is that characters have an additional
modifier, called Meta.  Every character has a Meta variant; examples
include `Meta-a' (normally written `M-a', for short), `M-A' (not the
same character as `M-a', but those two characters normally have the
same meaning in af), `M-<RET>', and `M-C-a'.  For reasons of tradition,
we usually write `C-M-a' rather than `M-C-a'; logically speaking, the
order in which the modifier keys <CTRL> and <META> are mentioned does
not matter.

   Some terminals have a <META> key, and allow you to type Meta
characters by holding this key down.  Thus, `Meta-a' is typed by
holding down <META> and pressing `a'.  The <META> key works much like
the <SHIFT> key.  Such a key is not always labelled <META>, however, as
this function is often a special option for a key with some other
primary purpose.

   If there is no <META> key, you can still type Meta characters using
two-character sequences starting with <ESC>.  Thus, to enter `M-a', you
could type `<ESC> a'.  To enter `C-M-a', you would type `<ESC> C-a'.
<ESC> is allowed on terminals with <META> keys, too, in case you have
formed a habit of using it.

   ASCII terminals represent function keys as a special sequence of
ASCII characters.  Because of this, it is possible, although not
simple, to configure af to handle function and arrow keys.  (*note
Customisation::.)


File: af.info,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

Keys
====

   A "key sequence" ("key", for short) is a sequence of characters that
are meaningful as a unit--as "a single command."  Some af command
sequences are just one character; for example, just `C-n' is enough to
move down one line.  But af also has commands that take two or more
characters to invoke.

   If a sequence of events is enough to invoke a command, it is a
"complete key".  Examples of complete keys include `C-n', <RET>, `C-x
C-f' and `C-x 4 C-f'.  If it isn't long enough to be complete, we call
it a "prefix key".  The above examples show that `C-x' and `C-x 4' are
prefix keys.  Every key sequence is either a complete key or a prefix
key.

   Many single characters constitute complete keys in the standard af
command bindings.  A few of them are prefix keys.  A prefix key combines
with the following character to make a longer key sequence, which may
itself be complete or a prefix.  For example, `C-x' is a prefix key, so
`C-x' and the next character combine to make a two-character key
sequence.  Most of these key sequences are complete keys, including
`C-x C-f' and `C-x b'.  A few, such as `C-x 4' and `C-x r', are
themselves prefix keys that lead to three-character key sequences.
There's no limit to the length of a key sequence, but in practice
people rarely use sequences longer than four characters.

   By contrast, you can't add more characters onto a complete key.  For
example, the two-character sequence `C-n C-k' is not a key, because the
`C-n' is a complete key in itself.  It's impossible to give `C-n C-k'
an independent meaning as a command.  `C-n C-k' is two key sequences,
not one.

   All told, the prefix keys in af are `C-h', `C-t', `C-x' `C-x 4', and
<ESC>.  But this is not cast in concrete; it is just a matter of af
standard key bindings.  If you customise af, you can make new prefix
keys, or eliminate these (*note Key Bindings::.).

   If you do make or eliminate prefix keys, that changes the set of
possible key sequences.  For example, if you redefine `C-n' as a
prefix, `C-n C-k' automatically becomes a key (complete, unless you
define it too as a prefix).  Conversely, if you remove the prefix
definition of `C-x 4', then `C-x 4 f' (or `C-x 4 ANYTHING') is no
longer a key.


File: af.info,  Node: Commands,  Next: Major Modes,  Prev: Keys,  Up: Top

Keys and Commands
=================

   This manual is full of passages that tell you what particular keys
do.  But af does not assign meanings to keys directly.  Instead, af
assigns meanings to named "commands", and then gives keys their
meanings by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is usually
made of a few English words separated by dashes; for example,
`next-line' or `open-message'.  The bindings between keys and commands
are recorded in various tables called "keymaps" (*note Key Bindings::.).

   When we say that "`C-n' moves down vertically one line" we are
glossing over a distinction that is irrelevant in ordinary use but is
vital in understanding how to customise af.  It is the command
`next-line' that is programmed to move down vertically.  `C-n' has this
effect *because* it is bound to that command.  If you rebind `C-n' to
the command `end-of-buffer' then `C-n' will move to the end of the
buffer instead.  Rebinding keys is a common method of customisation.

   In the rest of this manual, we usually ignore this subtlety to keep
things simple.  To give the information needed for customisation, we
state the name of the command which really does the work in parentheses
after mentioning the key that runs it.  For example, we will say that
"The command `C-n' (`next-line') moves point vertically down," meaning
that `next-line' is a command that moves vertically down and `C-n' is a
key that is standardly bound to it.

   While we are on the subject of information for customisation only,
it's a good time to tell you about "variables".  Often the description
of a command will say, "To change this, set the variable `foobar'." A
variable is a name used to remember a value.  Most of the variables
documented in this manual exist just to facilitate customisation: some
command or other part of af examines the variable and behaves
differently according to the value that you set.  Until you are
interested in customising, you can ignore the information about
variables.  When you are ready to be interested, read the basic
information on variables, and then the information on individual
variables will make sense (*note Variables::.).


File: af.info,  Node: Major Modes,  Next: Minor Modes,  Prev: Commands,  Up: Top

Major Modes
===========

   Af has several modes of operation; known as "major modes".  A major
mode is in effect a subset of af, where a command may have a different
effect, and different commands may be available (This is probably the
most pronounced difference between af and Emacs; Emacs major modes just
alter its behaviour in minor ways, such as changing key bindings; while
af major modes may have a completely different set of commands and
behaviour).

   There are three major modes currently available in af.  "Mail mode"
is the mode used for buffers displaying mail messages; most af buffers
use mail mode.  "Minibuffer mode" is used to support the minibuffer; it
has no commands to handle mail messages, but many extra commands to
allow editing of text.  "Typeout mode" is the mode used for displaying
text to the screen.  Again, it has no commands to handle mail messages,
it simply allows you to browse text displayed on the screen.

   Each major mode allows you to bind keys independently of the other
major modes (just like in Emacs), so keys may be bound in only one
mode, or even be bound to different things in different modes (just as
they can in Emacs).  For example, in mail mode `<SPC>' just clears the
echo area, in minibuffer mode it inserts a space into the text you are
editing, and in typeout mode it scrolls the text up to display the next
page.

   Each af command may be available in all modes, or just in some of
them.  For example the command `open-message' is only available in mail
mode, since in the other modes you are not dealing with mail messages
and the command wouldn't make sense.  So you can't run the command
`open-message' in typeout mode even by typing `M-x open-message'.

   A command may also have slightly different behaviour in different
modes.  For example the command search-forward in mail mode searches
through the text of each mail message, looking some text.  In typeout
mode it searches through the text you are viewing instead.

   This distinction is only really important when customising af; when
you are using af it is (hopefully) quite obvious what commands are
likely to work.  The important thing to remember is that keys may do
very different things depending on whether you are browsing a list of
messages, entering an argument in the minibuffer, or viewing text.


File: af.info,  Node: Minor Modes,  Next: Entering Af,  Prev: Major Modes,  Up: Top

Minor Modes
===========

   A minor mode is a particular feature which can be turned on or off.
For example, `Read Only' mode selects whether you are allowed to modify
the contents of a buffer.  Unlike the major modes, the minor modes are
independent of each other, although they may only be valid in some major
modes.

   Minor modes are usually specific to a buffer, so they may be turned
on in some buffers and off in others.  Normally, minor modes are turned
on or off automatically in response to some situation.  There may also
be a command to turn the minor mode off if it is on, or on if it is
off; this will be formed from the prefix `toggle-' followed by the name
of the mode.  So the command to turn `Read Only' mode on or off is
`toggle-read-only'.


File: af.info,  Node: Entering Af,  Next: Exiting,  Prev: Minor Modes,  Up: Top

Entering and Exiting Af
***********************

   The usual way to invoke af is with the shell command `af'.  Af
clears the screen and then displays an initial help message and
copyright notice while it processes any startup files (*note Startup
Files::.), and then reads your incoming mailbox.  (If your mailbox is
small, you may not see the initial help message and copyright; it would
be very inconvenient for experienced users if af were to pause long
enough to let you read the message.)  When af has finished reading the
mailbox, it displays a final count of how many messages it read, and
displays the buffer containing the messages.

   Some operating systems discard all type-ahead when af starts up; they
give af no way to prevent this.  Therefore, it is advisable to wait
until af clears the screen before typing your first command.

   It is possible to specify folders to be visited, or details of a
message you want to send, by giving af arguments in the shell command
line (*note Command Arguments::.).  But you can do these things from
within af too; whether you run af once and suspend it, or separately
each time you want to read or send mail is simply a matter of taste.

   Arguments starting with `-' are "options".  Other arguments specify
addresses to send mail to.  If you specify addresses, then af doesn't
read any folders; it simply allows you to send a single mail message to
the addresses you supplied, and then exits.

   You can use options to specify various other things, such as which
folders to read, the subject for mail you're sending, and so on.  A few
options support advanced usage, such as running `afl' functions in
batch mode.  The sections of this chapter describe the available
options, arranged according to their purpose.

   Most options specify how to initialise af, or set parameters for the
af session.  We call them "initial options".  A few options specify
things to do: for example, read folders or load `afl' programs (*note
Afl::.).  These are called "action options".  These and file names
together are called "action arguments".  Af processes all the action
arguments in the order they are written.

* Menu:

* Command Arguments::   The command line arguments af accepts
* Command Examples::    Examples of using command line arguments.
* Environment::         Environment variables that af uses.


File: af.info,  Node: Command Arguments,  Next: Command Examples,  Up: Entering Af

Command Line Arguments
======================

   Here is a table of the arguments and options that af accepts:

`ADDRESS'
     Send mail to ADDRESS.  *Note Sending Mail::.  If addresses are
     supplied, then many of the other arguments are disabled, since af
     will not be visiting any folders.  If the standard input is not a
     terminal, then af will silently send the message as requested,
     rather than expecting you to edit the text of the message.

`-E'
     This option has two effects.  Firstly, it makes af start up to
     send a single mail message even if no addresses were given as
     arguments.  Secondly, it forces af to allow you to edit the text
     of the message you send, even if the text is being obtained from
     the standard input.  This doesn't really seem very useful, but
     occasionally it can be very handy in allowing you to write
     flexible scripts which send mail using af.

`-H'
     Force af to present the user with the headers of an outgoing
     message when editing it, or to force translation of headers in
     mail sent from the standard input.  In effect, it causes af's
     `edit-initial-headers' variable to be set to `true' regardless of
     the contents of the user's `.afrc' file (*note Variables: Sending
     Mail.).

`-s SUBJECT'
     Specifies the Subject: for an outgoing message.  Only one `-s'
     option may be given, and it only takes effect if addresses (or the
     `-E' option) were given on the command line.

`-f FOLDER'
     Read FOLDER in place of your incoming mailbox.  Multiple `-f'
     options may be given, in which case each folder is read into its
     own buffer.  This option is ignored if addresses or the `-E' option
     were given.

`-u USER'
     Read USER's incoming mailbox in place of your own.  You must have
     permissions to read USER's mailbox.  Multiple `-u' options may be
     given, and they may be mixed with `-f' options.  This option is
     ignored if addresses or the `-E' option were given.

`-F'
     Interpret any arguments other than options as folders to be read
     in, rather than addresses to send mail to.  This can be very
     useful if you want to read in a set of folders with `af -F *'.

`-w'
     Create enough windows to display all the folders given with the
     `-f', `-u' or `-F' options, subject to the maximum number of
     windows that will fit on the screen (usually about four on a
     24-line display).  This option is ignored if addresses or the `-E'
     option were given.

`-e'
     Check whether there is mail in your default mailbox (or, if `-f' or
     `-u' are given, any specified mailboxes) and then exit.  The exit
     status is zero if there is mail in any of the mailboxes; one if
     not.  This option is ignored if addresses or the `-E' option were
     given.

`-z'
     Makes af terminate immediately with an exit status of 1 if your
     incoming mailbox (or, if `-f' or `-u' are given, any specified
     folders) is empty.  Otherwise, af will start up normally.  This
     option is ignored if addresses or the `-E' option were given.

`-n'
     Ignore the file `.afrc' in the user's home directory.  *Note
     Startup Files::.

`-v'
     Prints the version of af and then exit.  Ignores the effect of any
     other options.

`-l LOADFILE'
     Specifies a file which should be read and executed on startup
     before any buffers are created.  Used with the `-n' option, this
     allows the user to specify an alternate startup file, rather than
     the default of `.afrc' in their home directory.

`-S FILE'
     Names a file of commands in af's internal language `afl'.  The
     commands in the file are read and executed exactly as if af had
     been started up interactively and then the af command `load-file'
     had been executed.  When all the commands in FILE have been
     executed, or if an error is encountered in the file, then af
     terminates.  If the `-S' option is given, then af will not display
     the screen; only messages will be printed to the standard output.
     Only one `-S' option may be given, it is ignored if destinations
     or the `-E' option were specified.


File: af.info,  Node: Command Examples,  Next: Environment,  Prev: Command Arguments,  Up: Entering Af

Command Line Examples
=====================

   Here are a few examples of af command line usage, with brief
explanations.

   Read two folders `foo' and `bar' into separate windows:

     af -f foo -f bar -w

   Check if there is any mail in folders foo and bar:

     af -e -f foo -f bar

   Send mail to `fred' on the local system with subject `Hi':

     af -s Hi fred

   Take a current directory listing, and use it as a base for some mail
to user `fred@foobar.co.uk':

     ls -l | af -E fred@foobar.co.uk

   Run the afl script in file `script.afl' with folder `foobar' as the
default buffer:

     af -S script.afl -f foobar


File: af.info,  Node: Environment,  Prev: Command Examples,  Up: Entering Af

Environment Variables
=====================

   Af uses several "environment variables".  An environment variable is
a string passed from the operating system to af, and the collection of
environment variables is known as the "environment".  Environment
variable names are case sensitive and it is conventional to use upper
case letters only.

   Because environment variables come from the operating system there
is no general way to set them; it depends on the operating system and
especially the shell that you are using.  For example, here's how to set
the environment variable `ORGANIZATION' to `Utter Chaos' using bash:
     export ORGANIZATION="Utter Chaos"

and here's how to do it in csh or tcsh:
     setenv ORGANIZATION "Utter Chaos"

   It should be noted that the environment variables are used to
*customise* af, not to configure it.  None of these variables are
required; and af should work correctly without them.  They simply serve
to tailor af to your taste.

   Here is a list of the environment variables af uses, with a brief
description of what they are used for.

`MAIL'
     The full path to your incoming mailbox.

`HOME'
     Your home directory.

`FOLDER'
     The directory where your mail folders are stored.  Defaults to
     `~/Mail'.

`SAVEDIR'
     The directory where your news folders are stored.  Defaults to
     `~/News'.

`TMPDIR'
     The directory where temporary files should be created.

`VISUAL, EDITOR'
     The editor to use for editing outgoing mail (or messages if you
     choose to edit them).  `VISUAL' overrides `EDITOR' if they are set
     to different values.

`PAGER'
     The program to use when you ask af to display a message via an
     external pager.

`NAME'
     Your real name.  Used for generating the headers on the messages
     you send.

`ORGANIZATION'
     your organisational affiliation.  If set, af will generate an
     Organization: header on the messages you send.


File: af.info,  Node: Exiting,  Next: Basics,  Prev: Entering Af,  Up: Top

Exiting af
==========

   There are two commands for exiting af because there are two kinds of
exiting: "suspending" af and "killing" af.

   "Suspending" means stopping af temporarily and returning control to
its parent process (usually a shell), allowing you to resume reading
mail later in the same af job, with the same buffers, same kill ring,
and so on.

   "Killing" af means destroying the af job.  You can run af again
later, but you will get a fresh af; there is no way to resume the same
mail reading session after it has been killed.

`C-z'
     Suspend af (`suspend-af')

`C-x C-c'
     Kill af (`save-buffers-kill-af').

`M-z'
     Kill af, automatically saving any changed buffers
     (`save-all-kill-af').

   To suspend af, type `C-z' (`suspend-af').  This takes you back to
the shell from which you invoked af.  You can resume af with the shell
command `%af' in most common shells.

   On systems that do not support suspending programs, `C-z' starts an
inferior shell that communicates directly with the terminal (`shell').
Af waits until you exit the inferior shell.  (The way to do that is
probably with `C-d' or `exit', but it depends on which shell you use).
The only way on these systems to get back to the shell from which af
was run (to log out, for example) is to kill af.

   To kill af, type `C-x C-c' (`save-buffers-kill-af').  A
two-character key is used for this to make it harder to type.  This
command first offers to save any modified file-visiting buffers.  If you
do not save them all, it asks for confirmation with `yes' before
killing af, since any changes not saved will be lost forever.

   To kill af, saving all modified file-visiting buffers, type `M-z'
(`save-all-kill-af').  We don't recommend using this, since you might
accidentally save changes you didn't mean to, but you can use `M-z' to
exit if you prefer.

   The operating system usually listens for certain special characters
whose meaning is to kill or suspend the program you are running.  This
operating system feature is turned off while you are in af.  The
meanings of `C-z' and `C-x C-c' as keys in af were inspired by the use
of `C-z' and `C-c' on several operating systems as the characters for
stopping or killing a program, but that is their only relationship with
the operating system.  You can customise these keys to run any commands
of your choice (*note Key Bindings::.).


File: af.info,  Node: Basics,  Next: Typeout,  Prev: Exiting,  Up: Top

Basic af Commands
*****************

   We now give the basics of how to read, save, and delete messages,
send mail to people and save your changes back to your mailbox.

* Menu:

* Reading Messages::    How to read the current message.
* Moving Point::        How to move around in a buffer.
* Scrolling::           How to scroll the messages on the screen.
* Deleting Messages::	Deleting and killing messages.
* Information::         Commands to get information.
* Quitting::            abort a key or command.
* Basic Help::          How to ask af what a key does.
* Arguments::   	Numeric arguments to repeat a command.


File: af.info,  Node: Reading Messages,  Next: Moving Point,  Up: Basics

Reading Messages
================

   The most basic operation in af is to "open" the current message; to
display it's contents via typeout (*note Typeout::.), or some other
pager.

`RET or C-o'
     Open the current message, using the pager named in the `pager'
     variable, usually `typeout'.  If the message is a MIME message,
     then use the pager named in the `mime-pager' variable instead if
     possible.

`M-<RET> or C-M-o'
     Open the current message, using the pager named in the `PAGER'
     environment variable.

   Normally, only mail headers not listed in the
`headers-not-displayed' variable will be displayed when you open a
message.  A positive numeric argument makes af display all the message's
headers.  A negative argument makes af skip all headers, and only
display the body of the message.  *Note Arguments:: for more information
on numeric arguments.

   If your external pager doesn't need af to pause after displaying the
message; then you can make reading messages more convenient by setting
the variable `pause-after-paging-message' to `true'.


File: af.info,  Node: Moving Point,  Next: Scrolling,  Prev: Reading Messages,  Up: Basics

Changing the Location of Point
==============================

   To do anything useful with af, you have to know how to move point
(*note Point::.).  There are several keys which move point within a
buffer.

`C-n or n'
     Move down one line, vertically (`next-line').

`C-p or p'
     Move up one line, vertically (`previous-line').

`M-.'
     Move point to the vertical centre of the window.
     (`move-to-window-line').  Text does not move on the screen.

     A numeric argument says which screen line to place point on.  It
     counts screen lines down from the top of the window (zero for the
     top line).  A negative argument counts lines from the bottom (-1
     for the bottom line).

`M-< or <'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M-> or >'
     Move to the end of the buffer (`end-of-buffer').

`C-g'
     Read a number N and move point to line number N (`goto-line').
     Line 1 is the beginning of the buffer.


File: af.info,  Node: Scrolling,  Next: Deleting Messages,  Prev: Moving Point,  Up: Basics

Scrolling
=========

   Since only part of a large buffer fits in the window, af tries to
show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the buffer you want to see.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').  A numeric argument N
     says to move point to screen line N.

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`M-v'
     Scroll backward (`scroll-down').

   The names of all scroll commands are based on the direction that the
messages move in the window.  Thus, the command to scroll forward is
called `scroll-up', since the messages move up.

   When scrolling a windowful at a time, af leaves two lines that were
visible before you scrolled still visible afterwards, so that you can
retain the context you were in before you scrolled.  The number of lines
of overlap across a `C-v' or `M-v' is controlled by the variable
`next-screen-context-lines'; by default, it is two.


File: af.info,  Node: Deleting Messages,  Next: Information,  Prev: Scrolling,  Up: Basics

Deleting Messages
=================

`C-k or k'
     Kill the current message, removing it from the folder
     (`kill-line').  *Note Killing and Yanking::.

`M-x delete-message'
     Mark the current message as deleted.  This doesn't actually delete
     the message until you save the buffer.  At that point any messages
     marked as deleted will be killed, and not written to the folder.

`M-x undelete-message'
     Remove the deleted marker from the current message; so that it
     will not be killed when you save the buffer.


File: af.info,  Node: Information,  Next: Quitting,  Prev: Deleting Messages,  Up: Basics

Message and Position information
================================

   Here are commands to get information about messages, and your
position in the buffer.

`M-='
     Print line number of point in the buffer (`what-cursor-position').

`C-x ='
     Print a short summary of some of the message's details in the echo
     area (`message-info').

`C-t ?'
     Print the message's tags in the echo area (`message-tags').  *Note
     Tags::.


File: af.info,  Node: Quitting,  Next: Basic Help,  Prev: Information,  Up: Basics

Quitting
========

   At any time in af except when a command is running, you can type
`C-g' (`keyboard-quit') to quit from what you are doing.  If you have
typed part of a command, or a numeric argument, then `C-g' will get rid
of it.  If there isn't a partial command to get rid of, but you are in
the minibuffer or typeout then typing `C-g' will exit back to the mail
buffer, aborting the command you were running.

   This means, that you can always get back to the top level of af by
typing `C-g C-g'.  This is useful for aborting commands, or if you are
unsure where you are in af.


File: af.info,  Node: Basic Help,  Next: Arguments,  Prev: Quitting,  Up: Basics

Help
====

   If you forget what a key does, you can find out with the Help
character, which is <C-h>.  Type `C-h k' followed by the key you want to
know about; for example, `C-h k C-n' tells you all about what `C-n'
does.  <C-h> is a prefix key; `C-h k' is just one of its subcommands
(the command `describe-key').  The other subcommands of <C-h> provide
different kinds of help.  Type <C-h> three times to get a description
of all the help facilities.  (*note Help::.).


File: af.info,  Node: Arguments,  Prev: Basic Help,  Up: Basics

Numeric Arguments
=================

   Any af command can be given a "numeric argument" (also called a
"prefix argument"), although it may be ignored.  Some commands
interpret the argument as a repetition count.  For example, `C-n' with
an argument of ten moves down ten lines instead of one.  With these
commands, no argument is equivalent to an argument of one.  Negative
arguments tell most such commands to move or act in the opposite
direction.

   If your terminal keyboard has a <META> key, the easiest way to
specify a numeric argument is to type digits and/or a minus sign while
holding down the <META> key.  For example,

     M-5 C-n

would move down five lines.  The characters `Meta-1', `Meta-2', and so
on, as well as `Meta--', do this because they are keys bound to
commands (`digit-argument' and `negative-argument') that are defined to
contribute to an argument for the next command.

   Another way of specifying an argument is to use the `C-u'
(`universal-argument') command followed by the digits of the argument.
With `C-u', you can type the argument digits without holding down
modifier keys; `C-u' works on all terminals.  To type a negative
argument, type a minus sign after `C-u'.  Just a minus sign without
digits normally means -1.

   `C-u' followed by a character which is neither a digit nor a minus
sign has the special meaning of "multiply by four".  It multiplies the
argument for the next command by four.  `C-u' twice multiplies it by
sixteen.  Thus, `C-u C-u C-n' moves down sixteen lines.  This is a good
way to move down "fast", since it moves about 2/3 of a screen in the
usual size screen.  `C-u' is also a handy way of providing an argument
when you don't care about the value.

   Many commands care only about whether there is an argument, and not
about its value.  Other commands care only about the sign of the
argument.  For example, the command `<RET>' (`open-message') with no
argument shows only some of the message's headers; with a positive
argument, it shows all the headers, and with a negative argument it
shows no headers at all.  This may seem strange, but it is a convenient
way of modifying the behaviour of a command.

   We use the term "prefix argument" as well as "numeric argument" to
emphasise that you type the argument before the command, and to
distinguish these arguments from minibuffer arguments that come after
the command.


File: af.info,  Node: Typeout,  Next: Minibuffer,  Prev: Basics,  Up: Top

Typeout
*******

   Typeout is the mode af uses to display large amounts of text such as
mail messages or help information.  When af uses typeout, the typeout
window appears, covering the entire screen apart from the echo area.
Once you exit typeout, the window disappears, "uncovering" the original
windows.

   If possible, each line of the text is displayed as a single line on
the screen.  If a line is too long to fit on a single screen line, then
it will be displayed on several screen lines, with a `\' at the extreme
right margin of all but the last of them.  The `\' says that the
following screen line is not really a distinct line in the text, but
just the "continuation" of a line too long to fit the screen.  This is
called "line wrapping", and the lines after the first are often
referred to as "continuation lines".

   When you are viewing typeout, the position indicator in the mode line
will often say `MOR'.  This is because typeout does not wait to read
the entire input before displaying the first page, and since af doesn't
know how many lines there are in the text yet, it will give the
position as `MOR' to indicate this.

   Sometimes, the typeout window will appear, but you will still be
able to carry on with some other operation (such as displaying the help
options via `C-h C-h C-h').  In these cases the typeout window will
disappear when the operation is completed.

   Within typeout, only the cursor motion commands, the scrolling
commands and the text searching commands can be used.  To exit typeout,
simply type `C-g'.  The other af commands are irrelevant when you are
just viewing text.  Here is a brief summary of the commands available in
typeout:

`<SPC>'
     Scroll the text up to show the next page of text.  If you are
     already at the end of the text, then exit typeout
     (`typeout-scroll').  This is a convenient way of paging through
     short amounts of text.

`C-v'
     Scroll forward (a windowful, or a specified number of lines)
     (`scroll-up').

`M-v'
     Scroll backward (a windowful, or a specified number of lines)
     (`scroll-down').

`C-n'
     Scroll forward one line (`next-line');

`C-n'
     Scroll backward one line (`previous-line');

`C-l'
     Redraw the display (`recenter').

`C-s REGEX <RET>'
     Search forward through the text for a line matching REGEX
     (`search-forward').  *Note Searching::.

`C-r REGEX <RET>'
     Search backward through the text for a line matching REGEX
     (`search-forward').  *Note Searching::.


File: af.info,  Node: Minibuffer,  Next: Sending Mail,  Prev: Typeout,  Up: Top

The Minibuffer
**************

   The "minibuffer" is the facility used by af commands to read
arguments more complicated than a single number.  Minibuffer arguments
can be file names, buffer names, af command names, address lists, and
many other things, depending on the command reading the argument.  You
can use many editing commands in the minibuffer to edit the argument.

   When the minibuffer is in use, it appears in the echo area, and the
terminal's cursor moves there.  The beginning of the minibuffer line
displays a "prompt" which says what kind of input you should supply and
how it will be used.  Often this prompt is derived from the name of the
command that the argument is for.  The prompt normally ends with a
colon.

   Sometimes a "default argument" appears in parentheses after the
colon; it too is part of the prompt.  The default will be used as the
argument value if you enter an empty argument (e.g., just type
`<RET>').  For example, commands that read buffer names always show a
default, which is the name of the buffer that will be used if you type
just `<RET>'.

   The simplest way to enter a minibuffer argument is to type the text
you want, terminated by `<RET>' which exits the minibuffer.  You can
cancel the command that wants the argument, and get out of the
minibuffer, by typing `C-g'.

   Sometimes, a "default response" will already be in the minibuffer
when you enter it.  If it is completely wrong, then you can type `C-a
C-k' to remove it.  These default responses appear for convenience when
you are prompted for a long value that you are likely to want to edit,
rather then retype from scratch.

   Most commands which use typeout allow you to redirect the output
into a file, instead of viewing it.  The major exception to this is
`<RET>' (`open-message'), since there are several ways to save a
message to a file.  To redirect typeout to a file simply give the
command a prefix argument of any value; you will be prompted for the
file name using the minibuffer.

* Menu:

* Echo Area Conflicts:: How af handles echoing in the minibuffer.
* Inserting Text::      How to enter text into the minibuffer.
* Deleting Text::       How to delete text in the minibuffer.
* Editing the Text::    Basic minibuffer editing commands.
* Dealing with Words::  Commands which act on words in the text.
* Completion::          An abbreviation facility for minibuffer input.
* Minibuffer History::  Reusing recent minibuffer arguments.


File: af.info,  Node: Echo Area Conflicts,  Next: Inserting Text,  Up: Minibuffer

Echo Area Conflicts
===================

   Since the minibuffer uses the screen space of the echo area, it can
conflict with other ways af customarily uses the echo area.  Here is
how af handles such conflicts:

   * If a command gets an error while you are in the minibuffer, this
     does not cancel the minibuffer.  However, the echo area is needed
     for the error message and therefore the minibuffer itself is
     hidden for a while.  It comes back after a few seconds, or as soon
     as you type anything.

   * If in the minibuffer you use a command whose purpose is to print a
     message in the echo area, such as `C-x =', the message is printed
     normally, and the minibuffer is hidden for a while.  It comes back
     after a few seconds, or as soon as you type anything.

   * Echoing of keystrokes does not take place while the minibuffer is
     in use.


File: af.info,  Node: Inserting Text,  Next: Deleting Text,  Prev: Echo Area Conflicts,  Up: Minibuffer

Inserting Text
==============

   To insert printing characters into the minibuffer, just type them.
This inserts the characters you type into the buffer at the cursor
(that is, at "point"; which has a different appearance in the
minibuffer, but the same meaning).  The cursor moves forward, and any
text after the cursor moves forward too.  If the text in the buffer is
`foobar', with the cursor before the `b', then if you type `xx', you get
`fooxxbar', with the cursor still before the `b'.  This all works
because in the minibuffer all the printing characters run the command
`self-insert-command'.

   Direct insertion works for printing characters and <SPC>, but other
characters act as editing commands and do not insert themselves.  If you
need to insert a control character or a character whose code is above
200 octal, you must "quote" it by typing the character `C-q'
(`quoted-insert') first.  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by three octal digits inserts the character with
     the specified character code.

A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::.).

   When you have finished entering the text, simply type `<RET>'
(`newline') to accept the argument and exit the minibuffer.


File: af.info,  Node: Deleting Text,  Next: Editing the Text,  Prev: Inserting Text,  Up: Minibuffer

Deleting Text
=============

   To "delete" a character you have inserted, use `<DEL>'
(`delete-backward-char').  <DEL> deletes the character *before* the
cursor (not the one that the cursor is on top of or under; that is the
character AFTER the cursor).  The cursor and all characters after it
move backwards.  Therefore, if you type a printing character and then
type `<DEL>', they cancel out.

   To delete the character that the cursor is under, use `C-d'
(`delete-char').  This deletes the character, moving all the characters
after the cursor backwards.  The cursor is left in place.  Therefore
`C-d' is equivalent to `C-f DEL'.

   To delete the text from the cursor to the end of the line, use `C-k'
(`kill-line').  This kills the characters from the one the cursor is
under to the end of the line, leaving the cursor at the end of the line
(*note Minibuffer Kills::.).


File: af.info,  Node: Editing the Text,  Next: Dealing with Words,  Prev: Deleting Text,  Up: Minibuffer

Editing the Text
================

   To edit the text in the minibuffer, you need to be able to move
around in the text.  There are several commands available to do this:

`C-a'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
     Move to the end of the line (`end-of-line').

`C-f'
     Move forward one character (`forward-char').

`C-b'
     Move backward one character (`backward-char').

`C-t'
     Transpose the two characters on either side of point, moving point
     forward one character (`transpose-chars').


File: af.info,  Node: Dealing with Words,  Next: Completion,  Prev: Editing the Text,  Up: Minibuffer

Dealing with Words
==================

   The minibuffer includes several commands for dealing with words
rather than characters.  Often these take the usual command for moving
point, but use a Meta key rather then a control key:

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`M-<DEL>'
     Delete the next word (`backward-kill-word').

`M-d'
     Delete the previous word (`kill-word').

`M-l'
     Convert the next word to lower case (`downcase-word').

`M-u'
     Convert the next word to upper case (`upcase-word').

`M-c'
     Capitalise the next word (`capitalize-word').


File: af.info,  Node: Completion,  Next: Minibuffer History,  Prev: Dealing with Words,  Up: Minibuffer

Completion
==========

   For certain kinds of arguments, you can use "completion" to enter
the argument value.  Completion means that you type part of the
argument, then af visibly fills in the rest, or as much as can be
determined from the part you have typed.

   When completion is available, certain keys--<TAB>, <RET>, and
<SPC>--are rebound to complete the text present in the minibuffer into
a longer string that it stands for, by matching it against a set of
"completion alternatives" provided by the command reading the argument.
`?' is defined to display a list of possible completions of what you
have inserted.

   For example, when `M-x' uses the minibuffer to read the name of a
command, it provides a list of all available af command names to
complete against.  The completion keys match the text in the minibuffer
against all the command names, find any additional name characters
implied by the ones already present in the minibuffer, and add those
characters to the ones you have given.  This is what makes it possible
to type `M-x del <SPC> m <RET>' instead of `M-x delete-message <RET>'
(for example).

   Case is often significant in completion, because it is significant in
many of the names that you can complete (buffer names and file names).
Thus, `fo' often does not complete to `Foo'.  Completion does ignore
case distinctions for certain arguments in which case does not matter
(such as af command or configuration variable names).

* Menu:

* Example: Completion Example.   An example of minibuffer completion.
* Commands: Completion Commands. Commands that completion uses.
* Strict Completion::            Types of minibuffer completion.


File: af.info,  Node: Completion Example,  Next: Completion Commands,  Up: Completion

Completion Example
------------------

   A concrete example may help here.  If you type `M-x co <TAB>', the
<TAB> looks for alternatives (in this case, command names) that start
with `co'.  There are only two: `copy-region-as-kill' and
`copy-tagset-as-kill'.  These are the same as far as `copy-', so the
`co' in the minibuffer changes to `copy-'.

   If you type `<TAB>' again immediately, there are multiple
possibilities for the very next character--it could be `r' or `t'--so
no more characters are added; instead, <TAB> just produces a beep.  If
you now type `?', af will produce a list of all possible completions to
typeout; when you exit typeout, the minibuffer is still waiting for the
next character.

   If you go on to type `r <TAB>', this <TAB> sees `copy-r'.  The only
command name starting this way is `copy-region-as-kill', so completion
fills in the rest of that.  You now have `copy-region-as-kill' in the
minibuffer after typing just `co <TAB> r <TAB>'.  Note that <TAB> has
this effect because in the minibuffer it is bound to the command
`minibuffer-complete' when completion is available.


File: af.info,  Node: Completion Commands,  Next: Strict Completion,  Prev: Completion Example,  Up: Completion

Completion Commands
-------------------

   Here is a list of the completion commands defined in the minibuffer
when completion is available.

`<TAB>'
     Complete the text in the minibuffer as much as possible
     (`minibuffer-complete').

`<SPC>'
     Complete the minibuffer text, but don't go beyond one word
     (`minibuffer-complete-word').

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described below
     (`minibuffer-complete-and-exit').

`?'
     Print a list of all possible completions of the text in the
     minibuffer (`minibuffer-list-completions').

   <SPC> completes much like <TAB>, but never goes beyond the next
hyphen or space.  If you have `copy-r' in the minibuffer and type
`<SPC>', it finds that the completion is `copy-region-as-kill', but it
stops completing after `region-'.  This gives `copy-region-'.  Another
<SPC> at this point completes to `copy-region-as-'.


File: af.info,  Node: Strict Completion,  Prev: Completion Commands,  Up: Completion

Strict Completion
-----------------

   There are three different ways that <RET> can work in completing the
minibuffer, depending on how the argument will be used.

   * "Strict" completion is used when it is meaningless to give any
     argument except one of the known alternatives.  For example, when
     `M-x' reads the name of a command to run, it is meaningless to
     give anything but the name of an existing command or macro.  In
     strict completion, <RET> refuses to exit if the text in the
     minibuffer does not complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     <RET> exits only if the text was an exact match already, not
     needing completion.  If the text is not an exact match, <RET> does
     not exit, but it does complete the text.  If it completes to an
     exact match, a second <RET> will exit.

     Cautious completion is used for reading file names for files that
     must already exist.

   * "Permissive" completion is used when any string whatever is
     meaningful, and the list of completion alternatives is just a
     guide.  For example, when `C-x C-f' reads the name of a folder to
     visit, any folder name is allowed, in case you want to create a
     folder.  In permissive completion, <RET> takes the text in the
     minibuffer exactly as given, without completing it.


File: af.info,  Node: Minibuffer History,  Prev: Completion,  Up: Minibuffer

Minibuffer History
==================

   Every argument that you enter with the minibuffer is saved on a
"minibuffer history list" so that you can use it again later in another
argument.  You can think of the minibuffer history as a buffer which
you can move through displaying a line at a time.

`C-p'
     Move to the next earlier argument string saved in the minibuffer
     history (`previous-line').

`C-n'
     Move to the next later argument string saved in the minibuffer
     history (`next-line').

`M-<'
     Move to the first argument string saved in the minibuffer history
     (`beginning-of-buffer').

`M->'
     Move to the last argument string saved in the minibuffer history
     (`end-of-buffer').  This will always move you to the text you were
     editing before using the minibuffer history.

`C-r'
     Move to an earlier saved argument in the minibuffer history that
     matches the current text (`search-backward').

`C-s'
     Move to a later saved argument in the minibuffer history that
     matches the current text (`search-forward')..

   The simplest way to reuse the saved arguments in the history list is
to move through the history list one element at a time.  While in the
minibuffer, type `C-p' to "move to" the previous minibuffer input, and
use `C-n' to "move to" the next input.  Similarly, you can use `C-<'
and `C->' to "move to" the first and last elements in the history list.

   When you move to a new history line, any text you had typed is stored
for you as the last history element, so you can return to it by typing
`M->'.  To use a history element as the argument, exit the minibuffer
as usual with <RET>.  You can also edit the text before you reuse it;
this does not change the history element that you "moved" to, but your
new argument does go at the end of the history list in its own right.

   There are also commands to search forward or backward through the
history.  At the moment they search for a history element that starts
with the text you have typed in the minibuffer, up to the position of
the cursor; so typing `list- C-r' will search for a history element
that begins with `list-'.  If a matching history element is found then
the cursor will stay in the same column, so that typing `C-r' again
will search for another history element beginning with `list-'.

