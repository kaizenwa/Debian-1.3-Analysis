<HTML><HEAD><TITLE>Exmh 1.6.6 - EXMH CUSTOM (1)</TITLE></HEAD><BODY>

<H1><CENTER>CUSTOMIZING EXMH</CENTER></H1>

<H2><A NAME="CONTENTS">Contents</A></H2><UL>
<H4><A HREF="#NAME">NAME</A></H4>
<H4><A HREF="#CUSTOMIZING EXMH">CUSTOMIZING EXMH</A></H4>
<H4><A HREF="#PREFERENCES">PREFERENCES</A></H4>
<H4><A HREF="#PREFERENCE SECTIONS">PREFERENCE SECTIONS</A></H4>
<H4><A HREF="#BINDING UI">BINDING UI</A></H4>
<H4><A HREF="#MH PROFILE">MH PROFILE</A></H4>
<H4><A HREF="#X RESOURCES">X RESOURCES</A></H4>
<H4><A HREF="#WIDGET CLASS HIERARCHY">WIDGET CLASS HIERARCHY</A></H4>
<H4><A HREF="#RESOURCES FOR BUTTONS">RESOURCES FOR BUTTONS</A></H4>
<H4><A HREF="#RESOURCES FOR MENUS">RESOURCES FOR MENUS</A></H4>
<H4><A HREF="#BUTTON GROUPS">BUTTON GROUPS</A></H4>
<H4><A HREF="#COLOR RESOURCES">COLOR RESOURCES</A></H4>
<H4><A HREF="#COLORIZING HEADERS">COLORIZING HEADERS</A></H4>
<H4><A HREF="#GEOMETRY AND POSITION RESOURCES">GEOMETRY AND POSITION RESOURCES</A></H4>
<H4><A HREF="#ICON POSIITONS">ICON POSIITONS</A></H4>
<H4><A HREF="#ICON APPEARANCE">ICON APPEARANCE</A></H4>
<H4><A HREF="#FOLDER DISPLAY RESOURCES">FOLDER DISPLAY RESOURCES</A></H4>
<H4><A HREF="#MIME RESOURCES">MIME RESOURCES</A></H4>
<H4><A HREF="#SEDIT BINDING RESOURCES">SEDIT BINDING RESOURCES</A></H4>
<H4><A HREF="#MISCELLANEOUS RESOURCES">MISCELLANEOUS RESOURCES</A></H4>
<H4><A HREF="#PROGRAMMING EXMH">PROGRAMMING EXMH</A></H4>
<H4><A HREF="#CODE ORGANIZATION">CODE ORGANIZATION</A></H4>
<H4><A HREF="#SEE ALSO">SEE ALSO</A></H4>
<H4><A HREF="#AUTHOR">AUTHOR</A></H4>
<H4><A HREF="#THANKS">THANKS</A></H4>
</UL>
<H3><A NAME="NAME" HREF="#CONTENTS">NAME</A></H3>
exmh-custom - A guide to customizing the exmh mail user interface.
<H3><A NAME="CUSTOMIZING EXMH" HREF="#CONTENTS">CUSTOMIZING EXMH</A></H3>
<P>This man page describes the four mechanisms used to customize <I>Exmh</I>:
Preferences, the MH profile, X resources, and custom Tcl code.
<P><I>Exmh</I> is built with the assumption that you will want to
customize it to some degree.
The simplest way is by the Preferences user interface,
which exposes numerous knobs and dials that you can adjust to
control a lot of the behavior of <I>exmh</I>.
The second way is by defining X resources.  You will need to do this
if you want to control fonts and colors.  It would be great if there
was a user interface for this, but this is something that has not
been crossed off the TODO list, yet.
You also use X resources to define new buttons and menus.
The third way is by adding custom Tcl code to the implementation
of <I>exmh</I>.  A personal library of Tcl routines is supported.  You 
can either add new buttons or menus to invoke your functionality,
or take advantage of some hook points inside <I>exmh</I> to slip
in your new feature.  It is also possible to completely replace
any module of the <I>exmh</I> implementation.
Finally, there are a few MH profile components introduced by
<I>exmh</I>, although these may eventually migrate out of
the profile and into the Preferences package.
<H3><A NAME="PREFERENCES" HREF="#CONTENTS">PREFERENCES</A></H3>
<P>After you have used <I>exmh</I> a little, you should explore all
its capabilities by clicking on the Preferences button.
There is a two-level preferences scheme, mainly because
there are too many knobs and dials.  At the top-level you
see a menu that corresponds to different modules of
the implementation.  Clicking on one of the items brings up
the preferences items for that module.
Use the Help button to display more detailed information
about the preference items.
If you click on the label of an item, the help text
is scrolled to the information for that item.
<P>There are three types of options you can set through the Preferences dialog:
choices, booleans, and general items.
Each of these are tied to a Tcl variable and an X resource name.
Changes in the Preference user interface change the value of the Tcl
variable, which affects the <I>exmh</I> runtime behavior.
Then, when you click <B>Save</B> in the dialog, the values are saved as
X resource settings in your ~/.exmh-defaults file.
<P>Choices are represented by radio-style buttons where only one button
in the set can be enabled at once.  Changes take effect immediately.
Booleans are represented by check-style buttons.  If the checkbox is
dark, then the option is turned on.  Changes take effect immediately.
Numeric and filename settings have entry widgets in which you can
type in a new value.  Press &lt;Return&gt; for the change to take effect
immediately (or choose <B>Save</B>).
<P>You can cycle through all the preference dialogs by using the <B>Next</B>
button, which takes you to the next preference section.
There is also a Prev button to go back.  You should take time at least
once to go through all the Preference sections to get an idea of
what sort of options are available.
<P>If you decide you like your settings, click <B>Save</B> in the main
Preferences dialog to save
them in a .exmh-defaults file in your home directory.
Click <B>Reset All</B> in the main dialog to restore all the settings
to those of your last <B>Save</B>.  Within each module's preference dialog
there is a <B>Reset</B> button that resets only those module's settings.
<P><I>Warning!</I>
If you click <B>Dismiss</B> in the main dialog, some preferences may have
been set for the current session, but they will not have been saved to
your ~/.exmh-defaults file.
<H3><A NAME="PREFERENCE SECTIONS" HREF="#CONTENTS">PREFERENCE SECTIONS</A></H3>
<P>Here is a short summary of the preference sections and what
features they control.  The Tcl module that the section
corresponds to is listed so you can dig into the code if you want to.
<DL>

<DT>
Hacking Support
<DD>
A debug log can be enabled, and you can define the directory
for personal Tcl code. (main.tcl)

<DT>
MH Tweaks
<DD>
Background sending can be enabled. The naming convention for
deleted files (leading , or #) is set.
The age of files to purge can be defined. (mh.tcl)

<DT>
Simple Editor
<DD>
Formatting parameters can be adjusted
and automatic signatures can be enabled. (sedit.tcl)

<DT>
Editor Support
<DD>
An external editor, spell program, and MHN command can be defined. (editor.tcl)

<DT>
Printing
<DD>
The print command can be defined.  You can also enter an
arbitrary UNIX command to apply to a message. (print.tcl)

<DT>
Scan Listing
<DD>
You set the number of lines in the scan listing here.
There are several tweaks on message viewing: Implied Direction,
Next Guard, Auto Commit, Advance After Link, Show
New Messages, Skip Marked.  You can also choose the
scan format width here. (ftoc.tcl)

<DT>
MIME
<DD>
There are several adjustments you can make to the MIME message display.
Note that the font sizes chosen here do not affect non-MIME
messages. (mime.tcl)

<DT>
WWW
<DD>
Exmh can communicate with an external HTML viewer (e.g., Mosaic or netscape)
in order to display pages from the World Wide Web.
It can scan the current message for embedded URL.
The URLs are changed into active text buttons.  Click on one
and the web browser is asked to display the page.
Use the preferences to choose the external viewer and to
control if the URL scanning is done automatically. (uri.tcl)

<DT>
Incorporate Mail
<DD>
The method you use to Inc can be set.
You can set inc to run when you start exmh and when
you open the exmh window. (inc.tcl)

<DT>
Windows &amp; Scrolling
<DD>
Scrolling speed and parameters related to constrained text
scrolling can be defined.
Constrained scrolling keeps the last line of text
stuck to the bottom of the text display. (exwin.tcl and widgetText.tcl)

<DT>
Folder Cache
<DD>
Set how many lines are in your folder cache display, and
what folders are permanently in your folder cache. (fcache.tcl)

<DT>
Folder Display
<DD>
Set the number of rows of labels in the folder display.
The style of nested folder display is controlled here. (fdisp.tcl)

<DT>
Sound
<DD>
The sound effects can be controlled. (sound.tcl)

<DT>
Faces
<DD>
The use of the facesaver database and the decompression
of X-Face components can be controlled. (faces.tcl)

<DT>
PGP interface
<DD>
You choose whether <I>exmh</I> can remember your pass phrase or
if all PGP programs are run under an xterm instead. (pgp.tcl)

<DT>
Background Processing
<DD>
What actions occur in the background, and how frequently. (background.tcl)

<DT>
FS Box
<DD>
The file selector has a few parameters, including the threshold size
for large directories and whether or not you want to see files
whos names begin with a period.

<DT>
Busy Indicator
<DD>
What method of signaling that exmh is busy. (busy.tcl)
</DL>
<H3><A NAME="BINDING UI" HREF="#CONTENTS">BINDING UI</A></H3>
<P>There are a number of keystroke bindings already defined by <I>exmh</I>
that invoke different Tcl commands.  You can change the bindings
and add bindings for new commands via the Bind dialog.
Open the dialog from the <I>Commands</I> menu entry under the Bindings menu.
The dialog presents a scrollable column of commands and their bindings,
plus an area at the top to define a new binding.
<P><B>Binding Syntax</B>.
The following is a very brief summary of the Tk bind syntax.
For the complete story,
consult the Tk man page for the <I>bind</I> command.
The Tk syntax for the bindings events looks like this:
<BLOCKQUOTE><PRE>&lt;<I>modifier</I>-<I>type</I>-<I>detail</I>&gt;
</PRE></BLOCKQUOTE>
A <I>modifier</I> is a key that you hold down while pressing another key.
The modifiers you are likely to use are listed below.
Capitalization is important.
<BLOCKQUOTE><PRE>Control
Shift
Meta
</PRE></BLOCKQUOTE>
The <I>type</I> is the event type, and it can left out if the detail part
implies the type.  The types you will usually use are:
<BLOCKQUOTE><PRE>Key
Button
</PRE></BLOCKQUOTE>
The <I>detail</I> specifies the key or button number for the event.
Keys are named by their X keysym.  For the letters and digits, the
keysym is just the letter or digit, e.g., &lt;Key-a&gt;, which can
be shortened to &lt;a&gt;.  For punctuation, however, the keysyms are words.
Here are some examples, and again the Key type is left out.
<BLOCKQUOTE><PRE>&lt;comma&gt;
&lt;period&gt;
&lt;dollar&gt;
&lt;asciicircum&gt;
&lt;question&gt;
&lt;exclam&gt;
</PRE></BLOCKQUOTE>
Perhaps the easiest way to figure out the keysym is to use the following
Tcl/Tk command.  Run the Tcl/Tk shell, wish, and enter this command.
Then type with the mouse over the little window it displays.
<BLOCKQUOTE><PRE>bind . &lt;Any-Key&gt; {puts stdout &quot;keysym = %K letter = %A&quot;}
</PRE></BLOCKQUOTE>

<H3><A NAME="MH PROFILE" HREF="#CONTENTS">MH PROFILE</A></H3>
<P><I>Exmh</I> uses a couple of things from your .mh_profile file, including
several components that are new.
<DL>

<DT>
Header-Suppress and Header-Display
<DD>
You control what headers are displayed in a message with a combination
of the Header-Suppress and Header-Display profile components.
Hidden headers are just scrolled off the top of the message display window.
Each of these profile components is a list of <I>regular expression patterns</I>
that are used to
match against the header.  Case is <I>not</I> significant in the patterns.
Its easiest to explain by giving the algorithm that uses these patterns.
<BLOCKQUOTE><PRE>By default, show all headers.
If a header is in the Header-Suppress list, do not show it.
If a header is in the Header-Display list, show it.

The default values for these profile components are:

Header-Suppress: .*
Header-Display: Subject To From Date Cc
</PRE></BLOCKQUOTE>
</DL>
<P>If you are a mail junky, you may want to use Header-Suppress to
explicitly suppress the boring header componets you already
know about.  The new, interesting
components inserted by random mailers will be displayed for
you to check out.  In contrast, the default for Header-Suppress will
hide everything, and you explicitly
choose what headers you want to see by setting Header-Display.
<DL>

<DT>
Folder-Order
<DD>
The Folder-Order component defines a sort ordering for your folder labels
in the folder display area.  Each item in the order can be the
name of a folder, or a <I>string match</I> pattern to match on the folder names.
All folder names that match the same pattern are sorted alphabetically.
Longer pattern matches have priority over shorter patterns.
The patterns use the syntax of Tcl's string match function, which is
similar to that used in many shells.
<BLOCKQUOTE><PRE>* matches a sequence of any characters.
? matches any character.

The default Folder-Order puts your inbox first.

Folder-Order: inbox *

My Folder-Order looks like:

Folder-Order: personal exmh mxedit * mail* sun m3 mach background

</PRE></BLOCKQUOTE>
</DL>
<P>The other effect of Folder-Order is to define a traversal order for
visiting folders with unread mail in them.  When you do a Next and are
at the end of a folder, <I>exmh</I> will automatically change folders
to the next one in the Folder-Order that has unseen messages, if any.
When there are no more folders with unseen mail, then you will change
back to the first folder in your Folder-Order, unless you disable
this by turning off the <I>Cycle back to first</I> preference setting
under the Unseen Folders section.
<DL>

<DT>
Folder-Unseen
<DD>
The Folder-Unseen component lets you constrain
the search through folders for the
ones with messages in the unseen message sequence.  Its value is a set
of <I>string match</I> patterns that are matched against folder names.
If a folder name matches the pattern, it is searched for unseen messages.
If the pattern begins with a !, however, then a folder that matches
the pattern (not including the !) is excluded from the search.
The default is *, which matches everything.  Put the negated patterns
first in your list of patterns (e.g., !junk* inbox*).

<DT>
Folder-Ignore
<DD>
The Folder-Ignore component specifys a set of <I>string match</I>
patterns for folder names
you want to ignore.  These folders are not even displayed by exmh.
It defaults to &quot;.* */.* */*/.* */*/*.*&quot; , which causes <I>exmh</I> to
ignore directories whose name begins with a period.

<DT>
Draft-Folder
<DD>
The Draft-Folder component is used to know where to put messages being composed.
<I>Exmh</I> will ask you if it is ok to create a Draft-Folder entry
if you do not already have one.

<DT>
ExmhShowProc
<DD>
The ExmhShowProc component lets you define a program that pre-filters
a message before displaying it.  If an ExmhShowProc is defined,
then <I>exmh</I> runs that program with the current message as the
standard input and displays what is generated on the program's standard
output.  Note that the Header-Suppress and
Header-Display mechanism is still used even if you have a special
show proc.

<DT>
Scan-Proc
<DD>
The Scan-Proc component can be used to define an alternative scan program.
If you change the scan format, you need to make sure that the first
item on each scan line is the message number.
<I>Exmh</I> depends on this.  (It makes no attempt to decipher scan formats.)

<DT>
MailDrop
<DD>
The MailDrop component is required if you do not have your system
mail spool file in the &quot;standard&quot; location, which is typically
/usr/spool/mail/<I>username</I>.  If you do not define MailDrop
correctly then Inc will not do anything because it will not file
your new messages in the system spool file.

<DT>
Path
<DD>
The Path component is used to find your mail folders.  <I>Exmh</I> will
abort if this entry is not there on the presumption that
you have not set yourself up to use MH properly.
</DL>
<H3><A NAME="X RESOURCES" HREF="#CONTENTS">X RESOURCES</A></H3>
<P>The X resource database is used as a repository of Preference settings,
window positions, and definitions of fonts, colors, buttons, and menus.
The information in the database can come from a variety of sources,
which can be confusing.
The default values come from the <B>app-defaults</B> file that is kept
in the script library directory for <I>exmh</I>.
Color-specific resources are contained in the
app-defaults-color or app-defaults-mono file.
One of these two is used depending on the display.
<P>A site administrator can add local resource specifications in the
local-app-defaults file.  Put this into the exmh script library
directory (the same place as app-defaults).
To handle site-specific color-specific resources,
<I>exmh</I> will also read the local.app-defaults-color
or local.app-defaults-mono if those files exist.
<P>Each user has a ~/.exmh-defaults file in their
home directory.  To handle personal color-specific resources,
<I>exmh</I> will also read your ~/.exmh-defaults-color
or ~/.exmh-defaults-mono if those files exist.
<P>I do not recommend putting exmh-related resource settings in your
~/.Xdefaults, although you can do that.
If you do, be warned that values from the ~/.Xdefaults file and
the RESOURCE_MANAGER property on the root window will be
overridden by things in your ~/.exmh-defaults file.
<P>The ~/.exmh-defaults file is divided into sections.
The first section is for things you add by hand.
The remaining sections are automatically managed by <I>exmh</I>.
If you manually add settings to your ~/.exmh-defaults file, 
add entries to the <I>beginning</I> of this file.
Add them  before the
comment about the rest of the file being automatically
generated and you will not lose your changes.
<P>If a resource has a multiword
value, you *should not quote* the value in the resource file.
The right way to specify these in your ~/.exmh-defaults file is shown below.
The leading &quot;*&quot; gets around quirks in the way Tk names its applications;
different instances of the application have different names.
<BLOCKQUOTE><PRE>*scrollbarSide:      left
*c_current: violet red
</PRE></BLOCKQUOTE>
<P>Finally, if you are really serious about fiddling with resources, you
should look through the app-defaults file.  For one thing, there is
no guarantee that the resource names used in this man page,
which correspond to version 1.5, will be exactly the same in
later versions of <I>exmh</I>.
Furthermore, there might be new goodies
that appear in future versions that are not described here.
Only by reading the app-defaults file of the current
version will you be sure you are setting things correctly in
your ~/.exmh-defaults file.
(<I>Hint:</I> read through the main exmh script for the definition
of the exmh(library) Tcl variable, which is the script library
where app-defaults lives.  The script is short, and the definition
is near the beginning.)
<H3><A NAME="WIDGET CLASS HIERARCHY" HREF="#CONTENTS">WIDGET CLASS HIERARCHY</A></H3>
<P>If you want to dive into the widget tree and fiddle with fonts and colors
and such, here are the class descriptions.  I also highly recommend
the <I>tkinspect</I> program, which you can find in the Tcl archives.
<DL>

<DT>
Main
<DD>
Top row of buttons and title label

<DT>
Fdisp
<DD>
Folder label display

<DT>
Fltop
<DD>
Folder label display when it is in a detached toplevel.

<DT>
Fops
<DD>
Folder operation buttons and folder label

<DT>
Ftoc
<DD>
Folder table of contents display

<DT>
Mid
<DD>
Frame around Face, Msgid, Status, Mops

<DT>
Mid.Face
<DD>
Bitmap display

<DT>
Mid.Right.Status.label
<DD>
Message label

<DT>
Mid.Right.Status.msg
<DD>
Status line

<DT>
Mid.Right.Mops
<DD>
Message buttons

<DT>
Msg
<DD>
Message display

<DT>
Clip
<DD>
Detached message display

<DT>
Sedit
<DD>
Simple editor top-levels

<DT>
Help
<DD>
Help window

<DT>
Key
<DD>
Color key window

<DT>
Pref
<DD>
Preferences dialogs

<DT>
Log
<DD>
Error/debug log

<DT>
Pick
<DD>
The pick dialog

<DT>
Glimpse
<DD>
The glimpse dialog

<DT>
NewFolder
<DD>
The new folder dialog.

<DT>
DeleteFolder
<DD>
The delete folder dialog.

<DT>
WhatNow
<DD>
The What Now? dialog.

<DT>
Error
<DD>
Error popups

<DT>
Dialog
<DD>
General popups
</DL>
<H3><A NAME="RESOURCES FOR BUTTONS" HREF="#CONTENTS">RESOURCES FOR BUTTONS</A></H3>
<P><I>exmh</I> uses X resources to specify its
buttons and menus on the main display, the editor window,
and the What Now dialog.
You can add a button to one of these areas of the user interface
by listing it in a <B>ubuttonlist</B> resource
and then adding
some more resources that describe the button.
X resource names are hierarchical, and these are the button list
resources used by <I>exmh</I>.
<BLOCKQUOTE><PRE>*Main.ubuttonlist
*Fops.ubuttonlist
*Mops.ubuttonlist
*Sedit.Menubar.ubuttonlist
*WhatNow.ubuttonlist
</PRE></BLOCKQUOTE>
<B>Fops</B> is the set of folder operation buttons.
Mops is the set of message operations buttons.
<B>Sedit.Menubar</B> is the buttons in the built-in editor.
<B>WhatNow</B> is the What Now dialog used with external editors.
The <B>ubuttonlist</B>
resource is necessary because there is no easy way to enumerate the
contents of the resource database.
<P>There are actually several resources associated with each set of
buttons in order to provide maximum flexibility.  
There are three sources of button definitions:
system buttons are defined by the base release (&quot;at the factory&quot;);
local buttons are defined by your site administrator;
user buttons are defined by each user.
In addition, the site and the user can delete buttons with other resources.
The resources are:
<BLOCKQUOTE><PRE>buttonlist    The list of system defined buttons
lbuttonlist   The list of local (site) defined buttons
ubuttonlist   The list of user defined buttons
l-buttonlist  The list of buttons deleted at the local level.
u-buttonlist  The list of buttons deleted at the user level.
</PRE></BLOCKQUOTE>
When <I>exmh</I> creates a set of buttons, (e.g., the *Main buttons),
t asks for the definition of all these
resources to determine what buttons are being defined
(e.g., *Main.buttonlist, *Main.ubuttonlist, and so on.)
For each of these buttons, additional resources specify the
text label and command for each button.
This is best explained
by an example.  Here are the definitions for the main buttons:
<BLOCKQUOTE><PRE>*Main.buttonlist:    quit pref alias
*Main.quit.text:     Quit
*Main.quit.command:  Exmh_Done
*Main.pref.text:     Preferences
*Main.pref.command:  Preferences_Dialog
*Main.alias.text:    Aliases
*Main.alias.command: Aliases_Pref
</PRE></BLOCKQUOTE>
The <B>*Main.buttonlist</B> resource names the buttons that
appear in the top row of buttons.  Its value, in turn causes
<I>exmh</I> to look around for the other resources that define the
text and command attributes for each button.  The command is a Tcl command,
and most are simple commands of one or two words.
If you are really inspired you can set many different attributes of
a Tk button via resources, but you'll have to consult the Tk man page
on <I>button</I> for the details.
<P>As another example, here is how you would add a Repl button to the
message buttons.  By default, there are a few variations on Reply under
the Reply... menu.  You might like a Repl button that does your most
common form of reply.  The <B>Msg_Reply</B> Tcl command takes regular
arguments for the MH <I>repl</I> program.
<BLOCKQUOTE><PRE>*Mops.ubuttonlist: myrepl
*Mops.myrepl.text: Repl
*Mops.myrepl.command: Msg_Reply -filter myrepl.filter -cc all
</PRE></BLOCKQUOTE>
<P>If you hate the Reply... menu altogether, you can remove it by
adding it to the u-buttonlist resource.
You'll have to look at the master app-defaults file to find out
the internal name of each button.
<BLOCKQUOTE><PRE>*Mops.u-buttonlist:  reply
</PRE></BLOCKQUOTE>
<H3><A NAME="RESOURCES FOR MENUS" HREF="#CONTENTS">RESOURCES FOR MENUS</A></H3>
<P>The menus in <I>exmh</I> are defined in a similar way.
It is a little more complex because there is more to a menu
than a button, but the general idea is the same.  There are parallel
sets of resources for the system-defined and user-defined parts.
Each section has a list of menus defined
with the following resources:
<BLOCKQUOTE><PRE>menulist      The list of system defined menus
lmenulist     The list of local (site) defined menus
umenulist     The list of user defined menus
l-menulist    The list of menus deleted at the local level.
u-menulist    The list of menus deleted at the user level.
</PRE></BLOCKQUOTE>
<P>Each menu, in turn, has a <B>text</B> resource that defines
the label on the menubutton.
The <B>entrylist</B> resource lists
the entries that are found under the menu.
Again, the system-defined entries are listed under <B>entrylist</B>,
the administrator defines <B>lentrylist</B>,
and users are meant to add new entries to <B>uentrylist</B>.
System (or local) defined entries can be removed by adding them to
the <B>l-entrylist</B> and <B>u-entrylist</B> resources.
<P>For each menu entry there are resources with the following naming
convention (this is not standard Tk):
if the entrylist item is <I>foo</I>, then:
<BLOCKQUOTE><PRE>l_<I>foo</I> defines the label (text) for the entry.
c_<I>foo</I> defines the command.
t_<I>foo</I> defines the type: &quot;command&quot;, &quot;check&quot;, &quot;radio&quot;, &quot;cascade&quot;, or &quot;separator&quot;.
v_<I>foo</I> defines the variable associated with check and radio entries.
m_<I>foo</I> defines the menu associated with cascade entries.
</PRE></BLOCKQUOTE>
For more information, it might be helpful to consult the Tk
man page for <I>menu</I>.
For example, here is how the main menus for exmh are defined:
<BLOCKQUOTE><PRE>*Main.menulist:             bind help

*Main.bind.text:     Bindings
*Main.bind.m.entrylist: command sedit
*Main.bind.m.l_command: Commands
*Main.bind.m.c_command: Bind_Pref
*Main.bind.m.l_sedit:       Simple Edit
*Main.bind.m.c_sedit:       Sedit_Pref

*Main.help.text:     Help
*Main.help.m.entrylist:     help colorkey faq
*Main.help.m.l_colorkey:    Color Legend
*Main.help.m.c_colorkey:    Help_KeyDisplay
*Main.help.m.l_help: Quick Intro
*Main.help.m.c_help: Help
*Main.help.m.l_faq:  Frequently Asked Questions
*Main.help.m.c_faq:  Help FAQ
</PRE></BLOCKQUOTE>
<P>Note the additional <B>.m</B> component in the <B>*Main.help.m.entrylist</B>
resource name.  The <B>*Main.help</B> resource corresponds to the menubutton,
and <B>*Main.help.m</B> corresponds to the menu associated with that button.
<P>For another example, we can use
the <B>uentrylist</B> resource to add a new menu entry to
the message More... menu.  It will be a check-button type entry that will set
the Tcl variable that controls the &quot;skip marked&quot; behavior of
Next and Prev.  In addition,
we will separate the user-defined entries from the system entries
with a special separator menu entry.
The resources
in your ~/.exmh-defaults would look something like this:
<BLOCKQUOTE><PRE>*Mops.more.m.uentrylist: sep skip
*Mops.more.m.t_sep: separator
*Mops.more.m.t_skip: check
*Mops.more.m.l_skip: Skip marked messages
*Mops.more.m.v_skip: ftoc(skipMarked)
</PRE></BLOCKQUOTE>
<P>In this case the Tcl variable is <B>ftoc(skipMarked)</B>,
which is an element of an associative Tcl array.
Menu entries that use Tcl variables defined by <I>exmh</I>
might stop working in a future release.  However, you can easily
get an idea of what the important variables are by searching through
the code for Preferences_Add calls.  These calls set up the releationship
between the internal Tcl variables and the Preference items you see
in the interface.  In most cases the variables are elements of
an associative array.  In this example, <B>ftoc</B> is the array that
holds the state variables for ftoc.tcl, which implements the
scan listing.
<H3><A NAME="BUTTON GROUPS" HREF="#CONTENTS">BUTTON GROUPS</A></H3>
<P>When you use <I>exmh</I>, you will notice that some of the message
buttons are disabled when there is no current message.
This is implemented by putting the Mops buttons and menu entries into
groups.  The group membership is defined via resources.
The groups are <I>current</I>, <I>range</I>, and nodraft.
The current group contains
all the buttons and menu entries that are enabled when
there is a current message.
The range group contains buttons and menu entries that can
be applied to multiple messages.
The nodraft group is for those buttons and menu entries that
ought to be disabled when you are in the drafts folder.
<P>For each group there are several corresponding resources that
list the buttons, (system, local, and user), and menu entries,
(system, local, and user), in the group.
These are the group-defining resources and (part of) their
default values.
<BLOCKQUOTE><PRE>*Mops.g_current:     link move delete reply forward
*Mops.gm_current:    Print {Unmark (Undo)} Clip Redistribute {Burst Digest}
*Mops.lg_current:
*Mops.lgm_current:
*Mops.ug_current:
*Mops.ugm_current:
*Mops.l-g_current:
*Mops.l-gm_current:
*Mops.u-g_current:
*Mops.u-gm_current:

*Mops.g_range:              link move delete forward
*Mops.gm_range:             Print Unmark {Mark Unseen}
*Mops.lg_range:
*Mops.lgm_range:
*Mops.ug_range:
*Mops.ugm_range:
*Mops.l-g_range:
*Mops.l-gm_range:
*Mops.u-g_range:
*Mops.u-gm_range:

*Mops.g_nodraft:     reply forward
*Mops.gm_nodraft:    Redistribute
*Mops.lg_nodraft:
*Mops.lgm_nodraft:
*Mops.ug_nodraft:
*Mops.ugm_nodraft:
*Mops.l-g_nodraft:
*Mops.l-gm_nodraft:
*Mops.u-g_nodraft:
*Mops.u-gm_nodraft:
</PRE></BLOCKQUOTE>
The naming convention for buttons and menu entries is different.
The buttons are named the same way they appear in the <B>buttonlist</B>
resource specification.  The menu entries are named by their
textual label.  If a menu entry label includes spaces, then the
label must be grouped.  Braces are used for compatibility with the
Tcl grouping syntax.
<P><I>Warning!</I> If you 
move things between the *Mops.buttonlist and the
*Mops.more.m.entrylist, then you will have to adjust your group settings
because the naming convention for buttons and menus is
different.
<H3><A NAME="COLOR RESOURCES" HREF="#CONTENTS">COLOR RESOURCES</A></H3>
<P>The basic TK widget color attributes are listed below.
Most of these are defined in app-defaults-color to obtain
a family of gray levels.
<DL>

<DT>
background
<DD>
The main background of a widget.  Default is a light gray (#efefef)

<DT>
foreground
<DD>
The foreground, (e.g., for text).  Default is black.

<DT>
activeBackground
<DD>
The background of a button or menu when the mouse is over it.  Default is white.

<DT>
activeForeground
<DD>
The foreground of a button or menu when the mouse is over it.  Default is black.

<DT>
disabledForeground
<DD>
The foreground color of a button or menu that has been disabled.  Default is grey50.

<DT>
selectBackground
<DD>
The background of text when it is selected.  Default is canary blue.

<DT>
highlightColor
<DD>
The color of the focus highlight rectangle when a widget has focus.  Default is black.

<DT>
highlightBackground
<DD>
The color of the focus highlight rectangle when a widget does not have focus.  Default is the same gray as background.

<DT>
selector
<DD>
The color of the checkbutton and radiobutton glyph when the button is selected.  Default is black.

<DT>
troughColor
<DD>
The &quot;other background&quot; for scrollbars and scales.  Default is gray (#dfdfdf)
</DL>
<P>You can specify colors for particular classes of widgets.  All the labels
are blue in exmh, by default, because of the following in app-defaults:
<BLOCKQUOTE><PRE>*Label.foreground: blue
</PRE></BLOCKQUOTE>
<P>The following resources are used to control the looks in the scan listing and
folder label display.  The fact that some have a trailing Bg or Fg is
purely historical accident.  Originally you could only specify the
foreground (for current and unseen) or the background (for moved and
deleted) but now, for the benefit of greyscale users, you can specify
all of them.  You might also look at the fdispColor.tcl and ftocColor.tcl
files that use these resources.
<DL>

<DT>
c_current
<DD>
The color for the current message and current folder.  Default is violet red.

<DT>
c_currentBg
<DD>
The background color for the current message.  Default is white.

<DT>
c_unseen
<DD>
The color for unseen messages and folders that contain unseen messages.
Default is blue.

<DT>
c_unseenBg
<DD>
The background color for unseen messages.  Default is normal background
(same as text widget default background).

<DT>
c_moved
<DD>
The background color for messages that are marked for refile,
and the background label color for the target folder for refile.
Default is yellow.

<DT>
c_movedFg
<DD>
The foreground color for messages that are marked for refile.
The default is normal forground.

<DT>
c_deletedFg
<DD>
The foreground color for messages marked for delete.  Default is normal foreground.

<DT>
c_foreground
<DD>
The foreground color for labels in the folder display.  Default is black.

<DT>
c_background
<DD>
The background color for labels in the folder display.  Default is white.

<DT>
c_popup
<DD>
The color for the popups that display nested folders.  Default is grey.

<DT>
c_st_normal
<DD>
The color for normal status messages.  Default is blue.

<DT>
c_st_error
<DD>
The color for error messages. Default is purple.

<DT>
c_st_warn
<DD>
The color for warning messages.  Default is red.

<DT>
c_st_background
<DD>
The color for messages from the background process.  Default is medium sea green.

<DT>
c_uri
<DD>
The color used to highlight URL and URN text by the Highlight URI function.
The default is thistle.
</DL>
<H3><A NAME="COLORIZING HEADERS" HREF="#CONTENTS">COLORIZING HEADERS</A></H3>
<P>A set of resources are used to specify colors and other font attributes of
message headers.
<DL>

<DT>
m_tagnames
<DD>
This defines a list of mail headers for which you want to define
special looks when they are displayed in the message area.
For each tagname, you should define another resource with name
m_<I>tagname</I>
(e.g, m_subject) that has the text tag configuration options
for that header line.  Consult the Tk man page on the text widget
to see what sort of tag configuration options there are.
In addition, two special tagnames are used for defaults if there
are no more specific matching tag name.  &quot;default&quot; applies to
displayed headers, while &quot;hidden&quot; applies to hidden ones (scrolled off the top).
</DL>
<P>For example, here is what I
have in my own ~/.exmh-defaults file:
<BLOCKQUOTE><PRE>*m_tagnames:  hidden subject from x-filters-matched
*m_hidden:    -font 6x10
*m_default:   -foreground black
*m_subject:   -foreground blue
*m_x-phase-of-moon:  -foreground blue
*m_from:      -foreground &quot;medium sea green&quot;
</PRE></BLOCKQUOTE>
<H3><A NAME="GEOMETRY AND POSITION RESOURCES" HREF="#CONTENTS">GEOMETRY AND POSITION RESOURCES</A></H3>
<P>Exmh automatically remembers the position of top-level windows,
both within a session and between successive runs of <I>exmh</I>.
It does this by saving some <B>position</B> resource
specifications in your ~/.exmh-defaults file.
In addition, <I>exmh</I> will remember the geometry of the main window
and of the detached folder display.
<P><I>Warning</I>:  If you use a virtual root window manager,
the memory of a window location will cause problems if you
start <I>exmh</I> in a new &quot;room&quot;.  If you move <I>exmh</I> to
a new room, you'll have to edit your ~/.exmh-defaults and delete
all the *position resource specifications.
Or, you can turn off the <I>Remember Window Positions</I>
preference item under Window Stuff.
Then, when exmh exits, it removes these for you.
<P>You can adjust the width and height of
some of the text windows.
Here are the default values.  
<DL>

<DT>
*Fltop*Canvas.width:
<DD>
300

<DT>
*Fltop*Canvas.height:
<DD>
100

<DT>
*Sedit*Text.width:
<DD>
80

<DT>
*Sedit*Text.height:
<DD>
24

<DT>
*Clip*Text.width:
<DD>
80

<DT>
*Clip*Text.height:
<DD>
48

<DT>
*Help*Text.width:
<DD>
80

<DT>
*Help*Text.height:
<DD>
30

<DT>
*Log*Text.width:
<DD>
80

<DT>
*Log*Text.height:
<DD>
20
</DL>
<H3><A NAME="ICON POSIITONS" HREF="#CONTENTS">ICON POSIITONS</A></H3>
<P>The <B>iconposition</B> resources specify the location of
the icons, both for the main window and the detached folder display (if any).
The format is +X+Y to specify the upper-left hand point.
If you use - instead of +, then the position is relative to
the lower-right corner instead of the upper-left corner.
By default no position is specified so your window manager
will place the icon.  The <B>iconic</B> resource indicates the
startup disposition of the window.
<DL>

<DT>
exmh.iconposition:
<DD>
(empty - no default position)

<DT>
exmh.iconic:
<DD>
0

<DT>
*Fltop.iconposition:
<DD>
(empty - no default position)

<DT>
*Fltop.iconic:
<DD>
0

</DL>
<H3><A NAME="ICON APPEARANCE" HREF="#CONTENTS">ICON APPEARANCE</A></H3>
<P>You can control the bitmap and the label on the icon.
There are three states for the icon:
no mail, spooled mail, and unread mail.
For each of these states you can define a bitmap and a label.
The label can include references to exmh variables,
as you will see in the default values.
The value for the Bitmap is a file name.  If it is relative
then it is assumed to be in the exmh script library.
Specify an absolute pathname otherwise.
<DL>

<DT>
*iconUpBitmap:
<DD>
flagup.bitmap

<DT>
*iconDownBitmap:
<DD>
flagdown.bitmap

<DT>
*iconSpoolBitmap:
<DD>
flagup.bitmap

<DT>
*iconUpLabel:
<DD>
$flist(newMsgs) Unseen

<DT>
*iconDownLabel:
<DD>
exmh

<DT>
*iconSpoolLabel:
<DD>
$exmh(numUnInced) Spooled
</DL>
<P>You can reference any global exmh variable in the icon label.
The two most useful are $flist(newMsgs), which is a count
across all folders of messages in the unseen sequence,
and $exmh(numUnInced), which is the number of messages in
your system spool file.  This later value is only computed by
the background &quot;count&quot; operation.

<H3><A NAME="FOLDER DISPLAY RESOURCES" HREF="#CONTENTS">FOLDER DISPLAY RESOURCES</A></H3>
<DL>

<DT>
fl_font
<DD>
The font for the labels in the folder display. Default is &quot;fixed&quot;.

<DT>
fl_xgap
<DD>
The horizontal gap, in pixels, between labels in the folder display.
The default is 8.

<DT>
fl_ygap
<DD>
The vertical gap, in pixels, between labels in the folder display.
The default is 8.

<DT>
fl_curbutton
<DD>
The button that choses the current folder in the folder display.
The default is 1. (1=left, 2=middle, 3=right).

<DT>
fl_navbutton
<DD>
The button that navigates nested folders in the folder display.
The default is 2. (1=left, 2=middle, 3=right).

<DT>
fl_tarbutton
<DD>
The button that choses the target folder for refile in the folder display.
The default is 3. (1=left, 2=middle, 3=right).

</DL>
<H3><A NAME="MIME RESOURCES" HREF="#CONTENTS">MIME RESOURCES</A></H3>
<P>Resources are used to define the set of understood MIME types
and to define the font families used to display messages
in various character sets.
<DL>

<DT>
mimeTypes
<DD>
This lists the Content-Types for which handler procedures are defined.
For each of these there is a corresponding mime_<I>content/type</I>
resource that specifies the Tcl command used to display a part of
that type.  <B>mimeUTypes</B> is the parallel resource so that users can
add content types of their own.
For example:
<BLOCKQUOTE><PRE>text/plain text/richtext text/enriched multipart/mixed 
       multipart/digest multipart/parallel multipart/alternative 
       application/octet-stream message/external-body message/rfc822 
       image/gif
*mimeUTypes:

*mime_text/plain:           Mime_ShowText
*mime_text/richtext:        Mime_ShowRichText
*mime_text/enriched:        Mime_ShowRichText
*mime_multipart/mixed:             Mime_ShowMultipart
*mime_multipart/digest:            Mime_ShowMultipartDigest
*mime_multipart/parallel:   Mime_ShowMultipartParallel
*mime_multipart/alternative:       Mime_ShowMultipartAlternative
*mime_application/octet-stream:    Mime_ShowApplicationOctet
*mime_message/external-body:       Mime_ShowMessageExternal
*mime_message/rfc822:              Mime_ShowRfc822
*mime_image/gif:            Mime_ShowImage
</PRE></BLOCKQUOTE>

<DT>
mimeCharsets
<DD>
A font has a character set, which is an encoding for the characters.
This is an optional parameter to the text Content-type.
us-ascii is the basic ASCII charset, which lacks special characters
used in many European languages.
The iso-8859-1 character set has 8-bit characters and is used to
encode accented and other special characters used
in latin-based languages.
The iso-8859-8 is used for hebrew.
The iso-2022-jp is used for kanji.
You need a specialized version of the Tk toolkit to display kanji.
<BLOCKQUOTE><PRE>*mimeCharsets: us-ascii iso-8859-1 iso-8859-8 iso-2022-jp
*mimeUCharsets:
*mime_us-ascii_registry:    iso8859
*mime_us-ascii_encoding:    *
*mime_iso-8859-1_registry:  iso8859
*mime_iso-8859-1_encoding:  1
*mime_iso-8859-8_registry:  iso8859
*mime_iso-8859-8_encoding:  8
*mime_iso-2022-jp_registry:   jisx0208.1983
*mime_iso-2022-jp_encoding:   *
</PRE></BLOCKQUOTE>

<DT>
mime_<I>charset</I>_plain_families
<DD>
A font has a family that determines the basic look for the font,
like times or helvetica.  Each of the family resources specifies
a list of families that are tried, in order, to find a font
that is supported by the X server.
The plain family resource lists a set
of font families that are used for ordinary text/plain messages.
<BLOCKQUOTE><PRE>*mime_us-ascii_plain_families:     fixed clean lucidatypewriter courier terminal
*mime_iso-8859-1_plain_families:   lucidatypewriter fixed courier terminal
*mime_iso-8859-8_plain_families:   fixed
*mime_iso-2022-jp_plain_families:     fixed
</PRE></BLOCKQUOTE>

<DT>
mime_<I>charset</I>_fixed_families
<DD>
The fixed families are used to display fixed-width fonts.
Fixed is one of the types allowd by text/enriched fonts.
<BLOCKQUOTE><PRE>*mime_us-ascii_fixed_families:     lucidatypewriter fixed clean courier terminal
*mime_iso-8859-1_fixed_families:   lucidatypewriter fixed courier terminal
*mime_iso-8859-8_fixed_families:   fixed
*mime_iso-2022-jp_fixed_families:     fixed
</PRE></BLOCKQUOTE>

<DT>
mime_<I>charset</I>_proportional_families
<DD>
The proportional families are used for text/enriched.
<BLOCKQUOTE><PRE>*mime_us-ascii_proportional_families:     times &quot;new century schoolbook&quot; 
                                   lucidabright charter lucida helvetica
*mime_iso-8859-1_proportional_families:   times &quot;new century schoolbook&quot; 
                                   lucidabright charter lucida helvetica
*mime_iso-8859-8_proportional_families:   
*mime_iso-2022-jp_proportional_families:
</PRE></BLOCKQUOTE>

<DT>
mime_<I>charset</I>_title_families
<DD>
The title families are used for menu and section titles.
<BLOCKQUOTE><PRE>*mime_us-ascii_title_families:     times &quot;new century schoolbook&quot; 
                            lucidabright charter lucida helvetica
*mime_iso-8859-1_title_families:   times &quot;new century schoolbook&quot; 
                            lucidabright charter lucida helvetica
*mime_iso-8859-8_title_families:   
*mime_iso-2022-jp_title_families:
</PRE></BLOCKQUOTE>

<DT>
mimeExtMethods
<DD>
This resource lists thte set of external access methods
for use with message/external-body MIME parts.
For each of these methods there is a corresponding
resource that lists the Tcl command that handles the
access method.
<BLOCKQUOTE><PRE>*mimeExtMethods:     local-file anon-ftp
*mimeUExtMethods:
*mime_local-file:    MimeLocalFileTransfer
*mime_anon-ftp:             MimeFTPTransfer
</PRE></BLOCKQUOTE>
</DL>
<H3><A NAME="SEDIT BINDING RESOURCES" HREF="#CONTENTS">SEDIT BINDING RESOURCES</A></H3>
<P><DL>

<DT>
sedit_typeKillsSel
<DD>
Set to 1 or 0 to enable or disable type-in-kills selection:
if there is selected text, typing new characters delete the selection.

<DT>
sedit_scrollButton
<DD>
Set to Middle (the default), Shift-Middle, or Right,
to control which button is used for drag-scrolling text widgets.

<DT>
sedit_editprocs
<DD>
This is a list of built-in editing functions.  It doesn't really
make sense to change this unless you edit seditBind.tcl to provide
an implementation for the edit function.

<DT>
sedit_key_<I>function</I>
<DD>
There is a corresponding resource for each function listed in sedit_editprocs.
The value of the resources is one or more event sequences that trigger
the function.

</DL>
<H3><A NAME="MISCELLANEOUS RESOURCES" HREF="#CONTENTS">MISCELLANEOUS RESOURCES</A></H3>
<P><DL>

<DT>
helpInOneWindow
<DD>
Set this to 1 to get a new preferences interface.
</DL>
<H3><A NAME="PROGRAMMING EXMH" HREF="#CONTENTS">PROGRAMMING EXMH</A></H3>
<P><I>Exmh</I> is implemented as a Tcl/Tk script that uses the MH
programs to manage your mail.  The script is interpreted at runtime
and is therefore distributed in source form.  You can read the source
to figure out what really going on.  Furthermore, you can take advantage
of the Tcl library facility in order to override parts of the implementation.
Warning:  it is easy to add new Tcl procedures, or to replace whole
modules (i.e., files) of the exmh implementation.  It is more awkward
to override the definition of a single Tcl procedure, as explained below.
<P>By the way, if you do anything interesting to the sources, send the
results to Brent.Welch@sun.com so they can be folded back into
the master sources.  Many of the good features in <I>exmh</I> came
about this way.
<P>Even if you do not know Tcl you can probably figure it out as
you read through the source.  There is not enough room here to
talk in any detail about Tcl programming.  There are reasonably
good on-line manual pages that come with Tcl and Tk.  There are
books about Tcl, too.  John Ousterhout, the creator of Tcl and Tk,
has written <I>Tcl and the Tk Toolkit</I>, by Addison-Wesley.
I have written <I>Practical Programming in Tcl and Tk</I>,
published by Prentice-Hall, ISBN 0-13-182007-9.
<P>Your custom Tcl code is kept in your ~/.tk/exmh directory.
You maintain this as a Tcl library, which amounts to keeping a file
called <B>tclIndex</B> up-to-date.  This index file records which files
implement which Tcl procedures.  The normal Tcl shells (tclsh and wish)
provide a Tcl command <B>auto_mkindex</B> that generates this file for
you.  Within a Tcl shell you use it like this:
<BLOCKQUOTE><PRE>auto_mkindex ~/.tk/exmh  *.tcl
</PRE></BLOCKQUOTE>
The first argument is a directory name, and the second argument is
a filename pattern, which is usually *.tcl.  If you add a new file or
procedure to this directory, remember to update the index by running
this command.
<P>The Tcl library facility is used by <I>exmh</I> for the main sources,
too.  The implementation has been chopped up into over 50 files,
and these are loaded on demand as different features of <I>exmh</I>
are invoked.
The per-user library directory is search first, which means you
can replace parts of the <I>exmh</I> implementation.  While this is
quite flexible, it is not ideal.  The natural unit of replacement is
a whole file, which might contain several Tcl procedures, even though
you only want to change one.  Also, when a new <I>exmh</I> release comes
out, there might be incompatibilities with your customized code.
<P>NOTE: if you use TclX, then the auto_path stuff is different and the
personal library seems not to work.  If you figure out the right
thing to do in auto_path_update (in the main <I>exmh</I> script), let me know.
<P>In most cases you will merely supply new code as opposed to replacing
(i.e., fixing) parts of the implementation.  Because you can define
buttons and menus that invoke this new code without touching the
released sources, you should be able to graft on new functionality
somewhat cleanly.
<P>The user.tcl file contains two empty hook procedures,
User_Init and User_Layout.  User_Init is called early, before most
other modules are initialized.  User_Layout is called late, just
after the widget tree has been created and basically every module
initialized.
<P><I>IMPORTANT</I>You must supply both User_Init and User_Layout because of the way
Tcl auto-loading works.  Just copy user.tcl and edit it.
<P>You should be able to override individual Tcl procs
in User_Layout without having them trashed by the auto load facility.
In this case you'd just source a file that has the new definitions.
It turns out that Tcl procs have a global scope, so you could also
just define the procs right inside User_Layout.  Say, for example, you
hate the constrained text scrolling.  Try this:
<BLOCKQUOTE><PRE>proc User_Layout {} {
    # This procedure is called late, after WidgetTextYview has
    # been defined by the Exmh library. Let's override it now.
    proc WidgetTextYview { t args } {
       eval {$t yview} $args
    }
}
</PRE></BLOCKQUOTE>
<P>There are some optional hook procedures with names beginning with
Hook_.  These procedures are called if they exist, so you do not
need stub versions if you don't use them.  
Because of the way the library facility works, though, you
have to include your Hook procedures in your copy of user.tcl
or source the file that contains them from inside your User_Init
procedure.
<P>In addition, you can have
several hook procedures called from the same point by appending
things to the standard hook names.  That is, the implementation will
call all procedures that match the pattern Hook_Foo*, so you could
define Hook_FooBrent and Hook_FooWelch and both would be called at
the Foo hook point.  The hook points are:
<DL>

<DT>
Hook_FolderChange $folder
<DD>
Called after you changed into the named folder.

<DT>
folderHook(enter,$folder)
<DD>

<DT>
folderHook(leave,$folder)
<DD>
The <B>folderHook</B> array can be used to define enter and leave hooks
for a folder.  Just set these array elements to be the Tcl commands you
want invoked before and after the folder change.

<DT>
Hook_CheckPoint
<DD>
Called at Quit time.

<DT>
Hook_SeditSend $draft
<DD>
Called as a message is being sent.  The argument is the
pathname of the draft message.  You could frob the message
here before it is delivered.  If this raises an error,
the message is not sent.

<DT>
Hook_MsgShow $pathname mimeHdr
<DD>
Called before a message is displayed.  The first argument is the
pathname of the message file.  The second is the name of an array
that contains the header information plucked out of the message.
Because of multipart messages, the elements of the array look like:

<DT>
mimeHdr(0=1,hdrs)
<DD>
Lists all the headers defined in the message.  The header keys
are downcased (from, to, subject, etc.).

<DT>
mimeHdr(0=1,hdr,<I>key</I>)
<DD>
Contains the header line with the given <I>key</I>, e.g. <B>from</B> or <B>subject</B>.
</DL>
<P>Note that the MsgParseFrom procedure, which is
defined in msgShow.tcl, will extract the address part
of a header line, so use it as a starting point for your code.
<H3><A NAME="CODE ORGANIZATION" HREF="#CONTENTS">CODE ORGANIZATION</A></H3>
<P>I've tried to split up <I>exmh</I> into meaningful modules,
separating out display modules (e.g., fdisp) from those that
maintain display-independent data structures (e.g., flist).
Things like the Find and Pick dialogs are in their own file,
so you can easily replace those.
I have not documented the interfaces between modules at all,
so you'll have to read some code.
Note that the .tcl file names
reflect the names of the procedures defined in them so you
can locate definitions.  In addition, many modules use a single
global array to hold their state variables, and this array variable
has the same name as the module.
<P>If you are really interested in the internals of exmh
(i.e., something about it really bugs you!) you can look into
the implementation in order to see what is wrong and how you
might do things better.  The following is a list of the files
in the implementation along with a short explaination of what
the Tcl procedures in it are for.
<DL>

<DT>
exmh.MASTER
<DD>
This is the main script.  It gets patched with site-dependent information
and the results are written to <I>exmh</I>, which gets installed.
It doesn't define much because it loads just about everything from
the script library.

<DT>
exmh-bg.MASTER
<DD>
This is the main script for the background process.  It redefines a few
procedures, and loads in the rest of its implementation from the library.
The initial rendez-vous between the background process is implemented
in this script and in some supporting routines in background.tcl

<DT>
install.tcl
<DD>
These are supporting routines for the installation process.  This should
be generic enough for use with your own Tcl application.  Feel free
to borrow it.

<DT>
exmh.install
<DD>
This is the installation script for exmh.

<DT>
exmh-async
<DD>
This is the wrapper for external editors.
</DL>
<P>The remainder of the files are kept in the script library.
<P><DL>

<DT>
aliases.tcl
<DD>
A browser for the MH aliases file.

<DT>
audit.tcl
<DD>
Maintain an audit log of mail handling operations.

<DT>
background.tcl
<DD>
The background processing module.  This can run in a separate process
or as part of the main process.  The BgRPC routine is used to
invoke a background operation, and it works in either case.

<DT>
bindings.tcl
<DD>
This has the default bindings and the implementation of the
binding user interface.

<DT>
busy.tcl
<DD>
Three different ways to indicate that exmh is busy doing something.

<DT>
buttons.tcl
<DD>
The resource-based button and menu implementation.

<DT>
cutbuffer.tcl
<DD>
A stub for the C cutbuffer extension.

<DT>
dragNdrop.tcl
<DD>
Drag-and-drop for exmh.

<DT>
editor.tcl
<DD>
The interface to editors for message composition.

<DT>
env.tcl
<DD>
Environment variable initialization.

<DT>
error.tcl
<DD>
The error handler.

<DT>
extrasInit.tcl
<DD>
This has Init routines for optional modules.  The idea is to
avoid loading their complete implementation until they
are actually used.

<DT>
exwin.tcl
<DD>
The main window display is set up here.
The code that remembers where toplevel windows go is here.

<DT>
faces.tcl
<DD>
The interface to the faces database.

<DT>
fcache.tcl
<DD>
The folder cache display.

<DT>
fdisp.tcl
<DD>
The main folder display.

<DT>
fdispColor.tcl
<DD>
The color definitions for the folder display.

<DT>
fdispPopup.tcl
<DD>
The nested folder popup implementation.

<DT>
fileselect.tcl
<DD>
The file selection dialog.

<DT>
find.tcl
<DD>
The find dialog.

<DT>
flag.tcl
<DD>
The appearance of the icon is managed here.

<DT>
flist.tcl
<DD>
The set of unseen folders is managed by this module.

<DT>
folder.tcl
<DD>
Folder operations like Folder_Change and Folder_Commit.

<DT>
folderNew.tcl
<DD>
The folder create and delete dialogs.

<DT>
ftoc.tcl
<DD>
The scan listing (folder table-of-contents).

<DT>
ftocColor.tcl
<DD>
Color definitinos for the highlights in the scan listing.

<DT>
ftocFind.tcl
<DD>
The search routines over the scan listing.

<DT>
help.tcl
<DD>
Some very simple help text and a color key.

<DT>
import.tcl
<DD>
Routines to import folders from UCB mail.

<DT>
inc.tcl
<DD>
Several ways to incorporate mail.

<DT>
labels.tcl
<DD>
There are three labels in the display - can you see them?

<DT>
mailcap.tcl
<DD>
Routines to parse the mailcap files.

<DT>
main.tcl
<DD>
The main Exmh procedure, plus Exmh_Status and Exmh_Debug.

<DT>
mh.tcl
<DD>
A basic layer on top fo the MH commands.

<DT>
mime.tcl
<DD>
The mime display code.

<DT>
mosaic.tcl
<DD>
Code to request Mosaic to display an HTML page.

<DT>
msg.tcl
<DD>
Message operations - although these tend to be distributed
partly among ftoc.tcl and mh.tcl as well.

<DT>
msgShow.tcl
<DD>
This used to be the main message display code,
but it has become dwarfed by the mime display.

<DT>
partial.tcl
<DD>
Code to concatinate the parts of a message/partial MIME message.

<DT>
pgp.tcl
<DD>
An interface to the Pretty Good Privacy system.

<DT>
pgpEWN.tcl
<DD>
This implements the PGP function in the external editor What Now dialog.

<DT>
pgpExec.tcl
<DD>
This executs the PGP program to get things done.

<DT>
pgpMatch.tcl
<DD>
This looks for keys in your keyring.

<DT>
pgpMisc.tcl
<DD>
This has the main post-processing hook for messages.

<DT>
pick.tcl
<DD>
An interface to the MH <I>pick</I> program.

<DT>
preferences.tcl
<DD>
The preferences user interface.

<DT>
print.tcl
<DD>
Routines to print messages.

<DT>
ps.tcl
<DD>
Code to rummage through the process table.  OS-specific.

<DT>
report.tcl
<DD>
This impelemnts the Bug Report and Register New User forms.

<DT>
rich2tk.tcl
<DD>
This parses text/enriched MIME content-types.

<DT>
scan.tcl
<DD>
This manages the scan caches.

<DT>
sedit.tcl
<DD>
The main routines for the built-in editor.

<DT>
seditBind.tcl
<DD>
The keybindings for the built-in editor.

<DT>
seditCompose.tcl
<DD>
The mapping for the Compose key sequences that allow
input of 8-bit characters.

<DT>
seditEnriched.tcl
<DD>
The composition of text/enriched is implemented here.

<DT>
seditExtras.tcl
<DD>
More editor stuff, like Whom, Spell, Sign, Find, and
the dialogs associated with Insert Part.

<DT>
seditMime.tcl
<DD>
The MIME multipart structuring is implemented here.

<DT>
seditQP.tcl
<DD>
This is code to handle 8-bit characters via the MIME
quoted-printable encoding.

<DT>
select.tcl
<DD>
The keyboard selection of folders and messages is implemeted here.

<DT>
sound.tcl
<DD>
Sound effects.

<DT>
text.tcl
<DD>
Some text tagging routines.

<DT>
textButton.tcl
<DD>
An implementation of a pseudo-button in a text widget.

<DT>
textSelect.tcl
<DD>
The main guts of text bindings.

<DT>
thread.tcl
<DD>
This displays the messages related to the current subject.

<DT>
uri.tcl
<DD>
The code that scans messages for URLs.

<DT>
user.tcl
<DD>
Stubs for User_Init and User_Layout.

<DT>
widgetMenu.tcl
<DD>
Support for the popup menus used in MIME messages.

<DT>
widgetText.tcl
<DD>
Contrained text scrolling and dragging a selection off the
window is handled by the routines here.

<DT>
widgets.tcl
<DD>
A basic layer on top of the Tk widgets.  These routines integrate
the pack geometry manager.  Even more important, they guard
against errors that occur because of missing fonts.
You should try and use these instead of the straight
Tk widget commands.

<DT>
xns.tcl
<DD>
An interface to xnsgetmail for those folks with mail on an XNS mail server.
</DL>
<H3><A NAME="SEE ALSO" HREF="#CONTENTS">SEE ALSO</A></H3>
<A HREF="exmh-use.n.html">exmh-use</A>, <A HREF="exmh-ref.n.html">exmh-ref</A>, <A HREF="exmh.n.html">exmh</A>, mh
<H3><A NAME="AUTHOR" HREF="#CONTENTS">AUTHOR</A></H3>
Brent.Welch@Sun.COM
<H3><A NAME="THANKS" HREF="#CONTENTS">THANKS</A></H3>
To Xerox PARC/CSL, for supporting this work initially,
to Sun Microsystems Laboratories for continuing the support,
and to all the <A HREF="exmh.n.html">exmh</A> users that contributed ideas and code.

<HR>
[ <A HREF="../exmh/contents.html">exmh</A> ]
</BODY></HTML>
