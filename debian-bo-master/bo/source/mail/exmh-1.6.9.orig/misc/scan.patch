
This is the patches for the MH scan command to enable it to
view Non-ASCII text mail headers.

It looks for the MM_CHARSET environment variable to decide
if it is able to show you the received character set.  This
environment variable is also used by mhn and metamail. If
the received encoded header does not match your MM_CHARSET,
it will be left alone.

To enable this code, set the RFC1342 option in your MH
config file.

I hope this is complete, but i might have missed something
when i tried to separate this patch out of my somewhat
hacked mh source.

--
anders@ifi.uio.no

The diff for formatsbr.c has been corrected.
/Frederik H. Andersen, fha@dde.dk

diff -rN -x *.ifi -c mh-6.8.3/conf/makefiles/sbr mh.ifi/conf/makefiles/sbr
*** mh-6.8.3/conf/makefiles/sbr	Wed Dec  1 05:00:23 1993
--- mh.ifi/conf/makefiles/sbr	Thu Aug 25 10:26:52 1994
***************
*** 50,56 ****
  		ruserpass.c \
  @END: NORUSERPASS
  		showfile.c smatch.c sprintb.c ssequal.c strindex.c trimcpy.c \
! 		uleq.c uprf.c vfgets.c formatdef.c m_msgdef.c
  
  
  OFILES	=	add.o adios.o admonish.o addrsbr.o advertise.o advise.o \
--- 50,56 ----
  		ruserpass.c \
  @END: NORUSERPASS
  		showfile.c smatch.c sprintb.c ssequal.c strindex.c trimcpy.c \
! 		uleq.c uprf.c vfgets.c formatdef.c m_msgdef.c rfc1342.c
  
  
  OFILES	=	add.o adios.o admonish.o addrsbr.o advertise.o advise.o \
***************
*** 69,75 ****
  		ruserpass.o \
  @END: NORUSERPASS
  		showfile.o smatch.o sprintb.o ssequal.o strindex.o trimcpy.o \
! 		uleq.o uprf.o vfgets.o formatdef.o m_msgdef.o
  
  @BEGIN: SHAREDLIB
  ODEFS	=	formatdef.o m_msgdef.o
--- 69,75 ----
  		ruserpass.o \
  @END: NORUSERPASS
  		showfile.o smatch.o sprintb.o ssequal.o strindex.o trimcpy.o \
! 		uleq.o uprf.o vfgets.o formatdef.o m_msgdef.o rfc1342.o
  
  @BEGIN: SHAREDLIB
  ODEFS	=	formatdef.o m_msgdef.o
  
*** mh-6.8.3/sbr/formatsbr.old.c	Fri Mar 31 09:55:12 1995
--- mh-6.8.3/sbr/formatsbr.c	Thu Mar 30 14:21:12 1995
***************
*** 358,372 ****
--- 358,387 ----
      long l;
      char        *savestr;
      char	buffer[BUFSIZ];
+     char	workbuff[BUFSIZ];
  
      while (cp < ep) {
  	switch (fmt->f_type) {
  
  	case FT_COMP:
+ #ifdef RFC1342
+ 	    str = (unsigned char *)fmt->f_comp->c_text;
+ 	    if (maybe_decode_rfc1342 (str, buffer))
+ 		str = buffer;
+ 	    PUTS (cp, str);
+ #else       
  	    PUTS (cp, fmt->f_comp->c_text);
+ #endif
  	    break;
  	case FT_COMPF:
+ #ifdef RFC1342
+ 	    str = (unsigned char *)fmt->f_comp->c_text;
+ 	    if (maybe_decode_rfc1342 (str, buffer))
+ 		str = buffer;
+ 	    PUTSF (cp, str, fmt->f_width, fmt->f_fill);
+ #else           
  	    PUTSF (cp, fmt->f_comp->c_text, fmt->f_width, fmt->f_fill);
+ #endif
  	    break;
  
  	case FT_LIT:
***************
*** 500,505 ****
--- 515,524 ----
  
  	case FT_LS_COMP:
  	    str = fmt->f_comp->c_text;
+ #ifdef RFC1342
+ 	    if (maybe_decode_rfc1342 (str, buffer))
+ 		str = buffer;
+ #endif
  	    break;
  	case FT_LS_LIT:
  	    str = fmt->f_text;
***************
*** 743,748 ****
--- 762,771 ----
  			break;
  		  }
  		}
+ #ifdef RFC1342
+ 	    if (maybe_decode_rfc1342 (str, workbuff))
+ 		str = workbuff;
+ #endif /* RFC1342 */
  #endif	/* BERK */
  	    break;
  
diff -rN -x *.ifi -c mh-6.8.3/sbr/rfc1342.c mh.ifi/sbr/rfc1342.c
*** mh-6.8.3/sbr/rfc1342.c
--- mh.ifi/sbr/rfc1342.c	Thu Aug 25 10:25:57 1994
***************
*** 0 ****
--- 1,123 ----
+ /* rfc1342.c */ 
+ /*
+  * Decode RFC1342 header format 
+  */
+ 
+ #ifdef RFC1342
+ static char hexindex[] = {
+     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+      0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
+     -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
+ };
+ 
+ static int
+ unqp (byte1, byte2)
+ 	char byte1;
+ 	char byte2;
+ {
+   if (hexindex[byte1] == -1 || hexindex[byte2] == -1)
+     return -1;
+   return hexindex[byte1]<<4 | hexindex[byte2];
+ }
+ 
+ int
+ maybe_decode_rfc1342 (src, dst) 
+ 	char *src;
+ 	unsigned char *dst;
+ {
+ 	static char *mm_charset = 0;
+ 	extern char *getenv();
+ 	char *p;
+ 	unsigned char *q;
+ 	char *pp;
+ 	char *startofmime = 0;
+ 	char *endofmime = 0;
+ 	int c;
+ 	int quoted_printable;
+ 
+ 	if (!mm_charset) 
+ 		mm_charset = getenv ("MM_CHARSET");
+ 	if (!mm_charset || src == 0)
+ 		return 0;
+ 
+ 	for (p = src, q = dst; *p; p++) {
+ 		*q++ = *p;
+ 		if (*p == '=' && p[1] && p[1] == '?' && p[2]) {
+ 			/* Have: =? */
+ 			startofmime = p + 2;
+ 			if (strncmp (startofmime, mm_charset, 
+ 				     strlen (mm_charset)) != 0) 
+ 				continue;
+ 			/* Have: =?charset */
+ 			startofmime += strlen (mm_charset);
+ 			if (startofmime[0] != '?')
+ 				continue;
+ 			/* Have: =?charset? */
+ 			startofmime++;
+ 			if (*startofmime != 'B' &&
+ 			    *startofmime != 'b' &&
+ 			    *startofmime != 'Q' &&
+ 			    *startofmime != 'q')
+ 				continue;
+ 			/* Have: =?charset?E */
+ 			quoted_printable = *startofmime == 'Q' ||
+ 					   *startofmime == 'q';;
+ 			startofmime++;
+ 			if (*startofmime != '?')
+ 				continue;
+ 			/* Have: =?charset?E? */
+ 			startofmime++;
+ 			for (pp = startofmime; *pp && *(pp+1); pp++)
+ 				if (*pp == '?' && pp[1] == '=') {
+ 					endofmime = pp;
+ 					break;
+ 				}
+ 			/* Have: =?charset?E?text?= */
+ 			if (endofmime) {
+ 				q--;
+ 				if (quoted_printable)
+ 					for (pp = startofmime; pp < endofmime; pp++) {
+ 						if (*pp == '=') {
+ 							c =  unqp (pp[1], pp[2]);
+ 							if ( c == -1)
+ 								continue;
+ 							*q++ = c;
+ 							pp += 2;
+ 						} else if (*pp == '_')
+ 							*q++ = ' ';
+ 						else
+ 							*q++ = *pp;
+ 					}
+ 				else	/* base64 */
+ 					for (pp = startofmime; pp < endofmime; pp++) {
+ 					
+ 					}
+ 				p = endofmime + 1;
+ 				if (*p == ' ')
+ 					p++;
+ 			}
+ 		}
+ 	}
+ 	*q = 0;
+ 	return endofmime != 0;
+ }
+ #endif
+ 
+ #ifdef notdef	/* For debugging */
+ int
+ main(argc, argv)
+ 	int argc;
+ 	char **argv;
+ {
+ 	char buff[100];
+ 	if (maybe_decode_rfc1342 (argv[1], buff))
+ 		puts (buff);
+ 	else
+ 		puts ("NEI!");
+ }
+ #endif
