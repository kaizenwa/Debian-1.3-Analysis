This document describes how to use JED in its non-interactive mode.  It
assumes that the reader is reasonably familiar with S-Lang programming for
JED. 

---------------------------------------------------------------------------
In a very real sense, JED is a text processing utility that operates in two
modes: interactive mode and non-interactive or BATCH mode.  One example of
using JED in batch mode is:

   jed -batch -l preparse.sl
   
JED will run non-interactively only if the command line parameter is
`-batch'.   For example, 

    % jed -batch -f quit_jed
    loading /usr/local/jed/lib/site.slc
    loading /usr/local/jed/lib/os.sl
    loading /usr1/users/davis/.jedrc

Notice that this is very noisy since it displays all the files that it is
loading. There is a quieter non-interactive form that is specified by using
`-script' instead of `-batch'.  The syntax for this parameter is:

   jed -script script-file [arg] ....

The `-script' parameter functions exactly like the `-l' (load file)
parameter except that 

   1.  It runs in non-interactive mode.

   2.  The rest of the command line arguments (arg) are not parsed.  It is
       up to the code in the script file to parse the remaining arguments if
       they are present.
       
   3.  The user's .jedrc (jed.rc) file is NOT loaded.  To load it, add the
       appropriate `evalfile' to the script.

It is best to provide an example, although silly.  This example script
writes simply counts the number of lines in the files specified on the
command line and writes the value on stdout.

---------------------------------------------------------------------
variable i = 3;
variable count = 0;
if (i == MAIN_ARGC)
  {
     message ("Usage: jed -script count-lines.sl file ...");
     quit_jed ();
  }
  
while (i < MAIN_ARGC)
{
   read_file (command_line_arg (i)); pop ();
   eob ();
   count += whatline ();
   if (bolp ()) count--;
   delbuf (whatbuf());
   
   i = i + 1;
}

tt_send(string (count));
quit_jed ();
----------------------------------------------------------------------

Note the following points:

   1. When the script file is loaded, the NEXT command line argument to 
      be evaluated is 3.
      
   2. The global variable MAIN_ARGC contains the number of command line
      arguments.  Since they are numbered from 0, the last one is number
      MAIN_ARGC - 1.

   3. The function `command_line_arg' returns the specified argument.

   4. In the non-interactive mode, The function `tt_send' must be used to
      write to stdout.  JED also uses `message' but this function writes to
      stderr in batch mode. 

   5. `quit_jed' is called to exit the editor.  `exit_jed' could also be
      used when it is necessary to run the exit hooks.
      
To exectute this script, type:

   % jed -script count-lines.sl 
   
It should display the usage.

Unix also provides a mechanism for making any script file an executable
file.  The trick is to add the appropriate line to the top of the script and
change the permissions on the script to make it executable.  In this case,
do the following:

    1. Add:
    
         #!/usr/local/bin/jed -script
      
       to the top of the file.  Some operating systems put a limit on the
       number of characters for this line.  It might be necessary to create
       a symbolic link from, say /bin/jed to the place where jed is kept.
       
    2. At the unix prompt, enter:  chmod +x count-lines.sl

As a final example, consider a script file that may be used in DOS batch
files to replace strings in files, e.g., to replace all occurances of `x'
with `y' in `C:\windows\win.ini'.  If such a script file is called
`change.sl', it could be used as:

    jed -script change.sl C:\windows\win.ini x y
    
A script file that performs this task is:

   % change.sl
   
   if (MAIN_ARGC != 6)
     {
        message ("Usage: jed -script change.sl file old-string new-string");
        quit_jed ();
     }
  
   () = read_file (command_line_arg(3));
   replace (command_line_arg (4), command_line_arg (5));
   save_buffer ();
   quit_jed ();

