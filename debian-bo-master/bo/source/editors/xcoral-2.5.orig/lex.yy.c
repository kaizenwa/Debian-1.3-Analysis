/* A lexical scanner generated by flex */

/* scanner skeleton version:
 * $Header: /home/horse/u0/vern/flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36 vern Exp Locker: vern $
 */

#define FLEX_SCANNER

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <osfcn.h>

/* use prototypes in function declarations */
#define YY_USE_PROTOS

/* the "const" storage-class-modifier is valid */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#ifdef __STDC__

#ifdef __GNUC__
#include <stddef.h>
void *malloc( size_t );
void free( void* );
#else
#include <stdlib.h>
#endif	/* __GNUC__ */

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */


#ifdef __TURBOC__
#define YY_USE_CONST
#endif


#ifndef YY_USE_CONST
#define const
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
 * so it's got to be a K&R compiler, and therefore there's no standard
 * place from which to include these definitions
 */
char *malloc();
int free();
int read();
#endif


/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite()
 */
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0

/* no semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#define yyterminate() return ( YY_NULL )

/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 * 	if ( something_happens )
 *		YY_FATAL_ERROR( "oops, the something happened" );
 *	else
 *		everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the YY_FATAL_ERROR() call.
 */

#define YY_FATAL_ERROR(msg) \
	do \
		{ \
		(void) fputs( msg, stderr ); \
		(void) putc( '\n', stderr ); \
		exit( 1 ); \
		} \
	while ( 0 )

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN
 */
#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */
#define YY_NEW_FILE \
	do \
		{ \
		yy_init_buffer( yy_current_buffer, yyin ); \
		yy_load_buffer_state(); \
		} \
	while ( 0 )

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex YY_PROTO(( void )) 

/* code executed at the end of each rule */
#define YY_BREAK break;

#define YY_END_OF_BUFFER_CHAR 0

#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;

#define YY_CHAR unsigned char
# line 1 "gen.l"
#define INITIAL 0
# line 2 "gen.l"

#include "global_parse.h"
#include "gen.tab.h"

extern YYSTYPE yylval;

#include "browser_util.h"
#include <string.h>
#include <ctype.h>


/*------------------------------------------------------------------------------
*/
int line_count;

static int bracket_level;

static int parent_level;

static int tmp_line_count;

static int virtual_flag;

static int const_flag;


/*------------------------------------------------------------------------------
*/

/* #define ARG_BUFF_SIZE  4096 */
#define ARG_BUFF_SIZE  32768

static char arg_buff[ARG_BUFF_SIZE];

static int  arg_index = 0;


/*------------------------------------------------------------------------------
*/

static int  state_stack[20];

static int  next_free;

static int  current_state;


/*------------------------------------------------------------------------------
*/

#define LINE_COUNT()         {                                 \
                               unsigned char* current;                  \
                                                               \
                               current = yytext + yyleng;      \
                               while ((--current) >= yytext) { \
                                 if ((*current) == '\n')       \
                                   line_count++;               \
                               }                               \
                             }


/*------------------------------------------------------------------------------
*/

#define BEGIN_STATE(state)   BEGIN(current_state = state)

#define STACK_STATE(state)   { state_stack[next_free++] = current_state; \
                               BEGIN_STATE(state); }

#define UNSTACK_STATE()      { BEGIN_STATE(state_stack[--next_free]); }


#define YY_USER_INIT         BEGIN_STATE(MAIN_STATE)

#define MAIN_STATE 1
#define OPERATOR_STATE 2
#define PROC_STATE1 3
#define PROC_STATE2 4
#define CLASS_STATE1 5
#define CLASS_STATE2 6
#define TEMPLATE_STATE 7
#define PARENT_STATE 8
#define BODY_STATE 9
#define ARG_STATE 10
#define INIT_STATE 11
#define TAIL_STATE 12
#define CODE_STATE 13
# line 122 "gen.l"

/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
	yytext = yy_bp; \
	yyleng = yy_cp - yy_bp; \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	do \
		{ \
		/* undo effects of setting up yytext */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext )


struct yy_buffer_state
    {
    FILE *yy_input_file;

    YY_CHAR *yy_ch_buf;		/* input buffer */
    YY_CHAR *yy_buf_pos;	/* current position in input buffer */

    /* size of input buffer in bytes, not including room for EOB characters */
    int yy_buf_size;	

    /* number of characters read into yy_ch_buf, not including EOB characters */
    int yy_n_chars;

    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
    /* "pending" happens when the EOF has been seen but there's still
     * some text process
     */
#define EOF_PENDING 1
#define EOF_DONE 2
    };

static YY_BUFFER_STATE yy_current_buffer;

/* we provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state"
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed */
static YY_CHAR yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */



#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif

extern YY_CHAR *yytext;
extern int yyleng;
extern FILE *yyin, *yyout;

YY_CHAR *yytext;
int yyleng;

FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

#define YY_END_OF_BUFFER 89
typedef int yy_state_type;
static const short int yy_acclist[675] =
    {   0,
    16452,16452,   89,   87,   88,    5,   87,   88,    4,   88,
       87,   88,   78,   87,   88,   77,   87,   88,   87,   88,
       86,   87,   88,   86,   87,   88,   86,   87,   88,   86,
       87,   88,   86,   87,   88,   87,   88,    6,   87,   88,
        6,   87,   88,    6,   87,   88,   87,   88,    6,   87,
       88,    6,   87,   88,    6,   87,   88,    6,   87,   88,
        6,   87,   88,    6,   87,   88,    6,   87,   88,    6,
       87,   88,    6,   87,   88,   87,   88,    6,   87,   88,
        6,   87,   88,    6,   87,   88,    6,   87,   88,    6,
       87,   88,    8,   87,   88,    5,    8,   87,   88,    7,

        8,   87,   88,    8,   87,   88,    8,   78,   87,   88,
        8,   77,   87,   88,    8,   87,   88,   15,   87,   88,
        5,   15,   87,   88,   15,   87,   88,    9,   15,   87,
       88,   13,   15,   78,   87,   88,   14,   15,   87,   88,
       12,   15,   87,   88,   12,   15,   87,   88,   10,   15,
       77,   87,   88,   15,   87,   88,   18,   87,   88,    5,
       18,   87,   88,   18,   87,   88,   18,   78,   87,   88,
       17,   18,   87,   88,   18,   77,   87,   88,   18,   87,
       88,   21,   87,   88,    5,   21,   87,   88,   21,   87,
       88,   19,   21,   87,   88,   21,   78,   87,   88,   21,

       87,   88,   20,   21,   77,   87,   88,   21,   87,   88,
       29,   87,   88,   27,   87,   88,   28,   87,   88,   31,
       87,   88,   31,   87,   88,   31,   87,   88,   32,   77,
       87,   88,   86,   87,   88,   86,   87,   88,   86,   87,
       88,   86,   87,   88,   86,   87,   88,   86,   87,   88,
       35,   87,   88,   48,   87,   88,   60,   87,   88,   61,
       87,   88,   47,   87,   88,   55,   87,   88,   87,   88,
       53,   87,   88,   59,   87,   88,   54,   87,   88,   57,
       87,   88,   87,   88,   57,   87,   88,   57,   87,   88,
       57,   87,   88,   57,   87,   88,   57,   87,   88,   57,

       87,   88,   57,   87,   88,   57,   87,   88,   57,   87,
       88,   67,   87,   88,    5,   67,   87,   88,   67,   87,
       88,   67,   87,   88,   64,   67,   87,   88,   66,   67,
       87,   88,   65,   67,   87,   88,   67,   87,   88,   67,
       78,   87,   88,   67,   87,   88,   67,   87,   88,   67,
       87,   88,   67,   77,   87,   88,   67,   87,   88,   87,
       88,16452,    5,   87,   88,16452,    4,   88,16452,   87,
       88,16452, 8260,   78,   87,   88, 8260,   77,   87,   88,
       87,   88,16452,   76,   87,   88,    5,   76,   87,   88,
       87,   88,   73,   87,   88,   74,   87,   88,   76,   78,

       87,   88,   76,   87,   88,   69,   77,   87,   88,   70,
       87,   88,   76,   87,   88,    5,    1,    2,    3,   86,
       86,   86,   86,   86,   86,    6,    6,    6,    6,    6,
        6,    6,    6,    6,   12,   12,   17,   31,   31,   31,
       31,   86,   86,   86,   86,   86,   86,   86,   57,   49,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   62,16452, 8260,    5,16452,    1,16452,
        2,16452,16452,    3,16452,   76,    5,   76,   75,   76,
        3,   76,    2,    3,   84,   86,   86,   86,   86,   86,
        6,    6,   12,   16,   22,   30,   31,   31,   31,   31,

       86,   86,   86,   86,   86,   86,   86,   56,   57,   57,
       57,   57,   57,   40,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   63,    2,16452,    2, 8260,    3,16452,
       71,   72,    3,   76,   86,   86,   86,   86,   86,    6,
       12,   16,   30,   31,   31,   31,   31,   86,   86,   86,
       86,   86,   86,   86,   57,   58,   51,   57,   38,   57,
       57,   57,   46,   57,   41,   57,   57,   57,   57,   57,
       57,   57,   57,   79,   86,   86,   86,   86,   86,    6,
       11,   12,   31,   31,   31,   31,   80,   86,   86,   86,
       86,   86,   86,   86,   57,   57,   58,   44,   57,   45,

       57,   57,   39,   57,   57,   57,   43,   57,   57,   57,
       83,   86,   86,   82,   86,   81,   86,   31,   31,   23,
       31,   31,   34,   86,   86,   86,   86,   23,   86,   86,
       57,   57,   37,   57,   42,   57,   57,   57,   83,   82,
       86,   25,   31,   31,   26,   31,   34,   34,   86,   86,
       25,   86,   86,   33,   86,   57,   57,   57,   85,   86,
       31,   85,   86,   86,   50,   57,   36,   57,   52,   57,
       24,   31,   24,   86
    } ;

static const short int yy_accept[414] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    2,    3,    3,    3,    4,
        6,    9,   11,   13,   16,   19,   21,   24,   27,   30,
       33,   36,   38,   41,   44,   47,   49,   52,   55,   58,
       61,   64,   67,   70,   73,   76,   78,   81,   84,   87,
       90,   93,   96,  100,  104,  107,  111,  115,  118,  121,
      125,  128,  132,  137,  141,  145,  149,  154,  157,  160,
      164,  167,  171,  175,  179,  182,  185,  189,  192,  196,
      200,  203,  208,  211,  214,  217,  220,  223,  226,  229,

      233,  236,  239,  242,  245,  248,  251,  254,  257,  260,
      263,  266,  269,  271,  274,  277,  280,  283,  285,  288,
      291,  294,  297,  300,  303,  306,  309,  312,  315,  319,
      322,  325,  329,  333,  337,  340,  344,  347,  350,  353,
      357,  360,  363,  367,  370,  373,  377,  381,  384,  387,
      391,  393,  396,  399,  403,  406,  410,  413,  416,  417,
      418,  419,  419,  420,  420,  421,  421,  422,  423,  424,
      425,  425,  426,  427,  428,  429,  430,  431,  432,  433,
      434,  435,  436,  437,  437,  438,  438,  438,  438,  438,
      439,  439,  440,  441,  442,  443,  444,  445,  446,  447,

      448,  449,  449,  449,  450,  450,  450,  451,  452,  453,
      454,  455,  456,  457,  458,  459,  460,  461,  462,  463,
      464,  464,  465,  465,  465,  465,  465,  466,  467,  469,
      471,  473,  474,  476,  477,  479,  479,  480,  480,  480,
      480,  481,  483,  484,  485,  486,  487,  488,  489,  490,
      491,  492,  493,  494,  495,  495,  495,  495,  496,  497,
      498,  499,  500,  501,  502,  503,  504,  505,  506,  507,
      508,  509,  509,  509,  510,  511,  512,  513,  514,  516,
      517,  518,  519,  520,  521,  522,  523,  524,  525,  525,
      525,  527,  529,  531,  532,  533,  535,  536,  537,  538,

      539,  540,  541,  542,  543,  543,  544,  545,  546,  547,
      548,  549,  550,  551,  552,  553,  554,  555,  555,  555,
      557,  559,  561,  562,  563,  565,  567,  568,  569,  570,
      571,  572,  573,  574,  574,  574,  576,  577,  578,  579,
      580,  581,  583,  583,  584,  585,  586,  587,  589,  590,
      591,  592,  593,  594,  595,  596,  598,  600,  602,  603,
      605,  606,  607,  609,  610,  611,  611,  611,  613,  614,
      616,  618,  619,  620,  622,  623,  625,  626,  627,  628,
      630,  631,  632,  633,  635,  637,  638,  639,  640,  641,
      642,  644,  645,  647,  648,  650,  651,  653,  654,  656,

      657,  658,  659,  661,  662,  664,  665,  667,  669,  671,
      673,  675,  675
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        2,    4,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    6,    7,    1,    8,    9,   10,   11,
       12,   13,   14,   15,   16,   17,   18,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
       23,   24,    1,    1,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       26,   27,   28,   29,   25,    1,   30,   31,   32,   33,

       34,   35,   36,   37,   38,   25,   25,   39,   40,   41,
       42,   43,   25,   44,   45,   46,   47,   48,   49,   25,
       25,   25,   50,   51,   52,   53,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[54] =
    {   0,
        1,    2,    3,    2,    1,    4,    1,    1,    1,    5,
        1,    1,    1,    1,    1,    1,    1,    4,    6,    7,
        1,    1,    1,    8,    9,    1,    1,    1,    1,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    4,
        1,    4,    1
    } ;

static const short int yy_base[442] =
    {   0,
        0,    2,   52, 1427,  105, 1426,  157,  159,  209, 1425,
      262, 1407,  314,  363,  319,  321,  399, 1394,  428, 1391,
      480, 1390,  532,  581,  323,  354,  630,  681, 1393, 1510,
     1390, 1510,    1, 1510, 1510,    4,    8,  161,  327,  347,
      356,   13, 1366, 1363,    4, 1373, 1358,    8, 1510,    9,
       11,   13, 1357,   14,    0, 1351, 1355, 1343, 1339,  144,
     1510, 1510, 1368, 1510,   26, 1510, 1510,   38, 1510, 1367,
       28, 1510, 1510, 1510,    0, 1323, 1510,   41, 1510, 1362,
      156, 1510,  169, 1510,   45, 1510, 1359,  166, 1510, 1510,
      183, 1510,  186, 1510, 1510, 1510,  375,  407,  154, 1510,

        0, 1321, 1313, 1313,    4, 1317, 1510, 1510, 1510, 1510,
     1510, 1510, 1337, 1510, 1510, 1510,  385, 1325,  553,  602,
      355,  378,  154,  160,  361,  521,  166, 1510, 1347,  177,
     1331, 1510, 1510, 1510,  320, 1510, 1339, 1300, 1294, 1510,
      316,  298,  341,  324,  528, 1510, 1510,  732,    0, 1337,
      374,  302,  437,    0, 1332, 1510, 1510,  781, 1335, 1510,
        0,  351,    0,  565,  577, 1316,  607,  610,  643,  651,
      562,    0, 1510, 1510, 1510, 1265, 1249, 1243,    0, 1222,
     1188,    0, 1187,  614,  656, 1204,  572,  662,  665,  378,
     1185,  654,  576,  492,    0, 1170, 1154, 1129,  344, 1109,

     1061, 1076,  701,  636, 1057, 1048, 1510,  670,  676,  680,
      686,  693,  700,  706,  713,  687,  750,  717,  756,  760,
      451, 1510,    0, 1062, 1028, 1010,  540, 1510,  640,  551,
      600,    0,  829,    0, 1029,  588, 1510,    0,  997,  989,
        0,  860,    0,    0, 1510,  507,  510,  382,  714,  667,
      943,    0,  925,  801,  832,  946,  908, 1510,  805,  581,
      744,  793,  797,  907,  907,  893,  881,  867,  849,  834,
     1510,  837,  843,  813,  814,  844,  877,  884,  845,  891,
      897,  901,  905,  878,  911,  917,  921, 1510,  811,  793,
      928,    0,    0, 1510, 1510,    0,  649,  594,  626,  927,

      932,  792,  754,  964,  774,  970,  939,  941,  551,  694,
      706,  679,  670,  659,  640,  624,  605,  977,  987,  990,
      945,  958,  959,  966,  972,  976,  980,  984,  990,  996,
     1000, 1007, 1008,  602,  548,  766,  972,  990, 1021, 1018,
      537,    0, 1053, 1014, 1027, 1031, 1022,    0,  512,  433,
      410,  396,  386,  386, 1077, 1080, 1031, 1048, 1049, 1057,
     1065, 1064, 1072, 1076, 1082,  374,  374, 1078, 1086, 1082,
     1093, 1091, 1085, 1045, 1095, 1142,  351,  329,  300,    0,
      288, 1194, 1165, 1164, 1171, 1178, 1179, 1510, 1510, 1097,
     1089, 1175, 1179, 1208,    0,  162,    0,  148,    0, 1192,

     1225, 1226, 1181, 1226,    0,  143, 1193, 1232, 1238, 1232,
        0, 1510, 1280, 1289, 1298, 1307, 1316, 1325, 1333, 1341,
     1349, 1353, 1357, 1365, 1373, 1381, 1385, 1393, 1402, 1411,
     1420, 1429, 1438, 1447, 1451, 1459, 1468, 1476, 1484, 1492,
     1500
    } ;

static const short int yy_def[442] =
    {   0,
      413,  413,  412,    3,  412,    5,  414,  414,  412,    9,
      412,   11,  415,  415,  413,  413,    3,   17,    3,   19,
      412,   21,  416,  416,  417,  417,  418,  418,  412,  412,
      412,  412,  412,  412,  412,  419,  420,  420,  420,  420,
      420,  421,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  422,  412,  412,  422,  422,  412,
      412,  412,  412,  412,  412,  412,  412,  419,  412,  412,
      412,  412,  412,  412,  423,  423,  412,  419,  412,  412,
      412,  412,  424,  412,  419,  412,  412,  412,  412,  412,
      425,  412,  419,  412,  412,  412,  426,  426,   98,  412,

      427,  427,  427,  427,  427,  427,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  428,  429,  428,  428,
      120,  120,  120,  120,  120,  120,  120,  412,  412,  430,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      419,  431,  431,  431,  431,  412,  412,  431,  432,  432,
      433,  412,  412,  432,  432,  412,  412,  432,  412,  412,
      434,  419,  435,  412,  420,  412,  420,  420,  420,  420,
      421,  427,  412,  412,  412,  412,  412,  412,  422,  422,
      422,  423,  423,  412,  424,  412,  425,  436,  412,   98,
      412,   98,   98,   98,  427,  427,  427,  427,  427,  427,

      427,  412,  412,  120,  412,  429,  412,  120,  120,  120,
      120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      430,  412,  430,  412,  412,  412,  431,  412,  431,  431,
      437,  148,  148,  432,  432,  433,  412,  433,  412,  412,
      158,  432,  434,  435,  412,  170,  170,  170,  170,  170,
      422,  422,  423,  412,  412,  412,  436,  412,  412,   98,
       98,   98,   98,  427,  427,  427,  427,  427,  427,  427,
      412,  412,  438,  120,  120,  120,  120,  120,  120,  120,
      120,  120,  120,  120,  120,  120,  120,  412,  412,  412,
      437,  434,  233,  412,  412,  242,  170,  170,  170,  170,

      170,  422,  423,  412,  412,  412,   98,   98,   98,   98,
      427,  427,  427,  427,  427,  427,  427,  439,  439,  440,
      120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      120,  120,  120,  412,  412,  170,  170,  170,  170,  170,
      422,  423,  425,   98,   98,   98,   98,  427,  427,  427,
      427,  427,  427,  427,  441,  440,  120,  120,  120,  120,
      120,  120,  120,  120,  120,  412,  412,  170,  170,  170,
      170,   98,   98,   98,   98,  412,  427,  427,  427,  427,
      427,  441,  120,  120,  120,  120,  120,  412,  412,  170,
       98,   98,   98,  376,  376,  427,  427,  427,  427,  120,

      120,  120,  170,   98,  427,  427,  120,  120,  120,   98,
      427,    0,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412
    } ;

static const short int yy_nxt[1564] =
    {   0,
      412,   31,   32,   31,   32,  162,  412,  162,   36,  164,
      164,  164,  173,  160,  171,  171,  171,   33,  161,   33,
       34,  173,   34,  160,  173,  412,  174,  166,  161,  412,
      174,  174,  176,  174,  177,  173,  173,  178,  160,  162,
      160,  162,  162,  161,  162,  161,  162,  199,  162,   35,
      200,   35,   30,   31,   32,   30,   30,   30,   30,   30,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   33,
       30,   30,   34,   30,   30,   30,   37,   30,   30,   30,
       30,   37,   37,   38,   37,   37,   37,   37,   37,   39,
       37,   37,   37,   40,   37,   37,   41,   37,   37,   37,

       37,   35,   30,   30,   42,   30,   31,   32,   30,   43,
       30,   30,   44,   45,   30,   46,   30,   47,   48,   49,
       50,   30,   51,   30,   30,   34,   52,   53,   54,   55,
       56,   30,   30,   57,   55,   55,   55,   58,   55,   55,
       55,   55,   55,   55,   55,   59,   55,   55,   55,   55,
       55,   55,   55,   55,   35,   60,   30,   61,   63,   32,
       63,   32,  164,  164,  164,   68,  174,   64,  160,   64,
      184,  184,  184,  161,   65,  411,   65,   66,  160,   66,
      166,  406,  222,  161,  187,  187,  187,  162,  186,  162,
      204,  194,  204,  215,  173,  214,  204,  190,  204,  167,

      190,  204,  204,  223,  204,  405,   67,  220,   67,   69,
       70,   32,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   71,   69,   72,   73,
       69,   74,   69,   75,   69,   69,   69,   69,   75,   75,
       76,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   77,   69,
       69,   69,   79,   80,   32,   79,   79,   79,   79,   79,
       79,   79,   79,   79,   79,   79,   79,   79,   79,   81,
       79,   79,   82,   79,   79,   79,   83,   79,   79,   79,
       79,   83,   83,   83,   83,   83,   83,   83,   83,   83,

       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   84,   79,   79,   79,   87,   32,  162,  228,  162,
       31,   32,   31,   32,  143,  144,  399,   36,  164,  164,
      164,   88,  160,   89,   90,   91,   33,  161,   33,   34,
      145,   34,  229,  146,  228,  398,  166,  228,  164,  164,
      164,  239,  162,  240,  162,  143,  144,  164,  164,  164,
      148,  228,  397,   92,   87,   32,  166,  168,   35,   93,
       35,  145,  147,  228,  146,  166,  189,  189,  189,  237,
       88,  267,   89,   90,   91,  268,  203,  203,  203,  169,
      228,  204,  396,  204,  191,  212,  204,  216,  217,  204,

      238,  170,  204,  147,  205,  389,  218,  388,  189,  189,
      189,  165,   92,   94,  204,  381,  204,  380,  213,  204,
       95,  190,   96,   97,  190,  299,  191,  379,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   98,   97,   97,   97,   97,   99,   97,  100,  160,
      192,   30,  101,  193,  161,  378,  222,  101,  101,  102,
      101,  101,  103,  101,  101,  101,  101,  101,  101,  104,
      105,  101,  101,  101,  101,  106,  101,  223,  377,  107,
       30,   31,   32,   30,   30,   30,   30,   30,  108,   30,
      109,  110,  111,   30,  112,   30,  113,   33,   30,   30,

       34,  114,  115,  116,  117,  118,   30,   30,   30,  119,
      117,  120,  117,  121,  117,  117,  117,  122,  123,  117,
      117,  117,  117,  124,  125,  117,  126,  127,  117,   35,
       30,   30,   30,  129,   32,  263,  165,  130,  190,  165,
      230,  131,  132,  133,  376,  231,  134,  298,  228,  135,
      165,  297,  136,  165,  203,  203,  203,  204,  137,  204,
      228,  219,  204,  171,  171,  171,  164,  164,  164,  138,
      252,  228,  205,  187,  187,  187,  139,  228,  164,  164,
      164,  140,  129,   32,  166,  367,  130,  141,  346,  228,
      131,  132,  133,  237,  190,  134,  166,  190,  135,  208,

      228,  136,  227,  203,  203,  203,  262,  137,  164,  164,
      164,  164,  164,  164,  238,  184,  184,  184,  138,  190,
      292,  205,  190,  165,  190,  139,  166,  190,  307,  166,
      140,  150,   32,  186,  337,  151,  246,  165,  209,  152,
      210,  229,  366,  211,  164,  164,  164,  153,  247,  292,
      154,  354,  164,  164,  164,  338,  155,  184,  184,  184,
      228,  353,  166,  255,  255,  255,  189,  189,  189,  165,
      166,  256,  204,  352,  204,  186,  248,  204,  165,  156,
      249,  157,  150,   32,  191,  258,  151,  158,  351,  228,
      152,  260,  165,  336,  250,  261,  165,  190,  153,  350,

      190,  154,  203,  203,  203,  275,  204,  155,  204,  276,
      165,  204,  204,  301,  204,  274,  204,  204,  204,  349,
      272,  204,  204,  204,  204,  204,  277,  204,  282,  204,
      156,  204,  157,  232,  204,  232,  204,  190,  204,  278,
      347,  204,  204,  165,  204,  279,  280,  204,  281,  204,
      348,  204,  228,  204,  204,  204,  233,  165,  204,  300,
      284,  233,  233,  233,  233,  233,  233,  233,  233,  233,
      233,  233,  233,  233,  233,  233,  233,  233,  233,  233,
      233,  228,  241,  343,  241,  283,  204,  190,  204,  308,
      190,  204,  204,  285,  204,  165,  204,  204,  287,  342,

      286,  204,  304,  304,  304,  242,  306,  306,  306,  165,
      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
      227,  309,  227,  255,  255,  255,  190,  341,  335,  190,
      190,  256,  310,  190,  319,  319,  319,  293,  334,  204,
      204,  204,  204,  293,  321,  204,  318,  322,  293,  293,
      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
      293,  293,  293,  293,  293,  293,  293,  293,  296,  317,
      204,  204,  204,  204,  296,  204,  204,  316,  323,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,

      296,  296,  296,  296,  296,  296,  296,  296,  296,  255,
      255,  255,  315,  204,  204,  204,  204,  256,  204,  204,
      204,  324,  204,  325,  330,  204,  326,  204,  314,  204,
      227,  258,  204,  204,  327,  204,  313,  204,  204,  204,
      312,  204,  204,  204,  328,  329,  204,  204,  292,  204,
      333,  311,  331,  204,  332,  204,  165,  204,  204,  204,
      305,  165,  204,  340,  339,  304,  304,  304,  344,  303,
      165,  306,  306,  306,  345,  165,  302,  292,  319,  319,
      319,  204,  190,  204,  190,  190,  204,  190,  319,  319,
      319,  203,  203,  203,  204,  204,  204,  204,  295,  204,

      204,  165,  204,  357,  204,  368,  294,  204,  204,  272,
      204,  358,  204,  204,  204,  165,  204,  204,  204,  165,
      204,  204,  204,  361,  359,  204,  204,  362,  204,  360,
      235,  204,  204,  165,  204,  369,  204,  204,  204,  290,
      363,  204,  364,  204,  204,  204,  204,  165,  204,  204,
      165,  375,  370,  365,  187,  187,  187,  190,  373,  372,
      190,  165,  374,  371,  165,  190,  289,  204,  190,  204,
      190,  288,  204,  190,  190,  207,  273,  190,  203,  203,
      203,  203,  203,  203,  204,  204,  204,  204,  190,  204,
      204,  190,  271,  204,  383,  204,  272,  384,  204,  272,

      204,  204,  204,  204,  270,  204,  204,  165,  204,  385,
      204,  165,  204,  204,  204,  165,  386,  204,  204,  387,
      204,  165,  165,  204,  391,  165,  165,  390,  190,  165,
      392,  190,  190,  393,  190,  190,  165,  190,  190,  269,
      403,  190,  394,  394,  394,  394,  394,  394,  394,  394,
      394,  394,  394,  394,  394,  394,  394,  394,  394,  394,
      395,  394,  266,  394,  394,  394,  395,  394,  394,  394,
      394,  395,  395,  395,  395,  395,  395,  395,  395,  395,
      395,  395,  395,  395,  395,  395,  395,  395,  395,  395,
      395,  265,  394,  394,  394,  203,  203,  203,  400,  264,

      204,  204,  204,  204,  259,  204,  204,  204,  404,  204,
      165,  401,  204,  272,  204,  204,  204,  402,  190,  204,
      204,  190,  190,  254,  165,  190,  394,  253,  204,  204,
      204,  204,  394,  204,  204,  407,  252,  394,  394,  394,
      394,  394,  394,  394,  394,  394,  394,  394,  394,  394,
      394,  394,  394,  394,  394,  394,  394,  408,  410,  409,
      251,  204,  204,  204,  204,  173,  204,  204,  204,  190,
      204,  173,  190,  204,  204,  190,  204,  175,  190,  204,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   62,
       62,   62,   62,   62,   62,   62,   62,   62,   86,   86,

       86,   86,   86,   86,   86,   86,   86,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  142,  142,  142,  142,
      142,  142,  142,  142,  142,  149,  149,  149,  149,  149,
      149,  149,  149,  149,  163,  245,  159,  237,  235,  226,
      225,  163,  165,  165,  222,  224,  165,  165,  159,  165,
      172,  172,  207,  202,  201,  198,  197,  172,  179,  196,
      159,  179,  182,  159,  183,  182,  185,  185,  159,  159,
      185,  185,  181,  185,  188,  188,  180,  174,  175,  173,
      174,  188,  190,  190,  175,  174,  190,  190,  173,  190,
      195,  159,  412,  195,  204,  204,   36,   36,  204,  204,

       36,  204,  206,  206,  206,  206,  206,  206,  206,  206,
      206,  221,  221,   85,  221,  221,  221,  221,  221,  221,
      227,  227,  227,  227,  227,  227,  227,  227,  227,  234,
      234,   78,   36,   36,  234,  234,  234,  234,  236,  236,
      412,  236,  236,  236,  236,  236,  236,  243,  243,  412,
      243,  243,  243,  243,  243,  243,  244,  412,  412,  244,
      257,  257,  412,  257,  257,  412,  257,  257,  291,  291,
      291,  291,  291,  291,  291,  291,  291,  320,  320,  412,
      412,  412,  412,  412,  320,  355,  355,  412,  412,  412,
      412,  412,  355,  356,  356,  412,  412,  356,  356,  412,

      356,  382,  382,  412,  412,  382,  382,  412,  382,   29,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412
    } ;

static const short int yy_chk[1564] =
    {   0,
        0,    1,    1,    2,    2,   36,    0,   36,    2,   37,
       37,   37,   45,   33,   42,   42,   42,    1,   33,    2,
        1,   48,    2,   51,   50,    0,   45,   37,   51,    0,
       48,   50,   50,   51,   52,   52,   54,   54,   65,   68,
       71,   68,   78,   65,   78,   71,   85,  105,   85,    1,
      105,    2,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,

        3,    3,    3,    3,    3,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    7,    7,
        8,    8,   38,   38,   38,    8,   60,    7,   81,    8,
       83,   83,   83,   81,    7,  406,    8,    7,   88,    8,
       38,  398,  130,   88,   91,   91,   91,   93,   83,   93,
      123,   99,  123,  124,   60,  123,  124,   99,  124,   38,

       99,  124,  127,  130,  127,  396,    7,  127,    8,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,

       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   13,   13,  141,  142,  141,
       15,   15,   16,   16,   25,   25,  381,   16,   39,   39,
       39,   13,  135,   13,   13,   13,   15,  135,   16,   15,
       25,   16,  143,   25,  144,  379,   39,  142,   40,   40,
       40,  152,  162,  152,  162,   26,   26,   41,   41,   41,
       26,  143,  378,   13,   14,   14,   40,   39,   15,   14,
       16,   26,   25,  144,   26,   41,   97,   97,   97,  151,
       14,  199,   14,   14,   14,  199,  117,  117,  117,   40,
      143,  121,  377,  121,   97,  121,  121,  125,  125,  125,

      151,   41,  125,   26,  117,  367,  125,  366,   98,   98,
       98,  248,   14,   17,  122,  354,  122,  353,  122,  122,
       17,  190,   17,   17,  190,  248,   98,  352,   17,   17,
       17,   17,   17,   17,   17,   17,   17,   17,   17,   17,
       17,   17,   17,   17,   17,   17,   17,   17,   17,  153,
       98,   17,   19,   98,  153,  351,  221,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,  221,  350,   19,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,

       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   23,   23,  194,  246,   23,  194,  247,
      145,   23,   23,   23,  349,  145,   23,  247,  145,   23,
      246,  246,   23,  247,  119,  119,  119,  126,   23,  126,
      227,  126,  126,  171,  171,  171,  164,  164,  164,   23,
      341,  230,  119,  187,  187,  187,   23,  145,  165,  165,
      165,   23,   24,   24,  164,  335,   24,   24,  309,  227,
       24,   24,   24,  236,  309,   24,  165,  309,   24,  119,

      230,   24,  231,  120,  120,  120,  193,   24,  167,  167,
      167,  168,  168,  168,  236,  184,  184,  184,   24,  193,
      231,  120,  193,  298,  260,   24,  167,  260,  260,  168,
       24,   27,   27,  184,  298,   27,  167,  298,  120,   27,
      120,  229,  334,  120,  169,  169,  169,   27,  168,  231,
       27,  317,  170,  170,  170,  299,   27,  185,  185,  185,
      229,  316,  169,  188,  188,  188,  189,  189,  189,  299,
      170,  188,  204,  315,  204,  185,  169,  204,  297,   27,
      170,   27,   28,   28,  189,  188,   28,   28,  314,  229,
       28,  192,  297,  297,  170,  192,  250,  192,   28,  313,

      192,   28,  203,  203,  203,  209,  208,   28,  208,  210,
      250,  208,  209,  250,  209,  208,  210,  209,  210,  312,
      203,  210,  211,  216,  211,  216,  211,  211,  216,  212,
       28,  212,   28,  148,  212,  148,  213,  310,  213,  212,
      310,  213,  214,  249,  214,  213,  214,  214,  215,  215,
      311,  215,  148,  218,  215,  218,  148,  249,  218,  249,
      218,  148,  148,  148,  148,  148,  148,  148,  148,  148,
      148,  148,  148,  148,  148,  148,  148,  148,  148,  148,
      148,  148,  158,  305,  158,  217,  217,  261,  217,  261,
      261,  217,  219,  219,  219,  336,  220,  219,  220,  303,

      219,  220,  254,  254,  254,  158,  259,  259,  259,  336,
      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
      158,  158,  158,  158,  158,  158,  158,  158,  158,  158,
      233,  262,  233,  255,  255,  255,  262,  302,  290,  262,
      263,  255,  263,  263,  273,  273,  273,  233,  289,  274,
      275,  274,  275,  233,  274,  275,  272,  275,  233,  233,
      233,  233,  233,  233,  233,  233,  233,  233,  233,  233,
      233,  233,  233,  233,  233,  233,  233,  233,  242,  270,
      276,  279,  276,  279,  242,  276,  279,  269,  276,  242,
      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,

      242,  242,  242,  242,  242,  242,  242,  242,  242,  257,
      257,  257,  268,  277,  284,  277,  284,  257,  277,  284,
      278,  277,  278,  278,  284,  278,  280,  280,  267,  280,
      291,  257,  280,  281,  281,  281,  266,  282,  281,  282,
      265,  283,  282,  283,  282,  283,  283,  285,  291,  285,
      287,  264,  285,  286,  286,  286,  300,  287,  286,  287,
      256,  301,  287,  301,  300,  304,  304,  304,  307,  253,
      300,  306,  306,  306,  308,  301,  251,  291,  318,  318,
      318,  321,  307,  321,  308,  307,  321,  308,  319,  319,
      319,  320,  320,  320,  322,  323,  322,  323,  240,  322,

      323,  337,  324,  323,  324,  337,  239,  324,  325,  320,
      325,  324,  326,  325,  326,  337,  327,  326,  327,  338,
      328,  327,  328,  329,  327,  328,  329,  330,  329,  328,
      235,  329,  330,  338,  330,  338,  331,  330,  331,  226,
      331,  331,  332,  332,  333,  332,  333,  340,  332,  333,
      339,  347,  339,  333,  343,  343,  343,  344,  345,  344,
      344,  340,  346,  340,  339,  347,  225,  357,  347,  357,
      345,  224,  357,  345,  346,  206,  205,  346,  355,  355,
      355,  356,  356,  356,  358,  359,  358,  359,  374,  358,
      359,  374,  202,  360,  359,  360,  355,  361,  360,  356,

      362,  361,  362,  361,  201,  362,  361,  368,  363,  362,
      363,  370,  364,  363,  364,  369,  364,  364,  365,  365,
      365,  368,  371,  365,  372,  370,  390,  369,  373,  369,
      373,  373,  391,  375,  372,  391,  371,  372,  375,  200,
      390,  375,  376,  376,  376,  376,  376,  376,  376,  376,
      376,  376,  376,  376,  376,  376,  376,  376,  376,  376,
      376,  376,  198,  376,  376,  376,  376,  376,  376,  376,
      376,  376,  376,  376,  376,  376,  376,  376,  376,  376,
      376,  376,  376,  376,  376,  376,  376,  376,  376,  376,
      376,  197,  376,  376,  376,  382,  382,  382,  383,  196,

      384,  383,  384,  383,  191,  384,  383,  385,  392,  385,
      403,  386,  385,  382,  386,  387,  386,  387,  392,  386,
      387,  392,  393,  186,  403,  393,  394,  183,  400,  407,
      400,  407,  394,  400,  407,  400,  181,  394,  394,  394,
      394,  394,  394,  394,  394,  394,  394,  394,  394,  394,
      394,  394,  394,  394,  394,  394,  394,  401,  404,  402,
      180,  401,  402,  401,  402,  178,  401,  402,  408,  404,
      408,  177,  404,  408,  409,  410,  409,  176,  410,  409,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  414,
      414,  414,  414,  414,  414,  414,  414,  414,  415,  415,

      415,  415,  415,  415,  415,  415,  415,  416,  416,  416,
      416,  416,  416,  416,  416,  416,  417,  417,  417,  417,
      417,  417,  417,  417,  417,  418,  418,  418,  418,  418,
      418,  418,  418,  418,  419,  166,  159,  155,  150,  139,
      138,  419,  420,  420,  137,  131,  420,  420,  129,  420,
      421,  421,  118,  113,  106,  104,  103,  421,  422,  102,
       87,  422,  423,   80,   76,  423,  424,  424,   70,   63,
      424,  424,   59,  424,  425,  425,   58,   57,   56,   53,
       47,  425,  426,  426,   46,   44,  426,  426,   43,  426,
      427,   31,   29,  427,  428,  428,   22,   20,  428,  428,

       18,  428,  429,  429,  429,  429,  429,  429,  429,  429,
      429,  430,  430,   12,  430,  430,  430,  430,  430,  430,
      431,  431,  431,  431,  431,  431,  431,  431,  431,  432,
      432,   10,    6,    4,  432,  432,  432,  432,  433,  433,
        0,  433,  433,  433,  433,  433,  433,  434,  434,    0,
      434,  434,  434,  434,  434,  434,  435,    0,    0,  435,
      436,  436,    0,  436,  436,    0,  436,  436,  437,  437,
      437,  437,  437,  437,  437,  437,  437,  438,  438,    0,
        0,    0,    0,    0,  438,  439,  439,    0,    0,    0,
        0,    0,  439,  440,  440,    0,    0,  440,  440,    0,

      440,  441,  441,    0,    0,  441,  441,    0,  441,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412,  412,  412,  412,  412,  412,  412,  412,
      412,  412,  412
    } ;

static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;

static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static YY_CHAR *yy_full_match;
static int yy_lp;
static int yy_looking_for_trail_begin = 0;
static int yy_full_lp;
static int *yy_full_state;
#define YY_TRAILING_MASK 0x2000
#define YY_TRAILING_HEAD_MASK 0x4000
#define REJECT \
{ \
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yy_full_match; /* restore poss. backed-over text */ \
yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \
yy_state_ptr = yy_full_state; /* restore orig. state */ \
yy_current_state = *yy_state_ptr; /* restore curr. state */ \
++yy_lp; \
goto find_rule; \
}
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yyunput YY_PROTO(( YY_CHAR c, YY_CHAR *buf_ptr ));
void yyrestart YY_PROTO(( FILE *input_file ));
void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));

#define yy_new_buffer yy_create_buffer

#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif

YY_DECL
    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp, *yy_bp;
    register int yy_act;



 /************************************************************************************/
 /*                    la supression des commentaires et macros                      */
 /************************************************************************************/


    if ( yy_init )
	{
	YY_USER_INIT;

	if ( ! yy_start )
	    yy_start = 1;	/* first start state */

	if ( ! yyin )
	    yyin = stdin;

	if ( ! yyout )
	    yyout = stdout;

	if ( yy_current_buffer )
	    yy_init_buffer( yy_current_buffer, yyin );
	else
	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_load_buffer_state();

	yy_init = 0;
	}

    while ( 1 )		/* loops until end-of-file is reached */
	{
	yy_cp = yy_c_buf_p;

	/* support of yytext */
	*yy_cp = yy_hold_char;

	/* yy_bp points to the position in yy_ch_buf of the start of the
	 * current run.
	 */
	yy_bp = yy_cp;

	yy_current_state = yy_start;
	if ( yy_bp[-1] == '\n' )
	    ++yy_current_state;
	yy_state_ptr = yy_state_buf;
	*yy_state_ptr++ = yy_current_state;
yy_match:
	do
	    {
	    register YY_CHAR yy_c = yy_ec[*yy_cp];
	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = yy_def[yy_current_state];
		if ( yy_current_state >= 413 )
		    yy_c = yy_meta[yy_c];
		}
	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	    *yy_state_ptr++ = yy_current_state;
	    ++yy_cp;
	    }
	while ( yy_current_state != 412 );

yy_find_action:
	yy_current_state = *--yy_state_ptr;
	yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backtracking */
	for ( ; ; ) /* until we find what rule we matched */
	    {
	    if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
		{
		yy_act = yy_acclist[yy_lp];
		if ( yy_act & YY_TRAILING_HEAD_MASK ||
		     yy_looking_for_trail_begin )
		    {
		    if ( yy_act == yy_looking_for_trail_begin )
			{
			yy_looking_for_trail_begin = 0;
			yy_act &= ~YY_TRAILING_HEAD_MASK;
			break;
			}
		    }
		else if ( yy_act & YY_TRAILING_MASK )
		    {
		    yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
		    yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
		    }
		else
		    {
		    yy_full_match = yy_cp;
		    yy_full_state = yy_state_ptr;
		    yy_full_lp = yy_lp;
		    break;
		    }
		++yy_lp;
		goto find_rule;
		}
	    --yy_cp;
	    yy_current_state = *--yy_state_ptr;
	    yy_lp = yy_accept[yy_current_state];
	    }

	YY_DO_BEFORE_ACTION;
	YY_USER_ACTION;

do_action:	/* this label is used only to access EOF actions */


	switch ( yy_act )
	    {
case 1:
# line 128 "gen.l"
{ 
                                          int current;

                                          current = '\0';
                                          while (current != '/') {
                                            while (current != '*') {
         				     current = input();
					     if (current == '\n')
						line_count++;
					     else if (current == EOF)
						yyterminate ();
                                            }
					     current = input();
					     if (current == '\n')
						line_count++;
					     else if (current == EOF)
						yyterminate ();
                                          }
                                        }
	YY_BREAK
case 2:
# line 149 "gen.l"
{}
	YY_BREAK
case 3:
# line 152 "gen.l"
{
				    int inComment = 0;
				    int current = '\0';
				    int previous;

				    while ( 1 )
				    {
				      previous = current;
				      current  = input();
				      if (current == EOF )
					yyterminate ();
				      if (current == '\n' )
				      {
					line_count++;
					if (previous != '\\' && !inComment)
					  break;
				      }
				      else if (previous == '/' && current =='*')
				      {
				    	inComment = 1;
				      }
				      else if (previous == '*' &&
					       current =='/' && inComment)
					break;
				    }
					/* The above is incorrect */
				  }
	YY_BREAK
case 4:
# line 181 "gen.l"
{ line_count++; }
	YY_BREAK
case 5:
# line 184 "gen.l"
{}
	YY_BREAK
 /************************************************************************************/
 /*     le parcours de la liste des arguments d'une procedure ou d'une methode       */
 /************************************************************************************/
case 6:
# line 191 "gen.l"
{
                                          strcat(yylval.text, (char *) yytext);
                                          strcat(yylval.text, " ");
                                          BEGIN_STATE(PROC_STATE1);
                                        }
	YY_BREAK
 /************************************************************************************/
 /*     le parcours de la liste des arguments d'une procedure ou d'une methode       */
 /************************************************************************************/
case 7:
# line 202 "gen.l"
{
                                         int current;
                                         int  parent_level;

                                         arg_index             = 0;
                                         parent_level          = 1;
                                         tmp_line_count        = 0;
                                         arg_buff[arg_index++] = '(';
                                         while(parent_level != 0) {
	 		   current = input();
                                           switch(current) {
               			case EOF: yyterminate ();
               			 break;
                                             case '(' : parent_level++;
                                                        break;
                                             case ')' : parent_level--;
                                                        break;
                                           }
                                           if (current == '\n')
                                             tmp_line_count++;
                                           if (arg_index < ARG_BUFF_SIZE)
                                             arg_buff[arg_index++] = current;
                                           else {
                                             yylval.position = line_count;
                                             return(LEX_ERROR_TOK);
                                           }
                                         }
                                         const_flag = False;
                                         BEGIN_STATE(PROC_STATE2);
                                       }
	YY_BREAK
case 8:
# line 233 "gen.l"
{
                                         unput(yytext[0]);
                                         UNSTACK_STATE();
                                         if (current_state != BODY_STATE)
                                           *yy_class_name = '\0';
                                       }
	YY_BREAK
 /************************************************************************************/
 /*              la recherche du token qui suit la liste des arguments               */
 /************************************************************************************/
case 9:
# line 245 "gen.l"
{
                                         while (--arg_index >= 0)
                                           unput(arg_buff[arg_index]);
                                         parent_level = 0;
                                         yylval.is_virtual = virtual_flag;
                                         virtual_flag      = False;
                                         BEGIN_STATE(ARG_STATE);
                                         return(CPLUS_TOK);
                                       }
	YY_BREAK
case 10:
# line 256 "gen.l"
{
                                         unput('{');
                                         while (--arg_index >= 0)
                                           unput(arg_buff[arg_index]);
                                         parent_level = 0;
                                         yylval.is_virtual = virtual_flag;
                                         virtual_flag      = False;
                                         BEGIN_STATE(ARG_STATE);
                                         return(CPLUS_TOK);
                                       }
	YY_BREAK
case 11:
# line 268 "gen.l"
{ const_flag = True; }
	YY_BREAK
case 12:
# line 271 "gen.l"
{
                                         line_count  += tmp_line_count;
                                         virtual_flag = False;
                                         UNSTACK_STATE();
                                         return(C_TOK);
                                       }
	YY_BREAK
case 13:
# line 279 "gen.l"
{
                                         unput(';');
                                         UNSTACK_STATE();
                                         if (current_state == BODY_STATE) {
                                           while (--arg_index >= 0)
                                             unput(arg_buff[arg_index]);
                                           parent_level = 0;
                                           yylval.is_virtual = virtual_flag;
                                           virtual_flag      = False;
                                           STACK_STATE(ARG_STATE);
                                           return(DECL_TOK);
                                         }
                                         else
                                           line_count += tmp_line_count;
                                         virtual_flag = False;
                                       }
	YY_BREAK
case 14:
# line 297 "gen.l"
{
                                         unput('=');
                                         UNSTACK_STATE();
                                         if (current_state == BODY_STATE) {
                                           while (--arg_index >= 0)
                                             unput(arg_buff[arg_index]);
                                           parent_level = 0;
                                           yylval.is_virtual = virtual_flag;
                                           virtual_flag      = False;
                                           STACK_STATE(ARG_STATE);
                                           return(DECL_TOK);
                                         }
                                         else
                                           line_count += tmp_line_count;
                                         virtual_flag = False;
                                       }
	YY_BREAK
case 15:
# line 315 "gen.l"
{ 
                                         unput(yytext[0]);
                                         line_count += tmp_line_count;
                                         virtual_flag = False;
                                         UNSTACK_STATE();
                                       }
	YY_BREAK
 /************************************************************************************/
 /*                         La lecture du nom de la classe                           */
 /************************************************************************************/
case 16:
# line 327 "gen.l"
{}
	YY_BREAK
case 17:
# line 329 "gen.l"
{
                                         strcpy(yylval.text, (char *) yytext);
                                         yylval.position = line_count;
                                         BEGIN_STATE(CLASS_STATE2);
                                       }
	YY_BREAK
case 18:
# line 336 "gen.l"
{ unput(yytext[0]);
					 UNSTACK_STATE();
				       }
	YY_BREAK
case 19:
# line 341 "gen.l"
{
                                         BEGIN_STATE(PARENT_STATE);
                                         return(IDENT_TOK);
                                       }
	YY_BREAK
case 20:
# line 346 "gen.l"
{
                                         unput('{');
                                         BEGIN_STATE(PARENT_STATE);
                                         return(IDENT_TOK);
                                       }
	YY_BREAK
case 21:
# line 352 "gen.l"
{ unput(yytext[0]);
					 UNSTACK_STATE();
				       }
	YY_BREAK
case 22:
# line 356 "gen.l"

	YY_BREAK
				       {}
 /************************************************************************************/
 /*                               Quelques mots clefs                                */
 /************************************************************************************/
case 23:
# line 362 "gen.l"
{ return(PUBLIC_TOK);    }
	YY_BREAK
case 24:
# line 364 "gen.l"
{ return(PROTECTED_TOK); }
	YY_BREAK
case 25:
# line 366 "gen.l"
{ return(PRIVATE_TOK);   }
	YY_BREAK
 /************************************************************************************/
 /*                       La lecture de la liste des parents                         */
 /************************************************************************************/
case 26:
# line 373 "gen.l"
{}
	YY_BREAK
case 27:
# line 374 "gen.l"
{ return ('<'); }
	YY_BREAK
case 28:
# line 375 "gen.l"
{ return ('>');}
	YY_BREAK
case 29:
# line 376 "gen.l"
{ return (',');}
	YY_BREAK
case 30:
# line 378 "gen.l"
{}
	YY_BREAK
case 31:
# line 379 "gen.l"
{
                                         strcpy(yylval.text, (char *) yytext);
                                         yylval.position = line_count;
                                         return(IDENT_TOK);
                                       }
	YY_BREAK
case 32:
# line 385 "gen.l"
{ BEGIN_STATE(BODY_STATE); return '{'; }
	YY_BREAK
 /************************************************************************************/
 /*                  La lecture des "members" declares dans une classe               */
 /************************************************************************************/
case 33:
# line 392 "gen.l"
{ virtual_flag = True; }
	YY_BREAK
case 34:
# line 394 "gen.l"
{ LINE_COUNT(); }
	YY_BREAK
case 35:
# line 396 "gen.l"
{ 
					 UNSTACK_STATE();
                                         *yy_class_name = '\0';
                                         return('}');
                                       }
	YY_BREAK
 /************************************************************************************/
 /*      La lecture de la liste des arguments d'une methode ou d'une procedure       */
 /************************************************************************************/
case 36:
# line 407 "gen.l"
{ return(UNSIGNED_TOK); }
	YY_BREAK
case 37:
# line 409 "gen.l"
{ return(SIGNED_TOK);   }
	YY_BREAK
case 38:
# line 411 "gen.l"
{ return(CHAR_TOK);     }
	YY_BREAK
case 39:
# line 413 "gen.l"
{ return(SHORT_TOK);    }
	YY_BREAK
case 40:
# line 415 "gen.l"
{ return(INT_TOK);      }
	YY_BREAK
case 41:
# line 417 "gen.l"
{ return(LONG_TOK);     }
	YY_BREAK
case 42:
# line 419 "gen.l"
{ return(STRUCT_TOK);   }
	YY_BREAK
case 43:
# line 421 "gen.l"
{ return(UNION_TOK);    }
	YY_BREAK
case 44:
# line 423 "gen.l"
{ return(CLASS_TOK);    }
	YY_BREAK
case 45:
# line 425 "gen.l"
{ return(CONST_TOK);    }
	YY_BREAK
case 46:
# line 427 "gen.l"
{ return(ENUM_TOK);    }
	YY_BREAK
case 47:
# line 429 "gen.l"
{ return('*');          }
	YY_BREAK
case 48:
# line 431 "gen.l"
{ return('&');          }
	YY_BREAK
case 49:
# line 433 "gen.l"
{ LINE_COUNT(); return(ARRAY_TOK);    }
	YY_BREAK
case 50:
# line 435 "gen.l"
{}
	YY_BREAK
case 51:
# line 437 "gen.l"
{}
	YY_BREAK
case 52:
# line 439 "gen.l"
{}
	YY_BREAK
case 53:
# line 441 "gen.l"
{ return('<'); }
	YY_BREAK
case 54:
# line 442 "gen.l"
{ return('>'); }
	YY_BREAK
case 55:
# line 443 "gen.l"
{ return(','); }
	YY_BREAK
case 56:
# line 446 "gen.l"
{
                                         strcpy(yylval.text, (char *) yytext);
                                         return(ELLIPSIS_TOK);
                                       }
	YY_BREAK
case 57:
# line 452 "gen.l"
{
                                         strcpy(yylval.text, (char *) yytext);
                                         return(IDENT_TOK);
                                       }
	YY_BREAK
case 58:
# line 457 "gen.l"
{
                                         strcpy(yylval.text, (char *) yytext);
                                         return(IDENT_TOK);
                                       }
	YY_BREAK
case 59:
# line 463 "gen.l"
{ BEGIN_STATE(INIT_STATE); }
	YY_BREAK
case 60:
# line 466 "gen.l"
{
                                         parent_level++;
                                         return('(');
                                       }
	YY_BREAK
case 61:
# line 472 "gen.l"
{
                                         if ((--parent_level) == 0)
                                           BEGIN_STATE(TAIL_STATE);
                                         return(')');
                                       }
	YY_BREAK
case 62:
# line 479 "gen.l"
{}
	YY_BREAK
case 63:
# line 482 "gen.l"
{}
	YY_BREAK
case 64:
# line 485 "gen.l"
{
                                         int  parent_level;
                                         char current;

                                         parent_level = 1;
                                         while (parent_level != 0) {
                                           current = input();
                                          switch(current) {
               			case EOF: yyterminate ();
               			 break;
                                             case '(' : parent_level++;
                                                        break;
                                             case ')' : parent_level--;
                                                        break;
                                           }
                                      }
                                    }
	YY_BREAK
case 65:
# line 504 "gen.l"
{ unput(','); BEGIN_STATE(ARG_STATE); }
	YY_BREAK
case 66:
# line 507 "gen.l"
{ unput(')'); BEGIN_STATE(ARG_STATE); }
	YY_BREAK
case 67:
# line 510 "gen.l"
{}
	YY_BREAK
 /************************************************************************************/
 /*                                  Les Divers                                      */
 /************************************************************************************/
case 68:
# line 517 "gen.l"
{ 
                                         LINE_COUNT(); 
                                         UNSTACK_STATE();
                                         if (const_flag == True) {
                                           const_flag = False;
                                           return(CONST_TOK);
                                         }
                                       }
	YY_BREAK
 /************************************************************************************/
 /*                                  Les Divers                                      */
 /************************************************************************************/
case 69:
# line 531 "gen.l"
{ bracket_level++; }
	YY_BREAK
case 70:
# line 533 "gen.l"
{
                                         if ((--bracket_level) == 0) {
                                           UNSTACK_STATE();
                                           return(SYNC_TOK);
                                         }
                                       }
	YY_BREAK
case 71:
# line 540 "gen.l"
{}
	YY_BREAK
case 72:
# line 542 "gen.l"
{}
	YY_BREAK
case 73:
# line 544 "gen.l"
{}
	YY_BREAK
case 74:
# line 546 "gen.l"
{}
	YY_BREAK
case 75:
# line 548 "gen.l"
{}
	YY_BREAK
case 76:
# line 550 "gen.l"
{}
	YY_BREAK
case 77:
# line 552 "gen.l"
{
                                         bracket_level = 1;
                                         STACK_STATE(CODE_STATE);
	                                   }
	YY_BREAK
case 78:
# line 558 "gen.l"
{ return(SYNC_TOK); }
	YY_BREAK
 /************************************************************************************/
case 79:
# line 563 "gen.l"
{
                                         STACK_STATE(CLASS_STATE1);
                                         /*return(CLASS_TOK);*/
                                       }
	YY_BREAK
case 80:
# line 567 "gen.l"
{
                                         STACK_STATE(CLASS_STATE1);
                                         /*return(CLASS_TOK);*/
                                       }
	YY_BREAK
case 81:
# line 572 "gen.l"
{
                                         STACK_STATE(CLASS_STATE1);
                                         /*return(STRUCT_TOK);*/
                                       }
	YY_BREAK
case 82:
# line 577 "gen.l"
{ return(STATIC_TOK); }
	YY_BREAK
case 83:
# line 579 "gen.l"
{ return(INLINE_TOK); }
	YY_BREAK
case 84:
# line 581 "gen.l"
{
                                         unsigned char* current;

                                         current = yytext + yyleng - 2;
                                         while ((--current) >= yytext) {
                                           if (isspace(*current)) {
                                             if ((*current) == '\n')
                                               line_count++;
                                           }
                                           else
                                             break;
                                         }
                                         *(current + 1) = '\0';
                                         strcpy(yy_class_name, (char *) yytext);
                                       }
	YY_BREAK
case 85:
# line 598 "gen.l"
{
                                         strcpy(yylval.text, "operator ");
                                         yylval.position = line_count;
                                         STACK_STATE(OPERATOR_STATE);
                                       }
	YY_BREAK
case 86:
# line 605 "gen.l"
{
		         if ( yytext[0] != '~' )
	                                         strcpy(yylval.text, (char *) yytext);
		         else {
			register unsigned char *p = yytext + 1;
			yylval.text [0]= '~';
			while (  isspace( *p ) ) 
				p++;
			strcpy(&(yylval.text[1]), (char *) p );
			LINE_COUNT();
		         }
                                         yylval.position = line_count;
                                         STACK_STATE(PROC_STATE1);
                                       }
	YY_BREAK
case 87:
# line 621 "gen.l"
{}
	YY_BREAK
 /************************************************************************************/
case 88:
# line 626 "gen.l"
ECHO;
	YY_BREAK
	    case YY_STATE_EOF(INITIAL):
	    case YY_STATE_EOF(MAIN_STATE):
	    case YY_STATE_EOF(OPERATOR_STATE):
	    case YY_STATE_EOF(PROC_STATE1):
	    case YY_STATE_EOF(PROC_STATE2):
	    case YY_STATE_EOF(CLASS_STATE1):
	    case YY_STATE_EOF(CLASS_STATE2):
	    case YY_STATE_EOF(TEMPLATE_STATE):
	    case YY_STATE_EOF(PARENT_STATE):
	    case YY_STATE_EOF(BODY_STATE):
	    case YY_STATE_EOF(ARG_STATE):
	    case YY_STATE_EOF(INIT_STATE):
	    case YY_STATE_EOF(TAIL_STATE):
	    case YY_STATE_EOF(CODE_STATE):
		yyterminate();

	    case YY_END_OF_BUFFER:
		{
		/* amount of text matched not including the EOB char */
		int yy_amount_of_matched_text = yy_cp - yytext - 1;

		/* undo the effects of YY_DO_BEFORE_ACTION */
		*yy_cp = yy_hold_char;

		/* note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the end-
		 * of-buffer state).  Contrast this with the test in yyinput().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
		    /* this was really a NUL */
		    {
		    yy_state_type yy_next_state;

		    yy_c_buf_p = yytext + yy_amount_of_matched_text;

		    yy_current_state = yy_get_previous_state();

		    /* okay, we're now positioned to make the
		     * NUL transition.  We couldn't have
		     * yy_get_previous_state() go ahead and do it
		     * for us because it doesn't know how to deal
		     * with the possibility of jamming (and we
		     * don't want to build jamming into it because
		     * then it will run more slowly)
		     */

		    yy_next_state = yy_try_NUL_trans( yy_current_state );

		    yy_bp = yytext + YY_MORE_ADJ;

		    if ( yy_next_state )
			{
			/* consume the NUL */
			yy_cp = ++yy_c_buf_p;
			yy_current_state = yy_next_state;
			goto yy_match;
			}

		    else
			{
			goto yy_find_action;
			}
		    }

		else switch ( yy_get_next_buffer() )
		    {
		    case EOB_ACT_END_OF_FILE:
			{
			yy_did_buffer_switch_on_eof = 0;

			if ( yywrap() )
			    {
			    /* note: because we've taken care in
			     * yy_get_next_buffer() to have set up yytext,
			     * we can now set up yy_c_buf_p so that if some
			     * total hoser (like flex itself) wants
			     * to call the scanner after we return the
			     * YY_NULL, it'll still work - another YY_NULL
			     * will get returned.
			     */
			    yy_c_buf_p = yytext + YY_MORE_ADJ;

			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
			    goto do_action;
			    }

			else
			    {
			    if ( ! yy_did_buffer_switch_on_eof )
				YY_NEW_FILE;
			    }
			}
			break;

		    case EOB_ACT_CONTINUE_SCAN:
			yy_c_buf_p = yytext + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			yy_cp = yy_c_buf_p;
			yy_bp = yytext + YY_MORE_ADJ;
			goto yy_match;

		    case EOB_ACT_LAST_MATCH:
			yy_c_buf_p =
			    &yy_current_buffer->yy_ch_buf[yy_n_chars];

			yy_current_state = yy_get_previous_state();

			yy_cp = yy_c_buf_p;
			yy_bp = yytext + YY_MORE_ADJ;
			goto yy_find_action;
		    }
		break;
		}

	    default:
#ifdef FLEX_DEBUG
		printf( "action # %d\n", yy_act );
#endif
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	    }
	}
    }


/* yy_get_next_buffer - try to read in a new buffer
 *
 * synopsis
 *     int yy_get_next_buffer();
 *     
 * returns a code representing an action
 *     EOB_ACT_LAST_MATCH - 
 *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *     EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()

    {
    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
	YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

    /* try to read more data */

    /* first move last chars to start of buffer */
    number_to_move = yy_c_buf_p - yytext;

    for ( i = 0; i < number_to_move; ++i )
	*(dest++) = *(source++);

    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
	/* don't do the read, it's not guaranteed to return an EOF,
	 * just force an EOF
	 */
	yy_n_chars = 0;

    else
	{
	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;

	if ( num_to_read > YY_READ_BUF_SIZE )
	    num_to_read = YY_READ_BUF_SIZE;

	else if ( num_to_read <= 0 )
	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

	/* read in more data */
	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
		  yy_n_chars, num_to_read );
	}

    if ( yy_n_chars == 0 )
	{
	if ( number_to_move - YY_MORE_ADJ == 1 )
	    {
	    ret_val = EOB_ACT_END_OF_FILE;
	    yy_current_buffer->yy_eof_status = EOF_DONE;
	    }

	else
	    {
	    ret_val = EOB_ACT_LAST_MATCH;
	    yy_current_buffer->yy_eof_status = EOF_PENDING;
	    }
	}

    else
	ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    /* yytext begins at the second character in yy_ch_buf; the first
     * character is the one which preceded it before reading in the latest
     * buffer; it needs to be kept around in case it's a newline, so
     * yy_get_previous_state() will have with '^' rules active
     */

    yytext = &yy_current_buffer->yy_ch_buf[1];

    return ( ret_val );
    }


/* yy_get_previous_state - get the state just before the EOB char was reached
 *
 * synopsis
 *     yy_state_type yy_get_previous_state();
 */

static yy_state_type yy_get_previous_state()

    {
    register yy_state_type yy_current_state;
    register YY_CHAR *yy_cp;

    register YY_CHAR *yy_bp = yytext;

    yy_current_state = yy_start;
    if ( yy_bp[-1] == '\n' )
	++yy_current_state;
    yy_state_ptr = yy_state_buf;
    *yy_state_ptr++ = yy_current_state;

    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
	{
	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
	    {
	    yy_current_state = yy_def[yy_current_state];
	    if ( yy_current_state >= 413 )
		yy_c = yy_meta[yy_c];
	    }
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	*yy_state_ptr++ = yy_current_state;
	}

    return ( yy_current_state );
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *     next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
register yy_state_type yy_current_state;
#endif

    {
    register int yy_is_jam;

    register YY_CHAR yy_c = 1;
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
	{
	yy_current_state = yy_def[yy_current_state];
	if ( yy_current_state >= 413 )
	    yy_c = yy_meta[yy_c];
	}
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    *yy_state_ptr++ = yy_current_state;
    yy_is_jam = (yy_current_state == 412);

    return ( yy_is_jam ? 0 : yy_current_state );
    }


#ifdef YY_USE_PROTOS
static void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
#else
static void yyunput( c, yy_bp )
YY_CHAR c;
register YY_CHAR *yy_bp;
#endif

    {
    register YY_CHAR *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
	{ /* need to shift things up to make room */
	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
	register YY_CHAR *dest =
	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
	register YY_CHAR *source =
	    &yy_current_buffer->yy_ch_buf[number_to_move];

	while ( source > yy_current_buffer->yy_ch_buf )
	    *--dest = *--source;

	yy_cp += dest - source;
	yy_bp += dest - source;
	yy_n_chars = yy_current_buffer->yy_buf_size;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
	}

    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
	yy_cp[-2] = '\n';

    *--yy_cp = c;

    /* note: the formal parameter *must* be called "yy_bp" for this
     *       macro to now work correctly
     */
    YY_DO_BEFORE_ACTION; /* set up yytext again */
    }


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif

    {
    int c;
    YY_CHAR *yy_cp = yy_c_buf_p;

    *yy_cp = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
	{
	/* yy_c_buf_p now points to the character we want to return.
	 * If this occurs *before* the EOB characters, then it's a
	 * valid NUL; if not, then we've hit the end of the buffer.
	 */
	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
	    /* this was really a NUL */
	    *yy_c_buf_p = '\0';

	else
	    { /* need more input */
	    yytext = yy_c_buf_p;
	    ++yy_c_buf_p;

	    switch ( yy_get_next_buffer() )
		{
		case EOB_ACT_END_OF_FILE:
		    {
		    if ( yywrap() )
			{
			yy_c_buf_p = yytext + YY_MORE_ADJ;
			return ( EOF );
			}

		    YY_NEW_FILE;

#ifdef __cplusplus
		    return ( yyinput() );
#else
		    return ( input() );
#endif
		    }
		    break;

		case EOB_ACT_CONTINUE_SCAN:
		    yy_c_buf_p = yytext + YY_MORE_ADJ;
		    break;

		case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
		    YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
		}
	    }
	}

    c = *yy_c_buf_p;
    yy_hold_char = *++yy_c_buf_p;

    return ( c );
    }


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif

    {
    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif

    {
    if ( yy_current_buffer == new_buffer )
	return;

    if ( yy_current_buffer )
	{
	/* flush out information for old buffer */
	*yy_c_buf_p = yy_hold_char;
	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
	yy_current_buffer->yy_n_chars = yy_n_chars;
	}

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* we don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif

    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif

    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );

    if ( ! b )
	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );

    if ( ! b->yy_ch_buf )
	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    yy_init_buffer( b, file );

    return ( b );
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    if ( b == yy_current_buffer )
	yy_current_buffer = (YY_BUFFER_STATE) 0;

    free( (char *) b->yy_ch_buf );
    free( (char *) b );
    }


#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif

    {
    b->yy_input_file = file;

    /* we put in the '\n' and start reading from [1] so that an
     * initial match-at-newline will be true.
     */

    b->yy_ch_buf[0] = '\n';
    b->yy_n_chars = 1;

    /* we always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[1];

    b->yy_eof_status = EOF_NOT_SEEN;
    }
# line 626 "gen.l"


void flex_init(file)
   FILE* file;
{
  static int first_call = 1;
  line_count   = 1;
  next_free    = 0;
  virtual_flag = False;
  yyin = file;

  yy_init = 1;
  yy_start = 0;

  if (first_call == 1)
    first_call = 0;
  else
        yyrestart (file);
}
