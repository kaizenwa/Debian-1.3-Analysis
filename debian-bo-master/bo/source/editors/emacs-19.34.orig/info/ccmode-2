This is Info file ../info/ccmode, produced by Makeinfo-1.63 from the
input file cc-mode.texi.

   Copyright (C) 1995 Free Software Foundation, Inc.


File: ccmode,  Node: Custom Indentation Functions,  Next: Custom Brace and Colon Hanging,  Up: Advanced Customizations

Custom Indentation Functions
----------------------------

   One of the most common ways to customize `cc-mode' is by writing
"custom indentation functions" and associating them with specific
syntactic symbols (see *Note Syntactic Symbols::).  `cc-mode' itself
uses custom indentation functions to provide more sophisticated
indentation, for example when lining up C++ stream operator blocks:

     1: void main(int argc, char**)
     2: {
     3:   cout << "There were "
     4:     << argc
     5:     << "arguments passed to the program"
     6:     << endl;
     7: }

   In this example, lines 4 through 6 are assigned the `stream-op'
syntactic symbol.  If `stream-op' had an offset of `+', and
`c-basic-offset' was 2, lines 4 through 6 would simply be indented two
spaces to the right of line 3.  But perhaps we'd like `cc-mode' to be a
little more intelligent so that it offsets the stream operators under
the operator in line 3.  To do this, we have to write a custom
indentation function which finds the column of first stream operator on
the first line of the statement.  Here is the lisp code (from the
`cc-mode.el' source file) that implements this:

     (defun c-lineup-streamop (langelem)
       ;; lineup stream operators
       (save-excursion
         (let* ((relpos (cdr langelem))
                (curcol (progn (goto-char relpos)
                               (current-column))))
           (re-search-forward "<<\\|>>" (c-point 'eol) 'move)
           (goto-char (match-beginning 0))
           (- (current-column) curcol))))

Custom indent functions take a single argument, which is a syntactic
component cons cell (see *Note Syntactic Analysis::).  The function
returns an integer offset value that will be added to the running total
indentation for the line.  Note that what actually gets returned is the
difference between the column that the first stream operator is on, and
the column of the buffer relative position passed in the function's
argument.  Remember that `cc-mode' automatically adds in the column of
the component's relative buffer position and we don't want that value
added into the final total twice.

   Now, to associate the function `c-lineup-streamop' with the
`stream-op' syntactic symbol, we can add something like the following
to our `c++-mode-hook'(1):

     (c-set-offset 'stream-op 'c-lineup-streamop)

   Now the function looks like this after re-indenting (using `C-c
C-q'):

     1: void main(int argc, char**)
     2: {
     3:   cout << "There were "
     4:        << argc
     5:        << "arguments passed to the program"
     6:        << endl;
     7: }

   Custom indentation functions can be as simple or as complex as you
like, and any syntactic symbol that appears in `c-offsets-alist' can
have a custom indentation function associated with it.

   ---------- Footnotes ----------

   (1)  It probably makes more sense to add this to `c++-mode-hook'
than `c-mode-common-hook' since stream operators are only relevant for
C++.


File: ccmode,  Node: Custom Brace and Colon Hanging,  Next: Customizing Semi-colons and Commas,  Prev: Custom Indentation Functions,  Up: Advanced Customizations

Custom Brace and Colon Hanging
------------------------------

   Syntactic symbols aren't the only place where you can customize
`cc-mode' with the lisp equivalent of callback functions.  Brace
hanginess can also be determined by custom functions associated with
syntactic symbols on the `c-hanging-braces-alist' variable.  Remember
that ACTION's are typically a list containing some combination of the
symbols `before' and `after' (see *Note Hanging Braces::).  However, an
ACTION can also be a function symbol which gets called when a brace
matching that syntactic symbol is typed.

   These ACTION functions are called with two arguments: the syntactic
symbol for the brace, and the buffer position at which the brace was
inserted.  The ACTION function is expected to return a list containing
some combination of `before' and `after'.  The function can also return
`nil'.  This return value has the normal brace hanging semantics
described in *Note Hanging Braces::.

   As an example, `cc-mode' itself uses this feature to dynamically
determine the hanginess of braces which close `do-while' constructs:

     void do_list( int count, char** atleast_one_string )
     {
         int i=0;
         do {
             handle_string( atleast_one_string( i ));
             i++;
         } while( i < count );
     }

   `cc-mode' assigns the `block-close' syntactic symbol to the brace
that closes the `do' construct, and normally we'd like the line that
follows a `block-close' brace to begin on a separate line.  However,
with `do-while' constructs, we want the `while' clause to follow the
closing brace.  To do this, we associate the `block-close' symbol with
the ACTION function `c-snug-do-while':

     (defun c-snug-do-while (syntax pos)
       "Dynamically calculate brace hanginess for do-while statements.
     Using this function, `while' clauses that end a `do-while' block will
     remain on the same line as the brace that closes that block.
     
     See `c-hanging-braces-alist' for how to utilize this function as an
     ACTION associated with `block-close' syntax."
       (save-excursion
         (let (langelem)
           (if (and (eq syntax 'block-close)
                    (setq langelem (assq 'block-close c-syntactic-context))
                    (progn (goto-char (cdr langelem))
                           (if (= (following-char) ?{)
                               (forward-sexp -1))
                           (looking-at "\\<do\\>[^_]")))
               '(before)
             '(before after)))))

   This function simply looks to see if the brace closes a `do-while'
clause and if so, returns the list ``(before)'' indicating that a
newline should be inserted before the brace, but not after it.  In all
other cases, it returns the list ``(before after)'' so that the brace
appears on a line by itself.

   During the call to the brace hanging ACTION function, the variable
`c-syntactic-context' is bound to the full syntactic analysis list.

   Note that for symmetry, colon hanginess should be customizable by
allowing function symbols as ACTIONs on the `c-hanging-colon-alist'
variable.  Since no use has actually been found for this feature, it
isn't currently implemented.


File: ccmode,  Node: Customizing Semi-colons and Commas,  Next: Other Special Indentations,  Prev: Custom Brace and Colon Hanging,  Up: Advanced Customizations

Customizing Semi-colons and Commas
----------------------------------

   You can also customize the insertion of newlines after semi-colons
and commas, when the auto-newline minor mode is enabled (see *Note
Minor Modes::).  This is controlled by the variable
`c-hanging-semi&comma-criteria', which contains a list of functions
that are called in the order they appear.  Each function is called with
zero arguments, and is expected to return one of the following values:

   * non-`nil' - A newline is inserted, and no more functions from the
     list are called.

   * `stop' - No more functions from the list are called, but no
     newline is inserted.

   * `nil' - No determination is made, and the next function in the
     list is called.

   If every function in the list is called without a determination being
made, then no newline is added. The default value for this variable is a
list containing a single function which inserts newlines only after
semi-colons which do not appear inside parenthesis lists (i.e. those
that separate `for'-clause statements).


File: ccmode,  Node: Other Special Indentations,  Prev: Customizing Semi-colons and Commas,  Up: Advanced Customizations

Other Special Indentations
--------------------------

   One other customization variable is available in `cc-mode':
`c-special-indent-hook'.  This is a standard hook variable that is
called after every line is indented by `cc-mode'.  You can use it to do
any special indentation or line adjustments your style dictates, such
as adding extra indentation to constructors or destructor declarations
in a class definition, etc.  Note however, that you should not change
point or mark inside your `c-special-indent-hook' functions (i.e.
you'll probably want to wrap your function in a `save-excursion').


File: ccmode,  Node: Syntactic Symbols,  Next: Performance Issues,  Prev: Customizing Indentation,  Up: Top

Syntactic Symbols
*****************

   The complete list of recognized syntactic symbols is described in the
`c-offsets-alist' variable.  This chapter will provide some examples to
help clarify these symbols.

   Most syntactic symbol names follow a general naming convention.
When a line begins with an open or close brace, the syntactic symbol
will contain the suffix `-open' or `-close' respectively.

   Usually, a distinction is made between the first line that
introduces a construct and lines that continue a construct, and the
syntactic symbols that represent these lines will contain the suffix
`-intro' or `-cont' respectively.  As a sub-classification of this
scheme, a line which is the first of a particular brace block construct
will contain the suffix `-block-intro'.

   Let's look at some examples to understand how this works.  Remember
that you can check the syntax of any line by using `C-c C-s'.

       1: void
       2: swap( int& a, int& b )
       3: {
       4:     int tmp = a;
       5:     a = b;
       6:     b = tmp;
       7:     int ignored =
       8:         a + b;
       9: }

   Line 1 shows a `topmost-intro' since it is the first line that
introduces a top-level construct.  Line 2 is a continuation of the
top-level construct introduction so it has the syntax
`topmost-intro-cont'.  Line 3 shows a `defun-open' since it is the
brace that opens a top-level function definition.  Line 9 is a
`defun-close' since it contains the brace that closes the top-level
function definition.  Line 4 is a `defun-block-intro', i.e. it is the
first line of a brace-block, which happens to be enclosed in a
top-level function definition.

   Lines 5, 6, and 7 are all given `statement' syntax since there isn't
much special about them.  Note however that line 8 is given
`statement-cont' syntax since it continues the statement begun on the
previous line.

   Here's another example, which illustrates some C++ class syntactic
symbols:

        1: class Bass
        2:     : public Guitar,
        3:       public Amplifiable
        4: {
        5: public:
        6:     Bass()
        7:         : eString( new BassString( 0.105 )),
        8:           aString( new BassString( 0.085 )),
        9:           dString( new BassString( 0.065 )),
       10:           gString( new BassString( 0.045 ))
       11:     {
       12:         eString.tune( 'E' );
       13:         aString.tune( 'A' );
       14:         dString.tune( 'D' );
       15:         gString.tune( 'G' );
       16:     }
       17: }

   As in the previous example, line 1 has the `topmost-intro' syntax.
Here however, the brace that opens a C++ class definition on line 4 is
assigned the `class-open' syntax.  Note that in C++, structs and unions
are essentially equivalent syntactically (and are very similar
semantically), so replacing the `class' keyword in the example above
with `struct' or `union' would still result in a syntax of `class-open'
for line 4 (1).  Similarly, line 17 is assigned `class-close' syntax.

   Line 2 introduces the inheritance list for the class so it is
assigned the `inher-intro' syntax, and line 3, which continues the
inheritance list is given `inher-cont' syntax.

   Things get interesting at line 5.  The primary syntactic symbol for
this line is `access-label' since this a label keyword that specifies
access protection in C++.  However, this line actually shows two
syntactic symbols when you hit `C-c C-s'.  This is because it is also a
top-level construct inside a class definition.  Thus the other
syntactic symbol assigned to this line is `inclass'.  Similarly, line 6
is given both `inclass' and `topmost-intro' syntax.

   Line 7 introduces a C++ member initialization list and as such is
given `member-init-intro' syntax.  Note that in this case it is *not*
assigned `inclass' since this is not considered a top-level construct.
Lines 8 through 10 are all assigned `member-init-cont' since they
continue the member initialization list started on line 7.

   Line 11 is assigned `inline-open' because it opens an "in-class" C++
inline method definition.  This is distinct from, but related to, the
C++ notion of an inline function in that its definition occurs inside
an enclosing class definition, which in C++ implies that the function
should be inlined.  For example, if the definition of the `Bass'
constructor appeared outside the class definition, line 11 would be
given the `defun-open' syntax, even if the keyword `inline' appeared
before the method name, as in:

     class Bass
         : public Guitar,
           public Amplifiable
     {
     public:
         Bass();
     }
     
     inline
     Bass::Bass()
         : eString( new BassString( 0.105 )),
           aString( new BassString( 0.085 )),
           dString( new BassString( 0.065 )),
           gString( new BassString( 0.045 ))
     {
         eString.tune( 'E' );
         aString.tune( 'A' );
         dString.tune( 'D' );
         gString.tune( 'G' );
     }

Similarly, line 16 is given `inline-close' syntax.

   As in the first example above, line 12 is given `defun-block-open'
syntax and lines 13 through 15 are all given `statement' syntax.

   Here is another (totally contrived) example which illustrates how
syntax is assigned to various conditional constructs:

        1: void spam( int index )
        2: {
        3:     for( int i=0; i<index; i++ )
        4:     {
        5:         if( i == 10 )
        6:         {
        7:             do_something_special();
        8:         }
        9:         else
       10:             do_something( i );
       11:     }
       12:     do {
       13:         another_thing( i-- );
       14:     }
       15:     while( i > 0 );
       16: }

Only the lines that illustrate new syntactic symbols will be discussed.

   Line 4 has a brace which opens a conditional's substatement block.
It is thus assigned `substatement-open' syntax, and since line 5 is the
first line in the substatement block, it is assigned
`substatement-block-intro' syntax.  Lines 6 and 7 are assigned similar
syntax.  Line 8 contains the brace that closes the inner substatement
block.  It is given the generic syntax `block-close', as are lines 11
and 14.

   Line 9 is a little different - since it contains the keyword `else'
matching the `if' statement introduced on line 5; it is given the
`else-clause' syntax.  Note also that line 10 is slightly different
too.  Because `else' is considered a conditional introducing keyword
(2), and because the following substatement is not a brace block, line
10 is assigned the `substatement' syntax.

   One other difference is seen on line 15.  The `while' construct that
closes a `do' conditional is given the special syntax
`do-while-closure' if it appears on a line by itself.  Note that if the
`while' appeared on the same line as the preceding close brace, that
line would have been assigned `block-close' syntax instead.

   Switch statements have their own set of syntactic symbols.  Here's an
example:

        1: void spam( enum Ingredient i )
        2: {
        3:     switch( i ) {
        4:     case Ham:
        5:         be_a_pig();
        6:         break;
        7:     case Salt:
        8:         drink_some_water();
        9:         break;
       10:     default:
       11:         {
       12:             what_is_it();
       13:             break;
       14:         }
       15:     }
       14: }

   Here, lines 4, 7, and 10 are all assigned `case-label' syntax, while
lines 5 and 8 are assigned `statement-case-intro'.  Line 11 is treated
slightly differently since it contains a brace that opens a block - it
is given `statement-case-open' syntax.

   There are a set of syntactic symbols that are used to recognize
constructs inside of brace lists.  A brace list is defined as an `enum'
or aggregate initializer list, such as might statically initialize an
array of structs.  For example:

       1: static char* ingredients[] =
       2: {
       3:     "Ham",
       4:     "Salt",
       5:     NULL
       6: }

   Following convention, line 2 in this example is assigned
`brace-list-open' syntax, and line 3 is assigned `brace-list-intro'
syntax.  Likewise, line 6 is assigned `brace-list-close' syntax.  Lines
4 and 5 however, are assigned `brace-list-entry' syntax, as would all
subsequent lines in this initializer list.

   A number of syntactic symbols are associated with parenthesis lists,
a.k.a argument lists, as found in function declarations and function
calls.  This example illustrates these:

        1: void a_function( int line1,
        2:                  int line2 );
        3:
        4: void a_longer_function(
        5:     int line1,
        6:     int line2
        7:     );
        8:
        9: void call_them( int line1, int line2 )
       10: {
       11:     a_function(
       12:         line1,
       13:         line2
       14:         );
       15:
       16:     a_longer_function( line1,
       17:                        line2 );
       18: }

   Lines 5 and 12 are assigned `arglist-intro' syntax since they are
the first line following the open parenthesis, and lines 7 and 14 are
assigned `arglist-close' syntax since they contain the parenthesis that
closes the argument list.

   The other lines with relevant syntactic symbols include lines 2 and
17 which are assigned `arglist-cont-nonempty' syntax.  What this means
is that they continue an argument list, but that the line containing the
parenthesis that opens the list is *non-empty* following the open
parenthesis.  Contrast this against lines 6 and 13 which are assigned
`arglist-cont' syntax.  This is because the parenthesis that opens
their argument lists is the last character on that line (3).

   Note that there is no `arglist-open' syntax.  This is because any
parenthesis that opens an argument list, appearing on a separate line,
is assigned the `statement-cont' syntax instead.

   A few miscellaneous syntactic symbols that haven't been previously
covered are illustrated by this example:

        1: void Bass::play( int volume )
        2: const
        3: {
        4:     /* this line starts a multi-line
        5:      * comment.  This line should get `c' syntax */
        6:
        7:     char* a_long_multiline_string = "This line starts a multi-line \
        8: string.  This line should get `string' syntax.";
        9:
       10:   note:
       11:     {
       12: #ifdef LOCK
       13:         Lock acquire();
       14: #endif // LOCK
       15:         slap_pop();
       16:         cout << "I played "
       17:              << "a note\n";
       18:     }
       19: }

   The lines to note in this example include:

   * line 2 which is assigned the `ansi-funcdecl-cont' syntax;

   * line 4 which is assigned both `defun-block-intro' *and*
     `comment-intro' syntax (4);

   * line 5 which is assigned `c' syntax;

   * line 6 which, even though it contains nothing but whitespace, is
     assigned `defun-block-intro'.  Note that the appearance of the
     comment on lines 4 and 5 do not cause line 6 to be assigned
     `statement' syntax because comments are considered to be
     "syntactic whitespace", which are essentially ignored when
     analyzing code;

   * line 8 which is assigned `string' syntax;

   * line 10 which is assigned `label' syntax;

   * line 11 which is assigned `block-open' syntax;

   * lines 12 and 14 which are assigned `cpp-macro' syntax;

   * line 17 which is assigned `stream-op' syntax (5).

   In Objective-C buffers, there are three additional syntactic symbols
assigned to various message calling constructs.  Here's an example
illustrating these:

       1: - (void)setDelegate:anObject
       2:           withStuff:stuff
       3: {
       4:     [delegate masterWillRebind:self
       5:               toDelegate:anObject
       6:               withExtraStuff:stuff];
       7: }

   Here, line 1 is assigned `objc-method-intro' syntax, and line 2 is
assigned `objc-method-args-cont' syntax.  Lines 5 and 6 are both
assigned `objc-method-call-cont' syntax.

   Other syntactic symbols may be recognized by `cc-mode', but these
are more obscure and so I haven't included examples of them.  These
include: `knr-argdecl-intro', `knr-argdecl', and the `friend' modifier.

   ---------- Footnotes ----------

   (1)  This is the case even for C and Objective-C.  For consistency,
structs in all three languages are syntactically equivalent to classes.
Note however that the keyword `class' is meaningless in C and
Objective-C.

   (2)  The list of conditional keywords are (in C, Objective-C and
C++): `for', `if', `do', `else', `while', and `switch'.  C++ has two
additional conditional keywords: `try' and `catch'.

   (3)  The need for this somewhat confusing arrangement is that the
typical indentation desired for these lines is calculated very
differently.  This should be simplified in version 5 of `cc-mode',
along with the added distinction between argument lists in function
declarations, and argument lists in function calls.

   (4)  The `comment-intro' syntactic symbol is known generically as a
"modifier" since it always appears on a syntactic analysis list with
other symbols, and never has a relative buffer position.

   (5)  In C++ only.


File: ccmode,  Node: Performance Issues,  Next: Frequently Asked Questions,  Prev: Syntactic Symbols,  Up: Top

Performance Issues
******************

   C and its derivative languages are highly complex creatures.  Often,
ambiguous code situations arise that require `cc-mode' to scan large
portions of the buffer to determine syntactic context.  Some
pathological code can cause `cc-mode' to slow down considerably.  This
section identifies some of the coding styles to watch out for, and
suggests some workarounds that you can use to improve performance.

   Note that this is an area that will get a lot of attention in
`cc-mode' version 5.  The mode should end up being much faster, at the
expense of dropping Emacs 18 support, owing to the implementation of
syntactic analysis caching.  This is the last release of `cc-mode' that
will be compatible with Emacs 18.

   Because `cc-mode' has to scan the buffer backwards from the current
insertion point, and because C's syntax is fairly difficult to parse in
the backwards direction, `cc-mode' often tries to find the nearest
position higher up in the buffer from which to begin a forward scan.
The farther this position is from the current insertion point, the
slower the mode gets.  Some coding styles can even force `cc-mode' to
scan from the beginning of the buffer!

   One of the simplest things you can do to reduce scan time, is make
sure any brace that opens a top-level block construct always appears in
the leftmost column.  This is actually an Emacs constraint, as embodied
in the `beginning-of-defun' function which `cc-mode' uses heavily.  If
you insist on hanging top-level open braces on the right side of the
line, then you should set the variable `defun-prompt-regexp' to
something reasonable (1), however that "something reasonable" is
difficult to define, so `cc-mode' doesn't do it for you.

   You will probably notice pathological behavior from `cc-mode' when
working in files containing large amounts of cpp macros.  This is
because `cc-mode' cannot quickly skip backwards over these lines, which
do not contribute to the syntactic calculations.  You'll probably also
have problems if you are editing "K&R" C code, i.e. C code that does
not use function prototypes.  This is because there are ambiguities in
the C syntax when K&R style argument lists are used, and `cc-mode' has
to use a slower scan to determine what it's looking at.

   For the latter problem, I would suggest converting to ANSI style
protocols, and turning the variable `c-recognize-knr-p' to `nil' (this
is its default value for all modes).

   For the former problem, you might want to investigate some of the
speed-ups provided for you in the file `cc-lobotomy.el', which is part
of the canonical `cc-mode' distribution.  As mentioned previously,
`cc-mode' always trades accuracy for speed; however it is recognized
that sometimes you need speed and can sacrifice some accuracy in
indentation.  The file `cc-lobotomy.el' contains hacks that will "dumb
down" `cc-mode' in some specific ways, making that trade-off of speed
for accuracy.  I won't go into details of its use here; you should read
the comments at the top of the file, and look at the variable
`cc-lobotomy-pith-list' for details.

   ---------- Footnotes ----------

   (1)  Note that this variable is only defined in Emacs 19.


File: ccmode,  Node: Frequently Asked Questions,  Next: Getting the latest cc-mode release,  Prev: Performance Issues,  Up: Top

Frequently Asked Questions
**************************

     *Q.* *How do I re-indent the whole file?*

     *A.* Visit the file and hit `C-x h' to mark the whole buffer. Then
     hit `ESC C-\'.

     *Q.* *How do I re-indent the entire function?  `ESC C-x' doesn't
     work.*

     *A.* `ESC C-x' is reserved for future Emacs use.  To re-indent the
     entire function hit `C-c C-q'.

     *Q.* *How do I re-indent the current block?*

     *A.* First move to the brace which opens the block with `ESC C-u',
     then re-indent that expression with `ESC C-q'.

     *Q.* *Why doesn't the RET key indent the line to where the new
     text should go after inserting the newline?*

     *A.* Emacs' convention is that RET just adds a newline, and that
     LFD adds a newline and indents it.  You can make RET do this too
     by adding this to your `c-mode-common-hook' (see the sample
     `.emacs' file *Note Sample .emacs File::):

          (define-key c-mode-map "\C-m" 'newline-and-indent)

     This is a very common question. `:-)' If you want this to be the
     default behavior, don't lobby me, lobby RMS!

     *Q.* *I put `(c-set-offset 'substatement-open 0)' in my `.emacs'
     file but I get an error saying that `c-set-offset''s function
     definition is void.*

     *A.* This means that `cc-mode' wasn't loaded into your Emacs
     session by the time the `c-set-offset' call was reached, mostly
     likely because `cc-mode' is being autoloaded.  Instead of putting
     the `c-set-offset' line in your top-level `.emacs' file, put it in
     your `c-mode-common-hook', or simply add the following to the top
     of your `.emacs' file:

          (require 'cc-mode)

     See the sample `.emacs' file *Note Sample .emacs File:: for
     details.

     *Q.* *How do I make strings, comments, keywords, and other
     constructs appear in different colors, or in bold face, etc.?*

     *A.* "Syntax Colorization" is an Emacs 19 feature, controlled by
     `font-lock-mode'.  It is not part of `cc-mode'.



File: ccmode,  Node: Getting the latest cc-mode release,  Next: Sample .emacs File,  Prev: Frequently Asked Questions,  Up: Top

Getting the latest `cc-mode' release
************************************

   `cc-mode' is now distributed with both Emacs 19 and XEmacs 19, so
you would typically just use the version that comes with your Emacs.
Users of older versions of Emacs can get the latest release from this
URL:


         `ftp://ftp.python.org/pub/emacs/cc-mode.tar.gz'

   Note that this is a "gzipped" tar file.

   If you do not have anonymous ftp access, you can get the distribution
through an anonymous ftp-to-mail gateway, such as the one run by DEC at
`ftpmail@decwrl.dec.com'.  To get `cc-mode' via email, send the
following message in the body of your mail to that address:

     reply <a valid net address back to you>
     connect ftp.python.org
     binary
     uuencode
     chdir pub/emacs
     get cc-mode.tar.gz

or just send the message "help" for more information on ftpmail.
Response times will vary with the number of requests in the queue.


File: ccmode,  Node: Sample .emacs File,  Next: Requirements,  Prev: Getting the latest cc-mode release,  Up: Top

Sample `.emacs' file
********************

     ;; Here's a sample .emacs file that might help you along the way.  Just
     ;; copy this region and paste it into your .emacs file.  You may want to
     ;; change some of the actual values.
     
     (defconst my-c-style
       '((c-tab-always-indent           . t)
         (c-comment-only-line-offset    . 4)
         (c-hanging-braces-alist        . ((substatement-open after)
                                           (brace-list-open)))
         (c-hanging-colons-alist        . ((member-init-intro before)
                                           (inher-intro)
                                           (case-label after)
                                           (label after)
                                           (access-label after)))
         (c-cleanup-list                . (scope-operator
                                           empty-defun-braces
                                           defun-close-semi))
         (c-offsets-alist               . ((arglist-close     . c-lineup-arglist)
                                           (substatement-open . 0)
                                           (case-label        . 4)
                                           (block-open        . 0)
                                           (knr-argdecl-intro . -)))
         (c-echo-syntactic-information-p . t)
         )
       "My C Programming Style")
     
     ;; Customizations for all of c-mode, c++-mode, and objc-mode
     (defun my-c-mode-common-hook ()
       ;; add my personal style and set it for the current buffer
       (c-add-style "PERSONAL" my-c-style t)
       ;; offset customizations not in my-c-style
       (c-set-offset 'member-init-intro '++)
       ;; other customizations
       (setq tab-width 8
             ;; this will make sure spaces are used instead of tabs
             indent-tabs-mode nil)
       ;; we like auto-newline and hungry-delete
       (c-toggle-auto-hungry-state 1)
       ;; keybindings for C, C++, and Objective-C.  We can put these in
       ;; c-mode-map because c++-mode-map and objc-mode-map inherit it
       (define-key c-mode-map "\C-m" 'newline-and-indent)
       )
     
     ;; the following only works in Emacs 19
     ;; Emacs 18ers can use (setq c-mode-common-hook 'my-c-mode-common-hook)
     (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)


File: ccmode,  Node: Requirements,  Next: Limitations and Known Bugs,  Prev: Sample .emacs File,  Up: Top

Requirements
************

   `cc-mode.el' requires `reporter.el' for submission of bug reports.
`reporter.el' is distributed with the latest Emacs 19s.  Here is the
Emacs Lisp Archive anonymous ftp'ing record for those of you who are
using older Emacsen.


              GNU Emacs Lisp Code Directory Apropos -- "reporter"
     "~/" refers to archive.cis.ohio-state.edu:/pub/gnu/emacs/elisp-archive/
     
     reporter (2.12)       06-Jul-1994
          Barry A. Warsaw, <bwarsaw@cnri.reston.va.us>
          ~/misc/reporter.el.Z
          Customizable bug reporting of lisp programs.


File: ccmode,  Node: Limitations and Known Bugs,  Next: Mailing Lists and Submitting Bug Reports,  Prev: Requirements,  Up: Top

Limitations and Known Bugs
**************************

   * Multi-line macros are not handled properly.

   * Re-indenting large regions or expressions can be slow.

   * Use with Emacs 18 can be slow and annoying. You should seriously
     consider upgrading to Emacs 19.

   * There is still some weird behavior when filling C block comments.
     My suggestion is to check out add-on fill packages such as
     `filladapt', available at the elisp archive.

   * Lines following `inline-close' braces which hang "after" do not
     line up correctly.  Hit `TAB' to reindent the line.


File: ccmode,  Node: Mailing Lists and Submitting Bug Reports,  Next: Concept Index,  Prev: Limitations and Known Bugs,  Up: Top

Mailing Lists and Submitting Bug Reports
****************************************

   To report bugs, use the `C-c C-b' (`c-submit-bug-report') command.
This provides vital information I need to reproduce your problem.  Make
sure you include a concise, but complete code example.  Please try to
boil your example down to just the essential code needed to reproduce
the problem, and include an exact recipe of steps needed to expose the
bug.  Be especially sure to include any code that appears *before* your
bug example.

   Bug reports are now to be sent to `bug-gnu-emacs@prep.ai.mit.edu'
which is mirrored on the Usenet newsgroup `gnu.emacs.bug'.  Other
questions and suggestions should be mailed to
`help-gnu-emacs@prep.ai.mit.edu' which is mirrored on `gnu.emacs.help'.

   Note that the `cc-mode' Majordomo mailing lists have been disbanded!
With the inclusion of `cc-mode' in both of the latest flavors of Emacs
19, the need for them has ended.


File: ccmode,  Node: Concept Index,  Next: Command Index,  Prev: Mailing Lists and Submitting Bug Reports,  Up: Top

Concept Index
*************

* Menu:

* -block-intro syntactic symbols:       Syntactic Symbols.
* -close syntactic symbols:             Syntactic Symbols.
* -cont syntactic symbols:              Syntactic Symbols.
* -intro syntactic symbols:             Syntactic Symbols.
* -open syntactic symbols:              Syntactic Symbols.
* .emacs file:                          Getting Connected.
* cc-compat.el file:                    Introduction.
* cc-lobotomy.el file:                  Performance Issues.
* cc-mode-18.el file:                   Getting Connected.
* Adding Styles:                        Adding Styles.
* Advanced Customizations:              Advanced Customizations.
* announcement mailing list:            Mailing Lists and Submitting Bug Reports.
* Auto-newline insertion:               Auto-newline insertion.
* basic-offset (c-):                    Customizing Indentation.
* beta testers mailing list:            Mailing Lists and Submitting Bug Reports.
* block-close syntactic symbol:         Hanging Braces.
* block-open syntactic symbol:          Hanging Braces.
* BOCM:                                 Introduction.
* brace lists:                          Syntactic Symbols.
* brace-list-close syntactic symbol:    Hanging Braces.
* brace-list-entry syntactic symbol:    Hanging Braces.
* brace-list-intro syntactic symbol:    Hanging Braces.
* brace-list-open syntactic symbol:     Hanging Braces.
* BSD style:                            Built-in Styles.
* Built-in Styles:                      Built-in Styles.
* byte compile:                         Getting Connected.
* c-basic-offset:                       Customizing Indentation.
* c-hanging- functions:                 Indentation Commands.
* c-set-offset:                         Customizing Indentation.
* CC-MODE style:                        Built-in Styles.
* class-close syntactic symbol:         Hanging Braces.
* class-open syntactic symbol:          Hanging Braces.
* Clean-ups:                            Clean-ups.
* clean-ups:                            Hanging Colons.
* comment only line:                    Syntactic Analysis.
* comment-only line:                    Other electric commands.
* Custom Brace and Colon Hanging:       Custom Brace and Colon Hanging.
* custom indentation function:          Hanging Braces.
* Custom Indentation Functions:         Custom Indentation Functions.
* customizing brace hanging:            Custom Brace and Colon Hanging.
* customizing colon hanging:            Custom Brace and Colon Hanging.
* Customizing Indentation:              Customizing Indentation.
* Customizing Semi-colons and Commas <1>: Other Special Indentations.
* Customizing Semi-colons and Commas:   Customizing Semi-colons and Commas.
* defun-close syntactic symbol:         Hanging Braces.
* defun-open syntactic symbol:          Hanging Braces.
* electric characters:                  Minor Modes.
* electric commands:                    Auto-newline insertion.
* Ellemtel style:                       Built-in Styles.
* File Styles:                          File Styles.
* Frequently Asked Questions:           Frequently Asked Questions.
* Getting Connected:                    Getting Connected.
* Getting the latest cc-mode release:   Getting the latest cc-mode release.
* GNU style:                            Built-in Styles.
* Hanging Braces:                       Hanging Braces.
* Hanging Colons:                       Hanging Colons.
* Hanging Semi-colons and commas:       Hanging Semi-colons and commas.
* hooks:                                Permanent Customization.
* Hungry-deletion of whitespace:        Hungry-deletion of whitespace.
* in-class inline methods:              Syntactic Symbols.
* Indentation Calculation:              Indentation Calculation.
* Indentation Commands:                 Indentation Commands.
* inline-close:                         Limitations and Known Bugs.
* inline-close syntactic symbol:        Hanging Braces.
* inline-open syntactic symbol:         Hanging Braces.
* Interactive Customization:            Interactive Customization.
* Introduction:                         Introduction.
* Java style:                           Built-in Styles.
* java-mode:                            Built-in Styles.
* K&R style:                            Built-in Styles.
* Limitations and Known Bugs:           Limitations and Known Bugs.
* literal <1>:                          Indentation Commands.
* literal <1>:                          Hungry-deletion of whitespace.
* literal <1>:                          Clean-ups.
* literal:                              Auto-newline insertion.
* local variables:                      File Styles.
* Mailing Lists and Submitting Bug Reports: Mailing Lists and Submitting Bug Reports.
* Minor Modes:                          Minor Modes.
* modifier syntactic symbol:            Syntactic Symbols.
* New Indentation Engine:               New Indentation Engine.
* Other electric commands:              Other electric commands.
* Performance Issues:                   Performance Issues.
* Permanent Indentation:                Permanent Customization.
* relative buffer position:             Syntactic Analysis.
* reporter.el:                          Requirements.
* Requirements:                         Requirements.
* Sample .emacs file:                   Sample .emacs File.
* set-offset (c-):                      Customizing Indentation.
* statement-case-open syntactic symbol: Hanging Braces.
* stream-op syntactic symbol:           Custom Indentation Functions.
* Stroustrup style:                     Built-in Styles.
* Styles:                               Styles.
* substatement:                         Syntactic Analysis.
* substatement block:                   Syntactic Analysis.
* substatement-open syntactic symbol:   Hanging Braces.
* Syntactic Analysis:                   Syntactic Analysis.
* syntactic component:                  Syntactic Analysis.
* syntactic component list:             Syntactic Analysis.
* syntactic symbol:                     Syntactic Analysis.
* Syntactic Symbols:                    Syntactic Symbols.
* syntactic whitespace <1>:             Syntactic Symbols.
* syntactic whitespace:                 Auto-newline insertion.
* TAB:                                  Indentation Calculation.
* Whitesmith style:                     Built-in Styles.


File: ccmode,  Node: Command Index,  Next: Key Index,  Prev: Concept Index,  Up: Top

Command Index
*************

   Since all `cc-mode' commands are prepended with the string `c-',
each appears under its `c-<thing>' name and its `<thing> (c-)' name.

* Menu:

* add-style (c-):                       Adding Styles.
* beginning-of-defun:                   Performance Issues.
* c-add-style:                          Adding Styles.
* c-electric-brace:                     Hanging Braces.
* c-electric-delete:                    Hungry-deletion of whitespace.
* c-electric-pound:                     Other electric commands.
* c-electric-slash:                     Other electric commands.
* c-electric-star:                      Other electric commands.
* c-hanging-braces-alist:               Indentation Commands.
* c-indent-command:                     Indentation Commands.
* c-indent-defun <1>:                   Interactive Customization.
* c-indent-defun:                       Indentation Commands.
* c-indent-exp:                         Indentation Commands.
* c-lineup-streamop:                    Custom Indentation Functions.
* c-mark-function:                      Indentation Commands.
* c-set-offset <1>:                     File Styles.
* c-set-offset:                         Interactive Customization.
* c-set-style <1>:                      Built-in Styles.
* c-set-style:                          Indentation Commands.
* c-show-syntactic-information:         Syntactic Analysis.
* c-snug-do-while:                      Custom Brace and Colon Hanging.
* c-submit-bug-report:                  Mailing Lists and Submitting Bug Reports.
* c-toggle-auto-hungry-state:           Minor Modes.
* c-toggle-auto-state:                  Minor Modes.
* c-toggle-hungry-state:                Minor Modes.
* c-version:                            Introduction.
* defun-prompt-regexp:                  Performance Issues.
* electric-brace (c-):                  Hanging Braces.
* electric-delete (c-):                 Hungry-deletion of whitespace.
* electric-pound (c-):                  Other electric commands.
* electric-slash (c-):                  Other electric commands.
* electric-star (c-):                   Other electric commands.
* hanging-braces-alist (c-):            Indentation Commands.
* indent-command (c-):                  Indentation Commands.
* indent-defun (c-) <1>:                Interactive Customization.
* indent-defun (c-):                    Indentation Commands.
* indent-exp (c-):                      Indentation Commands.
* indent-region:                        Indentation Commands.
* lineup-streamop (c-):                 Custom Indentation Functions.
* mark-function (c-):                   Indentation Commands.
* newline-and-indent:                   Frequently Asked Questions.
* set-offset (c-) <1>:                  File Styles.
* set-offset (c-):                      Interactive Customization.
* set-style (c-) <1>:                   Built-in Styles.
* set-style (c-):                       Indentation Commands.
* show-syntactic-information (c-):      Syntactic Analysis.
* snug-do-while (c-):                   Custom Brace and Colon Hanging.
* submit-bug-report (c-):               Mailing Lists and Submitting Bug Reports.
* toggle-auto-hungry-state (c-):        Minor Modes.
* toggle-auto-state (c-):               Minor Modes.
* toggle-hungry-state (c-):             Minor Modes.


File: ccmode,  Node: Key Index,  Next: Variable Index,  Prev: Command Index,  Up: Top

Key Index
*********

* Menu:

* #:                                    Other electric commands.
* C-c C-a:                              Minor Modes.
* C-c C-b:                              Mailing Lists and Submitting Bug Reports.
* C-c C-d:                              Minor Modes.
* C-c C-o:                              Interactive Customization.
* C-c C-q <1>:                          Frequently Asked Questions.
* C-c C-q <1>:                          Custom Indentation Functions.
* C-c C-q <1>:                          Interactive Customization.
* C-c C-q:                              Indentation Commands.
* C-c C-s <1>:                          Syntactic Symbols.
* C-c C-s:                              Syntactic Analysis.
* C-c C-t:                              Minor Modes.
* C-u:                                  Auto-newline insertion.
* C-x h:                                Frequently Asked Questions.
* DEL:                                  Hungry-deletion of whitespace.
* ESC C-\:                              Frequently Asked Questions.
* ESC C-q:                              Frequently Asked Questions.
* ESC C-u:                              Frequently Asked Questions.
* ESC C-x:                              Frequently Asked Questions.
* LFD:                                  Frequently Asked Questions.
* M-C-\:                                Indentation Commands.
* M-C-h:                                Indentation Commands.
* M-C-q:                                Indentation Commands.
* RET:                                  Frequently Asked Questions.
* TAB <1>:                              Limitations and Known Bugs.
* TAB <1>:                              Indentation Commands.
* TAB:                                  Indentation Calculation.


File: ccmode,  Node: Variable Index,  Prev: Key Index,  Up: Top

Variable Index
**************

   Since all `cc-mode' variables are prepended with the string `c-',
each appears under its `c-<thing>' name and its `<thing> (c-)' name.

* Menu:

* basic-offset (c-):                    Advanced Customizations.
* c++-mode-hook:                        Permanent Customization.
* c-basic-offset:                       Advanced Customizations.
* c-cleanup-list:                       Clean-ups.
* c-delete-function:                    Hungry-deletion of whitespace.
* c-echo-syntactic-information-p:       Indentation Calculation.
* c-electric-pound-behavior:            Other electric commands.
* c-file-offsets:                       File Styles.
* c-file-style:                         File Styles.
* c-hanging-braces-alist <1>:           Custom Brace and Colon Hanging.
* c-hanging-braces-alist:               Hanging Braces.
* c-hanging-colon-alist:                Custom Brace and Colon Hanging.
* c-hanging-colons-alist:               Hanging Colons.
* c-hanging-semi&comma-criteria:        Customizing Semi-colons and Commas.
* c-mode-common-hook:                   Permanent Customization.
* c-mode-hook:                          Permanent Customization.
* c-offsets-alist <1>:                  Syntactic Symbols.
* c-offsets-alist <1>:                  Custom Indentation Functions.
* c-offsets-alist <1>:                  File Styles.
* c-offsets-alist <1>:                  Other electric commands.
* c-offsets-alist <1>:                  Hanging Braces.
* c-offsets-alist <1>:                  Indentation Calculation.
* c-offsets-alist:                      Syntactic Analysis.
* c-progress-interval:                  Indentation Commands.
* c-recognize-knr-p:                    Performance Issues.
* c-special-indent-hook:                Other Special Indentations.
* c-style-alist <1>:                    Advanced Customizations.
* c-style-alist:                        Adding Styles.
* c-syntactic-context:                  Custom Brace and Colon Hanging.
* c-tab-always-indent:                  Indentation Commands.
* cc-lobotomy-pith-list:                Performance Issues.
* cleanup-list (c-):                    Clean-ups.
* delete-function (c-):                 Hungry-deletion of whitespace.
* echo-syntactic-information-p (c-):    Indentation Calculation.
* electric-pound-behavior (c-):         Other electric commands.
* file-offsets (c-):                    File Styles.
* file-style (c-):                      File Styles.
* hanging-braces-alist (c-) <1>:        Custom Brace and Colon Hanging.
* hanging-braces-alist (c-):            Hanging Braces.
* hanging-colon-alist (c-):             Custom Brace and Colon Hanging.
* hanging-colons-alist (c-):            Hanging Colons.
* hanging-semi&comma-criteria (c-):     Customizing Semi-colons and Commas.
* java-mode-hook:                       Permanent Customization.
* objc-mode-hook:                       Permanent Customization.
* offsets-alist (c-) <1>:               Syntactic Symbols.
* offsets-alist (c-) <1>:               Custom Indentation Functions.
* offsets-alist (c-) <1>:               File Styles.
* offsets-alist (c-) <1>:               Other electric commands.
* offsets-alist (c-) <1>:               Hanging Braces.
* offsets-alist (c-) <1>:               Indentation Calculation.
* offsets-alist (c-):                   Syntactic Analysis.
* progress-interval (c-):               Indentation Commands.
* recognize-knr-p (c-):                 Performance Issues.
* special-indent-hook (c-):             Other Special Indentations.
* style-alist (c-) <1>:                 Advanced Customizations.
* style-alist (c-):                     Adding Styles.
* syntactic-context (c-):               Custom Brace and Colon Hanging.
* tab-always-indent (c-):               Indentation Commands.


