This is Info file ../info/emacs, produced by Makeinfo-1.63 from the
input file emacs.texi.


File: emacs,  Node: Indentation,  Next: Text,  Prev: Major Modes,  Up: Top

Indentation
***********

   This chapter describes the Emacs commands that add, remove, or
adjust indentation.

`TAB'
     Indent current line "appropriately" in a mode-dependent fashion.

`LFD'
     Perform RET followed by TAB (`newline-and-indent').

`M-^'
     Merge two lines (`delete-indentation').  This would cancel out the
     effect of LFD.

`C-M-o'
     Split line at point; text on the line after point becomes a new
     line indented to the same column that it now starts in
     (`split-line').

`M-m'
     Move (forward or back) to the first nonblank character on the
     current line (`back-to-indentation').

`C-M-\'
     Indent several lines to same column (`indent-region').

`C-x TAB'
     Shift block of lines rigidly right or left (`indent-rigidly').

`M-i'
     Indent from point to the next prespecified tab stop column
     (`tab-to-tab-stop').

`M-x indent-relative'
     Indent from point to under an indentation point in the previous
     line.

   Most programming languages have some indentation convention.  For
Lisp code, lines are indented according to their nesting in
parentheses.  The same general idea is used for C code, though many
details are different.

   Whatever the language, to indent a line, use the TAB command.  Each
major mode defines this command to perform the sort of indentation
appropriate for the particular language.  In Lisp mode, TAB aligns the
line according to its depth in parentheses.  No matter where in the
line you are when you type TAB, it aligns the line as a whole.  In C
mode, TAB implements a subtle and sophisticated indentation style that
knows about many aspects of C syntax.

   In Text mode, TAB runs the command `tab-to-tab-stop', which indents
to the next tab stop column.  You can set the tab stops with `M-x
edit-tab-stops'.

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.


File: emacs,  Node: Indentation Commands,  Next: Tab Stops,  Prev: Indentation,  Up: Indentation

Indentation Commands and Techniques
===================================

   To move over the indentation on a line, do `M-m'
(`back-to-indentation').  This command, given anywhere on a line,
positions point at the first nonblank character on the line.

   To insert an indented line before the current line, do `C-a C-o
TAB'.  To make an indented line after the current line, use `C-e LFD'.

   If you just want to insert a tab character in the buffer, you can
type `C-q TAB'.

   `C-M-o' (`split-line') moves the text from point to the end of the
line vertically down, so that the current line becomes two lines.
`C-M-o' first moves point forward over any spaces and tabs.  Then it
inserts after point a newline and enough indentation to reach the same
column point is on.  Point remains before the inserted newline; in this
regard, `C-M-o' resembles `C-o'.

   To join two lines cleanly, use the `M-^' (`delete-indentation')
command.  It deletes the indentation at the front of the current line,
and the line boundary as well, replacing them with a single space.  As
a special case (useful for Lisp code) the single space is omitted if
the characters to be joined are consecutive open parentheses or closing
parentheses, or if the junction follows another newline.  To delete
just the indentation of a line, go to the beginning of the line and use
`M-\' (`delete-horizontal-space'), which deletes all spaces and tabs
around the cursor.

   If you have a fill prefix, `M-^' deletes the fill prefix if it
appears after the newline that is deleted.  *Note Fill Prefix::.

   There are also commands for changing the indentation of several lines
at once.  `C-M-\' (`indent-region') applies to all the lines that begin
in the region; it indents each line in the "usual" way, as if you had
typed TAB at the beginning of the line.  A numeric argument specifies
the column to indent to, and each line is shifted left or right so that
its first nonblank character appears in that column.  `C-x TAB'
(`indent-rigidly') moves all of the lines in the region right by its
argument (left, for negative arguments).  The whole group of lines
moves rigidly sideways, which is how the command gets its name.

   `M-x indent-relative' indents at point based on the previous line
(actually, the last nonempty line).  It inserts whitespace at point,
moving point, until it is underneath an indentation point in the
previous line.  An indentation point is the end of a sequence of
whitespace or the end of the line.  If point is farther right than any
indentation point in the previous line, the whitespace before point is
deleted and the first indentation point then applicable is used.  If no
indentation point is applicable even then, `indent-relative' runs
`tab-to-tab-stop' (*note Tab Stops::.).

   `indent-relative' is the definition of TAB in Indented Text mode.
*Note Text::.

   *Note Format Indentation::, for another way of specifying the
indentation for part of your text.


File: emacs,  Node: Tab Stops,  Next: Just Spaces,  Prev: Indentation Commands,  Up: Indentation

Tab Stops
=========

   For typing in tables, you can use Text mode's definition of TAB,
`tab-to-tab-stop'.  This command inserts indentation before point,
enough to reach the next tab stop column.  If you are not in Text mode,
this command can be found on the key `M-i'.

   You can specify the tab stops used by `M-i'.  They are stored in a
variable called `tab-stop-list', as a list of column-numbers in
increasing order.

   The convenient way to set the tab stops is with `M-x edit-tab-stops',
which creates and selects a buffer containing a description of the tab
stop settings.  You can edit this buffer to specify different tab
stops, and then type `C-c C-c' to make those new tab stops take effect.
In the tab stop buffer, `C-c C-c' runs the function
`edit-tab-stops-note-changes' rather than its usual definition
`save-buffer'.  `edit-tab-stops' records which buffer was current when
you invoked it, and stores the tab stops back in that buffer; normally
all buffers share the same tab stops and changing them in one buffer
affects all, but if you happen to make `tab-stop-list' local in one
buffer then `edit-tab-stops' in that buffer will edit the local
settings.

   Here is what the text representing the tab stops looks like for
ordinary tab stops every eight columns.

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

   The first line contains a colon at each tab stop.  The remaining
lines are present just to help you see where the colons are and know
what to do.

   Note that the tab stops that control `tab-to-tab-stop' have nothing
to do with displaying tab characters in the buffer.  *Note Display
Vars::, for more information on that.


File: emacs,  Node: Just Spaces,  Prev: Tab Stops,  Up: Indentation

Tabs vs. Spaces
===============

   Emacs normally uses both tabs and spaces to indent lines.  If you
prefer, all indentation can be made from spaces only.  To request this,
set `indent-tabs-mode' to `nil'.  This is a per-buffer variable;
altering the variable affects only the current buffer, but there is a
default value which you can change as well.  *Note Locals::.

   There are also commands to convert tabs to spaces or vice versa,
always preserving the columns of all nonblank text.  `M-x tabify' scans
the region for sequences of spaces, and converts sequences of at least
three spaces to tabs if that can be done without changing indentation.
`M-x untabify' changes all tabs in the region to appropriate numbers of
spaces.


File: emacs,  Node: Text,  Next: Programs,  Prev: Indentation,  Up: Top

Commands for Human Languages
****************************

   The term "text" has two widespread meanings in our area of the
computer field.  One is data that is a sequence of characters.  Any file
that you edit with Emacs is text, in this sense of the word.  The other
meaning is more restrictive: a sequence of characters in a human
language for humans to read (possibly after processing by a text
formatter), as opposed to a program or commands for a program.

   Human languages have syntactic/stylistic conventions that can be
supported or used to advantage by editor commands: conventions involving
words, sentences, paragraphs, and capital letters.  This chapter
describes Emacs commands for all of these things.  There are also
commands for "filling", which means rearranging the lines of a
paragraph to be approximately equal in length.  The commands for moving
over and killing words, sentences and paragraphs, while intended
primarily for editing text, are also often useful for editing programs.

   Emacs has several major modes for editing human language text.  If
the file contains text pure and simple, use Text mode, which customizes
Emacs in small ways for the syntactic conventions of text.  Outline mode
provides special commands for operating on text with an outline
structure.

   For text which contains embedded commands for text formatters, Emacs
has other major modes, each for a particular text formatter.  Thus, for
input to TeX, you would use TeX mode.  For input to nroff, use Nroff
mode.

   Instead of using a text formatter, you can edit formatted text in
WYSIWYG style ("what you see is what you get"), with Enriched mode.
Then the formatting appears on the screen in Emacs while you edit.

* Menu:

* Words::         Moving over and killing words.
* Sentences::     Moving over and killing sentences.
* Paragraphs::	  Moving over paragraphs.
* Pages::	  Moving over pages.
* Filling::       Filling or justifying text.
* Case::          Changing the case of text.
* Text Mode::     The major modes for editing text files.
* Outline Mode::  The major mode for editing outlines.
* TeX Mode::      The major modes for editing input to the formatter TeX.
* Nroff Mode::    The major mode for editing input to the formatter nroff.
* Formatted Text::Editing formatted text directly in WYSIWYG fashion.


File: emacs,  Node: Words,  Next: Sentences,  Up: Text

Words
=====

   Emacs has commands for moving over or operating on words.  By
convention, the keys for them are all Meta characters.

`M-f'
     Move forward over a word (`forward-word').

`M-b'
     Move backward over a word (`backward-word').

`M-d'
     Kill up to the end of a word (`kill-word').

`M-DEL'
     Kill back to the beginning of a word (`backward-kill-word').

`M-@'
     Mark the end of the next word (`mark-word').

`M-t'
     Transpose two words or drag a word across other words
     (`transpose-words').

   Notice how these keys form a series that parallels the
character-based `C-f', `C-b', `C-d', `C-t' and DEL.  `M-@' is cognate
to `C-@', which is an alias for `C-SPC'.

   The commands `M-f' (`forward-word') and `M-b' (`backward-word') move
forward and backward over words.  These Meta characters are thus
analogous to the corresponding control characters, `C-f' and `C-b',
which move over single characters in the text.  The analogy extends to
numeric arguments, which serve as repeat counts.  `M-f' with a negative
argument moves backward, and `M-b' with a negative argument moves
forward.  Forward motion stops right after the last letter of the word,
while backward motion stops right before the first letter.

   `M-d' (`kill-word') kills the word after point.  To be precise, it
kills everything from point to the place `M-f' would move to.  Thus, if
point is in the middle of a word, `M-d' kills just the part after
point.  If some punctuation comes between point and the next word, it
is killed along with the word.  (If you wish to kill only the next word
but not the punctuation before it, simply do `M-f' to get the end, and
kill the word backwards with `M-DEL'.) `M-d' takes arguments just like
`M-f'.

   `M-DEL' (`backward-kill-word') kills the word before point.  It
kills everything from point back to where `M-b' would move to.  If
point is after the space in `FOO, BAR', then `FOO, ' is killed.  (If
you wish to kill just `FOO', do `M-b M-d' instead of `M-DEL'.)

   `M-t' (`transpose-words') exchanges the word before or containing
point with the following word.  The delimiter characters between the
words do not move.  For example, `FOO, BAR' transposes into `BAR, FOO'
rather than `BAR FOO,'.  *Note Transpose::, for more on transposition
and on arguments to transposition commands.

   To operate on the next N words with an operation which applies
between point and mark, you can either set the mark at point and then
move over the words, or you can use the command `M-@' (`mark-word')
which does not move point, but sets the mark where `M-f' would move to.
`M-@' accepts a numeric argument that says how many words to scan for
the place to put the mark.  In Transient Mark mode, this command
activates the mark.

   The word commands' understanding of syntax is completely controlled
by the syntax table.  Any character can, for example, be declared to be
a word delimiter.  *Note Syntax::.


File: emacs,  Node: Sentences,  Next: Paragraphs,  Prev: Words,  Up: Text

Sentences
=========

   The Emacs commands for manipulating sentences and paragraphs are
mostly on Meta keys, so as to be like the word-handling commands.

`M-a'
     Move back to the beginning of the sentence (`backward-sentence').

`M-e'
     Move forward to the end of the sentence (`forward-sentence').

`M-k'
     Kill forward to the end of the sentence (`kill-sentence').

`C-x DEL'
     Kill back to the beginning of the sentence
     (`backward-kill-sentence').

   The commands `M-a' and `M-e' (`backward-sentence' and
`forward-sentence') move to the beginning and end of the current
sentence, respectively.  They were chosen to resemble `C-a' and `C-e',
which move to the beginning and end of a line.  Unlike them, `M-a' and
`M-e' if repeated or given numeric arguments move over successive
sentences.

   Moving backward over a sentence places point just before the first
character of the sentence; moving forward places point right after the
punctuation that ends the sentence.  Neither one moves over the
whitespace at the sentence boundary.

   Just as `C-a' and `C-e' have a kill command, `C-k', to go with them,
so `M-a' and `M-e' have a corresponding kill command `M-k'
(`kill-sentence') which kills from point to the end of the sentence.
With minus one as an argument it kills back to the beginning of the
sentence.  Larger arguments serve as a repeat count.  There is also a
command, `C-x DEL' (`backward-kill-sentence'), for killing back to the
beginning of a sentence.  This command is useful when you change your
mind in the middle of composing text.

   The sentence commands assume that you follow the American typist's
convention of putting two spaces at the end of a sentence; they consider
a sentence to end wherever there is a `.', `?' or `!' followed by the
end of a line or two spaces, with any number of `)', `]', `'', or `"'
characters allowed in between.  A sentence also begins or ends wherever
a paragraph begins or ends.

   The variable `sentence-end' controls recognition of the end of a
sentence.  It is a regexp that matches the last few characters of a
sentence, together with the whitespace following the sentence.  Its
normal value is

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This example is explained in the section on regexps.  *Note Regexps::.

   If you want to use just one space between sentences, you should set
`sentence-end' to this value:

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

You should also set the variable `sentence-end-double-space' to `nil'
so that the fill commands expect and leave just one space at the end of
a sentence.  Note that this makes it impossible to distinguish between
periods that end sentences and those that indicate abbreviations.


File: emacs,  Node: Paragraphs,  Next: Pages,  Prev: Sentences,  Up: Text

Paragraphs
==========

   The Emacs commands for manipulating paragraphs are also Meta keys.

`M-{'
     Move back to previous paragraph beginning (`backward-paragraph').

`M-}'
     Move forward to next paragraph end (`forward-paragraph').

`M-h'
     Put point and mark around this or next paragraph
     (`mark-paragraph').

   `M-{' moves to the beginning of the current or previous paragraph,
while `M-}' moves to the end of the current or next paragraph.  Blank
lines and text formatter command lines separate paragraphs and are not
considered part of any paragraph.  Also, an indented line starts a new
paragraph.

   In major modes for programs (as opposed to Text mode), paragraphs
begin and end only at blank lines.  This makes the paragraph commands
continue to be useful even though there are no paragraphs per se.

   When there is a fill prefix, then paragraphs are delimited by all
lines which don't start with the fill prefix.  *Note Filling::.

   When you wish to operate on a paragraph, you can use the command
`M-h' (`mark-paragraph') to set the region around it.  Thus, for
example, `M-h C-w' kills the paragraph around or after point.  The
`M-h' command puts point at the beginning and mark at the end of the
paragraph point was in.  In Transient Mark mode, it activates the mark.
If point is between paragraphs (in a run of blank lines, or at a
boundary), the paragraph following point is surrounded by point and
mark.  If there are blank lines preceding the first line of the
paragraph, one of these blank lines is included in the region.

   The precise definition of a paragraph boundary is controlled by the
variables `paragraph-separate' and `paragraph-start'.  The value of
`paragraph-start' is a regexp that should match any line that either
starts or separates paragraphs.  The value of `paragraph-separate' is
another regexp that should match only lines that separate paragraphs
without being part of any paragraph.  Lines that start a new paragraph
and are contained in it must match only `paragraph-start', not
`paragraph-separate'.  For example, normally `paragraph-start' is `"[
\t\n\f]"' and `paragraph-separate' is `"[ \t\f]*$"'.

   Normally it is desirable for page boundaries to separate paragraphs.
The default values of these variables recognize the usual separator for
pages.


File: emacs,  Node: Pages,  Next: Filling,  Prev: Paragraphs,  Up: Text

Pages
=====

   Files are often thought of as divided into "pages" by the "formfeed"
character (ASCII control-L, octal code 014).  When you print hardcopy
for a file, this character forces a page break; thus, each page of the
file goes on a separate page on paper.  Most Emacs commands treat the
page-separator character just like any other character: you can insert
it with `C-q C-l', and delete it with DEL.  Thus, you are free to
paginate your file or not.  However, since pages are often meaningful
divisions of the file, Emacs provides commands to move over them and
operate on them.

`C-x ['
     Move point to previous page boundary (`backward-page').

`C-x ]'
     Move point to next page boundary (`forward-page').

`C-x C-p'
     Put point and mark around this page (or another page)
     (`mark-page').

`C-x l'
     Count the lines in this page (`count-lines-page').

   The `C-x [' (`backward-page') command moves point to immediately
after the previous page delimiter.  If point is already right after a
page delimiter, it skips that one and stops at the previous one.  A
numeric argument serves as a repeat count.  The `C-x ]' (`forward-page')
command moves forward past the next page delimiter.

   The `C-x C-p' command (`mark-page') puts point at the beginning of
the current page and the mark at the end.  The page delimiter at the
end is included (the mark follows it).  The page delimiter at the front
is excluded (point follows it).  `C-x C-p C-w' is a handy way to kill a
page to move it elsewhere.  If you move to another page delimiter with
`C-x [' and `C-x ]', then yank the killed page, all the pages will be
properly delimited once again.  The reason `C-x C-p' includes only the
following page delimiter in the region is to ensure that.

   A numeric argument to `C-x C-p' is used to specify which page to go
to, relative to the current one.  Zero means the current page.  One
means the next page, and -1 means the previous one.

   The `C-x l' command (`count-lines-page') is good for deciding where
to break a page in two.  It prints in the echo area the total number of
lines in the current page, and then divides it up into those preceding
the current line and those following, as in

     Page has 96 (72+25) lines

Notice that the sum is off by one; this is correct if point is not at
the beginning of a line.

   The variable `page-delimiter' controls where pages begin.  Its value
is a regexp that matches the beginning of a line that separates pages.
The normal value of this variable is `"^\f"', which matches a formfeed
character at the beginning of a line.


File: emacs,  Node: Filling,  Next: Case,  Prev: Pages,  Up: Text

Filling Text
============

   "Filling" text means breaking it up into lines that fit a specified
width.  Emacs does filling in two ways.  In Auto Fill mode, inserting
text with self-inserting characters also automatically fills it.  There
are also explicit fill commands that you can use when editing text
leaves it unfilled.  When you edit formatted text, you can specify a
style of filling for each portion of the text (*note Formatted Text::.).

* Menu:

* Auto Fill::	  Auto Fill mode breaks long lines automatically.
* Fill Commands:: Commands to refill paragraphs and center lines.
* Fill Prefix::	  Filling when every line is indented or in a comment, etc.


File: emacs,  Node: Auto Fill,  Next: Fill Commands,  Up: Filling

Auto Fill Mode
--------------

   "Auto Fill" mode is a minor mode in which lines are broken
automatically when they become too wide.  Breaking happens only when
you type a SPC or RET.

`M-x auto-fill-mode'
     Enable or disable Auto Fill mode.

`SPC'
`RET'
     In Auto Fill mode, break lines when appropriate.

   `M-x auto-fill-mode' turns Auto Fill mode on if it was off, or off
if it was on.  With a positive numeric argument it always turns Auto
Fill mode on, and with a negative argument always turns it off.  You can
see when Auto Fill mode is in effect by the presence of the word `Fill'
in the mode line, inside the parentheses.  Auto Fill mode is a minor
mode which is enabled or disabled for each buffer individually.  *Note
Minor Modes::.

   In Auto Fill mode, lines are broken automatically at spaces when
they get longer than the desired width.  Line breaking and
rearrangement takes place only when you type SPC or RET.  If you wish
to insert a space or newline without permitting line-breaking, type
`C-q SPC' or `C-q LFD' (recall that a newline is really a linefeed).
Also, `C-o' inserts a newline without line breaking.

   Auto Fill mode works well with Lisp mode, because when it makes a new
line in Lisp mode it indents that line with TAB.  If a line ending in a
comment gets too long, the text of the comment is split into two
comment lines.  Optionally new comment delimiters are inserted at the
end of the first line and the beginning of the second so that each line
is a separate comment; the variable `comment-multi-line' controls the
choice (*note Comments::.).

   Adaptive filling (see the following section) works for Auto Filling
as well as for explicit fill commands.  It takes a fill prefix
automatically from the second or first line of a paragraph.

   Auto Fill mode does not refill entire paragraphs; it can break lines
but cannot merge lines.  So editing in the middle of a paragraph can
result in a paragraph that is not correctly filled.  The easiest way to
make the paragraph properly filled again is usually with the explicit
fill commands.  *Note Fill Commands::.

   Many users like Auto Fill mode and want to use it in all text files.
The section on init files says how to arrange this permanently for
yourself.  *Note Init File::.


File: emacs,  Node: Fill Commands,  Next: Fill Prefix,  Prev: Auto Fill,  Up: Filling

Explicit Fill Commands
----------------------

`M-q'
     Fill current paragraph (`fill-paragraph').

`C-x f'
     Set the fill column (`set-fill-column').

`M-x fill-region'
     Fill each paragraph in the region (`fill-region').

`M-x fill-region-as-paragraph.'
     Fill the region, considering it as one paragraph.

`M-s'
     Center a line.

   To refill a paragraph, use the command `M-q' (`fill-paragraph').
This operates on the paragraph that point is inside, or the one after
point if point is between paragraphs.  Refilling works by removing all
the line-breaks, then inserting new ones where necessary.

   To refill many paragraphs, use `M-x fill-region', which divides the
region into paragraphs and fills each of them.

   `M-q' and `fill-region' use the same criteria as `M-h' for finding
paragraph boundaries (*note Paragraphs::.).  For more control, you can
use `M-x fill-region-as-paragraph', which refills everything between
point and mark.  This command deletes any blank lines within the
region, so separate blocks of text end up combined into one block.

   A numeric argument to `M-q' causes it to "justify" the text as well
as filling it.  This means that extra spaces are inserted to make the
right margin line up exactly at the fill column.  To remove the extra
spaces, use `M-q' with no argument.  (Likewise for `fill-region'.)
Another way to control justification, and choose other styles of
filling, is with the `justification' text property; see *Note Format
Justification::.

   The fill commands can deduce the proper fill prefix for a paragraph
automatically in certain cases: either whitespace or certain punctuation
characters at the beginning of a line are treated as a fill prefix.
They take the fill prefix from the paragraph's second line, unless the
paragraph has just one line.  You can turn off this feature by setting
`adaptive-fill-mode' to `nil'.

   Some major modes, including Text mode, treat whitespace at the
beginning of a line as a signal that this line starts a new paragraph.
It would be a mistake to copy text which implies the start of a
paragraph onto each line of the paragraph when filling it.  Therefore,
adaptive filling does not accept a fill prefix from a line which is a
paragraph-starter.  In particular, adaptive filling in Text mode does
not accept a fill prefix consisting of just whitespace.

   However, other modes including Indented Text mode (*note Text
Mode::.) do not consider whitespace as a signal to start a new
paragraph.  In these modes, adaptive filling does accept a fill prefix
consisting of just whitespace, if the first or second line of a
paragraph begins with whitespace.

   The variable `adaptive-fill-regexp' determines what kinds of line
beginnings can serve as a fill prefix: any characters at the start of
the line which match this regular expression are used.

   You can specify more complex ways of choosing a fill prefix
automatically by setting the variable `adaptive-fill-function' to a
function.  This function is called with point after the left margin of a
line, and it should return the appropriate fill prefix based on that
line.  If it returns `nil', that means it sees no fill prefix in that
line.

   The command `M-s' (`center-line') centers the current line within
the current fill column.  With an argument N, it centers N lines
individually and moves past them.

   The maximum line width for filling is in the variable `fill-column'.
Altering the value of `fill-column' makes it local to the current
buffer; until that time, the default value is in effect.  The default
is initially 70.  *Note Locals::.  The easiest way to set `fill-column'
is to use the command `C-x f' (`set-fill-column').  With a numeric
argument, it uses that as the new fill column.  With just `C-u' as
argument, it sets `fill-column' to the current horizontal position of
point.

   Emacs commands normally consider a period followed by two spaces or
by a newline as the end of a sentence; a period followed by just one
space indicates an abbreviation and not the end of a sentence.  To
preserve the distinction between these two ways of using a period, the
fill commands do not break a line after a period followed by just one
space.

   If the variable `sentence-end-double-space' is `nil', the fill
commands expect and leave just one space at the end of a sentence.
Ordinarily this variable is `t', so the fill commands insist on two
spaces for the end of a sentence, as explained above.  *Note
Sentences::.

   If the variable `colon-double-space' is non-`nil', the fill commands
put two spaces after a colon.


File: emacs,  Node: Fill Prefix,  Prev: Fill Commands,  Up: Filling

The Fill Prefix
---------------

   To fill a paragraph in which each line starts with a special marker
(which might be a few spaces, giving an indented paragraph), use the
"fill prefix" feature.  The fill prefix is a string which Emacs expects
every line to start with, and which is not included in filling.

`C-x .'
     Set the fill prefix (`set-fill-prefix').

`M-q'
     Fill a paragraph using current fill prefix (`fill-paragraph').

`M-x fill-individual-paragraphs'
     Fill the region, considering each change of indentation as
     starting a new paragraph.

`M-x fill-nonuniform-paragraphs'
     Fill the region, considering only paragraph-separator lines as
     starting a new paragraph.

   To specify a fill prefix, move to a line that starts with the desired
prefix, put point at the end of the prefix, and give the command
`C-x .' (`set-fill-prefix').  That's a period after the `C-x'.  To turn
off the fill prefix, specify an empty prefix: type `C-x .' with point
at the beginning of a line.

   When a fill prefix is in effect, the fill commands remove the fill
prefix from each line before filling and insert it on each line after
filling.  Auto Fill mode also inserts the fill prefix automatically when
it makes a new line.  The `C-o' command inserts the fill prefix on new
lines it creates, when you use it at the beginning of a line (*note
Blank Lines::.).  Conversely, the command `M-^' deletes the prefix (if
it occurs) after the newline that it deletes (*note Indentation::.).

   For example, if `fill-column' is 40 and you set the fill prefix to
`;; ', then `M-q' in the following text

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

produces this:

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

   Lines that do not start with the fill prefix are considered to start
paragraphs, both in `M-q' and the paragraph commands; this gives good
results for paragraphs with hanging indentation (every line indented
except the first one).  Lines which are blank or indented once the
prefix is removed also separate or start paragraphs; this is what you
want if you are writing multi-paragraph comments with a comment
delimiter on each line.

   You can use `M-x fill-individual-paragraphs' to set the fill prefix
for each paragraph automatically.  This command divides the region into
paragraphs, treating every change in the amount of indentation as the
start of a new paragraph, and fills each of these paragraphs.  Thus,
all the lines in one "paragraph" have the same amount of indentation.
That indentation serves as the fill prefix for that paragraph.

   `M-x fill-nonuniform-paragraphs' is a similar command that divides
the region into paragraphs in a different way.  It considers only
paragraph-separating lines (as defined by `paragraph-separate') as
starting a new paragraph.  Since this means that the lines of one
paragraph may have different amounts of indentation, the fill prefix
used is the smallest amount of indentation of any of the lines of the
paragraph.  This gives good results with styles that indent a
paragraph's first line more or less that the rest of the paragraph.

   The fill prefix is stored in the variable `fill-prefix'.  Its value
is a string, or `nil' when there is no fill prefix.  This is a
per-buffer variable; altering the variable affects only the current
buffer, but there is a default value which you can change as well.
*Note Locals::.

   The `indentation' text property provides another way to control the
amount of indentation paragraphs receive.  *Note Format Indentation::.


File: emacs,  Node: Case,  Next: Text Mode,  Prev: Filling,  Up: Text

Case Conversion Commands
========================

   Emacs has commands for converting either a single word or any
arbitrary range of text to upper case or to lower case.

`M-l'
     Convert following word to lower case (`downcase-word').

`M-u'
     Convert following word to upper case (`upcase-word').

`M-c'
     Capitalize the following word (`capitalize-word').

`C-x C-l'
     Convert region to lower case (`downcase-region').

`C-x C-u'
     Convert region to upper case (`upcase-region').

   The word conversion commands are the most useful.  `M-l'
(`downcase-word') converts the word after point to lower case, moving
past it.  Thus, repeating `M-l' converts successive words.  `M-u'
(`upcase-word') converts to all capitals instead, while `M-c'
(`capitalize-word') puts the first letter of the word into upper case
and the rest into lower case.  All these commands convert several words
at once if given an argument.  They are especially convenient for
converting a large amount of text from all upper case to mixed case,
because you can move through the text using `M-l', `M-u' or `M-c' on
each word as appropriate, occasionally using `M-f' instead to skip a
word.

   When given a negative argument, the word case conversion commands
apply to the appropriate number of words before point, but do not move
point.  This is convenient when you have just typed a word in the wrong
case: you can give the case conversion command and continue typing.

   If a word case conversion command is given in the middle of a word,
it applies only to the part of the word which follows point.  This is
just like what `M-d' (`kill-word') does.  With a negative argument,
case conversion applies only to the part of the word before point.

   The other case conversion commands are `C-x C-u' (`upcase-region')
and `C-x C-l' (`downcase-region'), which convert everything between
point and mark to the specified case.  Point and mark do not move.

   The region case conversion commands `upcase-region' and
`downcase-region' are normally disabled.  This means that they ask for
confirmation if you try to use them.  When you confirm, you may enable
the command, which means it will not ask for confirmation again.  *Note
Disabling::.


File: emacs,  Node: Text Mode,  Next: Outline Mode,  Prev: Case,  Up: Text

Text Mode
=========

   When you edit files of text in a human language, it's more convenient
to use Text mode rather than Fundamental mode.  Invoke `M-x text-mode'
to enter Text mode.  In Text mode, TAB runs the function
`tab-to-tab-stop', which allows you to use arbitrary tab stops set with
`M-x edit-tab-stops' (*note Tab Stops::.).  Features concerned with
comments in programs are turned off in Text mode except when explicitly
invoked.  The syntax table is changed so that periods are not
considered part of a word, while apostrophes, backspaces and underlines
are part of words.

   A similar variant mode is Indented Text mode, intended for editing
text in which most lines are indented.  This mode defines TAB to run
`indent-relative' (*note Indentation::.), and makes Auto Fill indent
the lines it creates.  The result is that normally a line made by Auto
Filling, or by LFD, is indented just like the previous line.  In
Indented Text mode, only blank lines separate paragraphs--indented
lines continue the current paragraph.  Use `M-x indented-text-mode' to
select this mode.

   Text mode, and all the modes based on it, define `M-TAB' as the
command `ispell-complete-word', which performs completion of the
partial word in the buffer before point, using the spelling dictionary
as the space of possible words.  *Note Spelling::.

   Entering Text mode or Indented Text mode runs the hook
`text-mode-hook'.  Other major modes related to Text mode also run this
hook, followed by hooks of their own; this includes Nroff mode, TeX
mode, Outline mode and Mail mode.  Hook functions on `text-mode-hook'
can look at the value of `major-mode' to see which of these modes is
actually being entered.  *Note Hooks::.

   Emacs provides two other modes for editing text that is to be passed
through a text formatter to produce fancy formatted printed output.
*Note Nroff Mode::, for editing input to the formatter nroff.  *Note
TeX Mode::, for editing input to the formatter TeX.

   Another mode is used for editing outlines.  It allows you to view the
text at various levels of detail.  You can view either the outline
headings alone or both headings and text; you can also hide some of the
headings at lower levels from view to make the high level structure more
visible.  *Note Outline Mode::.


File: emacs,  Node: Outline Mode,  Next: TeX Mode,  Prev: Text Mode,  Up: Text

Outline Mode
============

   Outline mode is a major mode much like Text mode but intended for
editing outlines.  It allows you to make parts of the text temporarily
invisible so that you can see the outline structure.  Type `M-x
outline-mode' to switch to Outline mode as the major mode of the current
buffer.

   When Outline mode makes a line invisible, the line does not appear on
the screen.  The screen appears exactly as if the invisible line were
deleted, except that an ellipsis (three periods in a row) appears at the
end of the previous visible line (only one ellipsis no matter how many
invisible lines follow).

   All editing commands treat the text of the invisible line as part of
the previous visible line.  For example, `C-n' moves onto the next
visible line.  Killing an entire visible line, including its
terminating newline, really kills all the following invisible lines
along with it; yanking it all back yanks the invisible lines and they
remain invisible.

   Outline minor mode provides the same commands as the major mode,
Outline mode, but you can use it in conjunction with other major modes.
Type `M-x outline-minor-mode' to enable the Outline minor mode in the
current buffer.  You can also specify this in the text of a file, with
a file local variable of the form `mode: outline-minor' (*note File
Variables::.).

   The major mode, Outline mode, provides special key bindings on the
`C-c' prefix.  Outline minor mode provides similar bindings with `C-c
@' as the prefix; this is to reduce the conflicts with the major mode's
special commands.  (The variable `outline-minor-mode-prefix' controls
the prefix used.)

   Entering Outline mode runs the hook `text-mode-hook' followed by the
hook `outline-mode-hook' (*note Hooks::.).

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines.
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.


File: emacs,  Node: Outline Format,  Next: Outline Motion,  Up: Outline Mode

Format of Outlines
------------------

   Outline mode assumes that the lines in the buffer are of two types:
"heading lines" and "body lines".  A heading line represents a topic in
the outline.  Heading lines start with one or more stars; the number of
stars determines the depth of the heading in the outline structure.
Thus, a heading line with one star is a major topic; all the heading
lines with two stars between it and the next one-star heading are its
subtopics; and so on.  Any line that is not a heading line is a body
line.  Body lines belong with the preceding heading line.  Here is an
example:

     * Food
     
     This is the body,
     which says something about the topic of food.
     
     ** Delicious Food
     
     This is the body of the second-level header.
     
     ** Distasteful Food
     
     This could have
     a body too, with
     several lines.
     
     *** Dormitory Food
     
     * Shelter
     
     Another first-level topic with its header line.

   A heading line together with all following body lines is called
collectively an "entry".  A heading line together with all following
deeper heading lines and their body lines is called a "subtree".

   You can customize the criterion for distinguishing heading lines by
setting the variable `outline-regexp'.  Any line whose beginning has a
match for this regexp is considered a heading line.  Matches that start
within a line (not at the left margin) do not count.  The length of the
matching text determines the level of the heading; longer matches make
a more deeply nested level.  Thus, for example, if a text formatter has
commands `@chapter', `@section' and `@subsection' to divide the
document into chapters and sections, you could make those lines count
as heading lines by setting `outline-regexp' to
`"@chap\\|@\\(sub\\)*section"'.  Note the trick: the two words
`chapter' and `section' are equally long, but by defining the regexp to
match only `chap' we ensure that the length of the text matched on a
chapter heading is shorter, so that Outline mode will know that
sections are contained in chapters.  This works as long as no other
command starts with `@chap'.

   It is possible to change the rule for calculating the level of a
heading line by setting the variable `outline-level'.  The value of
`outline-level' should be a function that takes no arguments and
returns the level of the current heading.  Some major modes such as C,
Nroff, and Emacs Lisp mode set this variable in order to work with
Outline minor mode.

   Outline mode makes a line invisible by changing the newline before it
into an ASCII control-M (code 015).  Most editing commands that work on
lines treat an invisible line as part of the previous line because,
strictly speaking, it *is* part of that line, since there is no longer a
newline in between.  When you save the file in Outline mode, control-M
characters are saved as newlines, so the invisible lines become ordinary
lines in the file.  But saving does not change the visibility status of
a line inside Emacs.


File: emacs,  Node: Outline Motion,  Next: Outline Visibility,  Prev: Outline Format,  Up: Outline Mode

Outline Motion Commands
-----------------------

   Outline mode provides special motion commands that move backward and
forward to heading lines.

`C-c C-n'
     Move point to the next visible heading line
     (`outline-next-visible-heading').

`C-c C-p'
     Move point to the previous visible heading line
     (`outline-previous-visible-heading').

`C-c C-f'
     Move point to the next visible heading line at the same level as
     the one point is on (`outline-forward-same-level').

`C-c C-b'
     Move point to the previous visible heading line at the same level
     (`outline-backward-same-level').

`C-c C-u'
     Move point up to a lower-level (more inclusive) visible heading
     line (`outline-up-heading').

   `C-c C-n' (`outline-next-visible-heading') moves down to the next
heading line.  `C-c C-p' (`outline-previous-visible-heading') moves
similarly backward.  Both accept numeric arguments as repeat counts.
The names emphasize that invisible headings are skipped, but this is
not really a special feature.  All editing commands that look for lines
ignore the invisible lines automatically.

   More powerful motion commands understand the level structure of
headings.  `C-c C-f' (`outline-forward-same-level') and `C-c C-b'
(`outline-backward-same-level') move from one heading line to another
visible heading at the same depth in the outline.  `C-c C-u'
(`outline-up-heading') moves backward to another heading that is less
deeply nested.


File: emacs,  Node: Outline Visibility,  Next: Outline Views,  Prev: Outline Motion,  Up: Outline Mode

Outline Visibility Commands
---------------------------

   The other special commands of outline mode are used to make lines
visible or invisible.  Their names all start with `hide' or `show'.
Most of them fall into pairs of opposites.  They are not undoable;
instead, you can undo right past them.  Making lines visible or
invisible is simply not recorded by the undo mechanism.

`C-c C-t'
     Make all body lines in the buffer invisible (`hide-body').

`C-c C-a'
     Make all lines in the buffer visible (`show-all').

`C-c C-d'
     Make everything under this heading invisible, not including this
     heading itself
     (`hide-subtree').

`C-c C-s'
     Make everything under this heading visible, including body,
     subheadings, and their bodies (`show-subtree').

`C-c C-l'
     Make the body of this heading line, and of all its subheadings,
     invisible (`hide-leaves').

`C-c C-k'
     Make all subheadings of this heading line, at all levels, visible
     (`show-branches').

`C-c C-i'
     Make immediate subheadings (one level down) of this heading line
     visible (`show-children').

`C-c C-c'
     Make this heading line's body invisible (`hide-entry').

`C-c C-e'
     Make this heading line's body visible (`show-entry').

`C-c C-q'
     Hide everything except the top N levels of heading lines
     (`hide-sublevels').

`C-c C-o'
     Hide everything except for the heading or body that point is in,
     plus the headings leading up from there to the top level of the
     outline (`hide-other').

   Two commands that are exact opposites are `C-c C-c' (`hide-entry')
and `C-c C-e' (`show-entry').  They are used with point on a heading
line, and apply only to the body lines of that heading.  Subheadings
and their bodies are not affected.

   Two more powerful opposites are `C-c C-d' (`hide-subtree') and `C-c
C-s' (`show-subtree').  Both expect to be used when point is on a
heading line, and both apply to all the lines of that heading's
"subtree": its body, all its subheadings, both direct and indirect, and
all of their bodies.  In other words, the subtree contains everything
following this heading line, up to and not including the next heading of
the same or higher rank.

   Intermediate between a visible subtree and an invisible one is having
all the subheadings visible but none of the body.  There are two
commands for doing this, depending on whether you want to hide the
bodies or make the subheadings visible.  They are `C-c C-l'
(`hide-leaves') and `C-c C-k' (`show-branches').

   A little weaker than `show-branches' is `C-c C-i' (`show-children').
It makes just the direct subheadings visible--those one level down.
Deeper subheadings remain invisible, if they were invisible.

   Two commands have a blanket effect on the whole file.  `C-c C-t'
(`hide-body') makes all body lines invisible, so that you see just the
outline structure.  `C-c C-a' (`show-all') makes all lines visible.
These commands can be thought of as a pair of opposites even though
`C-c C-a' applies to more than just body lines.

   The command `C-c C-q' (`hide-sublevels') hides all but the top level
headings.  With a numeric argument N, it hides everything except the
top N levels of heading lines.

   The command `C-c C-o' (`hide-other') hides everything except the
heading or body text that point is in, plus its parents (the headers
leading up from there to top level in the outline).

   You can turn off the use of ellipses at the ends of visible lines by
setting `selective-display-ellipses' to `nil'.  Then there is no
visible indication of the presence of invisible lines.


File: emacs,  Node: Outline Views,  Prev: Outline Visibility,  Up: Outline Mode

Viewing One Outline in Multiple Views
-------------------------------------

   You can display two views of a single outline at the same time, in
different windows, by means of an alternative implementation of Outline
mode called `noutline'.

   To do this, first load the library `noutline' with `M-x load-library
RET noutline RET'.  This loads the alternative implementation of
Outline mode.  It provides the same command names and key bindings as
regular Outline mode, but it implements them differently.

   Then, to display a second view of an outline buffer, you must create
an indirect buffer using `M-x make-indirect-buffer'.  The first
argument of this command is the existing outline buffer name, and its
second argument is the name to use for the new indirect buffer.  *Note
Indirect Buffers::.

   Once the indirect buffer exists, you can display it in a window in
the normal fashion, with `C-x 4 b' or other Emacs commands.  The Outline
mode commands to show and hide parts of the text operate on each buffer
independently; as a result, each buffer can have its own view.  If you
want more than two views on the same outline, create additional indirect
buffers.

   In a future Emacs version, the alternative `noutline' implementation
will probably become the principal implementation.

