This is Info file elisp, produced by Makeinfo-1.64 from the input file
elisp.texi.

   This version is the edition 2.4 of the GNU Emacs Lisp Reference
Manual.  It corresponds to Emacs Version 19.29.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Display,  Next: Calendar,  Prev: System Interface,  Up: Top

Emacs Display
*************

   This chapter describes a number of features related to the display
that Emacs presents to the user.

* Menu:

* Refresh Screen::      Clearing the screen and redrawing everything on it.
* Screen Size::         How big is the Emacs screen.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::       Where messages are displayed.
* Invisible Text::      Hiding part of the buffer text.
* Selective Display::   Hiding part of the buffer text (the old way).
* Overlay Arrow::       Display of an arrow to indicate position.
* Temporary Displays::  Displays that go away automatically.
* Overlays::		Use overlays to highlight parts of the buffer.
* Faces::		A face defines a graphics appearance: font, color, etc.
* Blinking::            How Emacs shows the matching open parenthesis.
* Inverse Video::	Specifying how the screen looks.
* Usual Display::	The usual conventions for displaying nonprinting chars.
* Display Tables::	How to specify other conventions.
* Beeping::             Audible signal to the user.
* Window Systems::      Which window system is being used.


File: elisp,  Node: Refresh Screen,  Next: Screen Size,  Up: Display

Refreshing the Screen
=====================

   The function `redraw-frame' redisplays the entire contents of a
given frame.  *Note Frames::.

 - Function: redraw-frame FRAME
     This function clears and redisplays frame FRAME.

   Even more powerful is `redraw-display':

 - Command: redraw-display
     This function clears and redisplays all visible frames.

   Processing user input takes absolute priority over redisplay.  If you
call these functions when input is available, they do nothing
immediately, but a full redisplay does happen eventually--after all the
input has been processed.

   Normally, suspending and resuming Emacs also refreshes the screen.
Some terminal emulators record separate contents for display-oriented
programs such as Emacs and for ordinary sequential display.  If you are
using such a terminal, you might want to inhibit the redisplay on
resumption.

 - Variable: no-redraw-on-reenter
     This variable controls whether Emacs redraws the entire screen
     after it has been suspended and resumed.  Non-`nil' means yes,
     `nil' means no.


File: elisp,  Node: Screen Size,  Next: Truncation,  Prev: Refresh Screen,  Up: Display

Screen Size
===========

   The screen size functions access or specify the height or width of
the terminal.  When you are using multiple frames, they apply to the
selected frame (*note Frames::.).

 - Function: screen-height
     This function returns the number of lines on the screen that are
     available for display.

          (screen-height)
               => 50

 - Function: screen-width
     This function returns the number of columns on the screen that are
     available for display.

          (screen-width)
               => 80

 - Function: set-screen-height LINES &optional NOT-ACTUAL-SIZE
     This function declares that the terminal can display LINES lines.
     The sizes of existing windows are altered proportionally to fit.

     If NOT-ACTUAL-SIZE is non-`nil', then Emacs displays LINES lines
     of output, but does not change its value for the actual height of
     the screen.  (Knowing the correct actual size may be necessary for
     correct cursor positioning.)  Using a smaller height than the
     terminal actually implements may be useful to reproduce behavior
     observed on a smaller screen, or if the terminal malfunctions when
     using its whole screen.

     If LINES is different from what it was previously, then the entire
     screen is cleared and redisplayed using the new size.

     This function returns `nil'.

 - Function: set-screen-width COLUMNS &optional NOT-ACTUAL-SIZE
     This function declares that the terminal can display COLUMNS
     columns.  The details are as in `set-screen-height'.


File: elisp,  Node: Truncation,  Next: The Echo Area,  Prev: Screen Size,  Up: Display

Truncation
==========

   When a line of text extends beyond the right edge of a window, the
line can either be continued on the next screen line, or truncated to
one screen line.  The additional screen lines used to display a long
text line are called "continuation" lines.  Normally, a `$' in the
rightmost column of the window indicates truncation; a `\' on the
rightmost column indicates a line that "wraps" or is continued onto the
next line.  (The display table can specify alternative indicators; see
*Note Display Tables::.)

   Note that continuation is different from filling; continuation
happens on the screen only, not in the buffer contents, and it breaks a
line precisely at the right margin, not at a word boundary.  *Note
Filling::.

 - User Option: truncate-lines
     This buffer-local variable controls how Emacs displays lines that
     extend beyond the right edge of the window.  The default is `nil',
     which specifies continuation.  If the value is non-`nil', then
     these lines are truncated.

     If the variable `truncate-partial-width-windows' is non-`nil',
     then truncation is always used for side-by-side windows (within one
     frame) regardless of the value of `truncate-lines'.

 - User Option: default-truncate-lines
     This variable is the default value for `truncate-lines', for
     buffers that do not have local values for it.

 - User Option: truncate-partial-width-windows
     This variable controls display of lines that extend beyond the
     right edge of the window, in side-by-side windows (*note Splitting
     Windows::.).  If it is non-`nil', these lines are truncated;
     otherwise, `truncate-lines' says what to do with them.

   You can override the images that indicate continuation or truncation
with the display table; see *Note Display Tables::.

   If your buffer contains *very* long lines, and you use continuation
to display them, just thinking about them can make Emacs redisplay
slow.  The column computation and indentation functions also become
slow.  Then you might find it advisable to set `cache-long-line-scans'
to `t'.

 - Variable: cache-long-line-scans
     If this variable is non-`nil', various indentation and motion
     functions, and Emacs redisplay, cache the results of scanning the
     buffer, and consult the cache to avoid rescanning regions of the
     buffer unless they are modified.

     Turning on the cache slows down processing of short lines somewhat.

     This variable is automatically local in every buffer.


File: elisp,  Node: The Echo Area,  Next: Invisible Text,  Prev: Truncation,  Up: Display

The Echo Area
=============

   The "echo area" is used for displaying messages made with the
`message' primitive, and for echoing keystrokes.  It is not the same as
the minibuffer, despite the fact that the minibuffer appears (when
active) in the same place on the screen as the echo area.  The `GNU
Emacs Manual' specifies the rules for resolving conflicts between the
echo area and the minibuffer for use of that screen space (*note The
Minibuffer: (emacs)Minibuffer.).  Error messages appear in the echo
area; see *Note Errors::.

   You can write output in the echo area by using the Lisp printing
functions with `t' as the stream (*note Output Functions::.), or as
follows:

 - Function: message STRING &rest ARGUMENTS
     This function displays a one-line message in the echo area.  The
     argument STRING is similar to a C language `printf' control
     string.  See `format' in *Note String Conversion::, for the details
     on the conversion specifications.  `message' returns the
     constructed string.

     In batch mode, `message' prints the message text on the standard
     error stream, followed by a newline.

     If STRING is `nil', `message' clears the echo area.  If the
     minibuffer is active, this brings the minibuffer contents back onto
     the screen immediately.

          (message "Minibuffer depth is %d."
                   (minibuffer-depth))
           -| Minibuffer depth is 0.
          => "Minibuffer depth is 0."
          
          ---------- Echo Area ----------
          Minibuffer depth is 0.
          ---------- Echo Area ----------

   Almost all the messages displayed in the echo area are also recorded
in the `*Messages*' buffer.

 - User Option: message-log-max
     This variable specifies how many lines to keep in the `*Messages*'
     buffer.  The value `t' means there is no limit on how many lines to
     keep.  The value `nil' disables message logging entirely.  Here's
     how to display a message and prevent it from being logged:

          (let (message-log-max)
            (message ...))

 - Variable: echo-keystrokes
     This variable determines how much time should elapse before command
     characters echo.  Its value must be an integer, which specifies the
     number of seconds to wait before echoing.  If the user types a
     prefix key (such as `C-x') and then delays this many seconds before
     continuing, the prefix key is echoed in the echo area.  Any
     subsequent characters in the same command will be echoed as well.

     If the value is zero, then command input is not echoed.

 - Variable: cursor-in-echo-area
     This variable controls where the cursor appears when a message is
     displayed in the echo area.  If it is non-`nil', then the cursor
     appears at the end of the message.  Otherwise, the cursor appears
     at point--not in the echo area at all.

     The value is normally `nil'; Lisp programs bind it to `t' for
     brief periods of time.


File: elisp,  Node: Invisible Text,  Next: Selective Display,  Prev: The Echo Area,  Up: Display

Invisible Text
==============

   You can make characters "invisible", so that they do not appear on
the screen, with the `invisible' property.  This can be either a text
property or a property of an overlay.

   In the simplest case, any non-`nil' `invisible' property makes a
character invisible.  This is the default case--if you don't alter the
default value of `buffer-invisibility-spec', this is how the
`invisibility' property works.  This feature is much like selective
display (*note Selective Display::.), but more general and cleaner.

   More generally, you can use the variable `buffer-invisibility-spec'
to control which values of the `invisible' property make text
invisible.  This permits you to classify the text into different subsets
in advance, by giving them different `invisible' values, and
subsequently make various subsets visible or invisible by changing the
value of `buffer-invisibility-spec'.

   Controlling visibility with `buffer-invisibility-spec' is especially
useful in a program to display the list of entries in a data base.  It
permits the implementation of convenient filtering commands to view
just a part of the entries in the data base.  Setting this variable is
very fast, much faster than scanning all the text in the buffer looking
for properties to change.

 - Variable: buffer-invisibility-spec
     This variable specifies which kinds of `invisible' properties
     actually make a character invisible.

    `t'
          A character is invisible if its `invisible' property is
          non-`nil'.  This is the default.

    a list
          Each element of the list makes certain characters invisible.
          Ultimately, a character is invisible if any of the elements
          of this list applies to it.  The list can have two kinds of
          elements:

         `ATOM'
               A character is invisible if its `invisible' propery value
               is ATOM or if it is a list with ATOM as a member.

         `(ATOM . t)'
               A character is invisible if its `invisible' propery value
               is ATOM or if it is a list with ATOM as a member.
               Moreover, if this character is at the end of a line and
               is followed by a visible newline, it displays an
               ellipsis.

   Ordinarily, commands that operate on text or move point do not care
whether the text is invisible.  However, the user-level line motion
commands explicitly ignore invisible newlines.


File: elisp,  Node: Selective Display,  Next: Overlay Arrow,  Prev: Invisible Text,  Up: Display

Selective Display
=================

   "Selective display" is a pair of features that hide certain lines on
the screen.

   The first variant, explicit selective display, is designed for use in
a Lisp program.  The program controls which lines are hidden by altering
the text.  Outline mode has traditionally used this variant.  It has
been partially replaced by the invisible text feature (*note Invisible
Text::.); there is a new version of Outline mode which uses that
instead.

   In the second variant, the choice of lines to hide is made
automatically based on indentation.  This variant is designed to be a
user-level feature.

   The way you control explicit selective display is by replacing a
newline (control-j) with a carriage return (control-m).  The text that
was formerly a line following that newline is now invisible.  Strictly
speaking, it is temporarily no longer a line at all, since only newlines
can separate lines; it is now part of the previous line.

   Selective display does not directly affect editing commands.  For
example, `C-f' (`forward-char') moves point unhesitatingly into
invisible text.  However, the replacement of newline characters with
carriage return characters affects some editing commands.  For example,
`next-line' skips invisible lines, since it searches only for newlines.
Modes that use selective display can also define commands that take
account of the newlines, or that make parts of the text visible or
invisible.

   When you write a selectively displayed buffer into a file, all the
control-m's are output as newlines.  This means that when you next read
in the file, it looks OK, with nothing invisible.  The selective display
effect is seen only within Emacs.

 - Variable: selective-display
     This buffer-local variable enables selective display.  This means
     that lines, or portions of lines, may be made invisible.

        * If the value of `selective-display' is `t', then any portion
          of a line that follows a control-m is not displayed.

        * If the value of `selective-display' is a positive integer,
          then lines that start with more than that many columns of
          indentation are not displayed.

     When some portion of a buffer is invisible, the vertical movement
     commands operate as if that portion did not exist, allowing a
     single `next-line' command to skip any number of invisible lines.
     However, character movement commands (such as `forward-char') do
     not skip the invisible portion, and it is possible (if tricky) to
     insert or delete text in an invisible portion.

     In the examples below, we show the *display appearance* of the
     buffer `foo', which changes with the value of `selective-display'.
     The *contents* of the buffer do not change.

          (setq selective-display nil)
               => nil
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
            3n this column
            3n this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------
          
          (setq selective-display 2)
               => 2
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

 - Variable: selective-display-ellipses
     If this buffer-local variable is non-`nil', then Emacs displays
     `...' at the end of a line that is followed by invisible text.
     This example is a continuation of the previous one.

          (setq selective-display-ellipses t)
               => t
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column ...
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

     You can use a display table to substitute other text for the
     ellipsis (`...').  *Note Display Tables::.


File: elisp,  Node: Overlay Arrow,  Next: Temporary Displays,  Prev: Selective Display,  Up: Display

The Overlay Arrow
=================

   The "overlay arrow" is useful for directing the user's attention to
a particular line in a buffer.  For example, in the modes used for
interface to debuggers, the overlay arrow indicates the line of code
about to be executed.

 - Variable: overlay-arrow-string
     This variable holds the string to display to call attention to a
     particular line, or `nil' if the arrow feature is not in use.

 - Variable: overlay-arrow-position
     This variable holds a marker that indicates where to display the
     overlay arrow.  It should point at the beginning of a line.  The
     arrow text appears at the beginning of that line, overlaying any
     text that would otherwise appear.  Since the arrow is usually
     short, and the line usually begins with indentation, normally
     nothing significant is overwritten.

     The overlay string is displayed only in the buffer that this marker
     points into.  Thus, only one buffer can have an overlay arrow at
     any given time.

   You can do the same job by creating an overlay with a
`before-string' property.  *Note Overlay Properties::.


File: elisp,  Node: Temporary Displays,  Next: Overlays,  Prev: Overlay Arrow,  Up: Display

Temporary Displays
==================

   Temporary displays are used by commands to put output into a buffer
and then present it to the user for perusal rather than for editing.
Many of the help commands use this feature.

 - Special Form: with-output-to-temp-buffer BUFFER-NAME FORMS...
     This function executes FORMS while arranging to insert any output
     they print into the buffer named BUFFER-NAME.  The buffer is then
     shown in some window for viewing, displayed but not selected.

     The string BUFFER-NAME specifies the temporary buffer, which need
     not already exist.  The argument must be a string, not a buffer.
     The buffer is erased initially (with no questions asked), and it is
     marked as unmodified after `with-output-to-temp-buffer' exits.

     `with-output-to-temp-buffer' binds `standard-output' to the
     temporary buffer, then it evaluates the forms in FORMS.  Output
     using the Lisp output functions within FORMS goes by default to
     that buffer (but screen display and messages in the echo area,
     although they are "output" in the general sense of the word, are
     not affected).  *Note Output Functions::.

     The value of the last form in FORMS is returned.

          ---------- Buffer: foo ----------
           This is the contents of foo.
          ---------- Buffer: foo ----------
          
          (with-output-to-temp-buffer "foo"
              (print 20)
              (print standard-output))
          => #<buffer foo>
          
          ---------- Buffer: foo ----------
          20
          
          #<buffer foo>
          
          ---------- Buffer: foo ----------

 - Variable: temp-buffer-show-function
     If this variable is non-`nil', `with-output-to-temp-buffer' calls
     it as a function to do the job of displaying a help buffer.  The
     function gets one argument, which is the buffer it should display.

     In Emacs versions 18 and earlier, this variable was called
     `temp-buffer-show-hook'.

 - Function: momentary-string-display STRING POSITION &optional CHAR
          MESSAGE
     This function momentarily displays STRING in the current buffer at
     POSITION.  It has no effect on the undo list or on the buffer's
     modification status.

     The momentary display remains until the next input event.  If the
     next input event is CHAR, `momentary-string-display' ignores it
     and returns.  Otherwise, that event remains buffered for
     subsequent use as input.  Thus, typing CHAR will simply remove the
     string from the display, while typing (say) `C-f' will remove the
     string from the display and later (presumably) move point forward.
     The argument CHAR is a space by default.

     The return value of `momentary-string-display' is not meaningful.

     If the string STRING does not contain control characters, you can
     do the same job in a more general way by creating an overlay with a
     `before-string' property.  *Note Overlay Properties::.

     If MESSAGE is non-`nil', it is displayed in the echo area while
     STRING is displayed in the buffer.  If it is `nil', a default
     message says to type CHAR to continue.

     In this example, point is initially located at the beginning of the
     second line:

          ---------- Buffer: foo ----------
          This is the contents of foo.
          -!-Second line.
          ---------- Buffer: foo ----------
          
          (momentary-string-display
            "**** Important Message! ****"
            (point) ?\r
            "Type RET when done reading")
          => t
          
          ---------- Buffer: foo ----------
          This is the contents of foo.
          **** Important Message! ****Second line.
          ---------- Buffer: foo ----------
          
          ---------- Echo Area ----------
          Type RET when done reading
          ---------- Echo Area ----------


File: elisp,  Node: Overlays,  Next: Faces,  Prev: Temporary Displays,  Up: Display

Overlays
========

   You can use "overlays" to alter the appearance of a buffer's text on
the screen, for the sake of presentation features.  An overlay is an
object that belongs to a particular buffer, and has a specified
beginning and end.  It also has properties that you can examine and set;
these affect the display of the text within the overlay.

* Menu:

* Overlay Properties::	How to read and set properties.
			What properties do to the screen display.
* Managing Overlays::   Creating, moving, finding overlays.


File: elisp,  Node: Overlay Properties,  Next: Managing Overlays,  Up: Overlays

Overlay Properties
------------------

   Overlay properties are like text properties in some respects, but the
differences are more important than the similarities.  Text properties
are considered a part of the text; overlays are specifically considered
not to be part of the text.  Thus, copying text between various buffers
and strings preserves text properties, but does not try to preserve
overlays.  Changing a buffer's text properties marks the buffer as
modified, while moving an overlay or changing its properties does not.
Unlike text propery changes, overlay changes are not recorded in the
buffer's undo list.

`priority'
     This property's value (which should be a nonnegative number)
     determines the priority of the overlay.  The priority matters when
     two or more overlays cover the same character and both specify a
     face for display; the one whose `priority' value is larger takes
     priority over the other, and its face attributes override the face
     attributes of the lower priority overlay.

     Currently, all overlays take priority over text properties.  Please
     avoid using negative priority values, as we have not yet decided
     just what they should mean.

`window'
     If the `window' property is non-`nil', then the overlay applies
     only on that window.

`category'
     If an overlay has a `category' property, we call it the "category"
     of the overlay.  It should be a symbol.  The properties of the
     symbol serve as defaults for the properties of the overlay.

`face'
     This property controls the font and color of text.  Its value is a
     face name or a list of face names.  *Note Faces::, for more
     information.  This feature may be temporary; in the future, we may
     replace it with other ways of specifying how to display text.

`mouse-face'
     This property is used instead of `face' when the mouse is within
     the range of the overlay.  This feature may be temporary, like
     `face'.

`modification-hooks'
     This property's value is a list of functions to be called if any
     character within the overlay is changed or if text is inserted
     strictly within the overlay.

     The hook functions are called both before and after each change.
     If the functions save the information they receive, and compare
     notes between calls, they can determine exactly what change has
     been made in the buffer text.

     When called before a change, each function receives four
     arguments: the overlay, `nil', and the beginning and end of the
     text range to be modified.

     When called after a change, each function receives five arguments:
     the overlay, `t', the beginning and end of the text range just
     modified, and the length of the pre-change text replaced by that
     range.  (For an insertion, the pre-change length is zero; for a
     deletion, that length is the number of characters deleted, and the
     post-change beginning and end are equal.)

`insert-in-front-hooks'
     This property's value is a list of functions to be called before
     and after inserting text right at the beginning of the overlay.
     The calling conventions are the same as for the
     `modification-hooks' functions.

`insert-behind-hooks'
     This property's value is a list of functions to be called before
     and after inserting text right at the end of the overlay.  The
     calling conventions are the same as for the `modification-hooks'
     functions.

`invisible'
     The `invisible' property can make the text in the overlay
     invisible, which means that it does not appear on the screen.
     *Note Invisible Text::, for details.

`intangible'
     The `intangible' property on an overlay works just like the
     `intangible' text property.  *Note Special Properties::, for
     details.

`before-string'
     This property's value is a string to add to the display at the
     beginning of the overlay.  The string does not appear in the
     buffer in any sense--only on the screen.  The string should
     contain only characters that display as a single column--control
     characters, including tabs or newlines, will give strange results.

`after-string'
     This property's value is a string to add to the display at the end
     of the overlay.  The string does not appear in the buffer in any
     sense--only on the screen.  The string should contain only
     characters that display as a single column--control characters,
     including tabs or newlines, will give strange results.

`evaporate'
     If this property is non-`nil', the overlay is deleted automatically
     if it ever becomes empty (i.e., if it spans no characters).

   These are the functions for reading and writing the properties of an
overlay.

 - Function: overlay-get OVERLAY PROP
     This function returns the value of property PROP recorded in
     OVERLAY, if any.  If OVERLAY does not record any value for that
     property, but it does have a `category' property which is a
     symbol, that symbol's PROP property is used.  Otherwise, the value
     is `nil'.

 - Function: overlay-put OVERLAY PROP VALUE
     This function sets the value of property PROP recorded in OVERLAY
     to VALUE.  It returns VALUE.

   See also the function `get-char-property' which checks both overlay
properties and text properties for a given character.  *Note Examining
Properties::.


File: elisp,  Node: Managing Overlays,  Prev: Overlay Properties,  Up: Overlays

Managing Overlays
-----------------

   This section describes the functions to create, delete and move
overlays, and to examine their contents.

 - Function: make-overlay START END &optional BUFFER
     This function creates and returns an overlay that belongs to
     BUFFER and ranges from START to END.  Both START and END must
     specify buffer positions; they may be integers or markers.  If
     BUFFER is omitted, the overlay is created in the current buffer.

 - Function: overlay-start OVERLAY
     This function returns the position at which OVERLAY starts.

 - Function: overlay-end OVERLAY
     This function returns the position at which OVERLAY ends.

 - Function: overlay-buffer OVERLAY
     This function returns the buffer that OVERLAY belongs to.

 - Function: delete-overlay OVERLAY
     This function deletes OVERLAY.  The overlay continues to exist as
     a Lisp object, but ceases to be part of the buffer it belonged to,
     and ceases to have any effect on display.

 - Function: move-overlay OVERLAY START END &optional BUFFER
     This function moves OVERLAY to BUFFER, and places its bounds at
     START and END.  Both arguments START and END must specify buffer
     positions; they may be integers or markers.  If BUFFER is omitted,
     the overlay stays in the same buffer.

     The return value is OVERLAY.

     This is the only valid way to change the endpoints of an overlay.
     Do not try modifying the markers in the overlay by hand, as that
     fails to update other vital data structures and can cause some
     overlays to be "lost".

 - Function: overlays-at POS
     This function returns a list of all the overlays that contain
     position POS in the current buffer.  The list is in no particular
     order.  An overlay contains position POS if it begins at or before
     POS, and ends after POS.

 - Function: next-overlay-change POS
     This function returns the buffer position of the next beginning or
     end of an overlay, after POS.

 - Function: previous-overlay-change POS
     This function returns the buffer position of the previous
     beginning or end of an overlay, before POS.


File: elisp,  Node: Faces,  Next: Blinking,  Prev: Overlays,  Up: Display

Faces
=====

   A "face" is a named collection of graphical attributes: font,
foreground color, background color and optional underlining.  Faces
control the display of text on the screen.

   Each face has its own "face id number" which distinguishes faces at
low levels within Emacs.  However, for most purposes, you can refer to
faces in Lisp programs by their names.

 - Function: facep OBJECT
     This function returns `t' if OBJECT is a face name symbol (or if
     it is a vector of the kind used internally to record face data).
     It returns `nil' otherwise.

   Each face name is meaningful for all frames, and by default it has
the same meaning in all frames.  But you can arrange to give a
particular face name a special meaning in one frame if you wish.

* Menu:

* Standard Faces::      The faces Emacs normally comes with.
* Merging Faces::	How Emacs decides which face to use for a character.
* Face Functions::	How to define and examine faces.


File: elisp,  Node: Standard Faces,  Next: Merging Faces,  Up: Faces

Standard Faces
--------------

   This table lists all the standard faces and their uses.

`default'
     This face is used for ordinary text.

`modeline'
     This face is used for mode lines and menu bars.

`region'
     This face is used for highlighting the region in Transient Mark
     mode.

`secondary-selection'
     This face is used to show any secondary selection you have made.

`highlight'
     This face is meant to be used for highlighting for various
     purposes.

`underline'
     This face underlines text.

`bold'
     This face uses a bold font, if possible.  It uses the bold variant
     of the frame's font, if it has one.  It's up to you to choose a
     default font that has a bold variant, if you want to use one.

`italic'
     This face uses the italic variant of the frame's font, if it has
     one.

`bold-italic'
     This face uses the bold italic variant of the frame's font, if it
     has one.


File: elisp,  Node: Merging Faces,  Next: Face Functions,  Prev: Standard Faces,  Up: Faces

Merging Faces for Display
-------------------------

   Here are all the ways to specify which face to use for display of
text:

   * With defaults.  Each frame has a "default face", whose id number is
     zero, which is used for all text that doesn't somehow specify
     another face.

   * With text properties.  A character may have a `face' property; if
     so, it is displayed with that face.  *Note Special Properties::.

     If the character has a `mouse-face' property, that is used instead
     of the `face' property when the mouse is "near enough" to the
     character.

   * With overlays.  An overlay may have `face' and `mouse-face'
     properties too; they apply to all the text covered by the overlay.

   * With a region that is active.  In Transient Mark mode, the region
     is highlighted with a particular face (see `region-face', below).

   * With special glyphs.  Each glyph can specify a particular face id
     number.  *Note Glyphs::.

   If these various sources together specify more than one face for a
particular character, Emacs merges the attributes of the various faces
specified.  The attributes of the faces of special glyphs come first;
then comes the face for region highlighting, if appropriate; then come
attributes of faces from overlays, followed by those from text
properties, and last the default face.

   When multiple overlays cover one character, an overlay with higher
priority overrides those with lower priority.  *Note Overlays::.

   If an attribute such as the font or a color is not specified in any
of the above ways, the frame's own font or color is used.


File: elisp,  Node: Face Functions,  Prev: Merging Faces,  Up: Faces

Functions for Working with Faces
--------------------------------

   The attributes a face can specify include the font, the foreground
color, the background color, and underlining.  The face can also leave
these unspecified by giving the value `nil' for them.

   Here are the primitives for creating and changing faces.

 - Function: make-face NAME
     This function defines a new face named NAME, initially with all
     attributes `nil'.  It does nothing if there is already a face named
     NAME.

 - Function: face-list
     This function returns a list of all defined face names.

 - Function: copy-face OLD-FACE NEW-NAME &optional FRAME NEW-FRAME
     This function defines the face NEW-NAME as a copy of the existing
     face named OLD-FACE.  It creates the face NEW-NAME if that doesn't
     already exist.

     If the optional argument FRAME is given, this function applies
     only to that frame.  Otherwise it applies to each frame
     individually, copying attributes from OLD-FACE in each frame to
     NEW-FACE in the same frame.

     If the optional argument NEW-FRAME is given, then `copy-face'
     copies the attributes of OLD-FACE in FRAME to NEW-NAME in
     NEW-FRAME.

   You can modify the attributes of an existing face with the following
functions.  If you specify FRAME, they affect just that frame;
otherwise, they affect all frames as well as the defaults that apply to
new frames.

 - Function: set-face-foreground FACE COLOR &optional FRAME
 - Function: set-face-background FACE COLOR &optional FRAME
     These functions set the foreground (or background, respectively)
     color of face FACE to COLOR.  The argument COLOR should be a
     string, the name of a color.

     Certain shades of gray are implemented by stipple patterns on
     black-and-white screens.

 - Function: set-face-stipple FACE PATTERN &optional FRAME
     This function sets the background stipple pattern of face FACE to
     PATTERN.  The argument PATTERN should be the name of a stipple
     pattern defined by the X server, or `nil' meaning don't use
     stipple.

     Normally there is no need to pay attention to stipple patterns,
     because they are used automatically to handle certain shades of
     gray.

 - Function: set-face-font FACE FONT &optional FRAME
     This function sets the font of face FACE.  The argument FONT
     should be a string.

 - Function: set-face-underline-p FACE UNDERLINE-P &optional FRAME
     This function sets the underline attribute of face FACE.
     Non-`nil' means do underline; `nil' means don't.

 - Function: invert-face FACE &optional FRAME
     Swap the foreground and background colors of face FACE.  If the
     face doesn't specify both foreground and background, then its
     foreground and background are set to the default background and
     foreground, respectively.

   These functions examine the attributes of a face.  If you don't
specify FRAME, they refer to the default data for new frames.

 - Function: face-foreground FACE &optional FRAME
 - Function: face-background FACE &optional FRAME
     These functions return the foreground color (or background color,
     respectively) of face FACE, as a string.

 - Function: face-stipple FACE &optional FRAME
     This function returns the name of the background stipple pattern
     of face FACE, or `nil' if it doesn't have one.

 - Function: face-font FACE &optional FRAME
     This function returns the name of the font of face FACE.

 - Function: face-underline-p FACE &optional FRAME
     This function returns the underline attribute of face FACE.

 - Function: face-id FACE
     This function returns the face id number of face FACE.

 - Function: face-equal FACE1 FACE2 &optional FRAME
     This returns `t' if the faces FACE1 and FACE2 have the same
     attributes for display.

 - Function: face-differs-from-default-p FACE &optional FRAME
     This returns `t' if the face FACE displays differently from the
     default face.  A face is considered to be "the same" as the normal
     face if each attribute is either the same as that of the default
     face or `nil' (meaning to inherit from the default).

 - Variable: region-face
     This variable's value specifies the face id to use to display
     characters in the region when it is active (in Transient Mark mode
     only).  The face thus specified takes precedence over all faces
     that come from text properties and overlays, for characters in the
     region.  *Note The Mark::, for more information about Transient
     Mark mode.

     Normally, the value is the id number of the face named `region'.


File: elisp,  Node: Blinking,  Next: Inverse Video,  Prev: Faces,  Up: Display

Blinking Parentheses
====================

   This section describes the mechanism by which Emacs shows a matching
open parenthesis when the user inserts a close parenthesis.

 - Variable: blink-paren-function
     The value of this variable should be a function (of no arguments)
     to be called whenever a character with close parenthesis syntax is
     inserted.  The value of `blink-paren-function' may be `nil', in
     which case nothing is done.

          *Please note:* This variable was named `blink-paren-hook' in
          older Emacs versions, but since it is not called with the
          standard convention for hooks, it was renamed to
          `blink-paren-function' in version 19.

 - Variable: blink-matching-paren
     If this variable is `nil', then `blink-matching-open' does nothing.

 - Variable: blink-matching-paren-distance
     This variable specifies the maximum distance to scan for a matching
     parenthesis before giving up.

 - Variable: blink-matching-paren-delay
     This variable specifies the number of seconds for the cursor to
     remain at the matching parenthesis.  A fraction of a second often
     gives good results, but the default is 1, which works on all
     systems.

 - Function: blink-matching-open
     This function is the default value of `blink-paren-function'.  It
     assumes that point follows a character with close parenthesis
     syntax and moves the cursor momentarily to the matching opening
     character.  If that character is not already on the screen, it
     displays the character's context in the echo area.  To avoid long
     delays, this function does not search farther than
     `blink-matching-paren-distance' characters.

     Here is an example of calling this function explicitly.

          (defun interactive-blink-matching-open ()
            "Indicate momentarily the start of sexp before point."
            (interactive)

          (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))


File: elisp,  Node: Inverse Video,  Next: Usual Display,  Prev: Blinking,  Up: Display

Inverse Video
=============

 - User Option: inverse-video
     This variable controls whether Emacs uses inverse video for all
     text on the screen.  Non-`nil' means yes, `nil' means no.  The
     default is `nil'.

 - User Option: mode-line-inverse-video
     This variable controls the use of inverse video for mode lines.
     If it is non-`nil', then mode lines are displayed in inverse video.
     Otherwise, mode lines are displayed normally, just like text.  The
     default is `t'.

     For X window frames, this displays mode lines using the face named
     `modeline', which is normally the inverse of the default face
     unless you change it.


File: elisp,  Node: Usual Display,  Next: Display Tables,  Prev: Inverse Video,  Up: Display

Usual Display Conventions
=========================

   The usual display conventions define how to display each character
code.  You can override these conventions by setting up a display table
(*note Display Tables::.).  Here are the usual display conventions:

   * Character codes 32 through 126 map to glyph codes 32 through 126.
     Normally this means they display as themselves.

   * Character code 9 is a horizontal tab.  It displays as whitespace
     up to a position determined by `tab-width'.

   * Character code 10 is a newline.

   * All other codes in the range 0 through 31, and code 127, display
     in one of two ways according to the value of `ctl-arrow'.  If it is
     non-`nil', these codes map to sequences of two glyphs, where the
     first glyph is the ASCII code for `^'.  (A display table can
     specify a glyph to use instead of `^'.)  Otherwise, these codes map
     just like the codes in the range 128 to 255.

   * Character codes 128 through 255 map to sequences of four glyphs,
     where the first glyph is the ASCII code for `\', and the others are
     digit characters representing the code in octal.  (A display table
     can specify a glyph to use instead of `\'.)

   The usual display conventions apply even when there is a display
table, for any character whose entry in the active display table is
`nil'.  Thus, when you set up a display table, you need only specify
the characters for which you want unusual behavior.

   These variables affect the way certain characters are displayed on
the screen.  Since they change the number of columns the characters
occupy, they also affect the indentation functions.

 - User Option: ctl-arrow
     This buffer-local variable controls how control characters are
     displayed.  If it is non-`nil', they are displayed as a caret
     followed by the character: `^A'.  If it is `nil', they are
     displayed as a backslash followed by three octal digits: `\001'.

 - Variable: default-ctl-arrow
     The value of this variable is the default value for `ctl-arrow' in
     buffers that do not override it.  *Note Default Value::.

 - User Option: tab-width
     The value of this variable is the spacing between tab stops used
     for displaying tab characters in Emacs buffers.  The default is 8.
     Note that this feature is completely independent from the
     user-settable tab stops used by the command `tab-to-tab-stop'.
     *Note Indent Tabs::.


File: elisp,  Node: Display Tables,  Next: Beeping,  Prev: Usual Display,  Up: Display

Display Tables
==============

   You can use the "display table" feature to control how all 256
possible character codes display on the screen.  This is useful for
displaying European languages that have letters not in the ASCII
character set.

   The display table maps each character code into a sequence of
"glyphs", each glyph being an image that takes up one character
position on the screen.  You can also define how to display each glyph
on your terminal, using the "glyph table".

* Menu:

* Display Table Format::	What a display table consists of.
* Active Display Table::	How Emacs selects a display table to use.
* Glyphs::			How to define a glyph, and what glyphs mean.
* ISO Latin 1::			How to use display tables
				  to support the ISO Latin 1 character set.


File: elisp,  Node: Display Table Format,  Next: Active Display Table,  Up: Display Tables

Display Table Format
--------------------

   A display table is actually an array of 262 elements.

 - Function: make-display-table
     This creates and returns a display table.  The table initially has
     `nil' in all elements.

   The first 256 elements correspond to character codes; the Nth
element says how to display the character code N.  The value should be
`nil' or a vector of glyph values (*note Glyphs::.).  If an element is
`nil', it says to display that character according to the usual display
conventions (*note Usual Display::.).

   If you use the display table to change the display of newline
characters, the whole buffer will be displayed as one long "line."

   The remaining six elements of a display table serve special purposes,
and `nil' means use the default stated below.

256
     The glyph for the end of a truncated screen line (the default for
     this is `$').  *Note Glyphs::.

257
     The glyph for the end of a continued line (the default is `\').

258
     The glyph for indicating a character displayed as an octal
     character code (the default is `\').

259
     The glyph for indicating a control character (the default is `^').

260
     A vector of glyphs for indicating the presence of invisible lines
     (the default is `...').  *Note Selective Display::.

261
     The glyph used to draw the border between side-by-side windows (the
     default is `|').  *Note Splitting Windows::.

   For example, here is how to construct a display table that mimics the
effect of setting `ctl-arrow' to a non-`nil' value:

     (setq disptab (make-display-table))
     (let ((i 0))
       (while (< i 32)
         (or (= i ?\t) (= i ?\n)
             (aset disptab i (vector ?^ (+ i 64))))
         (setq i (1+ i)))
       (aset disptab 127 (vector ?^ ??)))


File: elisp,  Node: Active Display Table,  Next: Glyphs,  Prev: Display Table Format,  Up: Display Tables

Active Display Table
--------------------

   Each window can specify a display table, and so can each buffer.
When a buffer B is displayed in window W, display uses the display
table for window W if it has one; otherwise, the display table for
buffer B if it has one; otherwise, the standard display table if any.
The display table chosen is called the "active" display table.

 - Function: window-display-table WINDOW
     This function returns WINDOW's display table, or `nil' if WINDOW
     does not have an assigned display table.

 - Function: set-window-display-table WINDOW TABLE
     This function sets the display table of WINDOW to TABLE.  The
     argument TABLE should be either a display table or `nil'.

 - Variable: buffer-display-table
     This variable is automatically local in all buffers; its value in a
     particular buffer is the display table for that buffer, or `nil' if
     the buffer does not have an assigned display table.

 - Variable: standard-display-table
     This variable's value is the default display table, used whenever a
     window has no display table and neither does the buffer displayed
     in that window.  This variable is `nil' by default.

   If there is no display table to use for a particular window--that is,
if the window has none, its buffer has none, and
`standard-display-table' has none--then Emacs uses the usual display
conventions for all character codes in that window.  *Note Usual
Display::.


File: elisp,  Node: Glyphs,  Next: ISO Latin 1,  Prev: Active Display Table,  Up: Display Tables

Glyphs
------

   A "glyph" is a generalization of a character; it stands for an image
that takes up a single character position on the screen.  Glyphs are
represented in Lisp as integers, just as characters are.

   The meaning of each integer, as a glyph, is defined by the glyph
table, which is the value of the variable `glyph-table'.

 - Variable: glyph-table
     The value of this variable is the current glyph table.  It should
     be a vector; the Gth element defines glyph code G.  If the value
     is `nil' instead of a vector, then all glyphs are simple (see
     below).

   Here are the possible types of elements in the glyph table:

STRING
     Send the characters in STRING to the terminal to output this
     glyph.  This alternative is available on character terminals, but
     not under X.

INTEGER
     Define this glyph code as an alias for code INTEGER.  You can use
     an alias to specify a face code for the glyph; see below.

`NIL'
     This glyph is simple.  On an ordinary terminal, the glyph code mod
     256 is the character to output.  With X, the glyph code mod 256 is
     the character to output, and the glyph code divided by 256
     specifies the "face id number" to use while outputting it.  *Note
     Faces::.

   If a glyph code is greater than or equal to the length of the glyph
table, that code is automatically simple.

