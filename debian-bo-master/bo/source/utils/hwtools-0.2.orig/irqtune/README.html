<!-- $Id$ -->
<HTML><HEAD>
<CENTER><TITLE>IRQTUNE -- A Linux x86 IRQ Priority Optimizer</TITLE>
</HEAD>
<BODY></CENTER><p><hr>

<H1> <EM>IRQTUNE</EM> -- A Linux x86 IRQ Priority Optimizer</H1>
<EM>irqtune</EM> changes the IRQ priority of devices to allow devices that require
high priority and fast service (e.g. serial ports, modems) to have it.
<p><STRONG>With</STRONG>
<EM>irqtune</EM>,
<STRONG>a 3X speedup of serial/modem throughput is possible.</STRONG>
<p><p><hr>

<H1> Where do I get <EM>irqtune</EM>?</H1>
<EM>irqtune</EM> is free software under the terms and conditions of the GNU Public
License.  See the file COPYING, included in the distribution, for details.
<p>
<UL>
<LI>It's available via anonymous ftp from:
<A HREF="ftp://www.best.com/pub/cae/irqtune.tgz">ftp://www.best.com/pub/cae/irqtune.tgz</A> (gzipped tar archive)
<p>
<LI>The author is Craig Estey, (<A HREF="MAILTO:cae@best.com">cae@best.com</A>).
<p>
<LI>This FAQ file is available both in html and text versions included in the tar
file.  This FAQ is also available online via <A HREF="http://www.best.com/~cae/irqtune">http://www.best.com/~cae/irqtune</A>
<p>
</UL>
<p><hr>

<H1> How do I know if I need <EM>irqtune</EM>?</H1>
<STRONG>You are running Linux on an x86 PC, other architectures to be implemented</STRONG>
<STRONG>later--Sorry.</STRONG>
<p><STRONG>You probably need</STRONG>
<EM>irqtune</EM>,
<STRONG>if you are experiencing any of the following:</STRONG>
<p>
<UL>
<LI>SLIP/PPP transfers seem slow.  For example, using a 28.8 (or better) modem,
the effective throughput is approximately 700 bytes/second instead of the
expected 2500 bytes/second.
<p>
<LI>A running SLIP/PPP dies at random times.
<p>
<LI>Serial connections are slow or drop data.
<p>
<LI>Netscape hangs mysteriously or stalls when trying to access a web page.
<p>
<LI>Equivalent programs under Windoze run much faster than under Linux.
<p>
<LI>Disk accesses seem to interfere with SLIP/PPP.
<p>
<LI>Interrupt handlers for specialized, time critical devices don't get control
when they need to.
<p>
</UL>
<p><hr>

<H1> 
<A NAME="src/irqtune_what_0">
What is actually happening to cause these problems?</A>
</H1>
<EM>Note to Linux kernel programmers:  Please forgive the simplifications.</EM>
<p><STRONG>Q: What should the system be doing?</STRONG>
<p>Serial devices are what are termed <EM>fast-interrupt</EM> devices:
They require frequent interrupts but the interrupt service executes quickly.
Such devices require high IRQ priority.
<p>On the the other end of the scale is the timer interrupt.
The kernel has some laborous tasks that it must perform internally for an
interrupt service routine.
These are too time consuming to perform with interrupts locked off.
Linux defers them and processes them, in the <EM>bottom-half</EM> or
<EM>soft-interrupt</EM> section of the timer interrupt.
<p>When the kernel is in the <EM>bottom-half</EM> routine, interrupts are enabled.  This
allows other interrupt routines to preempt the <EM>bottom-half</EM> routine, allow
<EM>fast-interrupt</EM> routines to run, and resume the <EM>bottom-half</EM> routine.
<p><STRONG>Q: Sounds fine, so what is wrong?</STRONG>
<p>Unfortunately, this is what should happen--it doesn't.
What actually happens is this:
<p>When the PC boots Linux, the timer is
given, by default, the highest IRQ priority in the system (it's IRQ 0 and thus,
priority 0).  On a standard configuration, the serial ports are priority
11 and 12!!!
<p>Because of the way the interrupt controller is currently programmed
under Linux, when it is executing the <EM>bottom-half</EM>,
<STRONG>preemptive interrupt processing does not occur</STRONG>.
The system will continue to execute the
<EM>bottom-half</EM> routine until completion.  The serial interrupt will not be
allowed to preempt the <EM>bottom-half</EM> when it needs to, causing some characters
to be delayed, or worse yet, dropped.
<p><STRONG>Q: But, why is this so--The bottom-half</STRONG>
<STRONG>interrupt code does enable interrupts!?!?</STRONG>
<p>It enables interrupts in the CPU itself (via <EM>sti</EM>),
<STRONG>not</STRONG> the interrupt controller.
The CPU <STRONG>would</STRONG> allow the preemptive interrupt, but the interrupt
controller will <STRONG>not</STRONG> permit the interrupt to be shown to the CPU.
<p><STRONG>Q: Why won't the interrupt controller allow the CPU to see the interrupt?</STRONG>
<p>Because the <EM>bottom-half</EM> routine is executing at IRQ priority 0--the highest
priority in the system.  The serial interrupt is given priority 11, one
of the lowest.  The interrupt controller will not allow a lower priority
device to preempt a higher priority device.
<p><STRONG>Q: So if we could make the serial interrupt a higher priority than the</STRONG>
<STRONG>timer interrupt, would this solve the problem?</STRONG>
<p>Exactly!  This is what <EM>irqtune</EM> does.  It allows you to change the IRQ
priority of devices so that the high priority interrupts occur when they
are supposed to.
<p><p><hr>

<H1> How do I install <EM>irqtune</EM>?</H1>

<UL>
<LI>Unpack the tar file:
<br>
<UL>
<LI><STRONG>gzip -d &lt; irqtune.tgz | tar xvf -</STRONG>
<br>
<LI>It will create a directory, <STRONG>irqtune</STRONG> in
whatever is the current directory.
<br>
</UL>

<LI><STRONG>cd ./irqtune</STRONG>
<br>
<LI><STRONG>make install</STRONG>
<br>
<UL>
<LI>This will install the files:
<br>
<UL>
<LI>/sbin/irqtune
<br>
<LI>/sbin/irqtune_mod.o
<br>
</UL>

</UL>

</UL>
<p><hr>

<H1> How do I use <EM>irqtune</EM>?  Don't I have to rebuild my kernel?</H1>
No, you do <STRONG>not</STRONG> have to rebuild your kernel.  <EM>irqtune</EM> uses <EM>insmod</EM> and
<EM>rmmod</EM> to dynamically load and unload a kernel module.  But you are correct
in sensing that irqtune is a kernel patch.
<p><STRONG>Q: Ok, if it's a kernel patch, why not just issue a kernel patch like</STRONG>
<STRONG>everybody else does (e.g. diff -u output)?</STRONG>
<p><EM>irqtune</EM> will work even if you don't have the kernel source loaded.  It uses
<EM>insmod</EM> to load the patch, invoke it, and then unload it.  The IRQ priority
changes will last so long as the kernel is booted.
<p><STRONG>Q: How do I invoke it?</STRONG>
<p><EM>irqtune</EM> takes two arguments optional arguments:
<p>
<UL>
<LI>irqtune <EM>master</EM> <EM>slave</EM>
<p>
</UL>
The only caveat is that you must specify the full pathname, evenif <EM>irqtune</EM> is placed in a directory that is in <STRONG>$PATH</STRONG>.  This is required
because <EM>irqtune</EM> uses argv[0] to locate its <STRONG>irqtune_mod.o</STRONG> file.
<p>The default is <EM>3 14</EM> which will work for many standard configurations.
More on this later.
<p><STRONG>Q: Could I do this from my /etc/rc.d/rc.local file?</STRONG>
<p>Yes. Just add a <STRONG>/sbin/irqtune</STRONG> line to this file and you're
in business.
You may also issue another <EM>irqtune</EM> command at any time.
<p><STRONG>Q: But aren't kernel patches dependent on the particular revision of the</STRONG>
<STRONG>kernel?  What if my kernel revision is different from the kernel revision</STRONG>
<STRONG>that you built it on?</STRONG>
<p><EM>irqtune</EM> is 99.44<STRONG>% </STRONG>kernel revision independent.  It is built
using ELF binaries, so your <EM>insmod</EM> must understand them.  But that's
really about it.
<p><STRONG>Q: But what if I don't have ELF binary support, how can I still do things?</STRONG>
<p>Well, I'd recommend that you upgrade your kernel as ELF binaries are cool :-)
But if you insist, you'll just have to recompile <EM>irqtune</EM>.  Just be sure
that <STRONG>/usr/src/linux/include</STRONG> is installed.  Then, just type:
<p>
<UL>
<LI><STRONG>make clean</STRONG>
<br>
<LI><STRONG>make sbin</STRONG>
<br>
<LI><STRONG>make install</STRONG>
<br>
</UL>
and that should do the trick.
<p><p><hr>

<H1> 
<A NAME="src/irqtune_what_1">
What about my non-standard hardware configuration?</A>
</H1>
<EM>irqtune</EM> defaults for a standard IRQ configuration.  It assumes that the
highest priority device should be on IRQ 3.  This is normally the first serial
port on standard configurations, which is what you want.
<p><STRONG>Q: How do I determine what my IRQ configuration is?</STRONG>
<p>Just type <STRONG>cat /proc/interrupts</STRONG> and you'll get something like:
<p> <PRE>     0:  8578913   timer
     1:   109547   keyboard
     2:        0 + cascade
     3:    86470 + serial
     4:   197648 + serial
    13:        1   math error
    14:    93123 + Ux4F
</PRE>Note that
<STRONG>/proc/interrupts</STRONG>
only reports on active devices.  So to scope out
the serial IRQ's ideally you'd have X Windows up with your serial mouse and
be connected via PPP to the net.
<p><STRONG>Q: OK, I've got the output from /proc/interrupts, what do I do with it?</STRONG>
<p>The leftmost number is the IRQ number.  The rightmost column is the <STRONG>internal</STRONG>
device name (not to be confused with /dev names).  In the above case, the two
serial ports are on IRQ 3 and IRQ 4.  Just use the lower number, in this
case 3:
<p>
<UL>
<LI><STRONG>/sbin/irqtune</STRONG> <EM>3</EM>
<p>
</UL>
This sets IRQ 3 to the highest priority.
In fact, before we invoked <EM>irqtune</EM>, the IRQ number was also its priority:
<p> <PRE>    IRQ  PRIOR
     0     0
     1     1
     2     2
     3     3
     4     4
     5     5
     6     6
     7     7
</PRE>After this command, the IRQ priorities are now:
<p> <PRE>    IRQ  PRIOR
     0     5
     1     6
     2     7
     3     0
     4     1
     5     2
     6     3
     7     4
</PRE><STRONG>Q: BTW, What's the cascade device I saw in the output of /proc/interrupts?</STRONG>
<p>Glad you asked.  There are actually two interrupt controllers, a <EM>master</EM>
and a <EM>slave</EM>.  The <EM>slave</EM> is <EM>cascaded</EM> to the <EM>master</EM> via its IRQ 2.
The <EM>master</EM> controls IRQ's 0-7 and the <EM>slave</EM> controls IRQ's 8-15.
<p>You actually may select two high IRQ priorities, one for the <EM>master</EM> and one
for the <EM>slave</EM>.  <EM>irqtune</EM> defaults the <EM>slave</EM> to IRQ 14, which is
normally the disk controller.
<p>Although the normal notation is to refer to IRQ's as 0-15, it may be easier to
understand if we refer to the <EM>master</EM> IRQ's as M0-M7 and the <EM>slave</EM> IRQ's
as S0-S7.
<p><STRONG>Q: But I've also got an Ethernet controller on IRQ 12.  What about that?</STRONG>
<p>In other words, your configuration might look something like this:
<p> <PRE>     0:  8578913   timer
     1:   109547   keyboard
     2:        0 + cascade
     3:    86470 + serial
     4:   197648 + serial
    12:    17968 + eth
    13:        1   math error
    14:    93123 + Ux4F<P>
</PRE>In this case, you might want to use:
<p>
<UL>
<LI><STRONG>/sbin/irqtune</STRONG> <EM>3 12</EM>
<p>
</UL>
because you want your ethernet card to have a higher priority than the diskcontroller.  Actually if you did have this configuration, setting 3 14
(the default) would make the ethernet card, the lowest priority device in the
system.
<p>In our new notation IRQ 12 is S4, and the resulting priority would be:
<p> <PRE>    IRQ M/S  PRIOR
    0   M0     5
    1   M1     6
    2   M2     7
    3   M3     0
    4   M4     1
    5   M5     2
    6   M6     3
    7   M7     4
    8   S0     12
    9   S1     13
    10  S2     14
    11  S3     15
    12  S4     8
    13  S5     9
    14  S6     10
    15  S7     11
</PRE><STRONG>Q: Suppose I also had a serial multiplexer card on IRQ 11?</STRONG>
<p>Once again, your configuration might look something like this:
<p> <PRE>     0:  8578913   timer
     1:   109547   keyboard
     2:        0 + cascade
     3:    86470 + serial
     4:   197648 + serial
    11:   197648 + sermux
    12:    17968 + eth
    13:        1   math error
    14:    93123 + Ux4F<P>
</PRE>This configuration is a bit tricky because now we've got a serial device on
the <EM>slave</EM> controller.  It would be much better to put all serial cards on
the <EM>master</EM> controller.  Things would stay much simpler.
<p>In this case you would want to use:
<p>
<UL>
<LI><STRONG>/sbin/irqtune</STRONG> <EM>2 11</EM>
<p>
</UL>
The resulting priorities would be more complex and would result in somethinglike:
<p> <PRE>    IRQ M/S  PRIOR
    0   M0     13
    1   M1     14
    2   M2     0
    3   M3     8
    4   M4     9
    5   M5     10
    6   M6     11
    7   M7     12
    8   S0     5
    9   S1     6
    10  S2     7
    11  S3     0
    12  S4     1
    13  S5     2
    14  S6     3
    15  S7     4
</PRE>The reason things would be better if all serial devices were on the <EM>master</EM>
is that now you have serial devices at priorities 0, 8, and 9.
<p><STRONG>Q: So what's wrong with that?</STRONG>
<p>Well, we boosted the priority of the serial multiplexer at the expense of the
regular serial ports.  The only way to allow all serial ports equally high
priority is to group them on consecutive IRQ's and set the high priority for
the lowest of those IRQ's.
<p><p><hr>

<H1> How can I tell if <EM>irqtune</EM> actually did anything for me?</H1>
Well, first off, if PPP/SLIP was dying mysteriously, it will probably be more
reliable.
<p>Secondly, run without it and get a feel for the transfer rate:
<p>
<UL>
<LI>Hit many of your favorite web sites and note the transfer rates in
bytes/second.
<br>
<LI>FTP reports the transfer time of a file in bytes/second.  Download (or upload)
a few files (300K or greater to smooth out the benchmark) and note the
transfer rates.
<br>
</UL>
Repeat this using <EM>irqtune</EM> and note the transfer times again.
<EM>NOTE: IRQTUNE just won't quit--if you want to test in the original mode</EM>
<EM>again, reboot the system first.</EM>
<p><p><hr>

<H1> 
<A NAME="src/irqtune_what_2">
What about other remedies I've heard about?</A>
</H1>
<STRONG>Q: What about disabling Van Jacobsen header compression?</STRONG>
<p>This reduces the amount of <EM>bottom-half</EM> processing the system has to do at
the expense of larger packets being sent.
<p><STRONG>Q: What about using ``hdparm -u'' to set the interrupt-unmask flag in hard</STRONG>
<STRONG>disk driver?</STRONG>
<p>It suffers from the same problem as the <EM>bottom-half</EM> routine.
The disk controller typically uses
IRQ 14 and 15.  While the <EM>slave</EM> interrupt controller would
probably allow preemption,
the <EM>master</EM> (on IRQ 2) would not because the priority of all <EM>slave</EM>
devices is higher than the serial IRQ priority.
<p><STRONG>Q: What about adjusting the MRU/MTU numbers?</STRONG>
<p>This will have less of an effect now.  In fact, you normally reduced the MRU
to a minimum (296) to reduce the <EM>bottom-half</EM> processing at the expense of
adding extra overhead bytes due to the reduced packet size.  You may now
actually be able to increase the MRU to regain the efficiency.
<p><EM>Beware: Do this slowly as the optimal may not be 1500.  The flip buffer</EM>
<EM>in the serial/tty drivers is only 512 bytes.</EM>
<p><STRONG>Q: What about going to newer kernel revisions?</STRONG>
<p>Although <EM>irqtune</EM> will work surprisingly well with just about any kernel
revision, the low level IRQ handlers and device drivers have been vastly
improved in the 2.0.X
kernels.  This will only improve <EM>irqtune</EM>'s effect.  In fact, 2.0.X and
<EM>irqtune</EM> actually complement one another.
<p>
</BODY>
</HTML>
