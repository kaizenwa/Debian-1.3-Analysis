
							  dpkg-cross
							  ==========

dpkg-cross is a collection of utilities (or do you want to call them
hacks? :-) to make cross compiling Debian packages easier. It consists
of the following parts:

 - dpkg-cross, to install libraries and header files for cross
   compiling directly from .deb files

 - A wrapper for dpkg-buildpackage, that sets some environment
   variables to select compiler, linker, ... to use for building.

 - A wrapper for dpkg-shlibdeps, to make it work on non-native
   binaries.

 - A config file, /etc/dpkg/cross-compile, for defining paths and
   package-specific environment variables.


1) Prerequisites
----------------

For doing cross compiling, you obviously need a cross compiler :-)
That one isn't supplied by dpkg-cross, you have to build it yourself.
There are also no cross compilers as Debian packages, since there are
numerous combinations of host and target architectures, and to handle
all these in the gcc and binutils packages would be tedious.

But I sounds more difficult as it is... I'll give you a brief outline
in the following. To make the examples easier, I pick the m68k
architecture as our target, but surely you can substitute any other
target architecture!

 - First (before gcc!) build cross-binutils. Get the current GNU
   binutils sources, and configure them. Most binutils can be built
   with support for many object file formats at once, which is at
   least needed for strip. This is because 'install' simply calls
   'strip', and if you're installing non-native binaries, 'install'
   would print a warning (and not strip...) if your /usr/bin/strip can
   handle only native binaries.

   But also for most other binutils, it is convenient to have them
   multi-architectural. Just type size, objdump, or whatever you like,
   without caring about the architecture... But in two cases, this
   luxury isn't possible: 'as' and 'ar' have to built singly for the
   target architecture.

   Ok, to summarize: First configure for multiple architectures:

     ./configure ... --enable-targets="i386-linux m68k-linux"

   and compile, and install the tools you want to have
   multi-architectural (best manually). You might want to consider
   dpkg-divert, to avoid the next binutils upgrade overwrite them...

   Next, configure only for the target arch:

     ./configure ... --target=m68k-linux

   and compile at least as and ar. Install them in your cross
   compiling bin directory, which is usually /usr/local/TARGET/bin.
   Here, TARGET would be "m68k-linux". IMHO the cross compiling stuff
   belongs into /usr/local, because it isn't part of the standard
   Debian distribution, but your mileage may vary... Choose what you
   like, but don't forget to tell dpkg-cross about your choice in
   /etc/dpkg/cross-compile.

 - Ok, this done, you can go for gcc. This is rather easy:

     ./configure ... --target=m68k-linux

   and build it. 'make install' should be ok, the Makefile doesn't do
   anything unwise, AFAIK.

 - If you don't want to type whole paths all the time you call a tool
   you haven't build multi-architectural, make symlinks like

     m68k-linux-size -> ../m68k-linux/bin/size

   in the bin directory of the hierarchy where all is installed. Then
   you can call the stuff with the target prefix.

 - That's it already :-) If I was too brief, there's also a HOWTO for
   cross compiling at ftp.uni-erlangen.de:/pub/Linux/680x0/docs.


2) dpkg-cross
-------------

dpkg-cross doesn't do any cross compiling itself, it addresses another
problem (you'd encounter if you wouldn't have dpkg-cross :-). For
cross compiling, you need also libraries and their accompanying
headers for the target architecture. If you're cross compiling Debian
packages, all you need is available as Debian packages, but you can't
simply install those packages on your compile host. dpkg refuses to do
so, because of architecture mismatch. Ok, you could install everything
on a host with the "correct" architecture and copy it back, but that's
a lot of work. Or you could use dpkg-deb --fsys-tarfile to get your
hands on the files, but that also involves a lot of moving files
around... dpkg-cross does that dirty jobs for you.

A word to directory layout: The cross compiling library directory is
simply only one. This means, you don't have separate dirs like /lib,
/usr/lib, /usr/X11R6/lib, ... where to look for libraries. dpkg-cross
calls this dir $(CROSSLIB), and it could be e.g.
/usr/local/m68k-linux/lib. There's also only one include directory.

Eeeh, wait, you say: Why do I need different headers for cross
compiling at all? Aren't they the same as the headers for the native
system, which I have installed already? Basically, you're right. But
my experience tells me, that there *are* differences, where you don't
expect them... I'd say, you're just more on the safe side if you have
the real headers for your target architecture in use. Having a
separate set of headers also allows you to install/remove native and
cross compiling library packages completely independent.

Ok, now really coming to dpkg-cross: It is a very lightweight clone of
the real dpkg, and uses the same options (as far as implemented :-):

 -i, --install: install packages
 -r, --remove: remove packages
 -s, --status: print status of packages
 -L, --list: list files belonging to a package

All except installing should be straightforward.

To install, dpkg-cross unpacks that .deb file into a temporary
location and looks for files in /lib, /usr/lib, /usr/X11R6/lib,
/usr/include, and /usr/X11R6/include. For the library directories,
only files directly in these directories are considered,
subdirectories are ignored. Libraries and other linker auxiliary files
(e.g. crt1.o) reside directly in the dir, not below. But for the
include directories, subdirectories are of course not ignored.
dpkg-cross moves all those files into $(CROSSLIB) or $(CROSSINC),
resp., depending on the kind of their source directory.

One complication are just some symlinks contain in some packages. E.g.
libc5-dev contains a symlink /usr/lib/libc.so -> /lib/libc.so.5.x.y.
This works for the native system, but not for cross compiling.
dpkg-cross tries to handles such situations, but there are chances
that more symlink problems can arise in future I haven't thought of...
You've been warned :-)

Another thing dpkg-cross does is to collect the shlibs files provided
usually by -dev packages, in $(CROSSINFO). These are needed later for
dpkg-shlibdeps.

BTW, you usually have to install both, the runtime lib package and the
accompanying -dev developer's package. A runtime-only kit isn't very
useful for a cross-compiling environment :-)


3) dpkg-buildpackage
--------------------

dpkg-buildpackage is the main tool for cross compiling, though it's
operation is rather simple: If called with the -a option, it sets a
few environment variables that will override definitions in Makefiles,
and then starts the real dpkg-buildpackage. Basic for that function is
that Makefile variables *are* override-able from the environment, but
that's a 'make' feature. And that most times, the same variable names
are used for building tools, like $(CC), $(LD), ... dpkg-cross
implements this setting of environment variables by putting a wrapper
around dpkg-buildpackage, which is renamed to dpkg-buildpackage.orig.

By default, dpkg-buildpackage sets the following environment variables
if called with the -a option:

  ARCH      = $(ARCH)
  CC        = $(CROSSPREFIX)gcc
  GCC       = $(CROSSPREFIX)gcc
  LD        = $(CROSSPREFIX)gcc
  AS        = $(CROSSPREFIX)as
  AR        = $(CROSSPREFIX)ar
  RANLIB    = $(CROSSPREFIX)ranlib
  STRIP     = $(CROSSPREFIX)strip
  MAKEFLAGS = -e

The latter is necessary so that environment variables really override
Makefile variables (see make(1)). $(ARCH) is determined from the
argument of the -a command line option. $(CROSSPREFIX) is taken from
/etc/dpkg/cross-compile. Finally, /usr/local/bin is appended to $PATH,
just in case some cross compiling tools should reside there. debmake's
build resets $PATH to /bin:/sbin:/usr/bin:/usr/sbin:/usr/bin/X11, so
this may be necessary.

These settings should usually be sufficient for most packages. If you
encounter that the Makefiles of the package need some other variables
to be set, create a package-dependent section in
/etc/dpkg/cross-compile. And if a Makefile calls an
architecture-dependent tool (e.g. ar, ranlib) directly, i.e. without
referring to a variable, feel free to change that! IMHO it's a bug to
hardwire those names...

Ok, that's dpkg-buildpackage's main task, but it does a bit more for
you: It also tries to merge resulting .changes files, so that you
don't have to perform more than one upload job with dupload, which
would also post more than one mail... The details of this merging are
the following: If there's another .changes file in the parent
directory (besides the one generated by this build run),
dpkg-buildpackage will merge the following properties:

 - All architecture names in the .changes' *file* name; more names are
   concatenated with '+', e.g. you may get a xxx_1.2-3_i386+m68k.changes

 - All architectures in the Architecture: field

 - All lines in the Files: field; here, the newer .changes has
   priority, if the same file should be mentioned in both .changes
   files. This comes in handy if you, e.g., forgot to specify -b to
   dpkg-buildpackage (or debmake's build) one time and thus built the
   source package twice...

I hope dpkg-buildpackage does the thing you expect it to do in this
respect...

Another feature: The current 1.4.0.7 (real) dpkg-buildpackage has a
bug so that it always signs the .dsc file, even in a binary-only run
(-b or -B). Either you get an error if no .dsc for the package exists
in the parent directory, or it gets signed twice. The
dpkg-buildpackage wrapper works around this by backing up an existing
.dsc file and restoring it after the real dpkg-buildpackage finished.
It also provides a dummy .dsc if there's none, to avoid "file not
found" errors.


4) dpkg-shlibdeps
-----------------

Another problem with cross compiling is (was :-) that dpkg-shlibdeps
worked only on native binaries (i.e., ones compiled for the machine it
is running on). This is caused by the fact that dpkg-shlibdeps calls
ldd, which in turn relys on a ld.so feature: If you run a program with
really no arguments, not even argv[0], it prints the shared libs to
would link. This obviously cannot work for binaries of another
architecture, since you can't run those.

To solve this problem, the dpkg-cross package puts a wrapper also
around dpkg-shlibdeps, that checks for a cross compile run (by testing
$ARCH and $MAKEFLAGS environment variables). If that is the case, it
implements another algorithm for finding shared library dependencies
that also works for non-native executables.

From the user's standpoint of view, the wrapper with the new algorithm
should behave exactly like the original. Of course, the original is
still used for native executables. There are only some prerequisites
it needs to work properly: You must have installed cross compiling
libraries with dpkg-cross, and you must have a objdump for the target
architecture somewhere. dpkg-shlibdeps tries $(CROSSPREFIX)objdump
(in $PATH), $(CROSSBIN)/objdump and objdump (in $PATH). The last
catches cases where you have a multi-architecture objdump installed.

If you're interested in the technical details: The .dynstr section
of an ELF object/executable contains are all strings used for dynamic
linking, i.e. names of the symbols to link, and the names of the
libraries where they should be found. dpkg-shlibdeps now reads this
section via objdump and scans it for strings looking like libxxx.so.y.
Since a '.' isn't allowed in C identifiers, this should be fairly
reliable to find the shared library names and nothing else. After
that, it determines the packages providing those libraries by
searching the .list files in $(CROSSINFO). This means, you should have
installed cross compiling libraries by dpkg-cross. After having found
the package, the rest of processing is much like the original
dpkg-shlibdeps, except that it looks for .shlibs files in $(CROSSINFO)
instead of /var/lib/dpkg/info.



5) /etc/dpkg/cross-compile
--------------------------

dpkg-cross, dpkg-buildpackage, and dpkg-shlibdeps use a common
configuration file, /etc/dpkg/cross-compile, for path settings and
package-specific definitions.

In that file, comments start (as usual) with '#' and extend to the end
of the line. Note that comments are *NOT* allowed after stuff doing
something else, i.e. after variable definitions or the like. Write
comments on their own lines.

The first section of the file contains path settings for all
dpkg-cross utilities. They have the form

    varname = value

(as you'd expect :-). The value on the right side can contain
references to other variables in the form

    $(VARIABLE)

Note that in references, variable names must be all uppercase, while
in definitions they're all lowercase. You can refer to all global
dpkg-cross variables, i.e. the ones defined in this section, and
additionally to $(ARCH) (which is set from the command line on
dpkg-cross and dpkg-buildpackage), and to every other environment
variable. Though environment variables have lower precedence than
internal variables.

The following variables can be defined in this first section:

 - crossbase (default: /usr/local)

   This is the path prefix for all other cross compiling paths below.
   It is used in their default definition, but a user definition need
   not necessarily use it. It's just there for anchoring other paths
   into a common filesystem hierarchy.

   Also already stated, IMHO cross compiling binaries and support
   files belong into /usr/local, since they're not part of the
   standard Debian distribution, but you've installed them locally.
   That's why /usr/local is the default. If your opinion differs, just
   define a different crossbase.

 - crossdir (default: $(CROSSBASE)/$(ARCH)-linux)

   This is the base directory for a specific architecture.
   $(ARCH)-linux is the standard target name, as used by gcc. (I
   assume you're cross compiling for Linux :-)

 - crossbin (default: $(CROSSDIR)/bin)

   This directory contains the binaries for cross compiling (gcc, as,
   ld, ...). It's mainly intended for referring to in other definitions
   (most probably some tool in a package-specific definition), but
   dpkg-shlibdeps also uses it as one alternative to locate a objdump
   that can parse objects of the architecture in question.

 - crosslib (default: $(CROSSDIR)/lib)

   This directory contains libraries and other linker support files
   (crt1.o ...) for cross compiling. The setting is used by
   dpkg-cross as place where to install files from usual /usr/lib,
   /lib, and /usr/X11R6/lib. It should also be one of the default
   library paths compiled into a cross gcc. (gcc's configure should
   have done that for you, it chooses $(prefix)/$(target)/lib).

 - crossinc (default: $(CROSSDIR)/include)

   This directory contains headers for cross compiling. The setting is
   used by dpkg-cross as place where to install files from usual
   /usr/include and /usr/X11R6/include. It also should be one of the
   default directories compiled into a cross gcc/cpp. (gcc's configure
   should have done that for you, it chooses
   $(prefix)/$(target)/include).

 - crossinfo (default: $(CROSSLIB)/dpkg-cross-info)

   In this directory dpkg-cross installs its auxiliary .list and
   .shlibs files. It's similar to /var/lib/dpkg/info for the native
   system.

 - crossprefix (default: $(ARCH)-linux-)

   This is the prefix for cross compiling binaries, like gcc. The
   default naming is GNU convention, e.g. you could have
   m68k-linux-gcc in your $PATH. They're are usually symlinks to the
   corresponding tools in $(CROSSBIN), and having them is simply a
   matter of convenience: You then have the cross compiling tools with
   a distinctive name in your $PATH and can call them without writing
   an explicit path. $(CROSSPREFIX) is mainly intended for referring to
   in other definitions, but dpkg-shlibdeps also uses it as one
   alternative to locate a objdump that can parse objects of the
   architecture in question (it tries ``$(CROSSPREFIX)objdump'').

Other sections after the first global one are started with a line with
the following format:

    package:

where package is the (source) package name of some package you intend
to cross-compile. The definitions in such a package-specific section
look exactly the same as global definitions, but they define
additional environment variables to be set by dpkg-buildpackage if
compiling the package in question. This can be used if the package's
Makefiles use some strange variable for some purpose, or you have to
override something else for cross compiling.

For example, I know the amd Makefiles to insist on using $(SYSCC) for
compiling some of the sources. If you don't take special precautions
about this, $(SYSCC) has been defined to be 'gcc' by the Makefile,
thus the objects will be native objects and can't be linked in the
end. So you have to override $(SYSCC) to be m68k-linux-gcc, too, and
you can do this by adding

    amd:
        SYSCC = $(CROSSPREFIX)gcc

to /etc/dpkg/cross-compile.

Another use could be if your Makefiles include e.g. -m486 into
$(CFLAGS), which obviously works only on the i386 architecture. In
this case, you can also define an environment override for CFLAGS,
without the -m486 this time.



Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
Sun, 9 Feb 1997 00:53:47 +0100
