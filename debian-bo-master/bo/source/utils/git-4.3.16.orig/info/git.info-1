This is Info file git.info, produced by Makeinfo-1.64 from the input
file ./git.texinfo.

START-INFO-DIR-ENTRY
* GIT: (git).         GNU Interactive Tools
END-INFO-DIR-ENTRY

   GIT: A set of interactive tools, by Tudor Hulubei and Andrei Pitis.

   This file documents the GNU Interactive Tools package.

   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: git.info,  Node: Top,  Next: Introduction,  Up: (dir)

   `GIT' is a package containing basically a file system browser, a
process viewer/killer and a ASCII/HEX file viewer.  This is edition
2.5, for GNU Interactive Tools version 4.3.16.

* Menu:

* Introduction::                An introduction to GIT concepts.
* Distrib::                     How to get the latest GIT distribution.

* Description::                 How to use GIT.
* Customization::               How to customize GIT.
* Limitations::                 Known GIT limitations.
* Bugs::                        How to report a bug.
* Key Index::                   An item for each standard GIT key sequence.
* Command Index::               An item for each command name.
* Variable Index::              An item for each documented variable.
* Concept Index::               An item for each concept.


File: git.info,  Node: Introduction,  Next: Distrib,  Prev: Top,  Up: Top

Introduction
************

   `GIT' is a set of interactive tools.  It contains an extensible file
system browser, an ascii/hex file viewer, a process viewer/killer and
some other related utilities and shell scripts.  It can be used to
increase the speed and efficiency of most of the daily tasks such as
copying and moving files and directories, invoking editors, compressing
and uncompressing files, creating and expanding archives, compiling
programs, sending mail, etc.  It looks nice, has colors (if the standard
ANSI color sequences are supported) and is user-friendly.

   `GIT' runs on a wide variety of `UNIX' systems because it uses the
`GNU Autoconf' package to get system specific information.  Please
refer to the PLATFORMS file included in the standard distribution for a
detailed list of systems on which `GIT' has been tested.

   One of the main advantages of `GIT' is its flexibility. It is not
limited to a given set of commands.  The configuration file can be
easily enhanced, allowing the user to add new commands or file
operations, depending on its needs or preferences.

   `GIT' also provides a shell like command prompt, just to make sure
that the entire power of the `UNIX' shell commands is still there.


File: git.info,  Node: Distrib,  Next: Key Index,  Prev: Introduction,  Up: Top

Distributing GNU Interactive Tools
**********************************

   `GIT' is "free software"; this means that everyone is free to use it
and free to redistribute it on certain conditions.  `GIT' is not in the
public domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of `GIT'
that they might get from you.  The precise conditions are found in the
GNU General Public License that comes with `GIT' and also appears
following this section.

   The easiest way to get a copy of `GIT' is from someone else who has
it.  You need not ask for our permission to do so, or tell any one else;
just copy it.  If you have access to the Internet, you can get the
latest distribution version of `GIT' from host `prep.ai.mit.edu' using
anonymous login.  See the file `/pub/gnu/GETTING.GNU.SOFTWARE' on that
host to find out about your options for copying and which files to use.

   You may also receive `GNU Interactive Tools' when you buy a
computer.  Computer manufacturers are free to distribute copies on the
same terms that apply to everyone else.  These terms require them to
give you the full sources, including whatever changes they may have
made, and to permit you to redistribute the GNU Interactive Tools
received from them under the usual terms of the General Public License.
In other words, the program must be free for you when you get it, not
just free for the manufacturer.


File: git.info,  Node: Description,  Next: Customization,  Prev: Concept Index,  Up: Top

Using GNU Interactive Tools
***************************

   The `GIT' package contains three interactive programs and a few
additional utilities.  Here there is a description of each of them.

* Menu:

* git::                         A file system browser.
* gitps::                       A process viewer/killer.
* gitview::                     An ASCII/HEX file viewer.
* gitkeys::                     An utility for displaying key sequences.
* gitwipe::                     An utility for wiping files.
* gitmount::                    A script for mounting file systems.
* gitaction::                   A per file type action script.
* gitrgrep::                    A recursive grep script.


File: git.info,  Node: git,  Next: gitps,  Up: Description

The GIT file system browser
===========================

   `git' is a file system browser with some shell like features
designed to make your work much easier and much efficient.  It displays
one or two panels, each one containing a file system directory.  You can
browse the directory tree with the usual cursor keys, pressing `ENTER'
when you want to enter or leave a directory and `TAB' when you want to
change the panels.

   Under the two panels there is a shell like input line which you can
use to type normal shell commands.  The input line can handle an
unlimited number of characters and keeps a history of typed commands
(using the GNU history library).

   Under the input line there is a status bar.  You can see there the
status of the currently executed command, the warnings and errors and
you will be prompted if a decision has to be taken.

* Menu:

* Conventions::                 Key binding conventions.

* Modes::                       How panels can look like.
* Sorting::                     How files can be sorted in a panel.
* Moving::                      How to move the cursor in the panel.
* Selecting::                   How to select (mark) files in a panel.
* Isearch::                     How to search a file name in a panel.
* Input Line::                  How to use the input line.  Basic editing.
* Files::                       How to copy/move/delete/compress/... files.
* Directories::                 How to operate with directories.
* Compiling::                   How to compile programs.
* Mail::                        How to send/receive ascii/binary mail.
* Shell::                       How to start a sub-shell.
* Grep::                        How to use grep/recursive grep.
* Locking::                     How to lock your console.
* Refreshing::                  How to refresh the screen contents.
* Reseting::                    How to reset your terminal.
* Mounting::                    How to mount/unmount a file system.
* Sysinfo::                     How to get some useful system information.
* Environment::                 How to look at the environment variables.
* Processes::                   How to view/kill processes.
* Sync::                        How to synchronize your file systems.

* Documentation::               How to read documentation.

* Exit::                        How to exit GNU Interactive Tools.


File: git.info,  Node: Conventions,  Next: Modes,  Up: git

Key binding conventions
-----------------------

   `git' now provides a new, easy to remember, scheme to bind commands
on keys.  This is only a convention, if you define new key bindings you
may, or may not follow it.

   All the file commands start with `^C'.  This prefix can be followed
by some modifiers, in order to affect the default behavior of the given
command.  These modifiers are `b' and `r'.

   `b' - this modifier specifies that the command will run in
background:

             ^CM = CHMOD; chmod %s{New mode of %i: ,%m} %i;;;;y

defines a command that changes the current selected files mode in
foreground, while

             ^CbM = B-CHMOD; chmod %s{New mode of %i: ,%m} %i&;;;;y

defines a background command that does the same thing.

   `r' - this modifier specifies that the command will be run
recursively:

             ^CrM = R-CHMOD; chmod -R %s{New mode of %i: ,} %i;;;;y

defines a command that recursively changes the mode of the selected
entries.

   The `b' and `r' modifiers can be combined, the resulting command
running recursively and in background:

             ^CbrM = B-R-CHMOD; chmod -R %s{New mode of %i: ,} %i&;;;;y

   You should also note that for some commands (like `gzip') there is
no need for a non-recursive version.  Running `gzip' recursively on
files is harmless.  If there is a directory between these files, `gzip'
will recursively compress that directory, so you can use the same key
binding for recursively and non-recursively compressing.  In fact, it
is a matter of selecting files or directories.

   Unfortunately, we can't run `chmod' recursively trying to change the
mode of all the files in a directory to 0644 because that directory
might contain subdirectories and removing the execution permission from
them is a bad idea.  So, in this case, we need separate commands.


File: git.info,  Node: Modes,  Next: Sorting,  Prev: Conventions,  Up: git

Panel modes
-----------

   `git' has three major modes of displaying the panels.  In the first
(default) mode, two panels are displayed, each one using half of the
screen.  In the second mode, only one panel uses the entire screen.  In
the third mode, only the status bar and the input line are displayed,
both panels being hidden.

   Briefly, a panel can use the entire screen or just half of it.  Even
when a panel is hidden, it still exists.

   Users can switch between these three major modes as needed:

`^X 0'
     Enlarges the other panel to use the entire screen.  It also changes the
     minor mode to `Enable all'. The current panel will become
     invisible (`enlarge-other-panel').

`^X 1'
     Enlarges the current panel to use the entire screen.  It also changes
     the minor mode to `Enable all'. The other panel will become
     invisible (`enlarge-panel').

`^X 2'
     Switches back to the two panel mode (`two-panel-mode').

`^O', `ESC o'
     Switches to the tty mode (no panels on the screen) (`tty-mode').

   Basically a panel displays the files and directories in a directory.
You can optionally specify some additional information about each entry
(file, directory, ...) to be displayed (a minor mode).

   When using the full screen mode, all the minor modes here can be
used.  In half screen mode, the `panel-enable-all' mode is not
available.

   These are the panel minor modes:

`ESC d o'
     Display the entry owner and group (`panel-enable-owner-group').

`ESC d d'
     Display the entry date and time (`panel-enable-date-time').

`ESC d s'
     Display the entry size (`panel-enable-size').

`ESC d m'
     Display the entry mode (`panel-enable-mode').

`ESC d f'
     Display the entry full name (`panel-enable-full-name').

`ESC d a'
     Display the entire information about file (`panel-enable-all').
     This mode is only available if the panel has been enlarged to use the
     entire screen with `enlarge-panel' or `enlarge-other-panel'
     (`panel-enable-all').

   There is also another way to change the panel minor modes:

`^]', `^[]'
     Switches to the next panel minor mode (`panel-enable-next-mode').


File: git.info,  Node: Sorting,  Next: Moving,  Prev: Modes,  Up: git

Sorting methods
---------------

   Entries in a panel can be sorted in different ways.  These are the
available options:

`ESC s n'
     Display the panel entries sorted by their names
     (`panel-sort-by-name').

`ESC s e'
     Display the panel entries sorted by their extensions
     (`panel-sort-by-extension').

`ESC s s'
     Display the panel entries sorted by their sizes
     (`panel-sort-by-size').

`ESC s d'
     Display the panel entries sorted by their `last modified' stamps
     (`panel-sort-by-date').

`ESC s m'
     Display the panel entries sorted by their modes
     (`panel-sort-by-mode').

`ESC s o i'
     Display the panel entries sorted by their owner ids
     (`panel-sort-by-owner-id').

`ESC s g i'
     Display the panel entries sorted by their group ids
     (`panel-sort-by-group-id').

`ESC s o n'
     Display the panel entries sorted by their owner names
     (`panel-sort-by-owner-name').

`ESC s g n'
     Display the panel entries sorted by their group names
     (`panel-sort-by-group-name').

   There is also another way to change the sort method:

`ESC s u'
     Switch to the next panel sort method (`panel-sort-next-method').


File: git.info,  Node: Moving,  Next: Selecting,  Prev: Sorting,  Up: git

Moving the cursor in the panel
------------------------------

   Moving the cursor in the panel is very easy.  If your keyboard has
arrows, use them.  If the arrow keys don't work (it might be due to a
badly configured TERM environment variable), you can use the Emacs
commands bindings as well.

`UP', `^P'
     Move the cursor vertically up one entry (`previous-line').

`DOWN', `^N'
     Move the cursor vertically down one entry (`next-line').

`HOME', `ESC <'
     Move the cursor on the first entry in the panel
     (`beginning-of-panel').

`END', `ESC >'
     Move the cursor on the last entry in the panel (`end-of-panel').

`PGUP', `ESC v'
     Move the cursor vertically down one page (`scroll-down').

`PGDOWN', `^V'
     Move the cursor vertically down one page (`scroll-up').

`^X P'
     In order to optimize the screen output, you can modify the scroll step
     (`set-scroll-step').  This is the number of lines to try scrolling
     a panel when the cursor moves out.  The `StartupScrollStep'
     specifies the initial scroll step, but using `set-scroll-step' you
     can dynamically change it.

`TAB', `^I', `^X o'
     Move the cursor in the other panel (`other-panel').

`^X P'
     Switch the two panels.  This command works even when `git' is not
     in the `two panels' mode (`switch-panels').


File: git.info,  Node: Selecting,  Next: Isearch,  Prev: Moving,  Up: git

Selecting files
---------------

`INS', `^T', `^X \', `^\'
     Toggle the `selected' flag of the current entry
     (`select-entry').

`^C s'
     Select (marks) all the files matching at least one pattern from a
     space separated list of shell patterns.  Spaces and \s are allowed in
     the patterns but they have to be escaped with a \.
     (`select-files-matching-pattern').

`^C u'
     Unselect (unmarks) all the files matching a pattern
     (`select-files-matching-pattern').  The user will be prompted for a
     pattern to match against.


File: git.info,  Node: Isearch,  Next: Input Line,  Prev: Selecting,  Up: git

Incremental searching files in a panel
--------------------------------------

   Users sometime need to search a file in a panel, especially when the
panel contains a big number of entries.  For that reason `git' provides
an incremental search feature.  Using forward and backward incremental
search, files can be very easy located.  Wrapped incremental search is
also provided.

`^S', `^Xs'
     Incremental search forward a file name in the current panel
     (`isearch-forward').  Pressing `^S' or `^Xs' again will
     force `git' to go to the next entry that matches the current
     isearched string.  When the end of the panel is reached, the isearch is
     restarted from its beginning.

`^R', `^Xr'
     Incremental search backward a file name in the current panel
     (`isearch-backward').  Pressing `^R' or `^Xr' again will
     force `git' to go to the next entry that matches the current
     isearched string.  When the beginning of the panel is reached, the
     isearch is restarted from its end.


File: git.info,  Node: Input Line,  Next: Files,  Prev: Isearch,  Up: git

Using the input line
--------------------

   The input line is one of the main methods used by `git' to interact
with the user.  All the answers the user should give in order to perform
some operation and all the shell like commands are built using it.  So
here is a description of all the basic editing operations that the
`input line' provides.  They are very much inspired from `Emacs', so
`Emacs' users should have no problem using them.

* Menu:

* Inserting Text::              Inserting text by simply typing it.
* Moving Point::                How to move the cursor to the place where you
                                    want to change something.
* Erasing::                     Deleting and killing text.
* Case Changes::                Case conversion of words.
* History::                     Reusing recent input line arguments.
* Setting Mark::                Commands to set the mark.
* Yanking::                     Reinserting recently killed text.


File: git.info,  Node: Inserting Text,  Next: Moving Point,  Up: Input Line

Inserting Text
..............

   Typing characters is the most usual way of inserting text into the
input line.  Key sequences starting with printable ascii characters are
not allowed in `git' so typing `a' for example results in inserting `a'
at the current point position.  Of course, there are some other ways of
inserting text into the command line and here there is a description of
most of them.

`ESC RET'
     Copy the current entry name into the input line at the current point
     position (`entry-to-input-line').

`ESC ESC RET'
     Copy the other panel path into the input line at the current point
     position (`other-path-to-input-line').

`^X ^I'
     Copy the names of all the selected entries into the input line at the
     current point position (`selected-entries-to-input-line').


File: git.info,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Input Line

Moving Point
............

`^B', `LEFT'
     Move the point backward one character (`backward-char').

`^F', `RIGHT'
     Move the point forward one character (`forward-char').

`ESC b'
     Move the point one word backward (`backward-word').

`ESC f'
     Move the point one word forward (`forward-word').

`^A'
     Move the cursor at the beginning of the input line (`beginning-of-line').

`^E'
     Move the cursor at the end of the input line (`end-of-line').


File: git.info,  Node: Erasing,  Next: Case Changes,  Prev: Moving Point,  Up: Input Line

Deleting and killing text
.........................

`DEL', `^D'
     Delete the character under the cursor (`delete-char').

`^H', `BKSPC'
     Delete the character before the cursor (`backward-delete-char').

`ESC BKSPC'
     Delete backward one word (`backward-kill-word').

`ESC d'
     Delete forward one word (`kill-word').

`ESC k'
     Delete the entire line (`kill-line').

`^U'
     Delete all the characters between the beginning of the input line and
     the point (`kill-to-beginning-of-line').

`^K'
     Delete all the characters between the point and the end of the input
     line (`kill-to-end-of-line').

`ESC SPC'
     Delete all the spaces around the point, leaving only one space
     (`just-one-space').

`ESC \'
     Delete all the spaces around the point
     (`delete-horizontal-space').

`^W'
     Save the region between the point and the mark into the kill "ring" and
     then kills it (`kill-region').  Note that there is no real
     kill-ring here.  The so-called kill-ring has only one entry.

`ESC w'
     Save the region between the point and the mark without killing it
     (`kill-ring-save').


File: git.info,  Node: Case Changes,  Next: History,  Prev: Erasing,  Up: Input Line

Case conversion of words.
.........................

`ESC l'
     Convert the following word to lower case, moving over.
     (`downcase-word').

`ESC u'
     Convert the following word to upper case, moving over.
     (`upcase-word').

`ESC c'
     Capitalize the following word, moving over.
     (`capitalize-word').


File: git.info,  Node: History,  Next: Setting Mark,  Prev: Case Changes,  Up: Input Line

Reusing recent input line arguments
...................................

   A separate history is kept for both built-in and user-defined
commands.  If you call a command that you have used before, you can
re-edit a previously entered string in order to minimize the amount of
characters needed to be typed for the new one.  There is no limit on
the number of strings that can be kept in the history.

`ESC p'
     Walk backward through the history of previously entered strings
     (`previous-history-element').

`ESC n'
     Walk forward through the history of previously entered strings
     (`next-history-element').


File: git.info,  Node: Setting Mark,  Next: Yanking,  Prev: History,  Up: Input Line

Commands to set the mark
........................

`^SPC'
     Set the mark at the current point position (`set-mark').

`^X ^X'
     Exchange the current point position with the mark one
     (`exchange-point-and-mark').


File: git.info,  Node: Yanking,  Prev: Setting Mark,  Up: Input Line

Reinserting recently killed text
................................

`^Y'
     Reinsert a previously killed text at the current point position
     (`yank').


File: git.info,  Node: Files,  Next: Directories,  Prev: Input Line,  Up: git

File operations
---------------

* Menu:

* Copying Files::               How to copy files.
* Moving Files::                How to move files.
* Creating Files::              How to create new files.
* Deleting Files::              How to delete files.
* Linking Files::               How to create hard and symbolic links.
* Renaming Files::              How to rename files.
* Packing Files::               How to pack files in the min. number of bins.
* Inode::                       How to change a file's mode, owner, group.

* Editing Files::               How to edit and create files.  Default editor.
* Viewing Files::               How to view files.  Default viewer.
* Compressing Files::           How to compress and decompress files.
* Encoding Files::              How to uuencode/uudecode, mpack/munpack a file.
* Encrypting Files::            How to encrypt/decrypt files with pgp.
* Comparing Files::             How to compare two files.
* Spelling Files::              How to spell a file.
* Wiping Files::                How to wipe a file.
* Searching Files::             How to search a file.
* Archive Files::               How to manage tar based archive files.
* RPM Packages::                How to install and uninstall RPM packages.
* MSDOS Files::                 How to access msdos floppies.

* Actions::                     A different action for each file type.


File: git.info,  Node: Copying Files,  Next: Moving Files,  Up: Files

Copying Files
.............

`F5', `ESC 5', `^C C'
     Copy the currently selected entries to the user supplied path
     (`copy').

`^C b C'
     Copy the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-COPY').


File: git.info,  Node: Moving Files,  Next: Creating Files,  Prev: Copying Files,  Up: Files

Moving Files
............

`F6', `ESC 6', `^C T'
     Move the currently selected entries to the user supplied path
     (`move').

`^C b T'
     Move the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-MOVE').


File: git.info,  Node: Creating Files,  Next: Deleting Files,  Prev: Moving Files,  Up: Files

Creating Files
..............

   The easiest way to create a new file is to start an editor passing
the file name as an argument.  Most editors will try to create the file
if the file doesn't exist.  *Note Editing Files::, for more information.


File: git.info,  Node: Deleting Files,  Next: Linking Files,  Prev: Creating Files,  Up: Files

Deleting Files
..............

`F8', `ESC 8', `^C D'
     Delete the currently selected entries (`delete').

`^C b D'
     Delete the currently selected entries.  The operation is performed in
     background (`B-DELETE').


File: git.info,  Node: Linking Files,  Next: Renaming Files,  Prev: Deleting Files,  Up: Files

Linking Files
.............

`^C H'
     Create a hard link from the current files to a user supplied file
     name (`LINK').

`^C b H'
     Create a hard link from the current files to a user supplied file name
     (`B-LINK').  The action is performed in background.

`^C S'
     Create a symbolic link from the current files to a user supplied file
     name (`SYMLINK').

`^C b S'
     Create a symbolic link from the current files to a user supplied file
     name (`B-SYMLINK').  The action is performed in background.


File: git.info,  Node: Renaming Files,  Next: Packing Files,  Prev: Linking Files,  Up: Files

Renaming Files
..............

`^C R'
     Rename the current file or directory with the user supplied name
     (`RENAME').

`^C b R'
     Rename the current file or directory with the user supplied name.  The
     operation is performed in background (`B-RENAME').

`^C n d'
     Change the name of all the selected entries to lowercase.
     (`name-downcase').

`^C n u'
     Change the name of all the selected entries to uppercase.
     (`name-upcase').


File: git.info,  Node: Packing Files,  Next: Inode,  Prev: Renaming Files,  Up: Files

Packing files into the minimum number of bins
.............................................

`^C ~'
     Pack the files into the smallest number of bins.  This is in fact an
     approximation, since the problem is NP-complete and no known algorithm
     can guarantee a solution better than `(11/9) * OPTIMAL + 4'.
     
     To make things even worst, it is generally difficult to figure out the
     file system block size for the target bin.  Asking the user is not a
     good idea either.  `git' currently assumes a file system block size
     of 1Kb.
     
     Bin packing can be useful when you want to put a bunch of files on
     floppies and you want to optimize things a little bit
     (`bin-packing').


File: git.info,  Node: Inode,  Next: Editing Files,  Prev: Packing Files,  Up: Files

Changing a file's mode, owner and group
.......................................

`^C M'
     Change the mode of the currently selected entries (`CHMOD').

`^C b M'
     Change the mode of the currently selected entries.  The operation is
     performed in background (`B-CHMOD').

`^C r M'
     Recursively change the modes of the selected entries if one of them is a
     directory (`R-CHMOD').

`^C b r M'
     Recursively change the modes of the selected entries if one of them is a
     directory.  The operation is performed in background (`B-R-CHMOD').

`^C O'
     Change the owner of the currently selected entries (`CHOWN').

`^C b O'
     Change the owner of the currently selected entries.  The operation is
     performed in background (`B-CHOWN').

`^C r O'
     Recursively change the owners of the selected entries if one of them is
     a directory (`R-CHOWN').

`^C b r O'
     Recursively change the owners of the selected entries if one of them is
     a directory.  The operation is performed in background
     (`B-R-CHOWN').

`^C G'
     Change the group of the currently selected entries (`CHGRP').

`^C b G'
     Change the group of the currently selected entries.  The operation is
     performed in background (`B-CHGRP').

`^C r G'
     Recursively change the groups of the selected entries if one of them is
     a directory (`R-CHGRP').

`^C b r G'
     Recursively change the groups of the selected entries if one of them is
     a directory.  The operation is performed in background
     (`B-R-CHGRP').


File: git.info,  Node: Editing Files,  Next: Viewing Files,  Prev: Inode,  Up: Files

Editing Files
.............

`F4', `ESC 4'
     Call the default editor with the current file name as an argument
     (`EDIT').

`^X e'
     Call the default editor with the selected entry names as arguments
     (`MULTIPLE-EDIT').

`^X ^F'
     Create a new file by calling the default editor with the user supplied
     file name as an argument (`FILE-CREATE').

`^X 4 a'
     Call the default editor in order to edit the `ChangeLog' file
     (`CHANGE-LOG').

   The default editor can be specified using the EDITOR or GIT_EDITOR
environment variables.  *Note Environment Variables::, for more
information.


File: git.info,  Node: Viewing Files,  Next: Compressing Files,  Prev: Editing Files,  Up: Files

Viewing Files
.............

`F3', `ESC 3', `^X h'
     Call the default viewer (`gitview') with the current file name as
     argument (`VIEW').

`^X v'
     Call the default pager (`more') with the currently selected entry
     names as arguments (`MULTIPLE-VIEW').


File: git.info,  Node: Compressing Files,  Next: Encoding Files,  Prev: Viewing Files,  Up: Files

Compressing Files
.................

`^C z'
     Compress the currently selected entries (`COMPRESS').

`^C b z'
     Compress the currently selected entries.  The operation is performed in
     background (`B-COMPRESS').

`^C Z'
     Uncompress the currently selected entries (`UNCOMPRESS').

`^C b Z'
     Uncompress the currently selected entries.  The operation is performed
     in background (`B-UNCOMPRESS').

`^C f Z'
     Uncompress the currently selected entries (`F-UNCOMPRESS').  Force
     uncompression of links.

`^C b f Z'
     Uncompress the currently selected entries.  Force uncompression of
     links.  The operation is performed in background (`BF-UNCOMPRESS').


File: git.info,  Node: Encoding Files,  Next: Encrypting Files,  Prev: Compressing Files,  Up: Files

Encoding Files
..............

`^C e'
     Encode the currently selected file (`UUENCODE').

`^C b e'
     Encode the currently selected file.  The operation is performed in
     background (`B-UUENCODE').

`^C E'
     Decode the currently selected file (`UUDECODE').

`^C b E'
     Decode the currently selected file.  The operation is performed in
     background (`B-UUDECODE').

`^C k'
     Encode the currently selected file using mpack (`MIME-PACK').

`^C b k'
     Encode the currently selected file using mpack.  The operation is
     performed in background (`B-MIME-PACK').

`^C K'
     Decode the currently selected file using munpack (`MIME-UNPACK').

`^C b K'
     Decode the currently selected file using munpack.  The operation is
     performed in background (`B-MIME-UNPACK').


File: git.info,  Node: Encrypting Files,  Next: Comparing Files,  Prev: Encoding Files,  Up: Files

Encrypting Files
................

`^C p'
     Encrypt (using `pgp') the current file (`ENCRYPT').

`^C P'
     Decrypt (using `pgp') the current file (`DECRYPT').


File: git.info,  Node: Comparing Files,  Next: Spelling Files,  Prev: Encrypting Files,  Up: Files

Comparing Files
...............

`^C ='
     Compare (using `diff') the current ASCII file with the other
     panel's current file (`DIFF').  If both entries are directories, a
     recursive diff is performed.

`^C ESC ='
     Compare (using `diff') the current ASCII file with its latest
     backup.  The latest backup is the file having the same name and a '~' at
     the end (`LAST-BACKUP-DIFF').

`^C B'
     Compare the current file with the other panel current file.  A binary
     comparison is performed (`compare').


File: git.info,  Node: Spelling Files,  Next: Wiping Files,  Prev: Comparing Files,  Up: Files

Spelling Files
..............

`^X I'
     Run the `ispell' command with the current file name as an
     argument.


File: git.info,  Node: Wiping Files,  Next: Searching Files,  Prev: Spelling Files,  Up: Files

Wiping Files
............

`^C W'
     Call `gitwipe' to wipe the selected files.  Asks for confirmation
     before actually wiping them in order to avoid errors (`WIPE').
   *Note gitwipe::, for more information.


File: git.info,  Node: Searching Files,  Next: Archive Files,  Prev: Wiping Files,  Up: Files

Searching Files
...............

`ESC %'
     Searche files on the file system, starting from the current directory
     (`FIND').

`ESC &'
     Use 'locate' to search files on the file system, starting from the
     current directory (`LOCATE').

`^X w'
     Locate the binary, source, and manual page files for a command
     (`WHEREIS').

`^X W'
     Locate a command; display its pathname or alias (`WHICH').


File: git.info,  Node: Archive Files,  Next: RPM Packages,  Prev: Searching Files,  Up: Files

Managing tar based archive files
................................

`^C a'
     Create a `tar' archive containing all the currently selected
     entries (`TAR').

`^C b a'
     Create a `tar' archive containing all the currently selected
     entries.  The operation is performed in background (`B-TAR').

`^C A'
     Expand the `tar' archive pointed by the cursor into the current
     directory (`UNTAR').

`^C b A'
     Expand the `tar' archive pointed by the cursor into the current
     directory.  The operation is performed in background (`B-UNTAR').

`^C x'
     Create a compressed `tar' archive containing all the currently
     selected entries (`TAR-COMPRESS').

`^C b x'
     Create a compressed `tar' archive containing all the currently
     selected entries.  The operation is performed in background
     (`B-TAR-COMPRESS').

`^C X'
     Expand the compressed `tar' archive pointed by the cursor into the
     current directory (`UNCOMPRESS-UNTAR').

`^C b X'
     Expand the compressed `tar' archive pointed by the cursor into the
     current directory.  The operation is performed in background
     (`B-UNCOMPRESS-UNTAR').


File: git.info,  Node: RPM Packages,  Next: MSDOS Files,  Prev: Archive Files,  Up: Files

Installing and Uninstalling RPM packages
........................................

   Red Hat Linux Distributions use a very powerful package manager
called `rpm'.  It is used whenever you need to
install/remove/upgrade/etc a software package.  The packages used by
`rpm' use the extension `.rpm'.  `git' provides default key bindings
for some of the basic operations `rpm' can perform on packages:
install, uninstall, upgrade and query.

`^C I'
     Install the `rpm' package pointed by the cursor
     (`RPM-INSTALL').

`^C b I'
     Install the `rpm' package pointed by the cursor
     (`B-RPM-INSTALL').  The operation is performed in background.

`^C i'
     Uninstall the `rpm' package pointed by the cursor
     (`RPM-UNINSTALL').

`^C b i'
     Uninstall the `rpm' package pointed by the cursor
     (`B-RPM-UNINSTALL').  The operation is performed in background.

`^C N'
     Upgrade the `rpm' package pointed by the cursor
     (`RPM-UPGRADE').

`^C b N'
     Upgrade the `rpm' package pointed by the cursor
     (`B-RPM-UPGRADE').  The operation is performed in background.

`^C q'
     Query the `rpm' package manager (`RPM-QUERY').  The default
     options used are `-qil'.  See the `rpm' manual page for
     more details on using `rpm'.


File: git.info,  Node: MSDOS Files,  Next: Actions,  Prev: RPM Packages,  Up: Files

Accessing MSDOS Files
.....................

`^C m d', `^C m ^D'
     Change the current `MSDOS' directory to a given directory
     (`MTOOLS-CHDIR').

`^C m P'
     Put the currently selected files on a `MSDOS' floppy
     (`MTOOLS-PUT').

`^C b m P'
     Put the currently selected files on a `MSDOS' floppy
     (`B-MTOOLS-PUT').  The operation is performed in background.

`^C m G'
     Get some files from a `MSDOS' floppy and put them in a given
     directory (`MTOOLS-GET').

`^C b m G'
     Get some files from a `MSDOS' floppy and put them in a given
     directory (`B-MTOOLS-GET').  The operation is performed in
     background.

`^C m D'
     Delete files from a `MSDOS' floppy (`MTOOLS-DELETE').

`^C b m D'
     Delete files from a `MSDOS' floppy (`B-MTOOLS-DELETE').  The
     operation is performed in background.

`^C m L'
     List files and directories on a `MSDOS' floppy (`MTOOLS-DIR').

`^C m F'
     Format a `MSDOS' floppy (`MTOOLS-FORMAT').

`^C b m F'
     Format a `MSDOS' floppy (`B-MTOOLS-FORMAT').  The operation is
     performed in background.

`^C m M'
     Create a directory on a `MSDOS' floppy (`MTOOLS-MKDIR').

`^C b m M'
     Create a directory on a `MSDOS' floppy (`B-MTOOLS-MKDIR').
     The operation is performed in background.

`^C m K'
     Remove a directory from a `MSDOS' floppy (`MTOOLS-RMDIR').
     All the files and subdirectories in that directory are removed as well.

`^C b m K'
     Remove a directory from a `MSDOS' floppy (`B-MTOOLS-RMDIR').
     All the files and subdirectories in that directory are removed as well.
     The operation is performed in background.

`^C m R'
     Rename a file or directory on a `MSDOS' floppy
     (`MTOOLS-RENAME').

`^C b m R'
     Rename a file or directory on a `MSDOS' floppy
     (`B-MTOOLS-RENAME').  The operation is performed in background.

`^C m T'
     Display the contents of a file located on a `MSDOS' floppy
     (`MTOOLS-TYPE').


File: git.info,  Node: Actions,  Prev: MSDOS Files,  Up: Files

A different action for each file type
.....................................

   Many files on `UNIX' systems have one or more extensions specifying
their types.  For example, a file that ends in `.c' is a file
containing a `C' program, while a file ending in `.tar.gz' is a `tar'
archive compressed with the `gzip' utility.  Having a default action
for each file type, binded on the same key, seems to be a good idea
because you can use that key to obtain type specific information about
a file or to process it in some type specific way much easier.  The
`GIT' package contains a script called `gitaction' that is used to
detect the current file type and perform a type specific action.  *Note
gitaction::, for more information.

`F2', `ESC 2', `^X a'
     Perform an action on the current file, depending on its type
     (`FILE-ACTION').


File: git.info,  Node: Directories,  Next: Compiling,  Prev: Files,  Up: git

Directory operations
--------------------

* Menu:

* Creating Dirs::               How to create new directories.
* Copying Dirs::                How to copy directories.
* Deleting Dirs::               How to delete directories.
* Moving Dirs::                 How to move directories.
* Renaming Dirs::               How to rename directories.
* Comparing Dirs::              How to compare directories.
* Dirs Usage::                  Summarize directory usage.
* Changing Dirs::               How to go to a new directory.
* Dirs History::                How to use the directory history.
* Hot Keys::                    Hot keys for the most used directories.


File: git.info,  Node: Creating Dirs,  Next: Copying Dirs,  Up: Directories

Creating directories
....................

`F7', `ESC 7', `^X M'
     Create a new subdirectory in the current directory with the user
     supplied name (`make-directory').


File: git.info,  Node: Copying Dirs,  Next: Deleting Dirs,  Prev: Creating Dirs,  Up: Directories

Copying directories
...................

`F5 (for directories)', `ESC 5 (for directories)', `^C C (for
directories)'
     Copy the currently selected entries to the user supplied path
     (`copy').

`^C b C (for directories)'
     Copy the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-COPY').


File: git.info,  Node: Deleting Dirs,  Next: Moving Dirs,  Prev: Copying Dirs,  Up: Directories

Deleting directories
....................

`F8 (for subdirectories)', `ESC 8 (for directories)', `^C D (for
subdirectories)'
     Delete the currently selected entries (`delete').

`^C b D (for directories)'
     Delete the currently selected entries.  The operation is performed in
     background (`B-DELETE').


File: git.info,  Node: Moving Dirs,  Next: Renaming Dirs,  Prev: Deleting Dirs,  Up: Directories

Moving directories
..................

`F6 (for directories)', `ESC 6 (for directories)', `^C T (for
directories)'
     Move the currently selected entries to the user supplied path
     (`move').

`^C b T (for directories)'
     Move the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-MOVE').


File: git.info,  Node: Renaming Dirs,  Next: Comparing Dirs,  Prev: Moving Dirs,  Up: Directories

Renaming directories
....................

`^C R (for directories)'
     Rename the current file or directory with the user supplied name
     (`RENAME').

`^C b R (for directories)'
     Rename the current file or directory with the user supplied name.  The
     operation is performed in background (`B-RENAME').


File: git.info,  Node: Comparing Dirs,  Next: Dirs Usage,  Prev: Renaming Dirs,  Up: Directories

Comparing Directories
.....................

`^C c q'
     Quickly compare the files in the left panel with the files in the right
     one.  Only the file names, sizes and time stamps are considered in the
     comparison.

`^C c t'
     Compare the files in the left panel with the files in the right one.
     The contents of each file in the current panel will be compared against
     the contents of its couterpart (if any) from the other panel.

`^C f d'
     Recursively compare (using `diff -r -q') the current directory with
     the other panel's current directory (`FAST-DIFF').  Print on
     standard output the names of the files that differ.

`^C d'
     Compare (using `diff') the current directory with the other panel
     current directory.  For successful operation, both panels should contain
     the same directory (`DIR-DIFF').

`^C b d'
     Compare (using `diff') the current directory with the other panel
     current directory.  For successful operation, both panels should contain
     the same directory.  The operation is performed in background
     (`DIR-DIFF').


File: git.info,  Node: Dirs Usage,  Next: Changing Dirs,  Prev: Comparing Dirs,  Up: Directories

Summarize directory usage
.........................

`^C U'
     Display the output of the `du -s' command on the status line
     (`DIRECTORY-USAGE').


File: git.info,  Node: Changing Dirs,  Next: Dirs History,  Prev: Dirs Usage,  Up: Directories

Changing directories
....................

`^X d', `^X ^D'
     Change the current working directory.  The user is asked for a new
     directory name and the new directory is added to the directory history
     (`change-directory').
   *Note Dirs History::, for more information.

`ESC a c'
     Change the current directory of the current panel to the directory of
     the other panel (`adapt-current-directory').

`ESC a o'
     Change the current directory of the other panel to the directory of the
     current panel (`adapt-other-directory').


File: git.info,  Node: Dirs History,  Next: Hot Keys,  Prev: Changing Dirs,  Up: Directories

Directory History
.................

   Users usually work on a limited set of subdirectories.  Providing a
fast method of switching between a number of intensively used
directories is a good idea and `git' has a set of builtin commands for
doing it.

   Usually new directories are added to the directory history when the
`change-directory' built-in command is used.  `git' also adds the
current directory to the history list when started, when the directory
history is reseted and when a command having a non empty `new-dir'
field successfully completes its execution.  *Note new-dir::, for more
information.

`^X ^N'
     Go to the next directory in the history (`next-directory').

`^X ^P'
     Go to the previous directory in the history
     (`previous-directory').

`^X ^R'
     Reset the entire directory history.  As explained above, the current
     directory becomes the only directory in the history
     (`reset-directory-history').


File: git.info,  Node: Hot Keys,  Prev: Dirs History,  Up: Directories

Hot Keys
........

   `git' provides default key bindings for switching to a number of
important directories as "/", "..", "$HOME", etc.

`ESC /'
     Go to the `/' directory (`ROOT-DIR').

`ESC .'
     Go to the `..' directory (`up-one-dir').

`ESC h'
     Go to the `~' ($HOME) directory (`HOME-DIR').

`ESC i'
     Go to the `/usr/include' directory (`INCLUDE-DIR').

`ESC ESC 1'
     Go to the `/mnt/fd0' directory (`FIRST-FLOPPY-DIR').

`ESC ESC 2'
     Go to the `/mnt/fd1' directory (`SECOND-FLOPPY-DIR').


File: git.info,  Node: Compiling,  Next: Mail,  Prev: Directories,  Up: git

Compiling programs
------------------

`F9', `ESC 9', `^X m'
     Run the `make' command in the current directory.  Use -k as the
     default option (`MAKE').

`^X b m'
     Run the `make' command in background in the current directory
     (`B-MAKE').
   *Note gitaction::, for more information.


File: git.info,  Node: Mail,  Next: Shell,  Prev: Compiling,  Up: git

Sending/receiving ascii/binary mail
-----------------------------------

`^C 2 a'
     Send the current current ascii file by mail to an user supplied email
     address (`ASCII-MAIL').

`^C b 2 a'
     The same as `ASCII-MAIL', the only difference being that the
     command runs in background (`B-ASCII-MAIL').

`^C 2 b'
     Send the current current binary file by mail to an user supplied list of
     email addresses.  The file is uuencoded first (`BINARY-MAIL').

`^C b 2 b'
     The same as `BINARY-MAIL', the only difference being that the
     command runs in background (`B-BINARY-MAIL').

`^C 2 m'
     Send the current current binary file by mail to an user supplied list of
     email addresses.  The file is encoded with mpack first
     (`MIME-MAIL').

`^C b 2 m'
     The same as `MIME-MAIL', the only difference being that the command
     runs in background (`B-MIME-MAIL').

`ESC x r m'
     Run the `emacs -f rmail' command.  This will start the Emacs's
     `rmail' function so that you can read your mail (`READ-MAIL').


File: git.info,  Node: Shell,  Next: Grep,  Prev: Mail,  Up: git

Starting a sub-shell
--------------------

`^X z'
     Call a sub-shell as specified by the $GIT_SHELL environment
     variable (`SUB-SHELL').
   *Note Environment Variables::, for more information.


File: git.info,  Node: Grep,  Next: Locking,  Prev: Shell,  Up: git

Using grep and recursive grep
-----------------------------

`^X g'
     Search using `grep' all the selected files for a given pattern
     (`GREP').

`^X g'
     Search recursively using `gitrgrep' all the user specified files
     and directories for a given pattern (`RECURSIVE-GREP').
   *Note gitrgrep::, for more information.


File: git.info,  Node: Locking,  Next: Refreshing,  Prev: Grep,  Up: git

Locking your console
--------------------

   Having a lock feature might be a good idea and, since not all the
`UNIX' systems provide one, `git' tries to get around the problem ...

`^X p'
     Prompt the user for a password and locks the console until the same
     password is reinserted (`lock').


File: git.info,  Node: Refreshing,  Next: Reseting,  Prev: Locking,  Up: git

Refreshing the screen contents
------------------------------

   Sometimes your screen needs to be refreshed.  Just think about what
happens when somebody wants to talk with you and the talk daemon writes
something like this

     Message from Talk_Daemon@galei.cs.vu.nl at 12:15 ...
     talk: connection requested by andrei@galei.cs.vu.nl.
     talk: respond with:  talk andrei@galei.cs.vu.nl

on your screen.  And sometimes you might also want to re-read the
current directories.  `git' provides some built-in commands for
refreshing the screen contents.

`^L'
     Re-read the directories contents re-displaying them using
     optimizations. Only those parts of the screen that have changed are
     repainted (`refresh').

`^X l'
     Refresh the entire screen contents without using optimizations.  Useful
     when some "nice" program wrote something on the screen, because
     `git' has no way to detect this (`hard-refresh').


File: git.info,  Node: Reseting,  Next: Mounting,  Prev: Refreshing,  Up: git

Reseting your terminal
----------------------

`^X ^L'
     Call `reset' in order to reset the terminal to its default
     settings (`TTY-RESET').


File: git.info,  Node: Mounting,  Next: Sysinfo,  Prev: Reseting,  Up: git

Mounting/unmounting file systems
--------------------------------

   People dealing with lots of files usually need to save/restore/copy
files from/to other file systems.  In order to be more efficient, `git'
provides a set of key bindings for mounting and unmounting file
systems.  *Note gitmount::, for more information.

   The default key bindings set has been designed to work under
`Linux', but it can be easily changed for other `UNIX' systems with
different device names.  Reading the configuration file `.gitrc.common'
should be enough.  *Note Hot Keys::, for more information.

   As a convention, the `/mnt' directory is used to store an empty
subdirectory for each mountable file system.  Each file system is
actually mounted in its counterpart `/mnt' subdirectory. Try to follow
this convention since the `gitmount' script is heavily based on it.
*Note Customization::, for more information.

`ESC m a'
     Call `mount'(1) in order to mount the first floppy
     (`/dev/fd0') in the `/mnt/fd0' directory (`MOUNT-A').

`ESC m b'
     Call `mount'(1) in order to mount the second floppy
     (`/dev/fd1') in the `/mnt/fd1' directory (`MOUNT-B').

`ESC m t'
     Call `mount'(1) in order to mount the file system corresponding to
     the currently pointed to subdirectory.  For example, if you are in the
     `/mnt' directory and the cursor is on the `fd0' subdirectory,
     the first floppy will be mounted (`MOUNT-THIS').

`ESC r a'
     Call `umount'(1) in order to remove (unmount) the first floppy
     (`/dev/fd0') (`UMOUNT-A').

`ESC r b'
     Call `umount'(1) in order to remove (unmount) the second floppy
     (`/dev/fd1') (`UMOUNT-B').

`ESC r t'
     Call `umount'(1) in order to remove (unmount) the file system
     mounted into the currently pointed to subdirectory
     (`UMOUNT-THIS'). For example, if the current directory is
     `/mnt' and the cursor points to the `fd1' subdirectory, the
     second floppy will be unmounted.

