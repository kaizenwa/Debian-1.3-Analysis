#! @bindir@/uuwish

#
# $Id: xdeview.head,v 1.6 1996/07/20 22:27:20 fp Exp $
#

#
# Init Options
#

proc ifndef { var val } {
    global $var
    if { [ catch { set $var } ] } {
	set $var $val
    }
}

#
# read in rc file
#

if { ! [ catch { set env(HOME) } ] } {
    catch { source $env(HOME)/.xdeviewrc }
}

#
# overridable options for decoding
#

ifndef OptionFast 0
ifndef OptionBracket 0
ifndef OptionOverwrite 0
ifndef OptionDesperate 0
ifndef OptionVerbose 0
ifndef OptionDumbness 0
ifndef OptionUsetext 0
ifndef SaveFilePath [ pwd ]
ifndef OptionDebug 0
ifndef OptionAutoInfo 0

#
# overridable encoding options
#

ifndef EncodeMaxLines	0
ifndef EncodeEncoding	0
ifndef EncodeSubject	""
ifndef EncodeFileYes	1
ifndef EncodeFilePath	$SaveFilePath
ifndef EncodeMailYes	0
ifndef EncodeMailAddr	""
ifndef EncodeNewsYes	0
ifndef EncodeNewsGroup	""
ifndef NNTPServer	""

#
# MIME configuration
#

ifndef MIMEGlobalTypes	""
ifndef MIMEGlobalCap	""
if { ! [ catch { set env(HOME) } ] } {
    ifndef MIMELocalTypes	$env(HOME)/.mime.types
    ifndef MIMELocalCap		$env(HOME)/.mailcap
} else {
    ifndef MIMELocalTypes	""
    ifndef MIMELocalCap		""
}

#
# check whether we are started from within uudeview and have tk support
#

if { [ catch { uu_Info have_tk } have_tk ] } {
    puts "Xdeview error: this file must be loaded from within uudeview"
    exit 1
}
if { ! [ lindex [ lindex $have_tk 0 ] 1 ] } {
    puts "Xdeview error: tk support not compiled"
    exit 1
}

##############################################################################
# General Helper functions
##############################################################################

#
# Get a file type from .mime.types
#

proc GetTypeByExtension { ext } {
    global MIMELocalTypes MIMEGlobalTypes

    foreach fname "$MIMELocalTypes $MIMEGlobalTypes" {
	if { [ catch { open $fname r } fileID ] } {
	    return
	}
	while { ! [ eof $fileID ] } {
	    if { [ gets $fileID TheLine ] < 0 } {
		break
	    }
	    if { [ string index $TheLine 0 ] == "#" } {
		continue
	    } elseif { [ llength $TheLine ] < 2 } {
		continue
	    }
	    for { set index 1 } { $index < [ llength $TheLine ] } { incr index } {
		if { [ string tolower [ lindex $TheLine $index ] ] == \
			[ string tolower $ext ] } {
		    close $fileID
		    return [ lindex $TheLine 0 ]
		}
	    }
	}
	close $fileID
    }
    return
}

#
# see what to do with this type by reading .mailcap
#

proc GetTypeAction { type } {
    global MIMELocalCap MIMEGlobalCap
    foreach fname "$MIMELocalCap $MIMEGlobalCap" {
	if { [ catch { open $fname r } fileID ] } {
	    continue
	}
	while { ! [ eof $fileID ] } {
	    if { [ gets $fileID TheLine ] < 0 } {
		break
	    }
	    if { [ string index $TheLine 0 ] == "#" } {
		continue
	    }

	    if { [ set ThisType [ lindex [ split $TheLine ";" ] 0 ] ] == "" } {
		continue
	    }

	    if { [ string match \
		    [ string tolower $ThisType ] [ string tolower $type ] ] } {
		close $fileID
		return [ lindex [ split $TheLine ";" ] 1 ]
	    }
	}
	close $fileID
    }
    return
}

##############################################################################
# Specific helper functions
##############################################################################

#
# Retrieve the current global FileList and display it. Store in $FileList
#

proc ShowFileList {} {
    global FileList

    proc GetStatus { Code } {
	if { [ expr $Code & 0x08 ] } {
	    return "No Data"
	} elseif { [ expr $Code & 0x20 ] } {
	    return "Error"
	} elseif { [ expr $Code & 0x10 ] } {
	    return "OK"
	} elseif { [ expr $Code & 0x01 ] } {
	    return "Incomplete"
	} elseif { [ expr $Code & 0x02 ] } {
	    return "No Begin"
	} elseif { [ expr $Code & 0x04 ] } {
	    return "No End"
	} elseif { $Code == 0 } {
	    return "Oops"
	}
	return "Error"
    }

    ._MainFrame._FileList._Status delete 0 end
    ._MainFrame._FileList._Liste delete 0 end

    set FileList [uu_GetListOfFiles]

    foreach item $FileList {
	._MainFrame._FileList._Status insert end [GetStatus [lindex $item 1]]
	._MainFrame._FileList._Liste insert end [ lindex $item 2 ]
    }
}

#
# Check the Path
#

proc CheckWritable { Path } {
    if { ! [ expr [ file isdirectory $Path ] && [ file writable $Path ] ] } {
	tk_dialog ._Dialog { Illegal Save Path } "You do not have the\
		proper permissions to write to the selected Save Path.\
		Please use a different Directory" \
		warning 0 OK
	return 0
    }
    return 1
}

#
# Callback function for warnings and errors
#

proc OpenMessageWindow { } {
    if { [ catch { .messages configure } ] } {
	toplevel .messages
	frame .messages.top
	frame .messages.bot
	text .messages.top.text -relief raised -bd 2 -wrap none \
		-xscrollcommand ".messages.top.sbx set" \
		-yscrollcommand ".messages.top.sby set" 
	scrollbar .messages.top.sbx -command ".messages.top.text xview" \
		-orient horizontal
	scrollbar .messages.top.sby -command ".messages.top.text yview"
	
	pack .messages.top.sbx -side bottom -fill x
	pack .messages.top.sby -side right -fill y
	pack .messages.top.text -fill both -expand 1
	
	button .messages.bot.done -text "Done" -command "destroy .messages"
	pack .messages.bot.done -side right -padx 4 -pady 4
	
	pack .messages.top -side top -fill both -expand 1
	pack .messages.bot -side bottom
	
	wm title .messages "Runtime Messages"
    }
}

#
# Display a message in our Runtime Messages window, if verbose
#

proc DisplayMessage { level string } {
    global OptionVerbose

    if { $OptionVerbose } {
	OpenMessageWindow
	.messages.top.text insert end $string
	.messages.top.text insert end "\n"
	.messages.top.text yview end
	update
    }
    if { $level == 2 } {
	tk_dialog ._Dialog "Warning" $string warning 0 OK
    } elseif { $level > 2 } {
	tk_dialog ._Dialog "Error" $string error 0 OK
    }    
}

#
# Dump the current File List in the Runtime Messages window
#

proc DumpFileList { } {
    global FileList

    OpenMessageWindow

    if { [ llength $FileList ] == 0 } {
	return
    }

    .messages.top.text insert end "\n"

    foreach file $FileList {
	if { [ expr [ lindex $file 1 ] & 0x08 ] } {
	    continue
	}
	.messages.top.text insert end \
		"Found '[lindex $file 2]'\
		State [lindex $file 1] [lindex $file 4]\
		Parts [lindex $file 5]\n"
    }
    .messages.top.text insert end "\n"
    .messages.top.text yview end
}

#
# Handle Busy Callback
#

proc WeAreBusy {} {
    set BusyInfo [uu_GetProgressInfo]

    if { [ lindex $BusyInfo 0 ] == 1 } {
	._Status._Text config -text \
		"Loading [ file tail [ lindex $BusyInfo 1 ] ] --\
		[ lindex $BusyInfo 4 ]% done"
    } elseif { [ lindex $BusyInfo 0 ] == 2 } {
	set percent [expr 100*[lindex $BusyInfo 2]+[lindex $BusyInfo 4]-100]
	set percent [expr $percent / [lindex $BusyInfo 3]]

	._Status._Text configure -text \
		"Decoding [file tail [lindex $BusyInfo 1 ] ] --\
		$percent% done"
    } elseif { [ lindex $BusyInfo 0 ] == 3 } {
	._Status._Text config -text \
		"Copying [ file tail [ lindex $BusyInfo 1 ] ] --\
		[ lindex $BusyInfo 4 ]% done"
    } elseif { [ lindex $BusyInfo 0 ] == 4 } {
	set percent [expr 100*[lindex $BusyInfo 2]+[lindex $BusyInfo 4]-100]
	set percent [expr $percent / [lindex $BusyInfo 3]]

	._Status._Text configure -text \
		"Encoding [file tail [lindex $BusyInfo 1 ] ] --\
		$percent% done"
    }
    update
}

#
# Helper function to load a bunch of files
#

proc LoadFiles { LoadFileList } {
    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]

    . config -cursor watch

    foreach file $LoadFileList {
	#
	# recurse into subdirectories
	#
	if { [ file isdirectory $file ] && [ file readable $file ] } {
	    LoadFiles [ glob -nocomplain [ file join $file * ] ]
	    continue
	} elseif { ! [ file readable $file ] || [ file isdirectory $file ] } {
	    tk_dialog ._Dialog "File Unreadable" "File $file is read\
		    protected or is a directory" warning 0 OK
	    continue
	}
	._Status._Text config -text "Loading [ file tail $file ] ..."
	update
	uu_LoadFile $file
    }

    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
}

##############################################################################
# Button bindings && Menu functions
##############################################################################

#
# Menu Command File->Quit
#

proc Quit {} { 
    uu_CleanUp
    destroy . 
}

#
# Menu Command File->Load
#

proc Load {} {
    global OptionVerbose

    set oldText [ lindex [ ._Status._Text config -text ] 4 ]
    ._Status._Text config -text "Waiting for you to Select Files"
    set LoadFileList [ tk_SelectFiles "Select Files for Decoding" 1 1 ]
    ._Status._Text config -text $oldText

    if { $LoadFileList != {} } {
	LoadFiles $LoadFileList
	ShowFileList
	if { $OptionVerbose } {
	    DumpFileList
	}
    }
}

#
# Menu Command File->Helper Setup
#

proc MimeSetup {} {
    global MIMEGlobalTypes MIMELocalCap MIMEGlobalCap MIMELocalTypes
    global tempGlobalTypes tempLocalCap tempGlobalCap tempLocalTypes
    global MSFinish

    set tempGlobalTypes $MIMEGlobalTypes
    set tempLocalCap    $MIMELocalCap
    set tempGlobalCap   $MIMEGlobalCap
    set tempLocalTypes  $MIMELocalTypes

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]
    set oldFocus  [ focus ]

    toplevel .mime
    wm title .mime "Helper Setup"

    frame .mime.top -relief groove -bd 1
    frame .mime.top.gt
    frame .mime.top.lt
    frame .mime.top.gc
    frame .mime.top.lc

    label .mime.top.gt.lab -text "Global Types File" -width 16 \
	    -justify left -anchor w
    entry .mime.top.gt.ent -relief sunken -width 30 \
	    -textvariable MIMEGlobalTypes
    button .mime.top.gt.but -text "Browse" -width 8 -command {
	set OldDir [ file dirname $MIMEGlobalTypes ]
	set NewFile [ tk_SelectFiles "Global Types File" 0 0 $OldDir ]
	if { $NewFile != "" } { set MIMEGlobalTypes $NewFile }
    }
    label .mime.top.lt.lab -text "Local Types File" -width 16 \
	    -justify left -anchor w
    entry .mime.top.lt.ent -relief sunken -width 30 \
	    -textvariable MIMELocalTypes
    button .mime.top.lt.but -text "Browse" -width 8 -command {
	set OldDir [ file dirname $MIMELocalTypes ]
	set NewFile [ tk_SelectFiles "Local Types File" 0 0 $OldDir ]
	if { $NewFile != "" } { set MIMELocalTypes $NewFile }
    }
    label .mime.top.gc.lab -text "Global Mailcap File" -width 16 \
	    -justify left -anchor w
    entry .mime.top.gc.ent -relief sunken -width 30 \
	    -textvariable MIMEGlobalCap
    button .mime.top.gc.but -text "Browse" -width 8 -command {
	set OldDir [ file dirname $MIMEGlobalCap ]
	set NewFile [ tk_SelectFiles "Global Mailcap File" 0 0 $OldDir ]
	if { $NewFile != "" } { set MIMEGlobalCap $NewFile }
    }
    label .mime.top.lc.lab -text "Local Mailcap File" -width 16 \
	    -justify left -anchor w
    entry .mime.top.lc.ent -relief sunken -width 30 \
	    -textvariable MIMELocalCap
    button .mime.top.lc.but -text "Browse" -width 8 -command {
	set OldDir [ file dirname $MIMELocalCap ]
	set NewFile [ tk_SelectFiles "Local Mailcap File" 0 0 $OldDir ]
	if { $NewFile != "" } { set MIMELocalCap $NewFile }
    }

    pack .mime.top.gt.lab -side left -padx 4 -pady 4
    pack .mime.top.gt.but -side right -padx 4
    pack .mime.top.gt.ent -side right -padx 4 -pady 4 -expand true -fill x

    pack .mime.top.lt.lab -side left -padx 4 -pady 4
    pack .mime.top.lt.but -side right -padx 4
    pack .mime.top.lt.ent -side right -padx 4 -pady 4 -expand true -fill x

    pack .mime.top.gc.lab -side left -padx 4 -pady 4
    pack .mime.top.gc.but -side right -padx 4
    pack .mime.top.gc.ent -side right -padx 4 -pady 4 -expand true -fill x

    pack .mime.top.lc.lab -side left -padx 4 -pady 4
    pack .mime.top.lc.but -side right -padx 4
    pack .mime.top.lc.ent -side right -padx 4 -pady 4 -expand true -fill x

    pack .mime.top.gt .mime.top.lt .mime.top.gc .mime.top.lc \
	    -side top -expand true -fill both

    frame .mime.but -relief raised -bd 2
    frame .mime.but.b

    button .mime.but.b.ok -text "Ok" -width 8 -command { 
	if { $MIMEGlobalTypes != "" && \
		! [ file readable $MIMEGlobalTypes ] } {
	    tk_dialog ._Dialog "File Does not Exist" "Global Types File\
		    $MIMEGlobalTypes does not exist or is not readable." \
		    error 0 OK
	} elseif { $MIMELocalTypes != "" && \
		! [ file readable $MIMELocalTypes ] } {
	    tk_dialog ._Dialog "File Does not Exist" "Local Types File\
		    $MIMELocalTypes does not exist or is not readable." \
		    error 0 OK
	} elseif { $MIMEGlobalCap != "" && \
		! [ file readable $MIMEGlobalCap ] } {
	    tk_dialog ._Dialog "File Does not Exist" "Global Mailcap File\
		    $MIMEGlobalCap does not exist or is not readable." \
		    error 0 OK
	} elseif { $MIMELocalCap != "" && \
		! [ file readable $MIMELocalCap ] } {
	    tk_dialog ._Dialog "File Does not Exist" "Local Mailcap File\
		    $MIMELocalCap does not exist or is not readable." \
		    error 0 OK
	} else {
	    set MSFinish ok
	}
    }
    button .mime.but.b.cancel -text "Cancel" -width 8 \
	    -command { set MSFinish cancel }

    pack .mime.but.b.ok .mime.but.b.cancel -side left -ipadx 4 -ipady 4 \
	    -padx 4 -pady 4 -expand true
    pack .mime.but.b -fill both -expand true -fill both

    pack .mime.top -side top -fill x
    pack .mime.but -side bottom -fill both -expand true

    bind .mime.top.gt.ent <Return> {
	if { $MIMEGlobalTypes != "" } {
	    if { ! [ file readable $MIMEGlobalTypes ] } {
		tk_dialog ._Dialog "File Does not Exist" "Global Types File\
			$MIMEGlobalTypes does not exist or is not readable." \
			error 0 OK
	    }
	}
    }
    bind .mime.top.lt.ent <Return> {
	if { $MIMELocalTypes != "" } {
	    if { ! [ file readable $MIMELocalTypes ] } {
		tk_dialog ._Dialog "File Does not Exist" "Local Types File\
			$MIMELocalTypes does not exist or is not readable." \
			error 0 OK
	    }
	}
    }
    bind .mime.top.gc.ent <Return> {
	if { $MIMEGlobalCap != "" } {
	    if { ! [ file readable $MIMEGlobalCap ] } {
		tk_dialog ._Dialog "File Does not Exist" "Global Mailcap File\
			$MIMEGlobalCap does not exist or is not readable." \
			error 0 OK
	    }
	}
    }
    bind .mime.top.lc.ent <Return> {
	if { $MIMELocalCap != "" } {
	    if { ! [ file readable $MIMELocalCap ] } {
		tk_dialog ._Dialog "File Does not Exist" "Local Mailcap File\
			$MIMELocalCap does not exist or is not readable." \
			error 0 OK
	    }
	}
    }

    . config -cursor watch
    tkwait visibility .mime
    ._Status._Text config -text "Waiting for Configuration"
    grab set .mime
    focus .mime
    set MSFinish {}

    tkwait variable MSFinish

    if { $MSFinish != "ok" } {
	set MIMEGlobalTypes $tempGlobalTypes
	set MIMELocalCap    $tempLocalCap
	set MIMEGlobalCap   $tempGlobalCap
	set MIMELocalTypes  $tempLocalTypes
    }
    . config -cursor $oldCursor
    ._Status._Text config -text $oldText
    focus $oldFocus
    destroy .mime
}

#
# Menu Command File->Save Setup
#

proc SaveSetup {} {
    global OptionFast OptionBracket OptionOverwrite
    global OptionDesperate OptionVerbose OptionAutoInfo
    global SaveFilePath EncodeMaxLines EncodeEncoding
    global EncodeFilePath NNTPServer MIMELocalTypes
    global MIMEGlobalTypes MIMELocalCap MIMEGlobalCap
    global OptionDumbness OptionUsetext
    global env

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]

    . config -cursor watch
    ._Status._Text config -text "Saving Setup"

    if { [ catch { set env(HOME) } ] || $env(HOME) == "" } {
	tk_dialog ._Dialog "OOps" "Could not find your home directory." \
		error 0 OK
	. config -cursor $oldCursor
	._Status._Text config -text $oldText
	return
    }

    #
    # need temp file
    #
    if { ! [ catch { set $env(TEMP) } ] } {
	set tempname "$env(TEMP)/xdeview[pid]"
    } else {
	set tempname "/tmp/xdeview.[pid]"
    }

    if { [ file exists $tempname ] } {
	foreach ext { 001 002 003 004 005 006 007 008 009 010 042 } {
	    if { ! [ catch { set $env(TEMP) } ] } {
		set tempname "$env(TEMP)/xdeview.$ext"
	    } else {
		set tempname "/tmp/xdeview.$ext"
	    }
	    if { [ file exists $tempname ] } {
		break
	    }
	}
	if { [ file exits $tempname] } {
	    tk_dialog ._Dialog "OOps" "Could not save your setup. Couldn't\
		    find suitable temporary file" error 0 OK
	    . config -cursor $oldCursor
	    ._Status._Text config -text $oldText
	    return
	}
    }
    if { [ catch { open $tempname w } writeID ] } {
	tk_dialog ._Dialog "OOps" "Cannot write to temp file $tempname.\
		Setup not saved." error 0 OK
	. config -cursor $oldCursor
	._Status._Text config -text $oldText
	return
    }

    set rcfile $env(HOME)/.xdeviewrc

    if { ! [ catch { open $rcfile r } readID ] } {
	#
	# copy existing resouce file
	#
	while { ! [ eof $readID ] } {
	    if { [ gets $readID TheLine ] < 0 } {
		break
	    }
	    puts $writeID $TheLine

	    if { [ string first "--xdeview--" $TheLine ] != -1 } {
		break
	    }
	}
	if { [ eof $readID ] } {
	    puts $writeID "#"
	    puts $writeID "# --xdeview-- auto-generated do not add code below"
	}
	close $readID
    } else {
	puts $writeID "#"
	puts $writeID "# --xdeview-- auto-generated do not add code below"
    }
    #
    # save configuration information
    #
    puts $writeID "#"
    puts $writeID "# options for decoding"
    puts $writeID "#"
    puts $writeID "ifndef OptionFast       $OptionFast"
    puts $writeID "ifndef OptionBracket    $OptionBracket"
    puts $writeID "ifndef OptionOverwrite  $OptionOverwrite"
    puts $writeID "ifndef OptionDesperate  $OptionDesperate"
    puts $writeID "ifndef OptionVerbose    $OptionVerbose"
    puts $writeID "ifndef OptionDumbness   $OptionDumbness"
    puts $writeID "ifndef OptionAutoInfo   $OptionAutoInfo"
    puts $writeID "ifndef OptionUsetext    $OptionUsetext"
    puts $writeID "ifndef SaveFilePath     \"$SaveFilePath\""
    puts $writeID "#"
    puts $writeID "# encoding options"
    puts $writeID "#"
    puts $writeID "ifndef EncodeMaxLines   $EncodeMaxLines"
    puts $writeID "ifndef EncodeEncoding   $EncodeEncoding"
    puts $writeID "ifndef EncodeFilePath   \"$EncodeFilePath\""
    puts $writeID "ifndef NNTPServer       \"$NNTPServer\""
    puts $writeID "#"
    puts $writeID "# MIME capabilities"
    puts $writeID "#"
    puts $writeID "ifndef MIMELocalTypes   \"$MIMELocalTypes\""
    puts $writeID "ifndef MIMEGlobalTypes  \"$MIMEGlobalTypes\""
    puts $writeID "ifndef MIMELocalCap     \"$MIMELocalCap\""
    puts $writeID "ifndef MIMEGlobalCap    \"$MIMEGlobalCap\""
    puts $writeID "#"
    puts $writeID ""

    close $writeID

    #
    # copy temp file back to real ./xdeviewrc
    #

    if { [ catch { open $tempname r } readID ] } {
	tk_dialog ._Dialog "This is weird" "Could not re-open the temp\
		file $tempname. Setup not saved." error 0 OK
	. config -cursor $oldCursor
	._Status._Text config -text $oldText
	exec -- rm -f $tempname
	return
    }
    if { [ catch { open $rcfile w } writeID ] } {
	tk_dialog ._Dialog "OOps" "Cannot write to setup file $rcfile.\
		Setup not saved." error 0 OK
	. config -cursor $oldCursor
	._Status._Text config -text $oldText
	close $readID
	exec -- rm -f $tempname
	return
    }
    while { ! [ eof $readID ] } {
	if { [ gets $readID TheLine ] < 0 } {
	    break
	}
	puts $writeID $TheLine
    }
    close $writeID
    close $readID

    exec -- rm -f $tempname
    
    . config -cursor $oldCursor
    ._Status._Text config -text $oldText

    tk_dialog ._Dialog "OK" "Setup successfully saved to $rcfile." \
	    "" 0 OK
}    

#
# Menu Command File->Encode
#

proc Encode {} {
    global EncodeFileName
    global EncodeMaxLines
    global EncodeEncoding
    global EncodeSubject

    global EncodeFileYes
    global EncodeFilePath
    global EncodeMailYes
    global EncodeMailAddr
    global EncodeNewsYes
    global EncodeNewsGroup
    global SaveFilePath
    global EncodeButton
    global HaveNNTPServer
    global NNTPServer
    global env

    ifndef EncodeMaxLines	0
    ifndef EncodeEncoding	0
    ifndef EncodeSubject	""
    ifndef EncodeFileYes	1
    ifndef EncodeFilePath	$SaveFilePath
    ifndef EncodeMailYes	0
    ifndef EncodeMailAddr	""
    ifndef EncodeNewsYes	0
    ifndef EncodeNewsGroup	""
    ifndef NNTPServer		""

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]
    set oldFocus  [ focus ]

    set have_mail [ lindex [ lindex [ uu_Info have_mail ] 0 ] 1 ]
    set have_news [ lindex [ lindex [ uu_Info have_news ] 0 ] 1 ]
    set need_nntp [ lindex [ lindex [ uu_Info need_nntpserver ] 0 ] 1 ]

    if { $have_news && $need_nntp && $NNTPServer == "" } {
	if { [ catch { set NNTPServer $env(NNTPSERVER) } ] } {
	    set NNTPServer ""
	}
    }

    ._Status._Text config -text "Waiting for you to Select Files for Encoding"
    set EncodeFileList [ tk_SelectFiles "Select Files for Encoding" 1 0 ]

    if { $EncodeFileList == {} } {
	._Status._Text config -text $oldText
	return
    }
    set EncodeFileCount [ llength $EncodeFileList ]

    #
    # what to do with these files?
    #

    toplevel ._Encode
    wm title ._Encode "Encode Files"

    #
    # first section: How many files left?
    #

    frame ._Encode._Toplab -relief raised -bd 2
    label ._Encode._Toplab.lab -text "0 Files left to Encode"
    pack ._Encode._Toplab.lab -padx 2 -pady 2 -anchor w

    #
    # second section: file names of source and sent file
    #

    frame ._Encode._Names -relief raised -bd 2
    frame ._Encode._Names.top
    frame ._Encode._Names.bot
    frame ._Encode._Names.sub

    label ._Encode._Names.top.lab -text "Filename:" -width 12 \
	    -justify left -anchor w
    entry ._Encode._Names.top.nam -relief sunken -width 30
    label ._Encode._Names.bot.lab -text "Send as:" -width 12 \
	    -justify left -anchor w
    entry ._Encode._Names.bot.nam -relief sunken -width 30 \
	    -textvariable EncodeFileName
    label ._Encode._Names.sub.msg -text "Use Subject:" -width 12 \
	    -justify left -anchor w
    entry ._Encode._Names.sub.ent -relief sunken -width 30 \
	    -textvariable EncodeSubject

    pack ._Encode._Names.top.lab -side left -padx 2 -pady 2
    pack ._Encode._Names.top.nam -side right -padx 2 -pady 2 \
	    -fill x -expand true
    pack ._Encode._Names.bot.lab -side left -padx 2 -pady 2
    pack ._Encode._Names.bot.nam -side right -padx 2 -pady 2 \
	    -fill x -expand true
    pack ._Encode._Names.sub.msg -side left -padx 2 -pady 2
    pack ._Encode._Names.sub.ent -side right -padx 2 -pady 2 \
	    -expand true -fill x

    pack ._Encode._Names.top ._Encode._Names.bot ._Encode._Names.sub \
	    -padx 4 -pady 4 -side top -fill x -expand true

    #
    # third section: encoding options
    #

    frame ._Encode._Options -relief raised -bd 2
    frame ._Encode._Options.left
    frame ._Encode._Options.right
    frame ._Encode._Options.left.top
    frame ._Encode._Options.left.empty
    frame ._Encode._Options.left.bot

    label ._Encode._Options.left.top.msg -text "Encoding Options:"

    entry ._Encode._Options.left.bot.lines -relief sunken -width 5 \
	    -textvariable EncodeMaxLines
    label ._Encode._Options.left.bot.msg -text "Lines per File" \
	    -justify left

    radiobutton ._Encode._Options.right.uue -text "UU Encoding" \
	    -variable EncodeEncoding -value 0 -relief flat -anchor w \
	    -selectcolor black
    radiobutton ._Encode._Options.right.xxe -text "XX Encoding" \
	    -variable EncodeEncoding -value 1 -relief flat -anchor w \
	    -selectcolor black
    radiobutton ._Encode._Options.right.b64 -text "Base64 Encoding" \
	    -variable EncodeEncoding -value 2 -relief flat -anchor w \
	    -selectcolor black

    pack ._Encode._Options.left.bot.lines ._Encode._Options.left.bot.msg \
	    -padx 4 -pady 4 -side left
    pack ._Encode._Options.left.top.msg -padx 2 -pady 2 -anchor nw
    pack ._Encode._Options.left.top -fill x -side top
    pack ._Encode._Options.left.bot -anchor sw -side bottom -padx 4 -pady 4
    pack ._Encode._Options.left.empty -fill both -expand true

    pack ._Encode._Options.right.uue ._Encode._Options.right.xxe \
	    ._Encode._Options.right.b64 -padx 4 -pady 2 -fill x

    pack ._Encode._Options.left ._Encode._Options.right \
	    -side left -fill both -expand true

    #
    # fourth section: what to do with encoded data
    #

    frame ._Encode._Actions -relief raised -bd 2
    frame ._Encode._Actions.title
    frame ._Encode._Actions.file
    frame ._Encode._Actions.mail
    frame ._Encode._Actions.news

    label ._Encode._Actions.title.lab -text "Encoding Actions:"
    pack ._Encode._Actions.title.lab -padx 2 -pady 2 -anchor w

    checkbutton ._Encode._Actions.file.but -variable EncodeFileYes \
	    -text "File In (Path):" -width 12 -justify left -anchor w \
	    -selectcolor black
    entry ._Encode._Actions.file.ent -relief sunken -width 30 \
	    -textvariable EncodeFilePath
    button ._Encode._Actions.file.bb -text "Browse" -command {
	set NewPath [ tk_SelectFiles "Encoding Path" 0 2 ]
	if { $NewPath != "" } {
	    if { [ CheckWritable $NewPath ] } {
		set EncodeFilePath [ CompressSlashes $NewPath ]
	    }
	}
    }

    checkbutton ._Encode._Actions.mail.but -variable EncodeMailYes \
	    -text "Email To ..." -width 12 -justify left -anchor w \
	    -selectcolor black
    entry ._Encode._Actions.mail.ent -relief sunken -width 30 \
	    -textvariable EncodeMailAddr

    checkbutton ._Encode._Actions.news.but -variable EncodeNewsYes \
	    -text "Post To ..." -width 12 -justify left -anchor w \
	    -selectcolor black
    entry ._Encode._Actions.news.ent -relief sunken -width 30 \
	    -textvariable EncodeNewsGroup

    #
    # if we need an NNTP server, add a button
    #

    if { $have_news && $need_nntp } {
	frame ._Encode._Actions.nntp
	checkbutton ._Encode._Actions.nntp.but -variable HaveNNTPServer \
		-text "NNTP Server" -width 12 -justify left -anchor w \
		-selectcolor black
	entry ._Encode._Actions.nntp.ent -relief sunken -width 30 \
		-textvariable NNTPServer
	._Encode._Actions.nntp.but select
    }

    pack ._Encode._Actions.file.but -side left -padx 4 -pady 4
    pack ._Encode._Actions.file.bb  -side right -padx 4
    pack ._Encode._Actions.file.ent -side right -padx 4 -pady 4 \
	    -expand true -fill x

    pack ._Encode._Actions.mail.but -side left -padx 4 -pady 4
    pack ._Encode._Actions.mail.ent -side right -padx 4 -pady 4 \
	    -expand true -fill x

    pack ._Encode._Actions.news.but -side left -padx 4 -pady 4
    pack ._Encode._Actions.news.ent -side right -padx 4 -pady 4 \
	    -expand true -fill x

    pack ._Encode._Actions.title -side top -fill x -expand true
    pack ._Encode._Actions.file  -side top -fill x -expand true
    pack ._Encode._Actions.mail  -side top -fill x -expand true
    pack ._Encode._Actions.news  -side top -fill x -expand true

    if { $have_news && $need_nntp } {
	pack ._Encode._Actions.nntp.but -side left -padx 4 -pady 4
	pack ._Encode._Actions.nntp.ent -side right -padx 4 -pady 4 \
		-expand true -fill x
	pack ._Encode._Actions.nntp -side top -fill x -expand true
    }

    #
    # fifth section: the buttons
    #

    frame ._Encode._Buttons -relief raised -bd 2
    frame ._Encode._Buttons.b

    button ._Encode._Buttons.b._Ok -text "Ok" -width 8 \
	    -command { set EncodeButton ok }
    button ._Encode._Buttons.b._OkAll -text "Ok to All" -width 8 \
	    -command { set EncodeButton okall }
    button ._Encode._Buttons.b._Next -text "Next" -width 8 \
	    -command { set EncodeButton next }
    button ._Encode._Buttons.b._Cancel -text "Cancel" -width 8 \
	    -command { set EncodeButton cancel }

    pack ._Encode._Buttons.b._Ok ._Encode._Buttons.b._OkAll \
	    ._Encode._Buttons.b._Next ._Encode._Buttons.b._Cancel \
	    -side left -ipadx 4 -ipady 4 -padx 4 -pady 4 -expand true
    pack ._Encode._Buttons.b -fill both -expand true


    pack ._Encode._Toplab ._Encode._Names ._Encode._Options \
	    ._Encode._Actions -fill x -side top
    pack ._Encode._Buttons -fill both -side bottom -expand true

    #
    # wow, dialog box is finally drawn. now make it do something
    #

    if { $have_mail == 0 } {
	._Encode._Actions.mail.but deselect
	._Encode._Actions.mail.ent delete 0 end
	._Encode._Actions.mail.ent insert 0 "(Email not Available)"
	._Encode._Actions.mail.but configure -state disabled
	._Encode._Actions.mail.ent configure -state disabled
    }
    if { $have_news == 0 } {
	._Encode._Actions.news.but deselect
	._Encode._Actions.news.ent delete 0 end
	._Encode._Actions.news.ent insert 0 "(Posting not Available)"
	._Encode._Actions.news.but configure -state disabled
	._Encode._Actions.news.ent configure -state disabled
    }

    bind ._Encode._Actions.file.ent <Return> {
	if { $EncodeFilePath == {} } {
	    set EncodeFilePath [ pwd ]
	}
	set EncodeFilePath [ CompressSlashes $EncodeFilePath ]
	CheckWritable $EncodeFilePath
    }
    bind ._Encode._Options.left.bot.lines <Return> {
	if { $EncodeMaxLines < 200 && $EncodeMaxLines != 0 } {
	    tk_dialog ._Dialog { Illegal Number of Lines } "You have\
		    entered an invalid value for the number of lines\
		    per encoded file. It must either be 0 (no limit)\
		    or greater than 200." error 0 OK
	    set EncodeMaxLines 0
	}
    }

    #
    # iterate through files
    #

    . config -cursor watch
    tkwait visibility ._Encode
    grab set ._Encode
    focus ._Encode

    set index 0
    set EncodeButton {}

    while { $index < $EncodeFileCount } {
	set EFPath [ lindex $EncodeFileList $index ]
	set EFName [ file tail $EFPath ]

	._Encode config -cursor {}

	if { ! [ file readable $EFPath ] || [ file isdirectory $EFPath ] } {
	    tk_dialog ._Dialog { Cannot read File } "Cannot read $EFPath" \
		    error 0 OK
	    incr index
	    continue
	}

	._Encode._Names.top.nam configure -state normal
	._Encode._Names.top.nam delete 0 end
	._Encode._Names.top.nam insert 0 $EFPath
	._Encode._Names.top.nam configure -state disabled

	._Encode._Names.bot.nam delete 0 end
	._Encode._Names.bot.nam insert 0 $EFName

	._Encode._Toplab.lab config -text \
		"[ expr $EncodeFileCount - $index ] Files left to Encode"

	._Status._Text config -text "Waiting for action on $EFName"

	if { $EncodeButton != "okall" } {
	    while { 42 } {
		set EncodeButton {}
		tkwait variable EncodeButton
		if { $EncodeButton == "cancel" } {
		    break
		}
		#
		# check parameter
		#
		if { $EncodeFilePath == {} } {
		    set EncodeFilePath [ pwd ]
		}
		set EncodeFilePath [ CompressSlashes $EncodeFilePath ]
		if { $EncodeFileYes && ! [ CheckWritable $EncodeFilePath ] } {
		    continue
		}
		if { $EncodeMaxLines < 200 && $EncodeMaxLines != 0 } {
		    tk_dialog ._Dialog { Illegal Number of Lines } "You have\
			    entered an invalid value for the number of lines\
			    per encoded file. It must either be 0 (no limit)\
			    or greater than 200." error 0 OK
		    set EncodeMaxLines 0
		    continue
		}
		if { $have_news && $need_nntp && $EncodeNewsYes } {
		    if { $HaveNNTPServer == 0 || $NNTPServer == {} } {
			tk_dialog ._Dialog { No NNTP Server } "You must\
				provide the address of an NNTP server in\
				order to post a file. You can also set\
				your environment variable\
				\$NNTPSERVER or define the address at\
				compile time." error 0 OK
			continue
		    }
		}
		break
	    }
	}
	#
	# check which button was pressed
	#
	if { $EncodeButton == "cancel" } {
	    break
	} elseif { $EncodeButton == "next" } {
	    incr index
	    continue
	}
	#
	# at this point, we want to process the file (either ok or okall)
	#

	if { $have_news && $need_nntp && $EncodeNewsYes } {
	    set env(NNTPSERVER) $NNTPServer
	}

	._Encode config -cursor watch

	if { $EncodeFileYes } {
	    ._Status._Text config -text "Encoding $EFName to File ..."
	    update
	    if { [ catch { uu_EncodeToFile $EFPath \
		    [ file join $EncodeFilePath $EncodeFileName] \
		    $EncodeFileName $EncodeSubject "" $EncodeMaxLines \
		    $EncodeEncoding } message ] } {
		tk_dialog ._Dialog { Error while Encoding } "The following\
			error occured while encoding into a file: $message" \
			error 0 OK
	    }
	}
	if { $EncodeMailYes } {
	    ._Status._Text config -text "Encoding and Emailing $EFName ..."
	    update
	    if { [ catch { uu_EncodeToMail $EFPath $EncodeMailAddr \
		    $EncodeFileName $EncodeSubject "" $EncodeMaxLines \
		    $EncodeEncoding } message ] } {
		tk_dialog ._Dialog { Error while Encoding } "The following\
			error occured while sending the file via mail:\
			$message" \
			error 0 OK
	    }
	}
	if { $EncodeNewsYes } {
	    ._Status._Text config -text "Encoding and Emailing $EFName ..."
	    update
	    if { [ catch { uu_EncodeToNews $EFPath $EncodeNewsGroup \
		    $EncodeFileName $EncodeSubject "" $EncodeMaxLines \
		    $EncodeEncoding } message ] } {
		tk_dialog ._Dialog { Error while Encoding } "The following\
			error occured while sending the file via news:\
			$message" \
			error 0 OK
	    }
	}
	#
	# end of processing
	#
	incr index
    }
    . config -cursor $oldCursor
    ._Status._Text config -text $oldText
    focus $oldFocus
    destroy ._Encode
}

#
# Helper function to decode a bunch of files
#

proc DecodeProc { DecodeList } {
    global OptionOverwrite
    global OptionDesperate
    global SaveFilePath
    global FileList

    set count      [ llength $DecodeList ]
    set oldCursor  [ lindex [ . config -cursor ] 4 ]
    set oldText    [ lindex [ ._Status._Text config -text ] 4 ]

    if { $DecodeList == {} } {
	return;
    }

    if { ! [ CheckWritable $SaveFilePath ] } {
	return;
    }

    . config -cursor watch

    for { set index 0 } { $index < $count } { incr index } {
	set ItemNo     [ lindex $DecodeList $index ]
	set FileName   [ lindex [ lindex $FileList $ItemNo ] 2 ]
	set FileNumber [ lindex [ lindex $FileList $ItemNo ] 0 ]
	set FilePath   [ file join $SaveFilePath $FileName ]

	._Status._Text configure -text "Decoding $FileName ..."

	if { [ file exists $FilePath ] && ! [ file writable $FilePath ] } {
	    tk_dialog ._Dialog { File Error } "The File $FilePath exists\
		    and can not be written" error 0 OK
	    continue
	} elseif { [ file exists $FilePath ] && ! $OptionOverwrite } {
	    set answer [ tk_dialog ._Dialog "File Exists" "$FileName\
		    already exists in $SaveFilePath." question 0 \
		    "Overwrite" "Next File" "Cancel" ]
	    if { $answer == "1" } { 
		continue
	    } elseif { $answer == "2" } {
		break
	    }
	}
	#
	# At this point, the target file either does not exist or
	# we want to overwrite it
	#

	update

	set result [ catch { uu_DecodeFile $FileNumber $FilePath } errorMsg ]

	if { $result } {
	    tk_dialog ._Dialog "Error while Decoding" "The following\
		    problem occured while decoding: $errorMsg" \
		    error 0 OK
	    continue
	}
    }

    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
}

#
# Button 'Decode'
#

proc Decode {} {
    DecodeProc [ ._MainFrame._FileList._Liste curselection ]
}

#
# Button 'Decode All'
#

proc DecodeAll {} {
    set count [ ._MainFrame._FileList._Liste size ]

    set DecodeList {}

    for { set index 0 } { $index < $count } { incr index } {
	lappend DecodeList $index
    }

    DecodeProc $DecodeList
}

#
# Action 'Info'
#
# Info about a file. This displays either the zeroeth part of a file or
# the first part up to the first encoded line
#

proc Info {} {
    set TheInfoFile [ lindex [ ._MainFrame._FileList._Liste curselection ] 0 ]

    if { $TheInfoFile == {} } {
	return
    }
    InfoFile $TheInfoFile
}

proc InfoFile { TheInfoFile } {
    global FileList

    set oldCursor  [ lindex [ . config -cursor ] 4 ]
    set oldText    [ lindex [ ._Status._Text config -text ] 4 ]
    set FileName   [ lindex [ lindex $FileList $TheInfoFile ] 2 ]
    set FileNumber [ lindex [ lindex $FileList $TheInfoFile ] 0 ]

    if { $FileName == "" } {
	return
    }

    . config -cursor watch
    ._Status._Text config -text "Getting File Info for $FileName"

    if { [ catch { .info configure } ] } {
	toplevel .info
	frame .info.top
	frame .info.bot
	text .info.top.text -relief raised -bd 2 -wrap none \
		-xscrollcommand ".info.top.sbx set" \
		-yscrollcommand ".info.top.sby set" 
	scrollbar .info.top.sbx -command ".info.top.text xview" \
		-orient horizontal
	scrollbar .info.top.sby -command ".info.top.text yview"

	pack .info.top.sbx -side bottom -fill x
	pack .info.top.sby -side right -fill y
	pack .info.top.text -fill both -expand 1

	button .info.bot.done -text "Done" -command "destroy .info"
	pack .info.bot.done -side right -padx 4 -pady 4

	pack .info.top -side top -fill both -expand 1
	pack .info.bot -side bottom
    }

    wm title .info "Info about [ file tail $FileName ]"

    .info.top.text configure -state normal

    if { [ catch { uu_InfoFile $FileNumber .info.top.text } errorMsg ] } {
	tk_dialog ._Dialog "No Info" "The following problem occured\
		while trying to get Info: $errorMsg" error 0 OK
    }

    .info.top.text configure -state disabled

    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
}

#
# Action 'List'
#

proc List {} {
    global FileList

    set ListFile [ lindex [ ._MainFrame._FileList._Liste curselection ] 0 ]

    if { $ListFile == {} } {
	return;
    }

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]
    set FileName  [ lindex [ lindex $FileList $ListFile ] 2 ]

    . config -cursor watch
    ._Status._Text config -text "Listing $FileName"

    if { [ catch { .list configure } ] } {
	toplevel .list
	frame .list.top
	frame .list.bot
	text .list.top.text -relief raised -bd 2 -wrap none \
		-xscrollcommand ".list.top.sbx set" \
		-yscrollcommand ".list.top.sby set" 
	scrollbar .list.top.sbx -command ".list.top.text xview" \
		-orient horizontal
	scrollbar .list.top.sby -command ".list.top.text yview"

	pack .list.top.sbx -side bottom -fill x
	pack .list.top.sby -side right -fill y
	pack .list.top.text -fill both -expand 1

	button .list.bot.done -text "Done" -command "destroy .list"
	pack .list.bot.done -side right -padx 4 -pady 4

	pack .list.top -side top -fill both -expand 1
	pack .list.bot -side bottom
    }

    wm title .list "Listing of [ file tail $FileName ]"

    .list.top.text configure -state normal

    if { [ catch { uu_ListFile $ListFile .list.top.text } errorMsg ] } {
	tk_dialog ._Dialog "Oops" "The following problem occured\
		while trying to list the file: $errorMsg" error 0 OK
    }

    .list.top.text configure -state disabled

    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
}

#
# Action 'Rename'
#

proc Rename {} {
    global FileList
    global NewName
    global OldName
    global RenBut

    set RenameList [ ._MainFrame._FileList._Liste curselection ]
    set count      [ llength $RenameList ]
    set oldCursor  [ lindex [ . config -cursor ] 4 ]
    set oldText    [ lindex [ ._Status._Text config -text ] 4 ]
    set oldFocus   [ focus ]

    if { $RenameList == {} } {
	return;
    }

    toplevel .rename
    frame .rename.cur -relief raised -bd 1
    frame .rename.new -relief raised -bd 1
    frame .rename.but -relief raised -bd 2
    frame .rename.but.but

    label .rename.cur.lab -text "Old Name: "
    entry .rename.cur.nam -width 40 -relief sunken -bd 2 \
	    -textvariable OldName
    label .rename.new.lab -text "New Name: "
    entry .rename.new.nam -width 40 -relief sunken -bd 2 \
	    -textvariable NewName

    pack .rename.cur.nam -side right -padx 8 -pady 8
    pack .rename.new.nam -side right -padx 8 -pady 8
    pack .rename.cur.lab -side left -padx 8 -pady 8 -fill x
    pack .rename.new.lab -side left -padx 8 -pady 8 -fill x

    button .rename.but.but.ok  -text "Ok"     -command "set RenBut 1"
    button .rename.but.but.can -text "Cancel" -command "set RenBut 0"

    pack .rename.but.but.ok  -side left -padx 4 -pady 4 -fill x
    pack .rename.but.but.can -side left -padx 4 -pady 4 -fill x
    pack .rename.but.but

    pack .rename.cur -side top -fill x
    pack .rename.new -side top -fill x
    pack .rename.but -side bottom -fill x

    bind .rename.new.nam <Return> "set RenBut 1"

    wm title .rename "Rename"
    . config -cursor watch
    set oldFocus [ focus ]
    tkwait visibility .rename
    grab set .rename
    focus .rename

    for { set index 0 } { $index < $count } { incr index } {
	set ItemNo     [ lindex $RenameList $index ]
	set FileName   [ lindex [ lindex $FileList $ItemNo ] 2 ]
	set FileNumber [ lindex [ lindex $FileList $ItemNo ] 0 ]

	._Status._Text config -text "Renaming $FileName"

	.rename.cur.nam configure -state normal
	set OldName $FileName
	set NewName $FileName
	.rename.cur.nam configure -state disabled
	set RenBut {}
	update
	tkwait variable RenBut

	if { $RenBut == 0 } {
	    break
	} elseif { $RenBut == 1 && $NewName != {} } {
	    if { [ catch { uu_Rename $ItemNo [file tail $NewName] } eMsg ] } {
		tk_dialog ._Dialog "Oops" "Couldn't rename the file for\
			the following reason: $eMsg" error 0 OK
	    }
	}
    }
    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
    destroy .rename
    focus $oldFocus

    ShowFileList
}

#
# Action 'Execute'
#

proc Execute {} {
    global FileList
    global FileTypes
    global ExeCom
    global ExeBut

    ifndef ExeCom {}

    set ListFile [ lindex [ ._MainFrame._FileList._Liste curselection ] 0 ]
    set app {}

    if { $ListFile == {} } {
	return;
    }

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]
    set FileName  [ lindex [ lindex $FileList $ListFile ] 2 ]
    set FileNumb  [ lindex [ lindex $FileList $ListFile ] 0 ]
    set mimtype   [ lindex [ lindex $FileList $ListFile ] 3 ]
    set oldFocus  [ focus ]

    . config -cursor watch
    ._Status._Text config -text "Decoding $FileName to temp file"
    update

    if { [ catch { uu_GetTempFile $FileNumb } tempFile ] } {
	tk_dialog ._Dialog "Error while decoding" "The following problem\
		occured while decoding: $tempFile" \
		error 0 OK
    } else {
	#
	# Do we have a Content-Type:
	#

	if { $mimtype != "" } {
	    set app [ GetTypeAction $mimtype ]
	}

	#
	# try to determine app from file extension
	#

	if { $app == "" } {
	    set lfn [ split [ string tolower $FileName ] . ]
	    set ext [ lindex $lfn [ expr [ llength $lfn ] - 1 ] ]

	    if { [ set mimtype [ GetTypeByExtension $ext ] ] != "" } {
		set app [ GetTypeAction $mimtype ]
	    }
	}

	#
	# if we have no app yet, ask the user
	#

	if { $app == "" } {
	    toplevel .app
	    label .app.msg -wraplength 3i -relief raised -bd 1 -text "Enter \
		    a command line to execute. Use %s for the file name.\
		    Do not attempt to background the command."

	    pack .app.msg -side top -ipadx 8 -ipady 8 -fill x

	    frame .app.com
	    label .app.com.lab -text "Command: "
	    entry .app.com.ent -relief sunken -bd 2 \
		    -textvariable ExeCom
	    pack .app.com.lab -side left -padx 8 -pady 8
	    pack .app.com.ent -side right -padx 8 -pady 8 -fill x -expand 1
	    pack .app.com -side top -fill x
	    
	    frame .app.but -relief raised -bd 2
	    frame .app.but.but
	    button .app.but.but.ok -text "Execute" -command "set ExeBut 1"
	    button .app.but.but.can -text "Cancel" -command "set ExeBut 0"
	    pack .app.but.but.ok -side left -padx 4 -pady 4 -fill x
	    pack .app.but.but.can -side left -padx 4 -pady 4 -fill x
	    pack .app.but.but
	    pack .app.but -side bottom -fill x

	    bind .app.com.ent <Return> "set ExeBut 1"

	    wm title .app "Execute Command"
	    tkwait visibility .app
	    grab set .app
	    focus .app

	    ._Status._Text config -text "Watiting for you to enter command"
	    set ExeBut {}
	    update
	    tkwait variable ExeBut
	    destroy .app
	    focus $oldFocus

	    if { $ExeBut == 1 } {
		set app $ExeCom
	    }
	}

	if { $app != "" } {
	    set RunString [ format $app $tempFile ]

	    ._Status._Text config -text "Watiting for child to terminate"

	    update

	    if { [ catch { eval exec $RunString } errorMsg ] } {
		tk_dialog ._Dialog "Execution failed" "The following problem\
			occured while executing your command: $errorMsg" \
			error 0 OK
	    }
	}
    }
    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
    focus $oldFocus
}

#
# Menu Help->About
#

proc About {} {
    global AboutFinish
    global FrankGFP

    set w ._About
    set AboutFinish {}

    toplevel $w
    wm title $w "About UUDeview"

    #
    # don't load the image if less than 256 colors or colormap full
    #

    if { [ catch { winfo colormapfull $w } cmf ] } {
	set cmf 0
    }

    if { [ winfo depth $w ] >= 8 && ! $cmf } {
	if { ! [ catch { image create photo Frank -data $FrankGFP } ] } {
	    frame $w._Image -relief raised -bd 2
	    label $w._Image._Frank -image Frank
	    label $w._Image._Name -text "This Is Me"
	    pack $w._Image._Frank $w._Image._Name -side top
	    pack $w._Image -side left -padx 3 -pady 3
	}
    }
    frame $w._Right
    label $w._Right._Text1 -text "UUDeview Version\
	[ lindex [ lindex [ uu_Info version ] 0 ] 1 ]" \
	    -font -Adobe-Helvetica-Bold-R-Normal--*-180-*-*-*-*-*-*
    label $w._Right._Text2 -text "Written by Frank Pilhofer"
    label $w._Right._Text3 -text "fp@informatik.uni-frankfurt.de\
	    \nhttp://www.uni-frankfurt.de/~fp/"
    label $w._Right._Text4 -text "This software is Freeware and may be\
	    distributed freely. But if you happen to like it, why not\
	    surprise the Author with a postcard, sent to" \
	    -font -Adobe-Helvetica-Bold-R-Normal--*-100-*-*-*-*-*-* \
	    -wraplength 3i
    label $w._Right._Addr -text "Frank Pilhofer\nDarmstadter Str. 22\
	    \n63225 Langen\nGermany" -justify left
    button $w._Right._Button -text "Ok" -command { set AboutFinish ok }

    pack $w._Right._Button -fill both -padx 10 -pady 3 -side bottom
    pack $w._Right._Text1 $w._Right._Text2 $w._Right._Text3 \
	    $w._Right._Text4 $w._Right._Addr \
	    -fill both -padx 10 -pady 5 -side top
    pack $w._Right -fill both

    set oldFocus [ focus ]
    tkwait visibility $w
    grab set $w
    focus $w
    tkwait variable AboutFinish
    destroy $w
    focus $oldFocus
}

#
# Menu Help->License
#

proc License {} {
    global COPYING

    set oldCursor [ lindex [ . config -cursor ] 4 ]
    set oldText   [ lindex [ ._Status._Text config -text ] 4 ]

    . config -cursor watch
    ._Status._Text config -text "Loading and Displaying License"

    if { [ catch { set COPYING } ] } {
	tk_dialog ._Dialog "Not Available" "I could not load the License\
		file. You received a copy of the GPL (GNU General Public\
		License) in the file COPYING along with the UUDeview\
		distribution. Please refer to this file instead." \
		error 0 OK
    } elseif { [ catch { .license configure } ] } {
	toplevel .license
	frame .license.top
	frame .license.bot
	text .license.top.text -relief raised -bd 2 -wrap none \
		-xscrollcommand ".license.top.sbx set" \
		-yscrollcommand ".license.top.sby set" \
		-font -*-Courier-Medium-R-Normal--*-120-*-*-*-*-*-*
	scrollbar .license.top.sbx -command ".license.top.text xview" \
		-orient horizontal
	scrollbar .license.top.sby -command ".license.top.text yview"

	pack .license.top.sbx -side bottom -fill x
	pack .license.top.sby -side right -fill y
	pack .license.top.text -fill both -expand 1

	button .license.bot.done -text "Done" -command "destroy .license"
	pack .license.bot.done -side right -padx 4 -pady 4

	pack .license.top -side top -fill both -expand 1
	pack .license.bot -side bottom

	wm title .license "GPL - Gnu General Public License"

	regsub -all "#" $COPYING "" TempText

	.license.top.text insert 1.0 $TempText
	.license.top.text configure -state disabled
    }

    ._Status._Text config -text $oldText
    . config -cursor $oldCursor
}

##############################################################################
## Display helper functions
##############################################################################

#
# these two procedures are needed to keep 2 listboxes in sync
#

proc ScrollCommand { args } {
    eval ._MainFrame._FileList._Status yview $args
    eval ._MainFrame._FileList._Liste  yview $args
}

proc UpdateListScroll { idlb1 idlb2 idsb first last } {
    set InMotion 1
    if { [ $idlb1 size ] } {
	set lbnf [ expr $first + 0.5 / [ $idlb1 size ] ]
    } else {
	set lbnf $first
    }
    $idsb set $first $last
    
    $idlb1 yview moveto $lbnf
    $idlb2 yview moveto $lbnf
}

proc UpdateSBScroll { idlb1 idlb2 idsb command number { units "" } } {
    set InMotion 1
    if { [ $idlb1 size ] } {
	set lbnf [ expr $number + 0.5 / [ $idlb1 size ] ]
    } else {
	set lbnf $number
    }
    if { $command == "scroll" } {
	$idlb1 yview $command $number $units
	$idlb2 yview $command $number $units
	update
    } elseif { $command == "moveto" } {
	$idlb1 yview $command $lbnf
	$idlb2 yview $command $lbnf
	update
    } else {
	puts "Unknown Scrolling Command: $view $command $number $units"
    }
}

##############################################################################
## Build our Main Frame
##############################################################################

#
# Menu Bar
#

frame ._MainMenu -relief raised -bd 4

menubutton ._MainMenu._File    -text File    -underline 0 \
	-menu ._MainMenu._File._Menu
menubutton ._MainMenu._Options -text Options -underline 0 \
	-menu ._MainMenu._Options._Menu
menubutton ._MainMenu._Actions -text Actions -underline 0 \
	-menu ._MainMenu._Actions._Menu
menubutton ._MainMenu._Help    -text Help    -underline 0 \
	-menu ._MainMenu._Help._Menu

menu ._MainMenu._File._Menu
menu ._MainMenu._Options._Menu
menu ._MainMenu._Actions._Menu
menu ._MainMenu._Help._Menu

._MainMenu._File._Menu add command -label "Load ..." -underline 0 \
	-command "Load"
._MainMenu._File._Menu add command -label "Encode ..." -underline 0 \
	-command "Encode"
._MainMenu._File._Menu add separator
._MainMenu._File._Menu add command -label "Helpers" -underline 0 \
	-command "MimeSetup"
._MainMenu._File._Menu add command -label "Save Setup" -underline 0 \
	-command "SaveSetup"
._MainMenu._File._Menu add separator
._MainMenu._File._Menu add command -label "Quit" -underline 0 \
	-command "Quit"

._MainMenu._Options._Menu add checkbutton -label "Fast Scanning" \
	-underline 0 -selectcolor black -variable OptionFast
._MainMenu._Options._Menu add checkbutton -label "Automatic Overwrite" \
	-underline 10 -selectcolor black -variable OptionOverwrite
._MainMenu._Options._Menu add checkbutton -label "Desperate Mode" \
	-underline 10 -selectcolor black -variable OptionDesperate
._MainMenu._Options._Menu add checkbutton -label "Verbose Mode" \
	-underline 0 -selectcolor black -variable OptionVerbose
._MainMenu._Options._Menu add checkbutton -label "Alternate Bracket Policy" \
	-underline 0 -selectcolor black -variable OptionBracket
._MainMenu._Options._Menu add checkbutton -label "Dumb Mode" \
	-underline 0 -selectcolor black -variable OptionDumbness
._MainMenu._Options._Menu add checkbutton -label "Handle Text Files" \
	-underline 0 -selectcolor black -variable OptionUsetext
._MainMenu._Options._Menu add checkbutton -label "Auto Info" \
	-underline 5 -selectcolor black -variable OptionAutoInfo

._MainMenu._Actions._Menu add command -label "Decode" -underline 0 \
	-command "Decode"
._MainMenu._Actions._Menu add command -label "Rename" -underline 0 \
	-command "Rename"
._MainMenu._Actions._Menu add command -label "Decode All" -underline 7 \
	-command "DecodeAll"
._MainMenu._Actions._Menu add command -label "Info" -underline 0 \
	-command "Info"
._MainMenu._Actions._Menu add command -label "Execute" -underline 0 \
	-command "Execute"
._MainMenu._Actions._Menu add command -label "List Text File" -underline 0 \
	-command "List"

._MainMenu._Help._Menu add command -label "About ..."   -underline 0 \
	-command "About"
._MainMenu._Help._Menu add command -label "License ..." -underline 0 \
	-command "License"
#._MainMenu._Help._Menu add command -label "Index ..."   -underline 0 \
#	-command "Index"

pack ._MainMenu._File ._MainMenu._Options ._MainMenu._Actions \
	._MainMenu._Help -side left
pack ._MainMenu._Help -side right

tk_menuBar ._MainMenu ._MainMenu._File ._MainMenu._Options \
	._MainMenu._Actions ._MainMenu._Help

#
# middle part, on the left the file listboxes, on the right some buttons
#

frame ._MainFrame -relief raised -bd 2

#
# Left: file listboxes and scrollbar
#

frame ._MainFrame._FileList
#
# definition of the second listbox which I couldn't get to work properly
#
# Design 1
#
#listbox ._MainFrame._FileList._Status -relief sunken -width 4 \
#	-yscrollcommand "\
#	UpdateListScroll ._MainFrame._FileList._Status \
#	                 ._MainFrame._FileList._Liste \
#                         ._MainFrame._FileList._Scrollbar "
#listbox ._MainFrame._FileList._Liste -relief sunken -selectmode extended \
#	-yscrollcommand "\
#	UpdateListScroll ._MainFrame._FileList._Status \
#	                 ._MainFrame._FileList._Liste \
#                         ._MainFrame._FileList._Scrollbar "
#scrollbar ._MainFrame._FileList._Scrollbar -command " \
#	UpdateSBScroll ._MainFrame._FileList._Status \
#	                 ._MainFrame._FileList._Liste \
#			 ._MainFrame._FileList._Scrollbar "
#pack ._MainFrame._FileList._Status -side left -padx 8 -pady 8 -fill y
#
# Design 2
#
#listbox ._MainFrame._FileList._Liste -relief sunken -selectmode extended \
#	-yscrollcommand "._MainFrame._FileList._Scrollbar set"
#scrollbar ._MainFrame._FileList._Scrollbar \
#	-command "._MainFrame._FileList._Liste yview"
#pack ._MainFrame._FileList._Liste -side left -padx 8 -pady 8 \
#	-expand true -fill both
#
# Design 3
#
listbox ._MainFrame._FileList._Status -relief sunken -width 8 \
	-yscrollcommand { ._MainFrame._FileList._Scrollbar set } \
	-exportselection false
listbox ._MainFrame._FileList._Liste -relief sunken -selectmode extended \
	-yscrollcommand { ._MainFrame._FileList._Scrollbar set } \
	-exportselection false
scrollbar ._MainFrame._FileList._Scrollbar \
	-command ScrollCommand
pack ._MainFrame._FileList._Status -side left -padx 8 -pady 8 -fill y
pack ._MainFrame._FileList._Liste -side left -padx 8 -pady 8 \
	-expand true -fill both
pack ._MainFrame._FileList._Scrollbar -pady 8 -side right -fill y

if { [ lindex [ ._MainFrame._FileList._Liste configure -width ] 4 ] < 20 } {
    ._MainFrame._FileList._Liste configure -width 20
}

#
# Right: some buttons
#

frame ._MainFrame._Buttons
button ._MainFrame._Buttons._Load    -text "Load"    -command "Load"
button ._MainFrame._Buttons._Decode  -text "Decode"  -command "Decode"
button ._MainFrame._Buttons._Execute -text "Execute" -command "Execute"
button ._MainFrame._Buttons._Info    -text "Info"    -command "Info"
button ._MainFrame._Buttons._Quit    -text "Quit"    -command "Quit"

pack ._MainFrame._Buttons._Load \
	._MainFrame._Buttons._Decode ._MainFrame._Buttons._Execute \
	._MainFrame._Buttons._Info   ._MainFrame._Buttons._Quit \
	-ipadx 4 -ipady 4 -fill x -padx 2 -pady 2

#
# packe MainFrame
#

pack ._MainFrame._FileList -side left -expand true -fill both
pack ._MainFrame._Buttons  -side right -padx 8 -pady 8 -anchor center

#
# Down: Save Path
#

frame  ._SPEntry -relief raised -bd 2
button ._SPEntry._Label -text "Save Path:" -bd 1 -command {
    set NewPath [ tk_SelectFiles "Savefile Path" 0 2 $SaveFilePath ]
    if { $NewPath != "" } {
	if { [ CheckWritable $NewPath ] } {
	    set SaveFilePath [ CompressSlashes $NewPath ]
	}
    }
}
entry  ._SPEntry._Path -relief sunken -textvariable SaveFilePath
pack   ._SPEntry._Label -side left -padx 4 -pady 4
pack   ._SPEntry._Path -side right -padx 4 -pady 4 -fill x -expand true

#
# noch weiter unten: Statuszeile
#

frame ._Status -relief sunken -bd 1
label ._Status._Desc -text "Status: " \
	-font -Adobe-Helvetica-Bold-R-Normal--*-100-*-*-*-*-*-*
label ._Status._Text -text "OK" -justify left -anchor w \
	-font -Adobe-Helvetica-Bold-R-Normal--*-100-*-*-*-*-*-*
pack ._Status._Desc -side left -padx 2 -pady 2
pack ._Status._Text -side left -pady 2 -fill x

#
# Packe alles zusammen
#

pack ._MainMenu -side top -fill x
pack ._Status -side bottom -fill x
pack ._SPEntry -side bottom -fill x
pack ._MainFrame -expand true -fill both

#
# Bindings
#

bind ._SPEntry._Path <Return> {
    if { $SaveFilePath == {} } {
	set SaveFilePath [ pwd ]
    }
    set SaveFilePath [ CompressSlashes $SaveFilePath ]
    CheckWritable $SaveFilePath
}

#
# AutoInfo pops up Info about a file whenever the user clicks on it
#

bind ._MainFrame._FileList._Liste <Button-1> {
    if { $OptionAutoInfo } {
	set TheInfoFile [ ._MainFrame._FileList._Liste index @%x,%y ]

	if { $TheInfoFile != "" } {
	    InfoFile $TheInfoFile
	}
    }
}

#
# continued in Xdeview.tail
#


