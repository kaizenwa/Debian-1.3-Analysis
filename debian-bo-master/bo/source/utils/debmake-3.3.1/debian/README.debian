debmake for DEBIAN
------------------

To debianize a packet:

1. Uncompress the source packet that you got via ftp.

2. Rename the source package to conform to the debian scheme of naming
   things. No uppercase! Sourcepackage name separated by - from the version.

3. cd in to the source package

4. execute "deb-make"

5. Customize files in debian and do whatever is needed to make the "make
   install" put the files into the correct directories in debian/tmp. By
   default debian/rules will pass a environment variable DESTDIR pointing
   to the absolute path of debian/tmp. If you put DESTDIR in front of all
   the absolute filenames used for installing the package in the Makefile
   then the regular installation will still work. You might submit a patch
   to the author to this effect.

Remember this is to get you started. You can edit lots of things in the
debian directory. Read especially the "debstd" manpage because this governs
how your package is generated. The *.ex files are examples customized for
your package that you can activate by removing the .ex ending. If you
want to get rid of those simply delete them.

The debian/dirs file
--------------------

Usually install scripts do not install directories like /usr/man for you.
The "dirs" file needs to be edited to contain the RELATIVE directorynames
that your package needs. Example:

usr/bin
usr/man/man{1,5}

Note: No leading slash!

Additional Features of Debmake (Read the manpages):
- debchange (abbreviation dch): modifies debian/changelog and manages
	version numbers for you. It will automatically increment the release
	if you have used the release command. You can stop worrying about
	version numbering using this tool.

- debstd: automatizes binary packages. This is one of the most
	important tools called from debian/rules to set up the
	binary tree under debian/tmp. Read the manpage carefully!

- debpkg: a wrapper for dpkg used by debi to allow convenient
	testing. debpkg needs to be invoked from your useraccount
	and will gain superuser priviledges to execute dpkg commands.
	These priviledges are necessary to test packages. If you
	have debpkg so equipped then you do not need to become superuser
	to install/test the package. That is a good thing to decrease the
	potential damage from accidental wrong use of commands in superuser
	mode (i.e. an inadvertant rm -rf * in the wrong directory is
	desastrous as I and many others can attest to)

- build: a wrapper for building a package to avoid problems with
	insufficient permissions and wrong paths. Build needs to have
	superuser priviledges to invoke all the tools to build the
	sourcepackages the binary packages and make everything ready for
	upload by using PGP to certify the authenticity of the package

- release: releases software (upload/announce/sync version numbers)
	and clears bug reports. Release will publicize the package
	you have been developing. Usually it is invoked after a successful
	"build" and proper testing of a package.

- debi: Install current package
	Invoked from the sourcedirectory it will install the package
	that was just build without any parameters. You will need that
	functionality frequently when troubleshooting packages.

- debc: List contents of current package. Do this after a successful
	"build" to see if the package looks all right.

- debclean: Clean a sourcetree. Debclean will remove all files that were
	generated from the current directory and all directories below.
	It will keep important .diffs or original files so that the binaries
	and other files can be rebuild if necessary. debclean can be invoked
	from userspace and will deal correctly with strange permissions in
	the debian/tmp directories.

- debsums: Check the integrity of the packages files
	Suspecting a package has been compromised by another application
	or a virus or so? Run this tool to find out if anything happened
	to the files.

- debconf: Run a pre-installation configure script

- uupdate: Update the package with .tar.gz or patches from
	an upstream author. This will be of help if you have to update
	your package. It will try to apply the latest diffs to the new
	package and tell you how successful it was.

- uscan: Automatically scan + apply upstream updates. Uscan can be used
	to check upstream ftp sites for any updates available. Uscan
	can then trigger automatic package building or something else
	(This is really fancy... Imagine you could be on vacation and
	suddenly your machine releases an update of a package...)

- deblint: Verify that a binary package conforms to some standards.
	(Only needed for packages not build using debmake to insure that
	they follow standards as well!)

- todo,done Keep a list of things to be done and move them into the
	changelog when done.

Typical Maintenance cycle with debmake
--------------------------------------

1. cd <sourcedirectory of package>

2. Editing of files

3. Log the changes with: dch "I changed this"

4. Run "debian/rules" to compile it. If it fails back to 2.
   (If lazy simply skip step 4, build will also compile)

5. build package with "build" if failure back to 2.

6. Check if package contents are ok with "debc"

7. Testinstall the package with "debi" and test the
   functionality it should provide.

8. If all is ok release it by executing "release"

Wrappers
--------

debmake comes with wrappers (the above mentioned "build" and "debpkg")  that
make life easier for you. These wrappers are doing filtering of environment
variables, setting a secure searchpath and only allow certain commands to be
executed. Processing Makefiles is inherently dangerous though since
any UNIX command can be executed. Thus these wrappers have to be manually
equipped to gain the necessary priviledges to do their jobs. Otherwise you
might activate something that is a security problem for your particular
setup.

You can either invoke these wrappers from "sudo" or
"super" or any other way you have to control superuser access

	OR

set them up to be accessible from a group of users (Some people suggest that
this is highly dangerous since it creates another executable that runs with
the Superuser bit set(!) and which wont ask you ever for a password!) by
issuing the following command:

      chmod 4754 /usr/bin/{build,debpkg}

after each upgrade. This will enable access to the wrappers for all
users who are members of the group "root". You are in effect giving those
users superuser access to your system!

You can avoid the repetition by using suidmanager. debmake is fully
supporting suidmanager. Make sure the suidmanager package is installed then do

	suidregister /usr/bin/build root your_group 4754
	suidregister /usr/bin/debpkg root your_group 4754

If you would like another group to determine who has access to these
wrappers then change the group ownership of these files.

I would recommend the above method especially for beginner for whom the
other tools to gain superuser priviledges are not well known. Only do this
on your home linux box NOT on a busy internet server!

Christoph Lameter <clameter@waterf.org>
