.\" Copyright (c) 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUARS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED A, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUARS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED A, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR ART (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)printf.3	6.14 (Berkeley) 7/30/91
.\"
.\" Converted for Linux, Mon Nov 29 12:06:07 1993, faith@cs.unc.edu
.\"
.\"
.\" Traducido al castellano (con permiso) por:
.\" Sebastian Desimone (chipy@argenet.com.ar) (desimone@fasta.edu.ar)
.TH PRINTF 3  "Enero 10, 1995" "BSD" "Manual del Programador de Linux"
.SH NOMBRE
printf, fprintf, sprintf, vprintf, vfprintf, vsprintf \- conversión de 
salida formateada
.SH SINOPSIS
.B #include <stdio.h>
.sp
.BI "int printf( const char *" format ", ...);"
.br
.BI "int fprintf( FILE *" stream ", const char *" format ", ...);"
.br
.BI "int sprintf( char *" str ", const char *" format ", ...);"
.sp
.B #include <stdarg.h>
.sp
.BI "int vprintf( const char *" format ", va_list " ap );
.br
.BI "int vfprintf( FILE *" stream ", const char *" format ", va_list " ap );
.br
.BI "int vsprintf( char *" str ", char *" format ", va_list " ap );
.SH DESCRIPCION
La familia de funciones
.B printf
produce una salida de acuerdo a
.I format
como se describe abajo.
.B Printf
y
.B vprintf
escriben su salida a
.IR stdout ,
la corriente (stream) de salida estandar;
.B fprintf
y
.B vfprintf
escriben su salida a la
.IR stream 
dada ;
.BR sprintf ,
y
.BR vsprintf
escriben a una cadena de caracteres
.IR  str .
Todas estas funciones escriben la salida bajo el control de una cadena
.I format
que especifica como los subsecuentes argumentos (o argumentos accedidos
via las facilidades de argumentos de longitud variables de
.BR stdarg (3)
son convertidos para su salida. Estas funciones retornan el número de 
caracteres impresos (no incluyendo el delimitador `\e0' usado para terminar
la salida de cadenas).
.PP
La cadena \fBformat\fP está compuesta de cero o más directivas: caracteres
ordinarios (no
.BR % ),
que son copiados sin cambios a la corriente (stream) de salida; y 
especificaciones de conversión, cada una de las que resulta en ir a buscar
cero o más subsecuentes argumentos. Cada especificación de conversión es 
introducida por el caracter
.BR % .
Los argumentos deben corresponder adecuadamente según la conversión 
especificada. Luego de
.BR % ,
los siguientes caracteres pueden aparecer en secuencia:
.TP
.B \(bu
Cero o más de las siguientes banderas:
.RS
.TP
.B #
especificando que el valor debe ser convertido a un ``formato alternativo''.
Para las conversiones
.BR c ,
.BR d ,
.BR i ,
.BR n ,
.BR p ,
.BR s ,
y
.BR u
, esta opción no tiene efecto. Para la conversión
.BR o
, la precisión del número es incrementada para forzar el primer caracterer
de la cadena de salida a cero ( excepto que un valor cero sea impreso con 
una explícita precisión de cero). 
Para conversiones
.B x
y
.B X
, un resultado distinto de cero tiene la cadena `0x' (o `0X' para conversiones
.B X
) precediendola.  Para conversiones
.BR e ,
.BR E ,
.BR f ,
.BR g ,
y
.B G
, el resultado siempre contendrá un punto decimal, aún si ningún dígito lo
sigue ( normalmente, un punto decimal aparece solamente en el resultado de
aquellas conversiones que son seguidas de algún dígito). Para conversiones 
.B g
y
.B G
, los ceros finales (trailing zeros) no son removidos del resultado.
.TP
.B \&0
especificando el relleno con ceros. Para todas las converiones excepto
.BR n ,
el valor convertido es rellenado a la izquierda con ceros en vez de blancos.
Si una precisión es dada con una conversión numérica
.BR "" ( d ,
.BR i ,
.BR o ,
.BR u ,
.BR i ,
.BR x ,
y
.BR X ),
la bandera
.B \&0
es ignorada.
.TP
.B \-
(un campo negativo como flag) indica que el valor convertido es justificado
a la izquierda sobre el límite del campo. Excepto para conversiones
.B n
, el valor convertido es rellenado a la derecha con blancos, en vez de a la
izquierda con blancos o ceros. Un
.B \-
sobreescribe un 
.B \&0
si ambos son dados.
.TP
.B ""
(un espacio) especifica que un blanco debe ser dejado antes de que un número
positivo sea producido por una conversión de signo
.BR "" ( d ,
.BR e ,
.BR E ,
.BR f ,
.BR g ,
.BR G ,
o
.BR i ).
.TP
.B +
especifica que el signo siempre sera ubicado antes de un número producido pora
una conversión con signo.  Un
.B +
sobreescribe un espacio si ambos son usados.
.RE
.TP
.B \(bu
Una cadena de dígitos decimales opcionales especifican un ancho de campo
mínimo, este puede ser rellenado con espacios a la izquierda (o derecha,
si el flag de justificado a la izquierda a sido dado) para llenar el ancho
del campo.
.TP
.B \(bu
Una opcional precisión, con formato de un punto (`\&.') seguido por una
cadena de dígitos opcionales. Si la cadena de dígitos es omitida, la 
precisición es tomada como cero. Esto da el mínimo número de dígitos 
para aparecer en las conversiones
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
y
.B X
, el número de dígitos para aparecer luego del punto decimal para las 
conversiones
.BR e ,
.BR E ,
y
.B f
, el máximo número de dígitos signifiativos para las conversiones 
.B g
y
.B G
, o el máximo número de caracteres a ser impresos desde una cadena para
las conversiones 
.B s
.
.TP
.B \(bu
El caracter opcional
.BR h ,
especifica que una de las siguientes
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
o
.BR X
corresponde a un argumento
.I short int
o
.I unsigned short int
, o que una conversión siguiente
.B n
corresponde a un puntero a un argumento
.I short int
.
.TP
.B \(bu
El caracter opcional
.B l
(ele) especifica que una de las siguinetes conversiones
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
o
.BR X
aplica a un puntero de argumento 
.I long int
o
.I unsigned long int
, que una conversión siguiente
.B n
corresponde a un puntero de argumento
.I long int
.
.TP
.B \(bu
El caracter
.BR L
espeficifa que una de las siguientes conversions
.BR e ,
.BR E ,
.BR f ,
.BR g ,
o
.B G
corrsponde a un argumento
.I long double
.
.TP
.B \(bu
Un caracter que especifica el tipo de conversión a ser aplicado.
.PP
Un campo de ancho o precisión, o ambos, pueden ser indicados por un asterisco 
`*' a menos de una cadena de dígitos. En este caso, un argumento
.I int
suministra el campo de ancho o precisión. Un campo negativo es tratado
como una bandera de justificado a la izquierda seguida por un campo de ancho
positivo; una precisión negativa es tratada como si estuviese perdida.
.PP
Los especificadores de conversión y sus significados son:      
.TP
.B diouxX
El argumento
.I int
( o la apropiada variante) es convertida a un decimal con signo
.BR "" ( d
y
.BR i ),
a octal sin signo
.BR "" ( o ,
a decimal sin signo
.BR "" ( u ,
a hexadecimal sin signo
con notación 
.BR "" ( x
y
.BR X )
.  Las letras
.B abcdef
son usadas para conversiones
.B x
; las letras
.B ABCDEF
son usadas para conversiones
.B X
. La precisión, cualquira, da el mínimo número de dígitos que deben aparecer;
si el valor convertido requiere menos dígitos, este es rellenado a la
izquierda con ceros.
.TP
.B DOU
El argumento
.I long int
es convertido a un decimal con signo, octal sin signo, o decimal sin signo,
como si el formato haya sido
.BR ld ,
.BR lo ,
o
.B lu
respectivamente. Esas conversiones caracter son despreciadas, y pueden
eventualmente desaparecer. 
.TP
.B eE
El argumento 
.I double
es redondeado y convertido en un estilo
.BR "" [\-]d \&. ddd e \\*(Pmdd
donde hay un dígito antes del caracter del punto decimal y el número de
dígitos despues de este es igual a la precisión; si la precisión esta
perdida, es tomada como 6; si la precisión es cero, ningún caracter del
punto decimal aparece. Una conversión
.B E
usa la letra
.B E
( en vez de 
.BR e )
para introducir el exponente. El exponente siempre contiene al menos dos
dígitos; si el valor es cero, el exponente es 00.
.TP
.B f
El argumento
.I double
es redondeado y convertido a una notación decimal del estilo
.BR "" [-]ddd \&. ddd,
donde el número de dígitos luego del caracter del punto decimal es igual a 
la especificación de la precisión. Si la precisión esta
perdida, es tomada como 6; si la precisión es cero, ningún caracter del
punto decimal aparece. Si un punto decimal aparece, al menos un dígito aparece
despues de este.
.TP
.B g
El argumento
.I double
es convertido al estilo de
.B f
o
.B e
(o
.B E
para conversiones
.B G
). La precisión especifica el número de dígitos significativos.
Si la precisión esta perdida, 6 dígitos son dados; si la precisión es cero,
esta es tratada como 1. El estilo
.B e
es usado si el exponente para esta conversión es menor que \-4 o más grande
o igual a la precisión. Ceros finales son removidos de la parte fraccional
del resultado; un punto decimal solo aparece si es seguido de al menos un
dígito. 
.TP
.B c
El argumento
.I int
es convertido a un
.IR "unsigned char" ,
y el caracter resultante es escrito.
.TP
.B s
El argumento
.IR "" `` "char *" ''
es esperado como un tipo puntero a una cadena de caracteres. Caracteres del
array son escritos hasta (pero no incluyendo) un caracter terminador 
.B NUL
; si una precisión es especificada, no más que el número especificado
son escritos. Si una precisión es dada, ningún caracter nulo necesita estar
presente; si la precisión no es specificada, o es más grande que el tamaño
de la cadena, la cadena debe contener un caracter de terminación
.B NUL
.
.TP
.B p
El argumento puntero
.IR "" `` "void *" ''
es impreso en hexadecimal (como con
.B %#x
o
.BR  %#lx ).
.TP
.B n
El número de caracteres escritos hasta que es guardado en el entero indicado
por el argumento 
.IR "" `` "int *" ''
(o la variante). Ningún argumento es convertido.
.TP
.B %
Un `%' es escrito. Ningún argumento es convertido. La completa especificación
de conversión es `%%'.
.PP
En ningún caso un no existente o pequeño ancho de campo causa truncación del
campo; si el resultado de una conversión es más ancho que el especificado,
el campo es expandido para contener el resultado convertido.
.PP
.SH EJEMPLOS
.br
Para imprimir fecha y hora en la forma `Sunday, July 3, 10:02',
donde
.I weekday
y
.I month
son punteros a cadenas:
.RS
.nf
#include <stdio.h>
fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
	weekday, month, day, hour, min);
.fi
.RE
.PP
Para imprimir \*(Pi
con cinco lugares decimales:
.RS
.nf
#include <math.h>
#include <stdio.h>
fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));
.fi
.RE
.PP
Para alojar una cadena de 128 bytes e imprimirla:
.RS
.nf
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
char *newfmt(const char *fmt, ...)
{
		char *p;
		va_list ap;
		if ((p = malloc(128)) == NULL)
			return (NULL);
		va_start(ap, fmt);
		(void) vsnprintf(p, 128, fmt, ap);
		va_end(ap);
		return (p);
}
.fi
.RE
.SH "VER TAMBIEN"
.BR printf "(1), " scanf (3)
.SH STANDARDS
Las funciones
.BR fprintf ,
.BR printf ,
.BR sprintf ,
.BR vprintf ,
.BR vfprintf ,
y
.B vsprintf
estan conforme a ANSI C3.159-1989 (``ANSI C'').
.SH BUGS
Algunas conversiones de punto flotante bajo Linux causan pérdidas de memoria.
.PP
Los formatos de conversiones
.BR \&%D ,
.BR \&%O ,
y
.B %U
no son estandars y son provistos solo para compatibilidad hacia atrás. Pueden
no ser provistas bajo Linux.
.PP
El efecto de relleno del formato 
.B %p
con ceros (tanto por la bandera 
.B 0
o por especificar una precisión), y el benigno efecto (p.e., nada) de la
bandera
.B #
activa con las conversiones
.B %n
y
.B %p
, como con otras combinaciones sin sentido como
.BR %Ld ,
no son estandars; dichas combinaciones pueden ser evitadas.
.PP
Como
.B sprintf
y
.B vsprintf
asumen una cadana de largo infinito, llamadores deben ser cuidadosos de
no sobrepasar el espacio actual; esto es a menudo imposible de garantizar.
