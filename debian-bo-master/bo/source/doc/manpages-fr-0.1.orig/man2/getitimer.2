.\" Copyright 7/93 by Darren Senn (sinster@scintilla.santa-clara.ca.us)
.\" Based on a similar page Copyright 1992 by Rick Faith
.\" May be freely distributed
.\" 
.\" Traduction  11/10/1996 Christophe BLAESS (ccb@club-internet.fr)
.\" 
.TH GETITIMER 2 "11 Octobre 1996" "Linux 0.99.11" "Manuel du programmeur Linux"
.SH NOM
getitimer, setitimer \- Lire ou ecrire la valeur d'une temporisation.
.SH SYNOPSIS
.PD 0
.HP
.B #include <sys/time.h>
.sp
.HP
.B int getitimer(int
.IB which ,
.B struct itimerval
.BI * value );
.HP
.B int setitimer(int
.IB which ,
.B const struct itimerval
.BI * value ,
.B struct itimerval
.BI * ovalue );
.PD
.SH DESCRIPTION
Le systeme fournit pour chaque processus trois temporisations, chacune avec
un fonctionnement particulier.
Lorsqu'une temporisation expire, un signal est envoye au processus 
et la temporisation redemarre eventuellement.
.TP 1.5i
.B ITIMER_REAL
decroit en temps reel et un signal
.B SIGALRM
est emis a l'expiration du delai.
.TP
.B ITIMER_VIRTUAL
decroit uniquement quand le processus s'execute, et un signal
.B SIGVTALRM
est emis a l'expiration du delai.
.TP
.B ITIMER_PROF
decroit a la fois quand le processus s'execute, et quand le processeur
execute des fonctions systemes a la demande du processus.
Ce timer, utilise conjointement avec
.BR ITIMER_VIRTUAL,
est generalement utilise pour obtenir le profil d'execution du processus
entre les fonctionnalites utilisateur et le noyau.
.B SIGPROF
est emis a l'expiration du delai.
.LP
Les valeurs des temporisations sont definies avec les structures suivantes :
.PD 0
.RS .5i
.nf

struct itimerval {
  struct timeval it_interval; /* valeur suivante */
  struct timeval it_value;    /* valeur actuelle */
};

struct timeval {
  long tv_sec;                /* secondes        */
  long tv_usec;               /* micro secondes  */
};
.fi
.RE
.PD
.LP
.BR Getitimer (2)
renseigne la structure pointee par
.I value
avec le parametrage de la temporisation
.I which
(parmi
.BR ITIMER_REAL ,
.BR ITIMER_VIRTUAL ,
ou
.BR ITIMER_PROF ).
L'element
.B it_value
est rempli avec le delai restant dans la temporisation, ou zero si la
temporisation est desactivee. De meme
.B it_interval
sera rempli avec la valeur originale de la temporisation.

.BR Setitimer (2)
positionne la temporisation avec les valeurs de
.IR value .
Si
.I ovalue
est non nulle, les parametres precedents de la temporisation y sont
inscrits.
.LP
Les temporisations decroissent de
.I it_value
a zero, declenchent un signal, et sont replacees a
.IR it_interval .
Une temporisation s'arrete si elle est mise a zero
.RI (it_value
vaut zero) ou bien elle expire et
.I it_interval
vaut zero.
.LP
Les deux champs
.I tv_sec
et
.I tv_usec
sont utilises pour determiner la duree d'une temporisation.
.LP
Les temporisations n'expirent jamais avant la fin du temps
requis, et expirent plutot avec un delai court et constant
apres la limite. Ce delai depend de la resolution du timer
systeme (actuellement 10 ms).
A l'expiration un signal est declenche puis la temporisation
reinitialisee.
Si la temporisation expire alors que le processus est actif
(toujours vrai avec
.BR ITIMER_VIRT)
le signal sera delivre immediatement. Autrement il y aura
un petit delai avant reception du signal, dependant de la
charge du systeme.
.LP
.SH "VALEUR RENVOYEE"
.BR getitimer " et " setitimer
renvoient 0 s'ils reussissent, ou \-1 s'ils echouent, auquel cas
.I errno
contient le code d'erreur.
.SH ERREURS
.TP 1.5i
.B EFAULT
.I value
ou
.I ovalue
pointent en dehors de l'espace d'adressage accessible.
.TP
.B EINVAL
.I which
n'est pas dans la liste
.BR ITIMER_REAL ,
.BR ITIMER_VIRT ,
ou
.BR ITIMER_PROF .
.SH "VOIR AUSSI"
.BR gettimeofday (2),
.BR sigaction (2),
.BR signal (2).
.SH BUGS
Sous Linux, l'emission et la reception d'un signal sont distincts, et
un meme signal ne peut pas etre emis deux fois de suite si le premier
n'a pas ete recu.
Il est aussi possible qu'avec une charge systeme tres elevee, 
une temporisation
.B ITIMER_REAL
expire avant que le signal d'une expiration precedente n'ait ete recu.
Le second signal sera alors perdu.
