\documentclass[times,sans-serif]{athenaslides}
\usepackage{italian}
\usepackage{alltt}
\titlecolor{NavyBlue}
\titlefont{\LARGE\bf}
\newcommand{\cilkkw}[1]{{\bf #1}}
\newcommand{\Backer}{{\sc Backer}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
                                %
                                %
\begin{document}
                                %
                                %
\begin{slide}
  \bigskip\someglue
  \begin{center}
    \begin{LARGE}
      \begin{Blue}
        \bf
        Scacchi, multithreading e linux
      \end{Blue}
    \end{LARGE}
    \bigskip\someglue
    \begin{large}
      Matteo Frigo
    \end{large}
    \bigskip\someglue
    \begin{large}
      \sl 
      MIT Lab for Computer Science
    \end{large}
    \medskip
    \begin{large}
      e
    \end{large}
    \medskip
    \begin{large}
      \sl 
      PLUTO Lumen Utentibus Terrarum Orbis
    \end{large}
    \bigskip
  \end{center}
\end{slide}
                                %
                                %
\begin{slide}[The King -- Cilkchess]
  \centerepsfig{file=the-king-final,width=.5\linewidth}
  \smallskip
  Il bianco abbandona.
  \smallskip
  \centerline{\texttt{http://theory.lcs.mit.edu/\textasciitilde{}cilk}}
\end{slide}
                                %
                                %
\begin{slide}[Cilkchess]
  \begin{itemize}
  \item Nuovo algoritmo di ricerca $MTD(f)$ [Plaat, Schaeffer, Pjils,
    de Bruin], dimostrabilmente (ed empiricamente) migliore di 
    alpha-beta.
  \item Scritto da Don Dailey in Cilk.
  \item Ha vinto il Dutch Open Computer Chess Championship (17 nov 96)
  \item 12 processori UltraSparc 167Mhz.
  \item 1 GB RAM.
  \item Il programma \emph{non sa} di essere parallelo!
  \item Don Dailey lo sa ma non gli interessa \texttt{:-)}
  \end{itemize}
\end{slide}
                                %
                                %
\begin{slide}[Il resto del mio discorso]
  \begin{itemize}
  \item Multithreading.
  \item Multithreading \emph{migliore}: Cilk.
  \item Aspetti dell'implementazione di Cilk su SMP:
    \begin{itemize}
    \item Lazy task creation.
    \item Cactus stack.
    \item Locks e protocolli.
    \item Modelli di memoria.
    \end{itemize}
  \end{itemize}
\end{slide}
                                %
                                %
\begin{slide}[Multithreading]
  Un programma multithreaded \`e fatto di tanti ``thread'',
  potenzialmente eseguibili in parallelo, che interagiscono
  fra di loro.

  \begin{Red}
    Multithreading: modo furbo di esporre e sfruttare il parallelismo.
  \end{Red}

  \begin{itemize}
  \item ``Featherweight'': Superscalar, VLIW, Dataflow Processors.
  \item Lightweight: un thread \`e pi\'u o meno una chiamata di funzione.
    Cilk, MultiLISP, etc.
  \item Heavyweight: POSIX/Solaris threads, processi di Unix, etc.
  \end{itemize}

\end{slide}
                                %
                                %
\begin{slide}[OS threads]
  Sembrano usciti dalla mente di B.~G.:

  \begin{itemize}
  \item Lenti: creazione di un thread $\approx$ 5000 cicli (Solaris)
    $\Longrightarrow$ se ne possono creare pochi.
  \item Prestazioni dipendono dal numero di processori.
  \item Nessun supporto linguistico.  Sincronizzazione fatta a mano.
    Bisogna impaccare gli argomenti in \texttt{struct}, ecc.
  \item Bisogna allocare uno stack a priori.
  \item Nessuna garanzia.
  \end{itemize}

  Usati anche da un noto \emph{Internet language}.
\end{slide}  
                                %
                                %
\begin{slide}[Cilk]
  \smaller
  Cilk [Blumofe, Frigo, Joerg, Leiserson, Randall, e altri]
  \`e un linguaggio multithreaded basato sul \texttt{C}.
  
  La release attuale \`e Cilk-4 (Cilk-5 \`e in cantiere).

  \begin{itemize}
  \item Velocit\`a: la creazione di un thread costa come $\approx 3$
    chiamate di funzione.
  \item Supporto linguistico: basta una keyword ed una funzione 
    \texttt{C} diventa subito un thread.
  \item Dimostrabilmente efficiente (ottimo a meno di fattori costanti).
  \item Empiricamente efficiente (fattore costante $\approx 1$, di solito,
    mai maggiore di $2$).
  \item Portabile: si traduce in C (no assembly).
  \end{itemize}
\end{slide}
                                %
                                %
\begin{slide}[Sintassi di Cilk]
  \begin{minipage}{.6\linewidth}\smaller
    \begin{alltt}
\Black{}\cilkkw{cilk} int fib(int n)
\{
     \Blue{}if (n < 2)
          return n;
     else \{
          int x, y;
          x = \cilkkw{spawn} fib(n - 1);
          \Red{}y = \cilkkw{spawn} fib(n - 2);
          \Black{}\cilkkw{sync};
          \Green{}return x + y;
     \Black{}\}
\}
\end{alltt}
\end{minipage}
\hfill
\begin{minipage}{.4\linewidth}\raggedright\restoresize
  \begin{itemize}
  \item Una \emph{\Red procedure} \`e un blocco di codice sequenziale.
  \item Un \emph{\Red thread} \`e codice senza \cilkkw{spawn}
    e \cilkkw{sync}.
  \end{itemize}
\end{minipage}
\bigskip
{\Red Obiettivo:} aggiungere \cilkkw{spawn} e \cilkkw{sync} finch\'e il
programma non diventa parallelo \texttt{:-)}.
\end{slide}
                                %
                                %
\begin{slide}[Teoria di Cilk]
  Un programma genera dinamicamente una multithreaded computation
  che \`e un DAG (directed acyclic graph).

  \splitpage[.4,.55]{
    \centerepsfig{file=fib.eps,width=\linewidth}
    }{   
    {\Red $T_1$} = \# thread nel DAG. \\
    {\Red $T_\infty$} = \# thread nel cammino critico.

    Lower bound:
    \begin{eqnarray*}
      T_P &\geq& T_1/P \\
      T_P &\geq& T_\infty 
    \end{eqnarray*}
    }

  \smallskip
  Cilk ottiene
  \[\Blue
                 T_P = T_1/P + O(T_\infty)
  \]
  In pratica, $T_P \approx T_1/P + 1\cdot T_\infty$.
\end{slide}
                                %
                                %
\begin{slide}[Lo stack di Cilk]
  \bigskip
  \begin{minipage}{.5\linewidth}\smaller
\begin{alltt}
\cilkkw{cilk} void foo(void)
\{
     int a;
     \cilkkw{spawn} bar(\&a);
     \cilkkw{spawn} bar(\&a);
     \cilkkw{sync};
\}

\cilkkw{cilk} void bar(int *ap)
\{
     int b;
     /* use *ap and b */
\}
\end{alltt}
\end{minipage}
\hfill
\begin{minipage}{.45\linewidth}\restoresize
  Ci aspettiamo che \texttt{ap} punti ad \texttt{a}
  nelle due istanze di \texttt{bar}, e che le due istanze di
  \texttt{b} siano differenti.

  \centerepsfig{file=cactus.eps}
\end{minipage}
\end{slide}
                                %
                                %
\begin{slide}[Cactus stack]
  \bigskip
  \splitpage[.3,.60]{
    \centerepsfig{file=bigcactus.eps,width=\linewidth}
    }{
    \begin{itemize}
    \item
      Il \emph{runtime system} mantiene un \emph{cactus stack},
      sfruttando la \emph{user-level virtual memory}
      (\texttt{mmap()} e \texttt{mprotect()})  [\`a la TreadMarks].

    \item
      Ogni thread vede un singolo spazio di indirizzi lineare.
    \end{itemize}
    }
\end{slide}
                                %
                                %
\begin{slide}[Work stealing]
  {\Red Idea}: fai finta di essere un programma sequenziale finch\'e
  puoi [\`a la ``Lazy Task Creation''].

  \splitpage[.7,.3]{
    \begin{itemize}
    \item Mantieni uno stack di frame.
    \item Allo \cilkkw{spawn}, salva lo stato sullo stack e comincia
      ad eseguire la nuova procedure.
    \end{itemize}
    
    {\Red Work stealing}: quando non hai niente da fare, vai da un
    processore a caso e ruba il frame in cima allo stack.
    
    \emph{Lo scheduler di Cilk \`e {\Red dimostrabilmente} ottimale
      nel tempo di esecuzione}.  \`E anche dimostrabilmente efficiente
    nell'utilizzo della memoria.  
    }{
    \centerepsfig{file=queue.eps}
    }
\end{slide}
%
%
\begin{slide}[Implementazione dello scheduler]
  \bigskip
  {\Red Obiettivi}:
  \begin{itemize}
  \item Ottimizzare il common case.
  \item Usare C standard (cio\`e \texttt{gcc}).
  \end{itemize}

  \smallskip
  Il compilatore genera {\Red due versioni} di ogni procedura:
  \smallskip
  \splitpage[.7,.25]{
    \begin{itemize}
    \item La versione \emph{\Red fast} gira sequenzialmente sullo
      stack di C. \cilkkw{spawn} fa partire una versione fast.
    \item La versione \emph{\Red slow} gira su uno shadow stack,
      e sa di essere parallela.  La versione slow \`e eseguita
      dopo uno steal.
    \end{itemize}
    }{
    \centerepsfig{file=clones.eps,width=.6\linewidth}
    }
\end{slide}
%
%
\begin{slide}[Versione fast]
  \smallskip
  La versione fast \`e codice C normale, con le seguenti
  eccezioni:
  \begin{itemize}
  \item Prima di \cilkkw{spawn}, il compilatore salva lo stato nello
    shadow cactus stack.
  \item Dopo \cilkkw{spawn}, la versione fast controlla se il frame
    \`e stato rubato.  In questo caso, ritorna al runtime system.
  \item \cilkkw{sync} non fa niente!
  \item L'overhead per \cilkkw{spawn} \`e circa 3 volte il costo
    di una chiamata di funzione in C.
  \end{itemize}
\end{slide}
%
%
\begin{slide}[Versione slow]
  \smallskip
  \begin{itemize}
  \item Ogni variabile viene convertita in un accesso allo shadow stack
    (cio\`e, \texttt{n} diventa \texttt{\_frame->n}).
  \item Dopo \cilkkw{spawn} la versione slow controlla se il frame
    \`e stato rubato.
  \item \cilkkw{sync} ora controlla se ci sono procedure che devono
    ancora terminare. In questo caso, ritorna al runtime system.
  \item La versione slow pu\`o ripartire all'inizio di ogni thread.
    Usiamo \texttt{goto} per saltare al posto giusto.
  \end{itemize}
  \medskip
  \begin{Red}
    Di solito il programma gira in modo fast, alla stessa velocit\`a
    di~C.
  \end{Red}
\end{slide}
                                %
                                %
\begin{slide}[Implementazione del cactus stack]
  \begin{Red}
    Virtual memory: meccanismo per ridefinire il significato
    di un indirizzo in memoria.
  \end{Red}

  \begin{itemize}
  \item {\tt mmap()} stabilisce una corrispondenza tra un indirizzo
    in memoria ed oggetti nel file system.
  \item Non \`e specificato esattamente che cosa faccia (NFS?).
    Varia da macchina a macchina.
  \item Usando {\tt mmap()} possiamo implementare il cactus stack.
  \item Una pagina di memoria pu\`o essere \emph{unmapped}.  Un
    accesso alla pagina provoca un page fault, che pu\`o essere
    intercettato dal programma utente ($\approx .5\, \rm ms$).
  \item L'intera idea di {\tt mmap()} \`e stupida. 1 GB di memoria
    e 30MB in {\tt /tmp}!
  \end{itemize}
\end{slide}
                                %
                                %
\begin{slide}[Lock]
\smaller
  \begin{Red}
    I lock del sistema operativo sono lenti.
  \end{Red}
\begin{verbatim}
static inline int Cilk_xmem(register volatile int *ptr, 
                            register int xchg)
{    asm volatile ("swap [%1],%0"
                   :"=r" (xchg)
                   :"r"(ptr), "0"(xchg)
     );
     return xchg;
}

static inline void Cilk_sema_wait(LockT *lock)
{    while (Cilk_xmem(lock, 1) != 0) {
          while (*lock != 0);
     }
}
\end{verbatim}

  Problema: swap richiede 14 cicli.  Troppi (serve un lock per ogni
  thread).
\end{slide}
                                %
                                %
\begin{slide}[Algoritmo di Dekker]
  L'algoritmo di Dekker garantisce la mutua esclusione tra 
  \emph{due} processori, senza usare lock.  Noi lo usiamo per
  la mutua esclusione del `ladro' e della `vittima'.

  \texttt{H}: Indice della prima locazione nello stack.

  \texttt{T}: Indice dell'ultima locazione dello stack.

  Se \texttt{H}=\texttt{T} lo stack \`e vuoto.

  \begin{minipage}[t]{.5\linewidth}
    \centerline{Vittima}
\begin{verbatim}
T--;
if H >= T
  T++;
  grab the lock
\end{verbatim}
  \end{minipage}
  \begin{minipage}[t]{.5\linewidth}
    \centerline{Ladro}
\begin{verbatim}
grab the lock
H++;
if H >= T
  H--;
  retry or give up
\end{verbatim}
  \end{minipage}
\end{slide}
                                %
                                %
\begin{slide}[Bit Rot]
  L'algoritmo di Dekker \`e il classico esempio di 
  \emph{programmi che vanno a male} (bit rot).  Fino a qualche
  anno fa funzionava\ldots

  \bigskip
  \begin{Red}
    \centerline{Problema: modelli di memoria.}
  \end{Red}
  \bigskip
  
  \emph{I processori attuali si prendono la libert\`a di scambiare
    l'ordine degli accessi alla memoria, per ragioni di efficienza.}

  SPARC usa (di solito) Total Store Order: la CPU pu\`o scambiare
  l'ordine di un \texttt{load} e di uno \texttt{store}.
\end{slide}
                                %
                                %
\begin{slide}[Alcuni modelli di memoria]
  \begin{smaller}
    {\fancyfont{Tymes-Elfin}
      \hbox{}\hfill There are nine kinds of dragon, \\
      \hbox{}\hfill and no two kinds are alike. \\
      }
    \hbox{}\hfill\sf (Cao Xuequin --- Hong lou meng)
  \end{smaller}

  \begin{itemize}
  \item {\Red Sequential consistency} [Lamport 1979]
  \item {\Red Weak consistency} [Dubois-Scheurich-Briggs 1986]
  \item {\Red Processor consistency} [Goodman 1989]
  \item {\Red DAG consistency} [Frigo 1999]
  \item {\Red Infiniti altri}: IBM 370, TSO, Processor consistency II,
    PSO, Release Consistency (due tipi), Alpha, PowerPC, SPARC RMO.
  \end{itemize}
\end{slide}
                                %
                                %
\begin{slide}[Conclusioni]
  \begin{itemize}
  \item Il 1996 \`e l'anno degli SMP.
  \item Multithreading \`e una buona idea.
  \item Multithreading classico \`e fatto male.
  \item Cilk fornisce efficienza, supporto linguistico e garanzie.
  \item Vogliamo user-level virtual-memory veloce ed intelligente.
  \item Vogliamo modelli di memoria chiari.
  \end{itemize}
    
  \smallskip
  \centerline{\texttt{http://theory.lcs.mit.edu/\textasciitilde{}cilk}}
\end{slide}
                                %
                                %
\begin{slide}[Lavori in corso]
  Intel:  $2 \times 4 \cdot \hbox{P6} \rightarrow$ \texttt{athena}.

  \noindent\verb|A:\> format C:| \\
  \noindent\verb|athena% install linux|

  Alcune idee che prover\`o col tempo:

  \begin{itemize}
  \item Ridefinizione dell'interfaccia della virtual memory.
    Page fault veloci?
  \item Incorporare il work-stealing scheduler nel kernel di Linux.
  \item File system parallelo.
  \end{itemize}

  \begin{Red}
    Pubblicit\`a: usate \verb|\documentclass{athenaslides}|
  \end{Red}
\end{slide}
\end{document}
