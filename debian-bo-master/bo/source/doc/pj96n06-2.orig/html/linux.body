<!--
	linux.html
	Last modification: Tue, 15 Oct 1996 15:50:26 EET DST
	linux.		Linux ... e poi?	PJ 6: Linux ... e poi?		Articoli
  -->
<P align="center"><Font size=6>OK, Linux... ma ora???</font><br>
<address>
<p align=right>
<font size=+0>
di
<a href="mailto:nuke@mbox.queen.it">
Enrico Rubboli</a>
</font></p>
</address>


<Font size=+1>Una piccola guida per passare da dos a linux</font></p>
<P>Molti passando dall' onnipresente dos a Linux si sentono spaesati, raggiunto il sudato prompt si chiedono:
e linux dov'e'??? Ora che faccio??<br>
Bene, e' giunto il momento di fare un po' di chiarezza sui comandi che differenziano linux dal sistema operativo
del <I>caro</I> Bill. </P>
<P>Innanzitutto vediamo come muoversi all' interno del S.O. :<br>
Una volta avviato linux avremo un prompt di questo tipo:<br>
<pre>host:~#</pre>
il che vuol dire che vi trovate nella home directory del vostro account, se allora il vostro <I>login</I> e' pallino dovreste realmente trovare nella directory:<br>
<pre>/home/pallino/</pre>
a questo punto proviamo ad andare nella directory principale del sistema (<I>root</I>) quindi:<br>
<pre>cd /</pre>
OK, ora siamo al principio, un po' come <B>C:/</B> del dos. <br>
Linux permette anche di poter vedere il contenuto di una directory (:-)) con il comando:<br>
<pre>ls</pre>
Ora dovremmo vedere  i nomi dei file e delle sottodirectory , per vedere anche le informazioni 
riguardanti i file e' sufficiente aggiungere l' attributo -l, il risultato sara' simile a questo:<br><br>
<pre>
total 401
drwxr-xr-x   2 root     bin          2048 Aug  6 00:05 bin/
drwxr-xr-x   2 root     root         1024 Aug  6 00:26 boot/
drwxr-xr-x   2 root     root         1024 Sep  4  1995 cdrom/
drwxr-xr-x   2 root     root         9216 Aug  6 23:44 dev/
drwxr-xr-x  10 root     root         2048 Aug  6 23:44 etc/
drwxr-xr-x   3 root     root         1024 Aug  6 00:05 home/
drwxr-xr-x   2 root     root         1024 Aug  6 00:01 lib/
drwxr-xr-x   2 root     root        12288 Aug  5 23:51 lost+found/
drwxr-xr-x   2 root     root         1024 Sep  4  1995 mnt/
dr-xr-xr-x   7 root     root            0 Aug  7 00:44 proc/
drwxr-x--x   4 root     root         1024 Aug  6 00:15 root/
drwxr-xr-x   2 root     bin          2048 Aug  6 00:05 sbin/
drwxrwxrwt   3 root     root         1024 Aug  6 23:50 tmp/
drwxr-xr-x  19 root     root         1024 Aug  6 00:15 usr/
drwxr-xr-x  16 root     root         1024 Aug  6 00:15 var/
-r--------   1 root     root       336975 Aug  6 00:05 vmlinuz
</pre>
Vediamo di decifrare queste informazioni, si puo' subito notare che i nomi dei file si trovano all' estrema 
destra, subito dopo alla data e l' ora di scrittura del file e le sue dimensioni. Proseguendo verso sinistra
si trovano il <I>gruppo di appartenenza</I> , il <I>proprietario</I> del file, il numero dei puntatori sul file 
ed infine i <I>permessi</I> del file.<br>
Non spaventatevi, vedremo tutto piu' a fondo piano piano.<br><BR>

Poiche linux e' un Sistema Operativo multiutente e' necessario poter proteggere i file e le directory dagli
altri utenti. Per questo sino stati introdotti i <I>permessi </I>, che riguardano la lettura (<I>read</I>), la 
scrittura (<I>write</I>) e l' esecuzione (<I>execute</I>) relativi al proprietario, al gruppo e  a tutti gli altri
utenti.<br>

In pratica :
<pre>-rwxr-xr-- 2  utenti     pallino          2048 Aug  6 00:00 <I>miofile</I></pre> 

significa che il propietario puo' leggere, scrivere ed eseguire il file (rwx), gli utenti appartenenti
al gruppo del file (specificato nella terza colonna ) possono solo leggere ed eseguire il file (r-x) 
ed infine gli altri utenti hanno solo il permesso di lettura (r--).<br>
Nella definizione dei permessi il primo carattere (nel caso del file <I>miofile</I> - ) indica il tipo di file.<br>
Per modificare i permessi si utlilizza il comando  <I>chmod</I>,i permessi possono essere modificati solo dal proprietario
del file, la sintassi del comando e' la seguente:<br>
<pre>chmod {a,u,g,o} {+,-} {r,w,x} &lt;nome del file&gt;</pre>
Vediamo un po' di esempi fatti sul famoso file <I>miofile</I>:<BR><BR>
<TABLE  BORDER=0>
<TR>
	<TD>Comando</TD>
	<TD>Azione</TD>
	<TD align=center>Risultato</TD>
</TR>

<TR>
	<TD><pre>chmod og-r miofile   </pre></TD>
	<TD>Viene tolto il permesso di lettura a tutti gli utenti tranne che al proprietario</TD>
	<TD><pre>   -rwx--x--- </pre></TD>
</TR>
<TR>
	<TD><pre>chmod a+r miofile   </pre></TD>
	<TD>Viene permessa la lettura a tutti gli utenti </TD>
	<TD><pre>   -rwxr-xr--</pre></TD>
</TR>
<TR>
	<TD><pre>chmod u-rx miofile   </pre></TD>
	<TD>Toglie i permesso di lettura ed esecuzione al proprietario</TD>
	<TD><pre>   --w-r-xr--</pre></TD>
</TR>
<TR>
	<TD><pre>chmod p-rwx miofile   </pre></TD>
	<TD>Toglie il i permessi di lettura, scrittura ed esecuzione a tutti gli utenti tranne che al proprietario</TD>
	<TD><pre>   --w-------</pre></TD>
</TR>
<TR>
	<TD><pre>chmod a+xr miofile   </pre></TD>
	<TD>Viene dato il permesso di lettura ed esecuzione a tutti gli utenti</TD>
	<TD><pre>   -rwxr-xr-x</pre></TD>
</TR>
</TABLE>
In pratica a,u,g,o corrispondono rispettivamente a tutti (<I>all</I>), utente (<I>user</I>), gruppo (<I>group</I>) e altri (<I>other</I>).<br>
Dopodiche si specifica l' azione : permetti (+) o proteggi (-) <br>
Ed infine si indicano i permessi w,r,x.<br><br>

L' utilizzo del comando <I>chmod</I> puo' avvenire anche in un secondo metodo, 
cioe' utilizzando una serie di 3 numeri corrispondenti ai permessi<I> u,g,o</I> secondo la
seguente tabella (che ricorda la numerazione binaria):<br>
<TABLE BORDER=0>
   <TD>Numero </TD>
   <TD>In binario</TD>
   <TD>Risultato</TD>
<TR>
  <TD>0 </TD>
   <TD>000 </TD>
   <TD>--- </TD>
<TR>
   <TD>1 </TD>
   <TD>001 </TD>
   <TD>--x </TD>
<TR>
   <TD>2 </TD>
   <TD>010 </TD>
   <TD>-w- </TD>
<TR>
   <TD>3 </TD>
   <TD>011 </TD>
   <TD>-wx </TD>
<TR>
   <TD>4 </TD>
   <TD>100 </TD>
   <TD>r-- </TD>
<TR>
   <TD>5 </TD>
   <TD>101 </TD>
   <TD>r-x </TD>
<TR>
   <TD>6 </TD>
   <TD>110 </TD>
   <TD>rw- </TD>
<TR>
   <TD>7 </TD>
   <TD>111 </TD>
   <TD>rwx </TD>
</TABLE>
<br> Un esempio chiarira' tutto:<br>
<B>qualunque sia lo stato di partenza</B> con:
<pre> chmod 755 <i>nomefile</I></pre>
si arriva a:
<pre> rwxr-xr-x</pre>
<br>
Ritorniamo al primo carattere, quello che come prima accennato identifica il tipo di file, alla sinistra
dei permessi, il suo valore puo' essere:
<TABLE BORDER=0>
   <TD>Valore </TD>
   <TD>Stato </TD>
<TR>
   <TD ALIGN=center>- </TD>
   <TD>identifica i file semplici </TD>
<TR>
   <TD ALIGN=center>l </TD>
   <TD>link ad altri files </TD>
<TR>
   <TD ALIGN=center>d </TD>
   <TD>directory </TD>
<TR>
   <TD ALIGN=center>b </TD>
   <TD>files in blocchi </TD>
<TR>
   <TD ALIGN=center>c </TD>
   <TD>files di caratteri </TD>
<TR>
   <TD ALIGN=center>p </TD>
   <TD>files speciali (sockets) </TD>
</TABLE>
<BR>
<BR>
<BR>


<font size=+1>Ora vediamo qualche comando per gestire i file:</font><BR><BR>

<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH=0 BORDER=1>
<TR>
	<TD width=70 >cd</TD>
	<TD>Cambia directory, e' sufficiente specificare la destinazione.<br>
                                Sintassi: cd <I>&lt;path&gt;</I></TD>
</TR>
<TR>
	<TD>ls</TD>
	<TD>Visualizza il contenuto di una directory.<br>
      	           Sintassi: ls <I>argomenti &lt;file1&gt;&lt;file2&gt; ... &lt;file N&gt;</I></TD>
</TR>

<TR>
	<TD>cp</TD>
	<TD>Copia uno o piu' file in un altro file o in una directory<br>
	Sintassi: cp <I>&lt;file1&gt;&lt;file2&gt; ... &lt;fileN&gt; &lt;destinazione&gt;</I></TD>
</TR>
<TR>
	<TD>mv</TD>
	<TD>Sposta uno o piu' file in un altro file o in una directory<br>
	Sintassi: mv <I>&lt;file1&gt;&lt;file2&gt; ... &lt;fileN&gt; &lt;destinazione&gt;</I></TD></TD>
</TR>
<TR>
	<TD>rm</TD>
	<TD>Cancella i file.<br>
	Sintassi: rm <I>&lt;file1&gt;&lt;file2&gt; ... &lt;fileN&gt; </I></TD>
</TR>
<TR>
	<TD>mkdir</TD>
	<TD>Crea una nuova directory.<br>
	Sintassi: mkdir <I>&lt;dir1&gt;&lt;dir2&gt; ... &lt;dirN&gt;</I></TD>
</TR>

<TR>
	<TD>rmdir</TD>
	<TD>elimina directory vuote.<br>
	Sintassi: rmdir <I>&lt;dir1&gt;&lt;dir2&gt; ... &lt;dirN&gt;</I></TD>
</TR>
<TR>
	<TD>more</TD>
	<TD>Visualizza il contenuto dei file.<br>
	Sintassi: more <I>&lt;file1&gt;&lt;file2&gt; ... &lt;fileN&gt;</I></TD>
</TR>
</TABLE><BR>
<BR>
Bene, ora penso che si riesca almeno a <I>respirare</I> all' interno del sistema,  no???<br><BR><BR>
<font size =+1>stdin, stdout and pipeline</font><br><BR>
Molti comandi sono apparentemente inutili, come ad esempio <I>cat</I>, il quale servirebbe per
concatenare dei file, ma la seguente espressione mostra solo il contenuto del file <I>miofile</I>:
<pre>cat miofile</pre>
questo perche' se nulla viene specificato <i>cat</I> legge i dati dallo <I>standard input</I> e li invia
allo <I>standard output</I>.Cioh legge i dati dalla tastiera e li visualizza sul monitor.<br>
Nell' espressione precedente l' output non e' stato specificato, sarebbe bastato:
<pre>cat miofile &gt; tuofile</pre>
per <I>copiare</I> il contenuto di <I>miofile</I> sul nuovo file <I>tuofile</I>. Se oltre <I>miofile</I>
fosse stato specificato un secondo file questo sarebbe stato aggiunto a <I>miofile</I> in <I>tuofile</I>.<br>
Se si fosse eseguito <I>cat</I> senza nessun paramentro questo avrebbe atteso l' immissione di testo dalla
tastiera per poi visualizzarlo sul monito, in pratica ad ogni riga scritta questa viene rivisualizzata nella riga sottostante.<br>
Se scriviamo:
<pre>ls /  &gt; miofile</pre>
viene registrato nel file <I>miofile</I> il contenuto della directory di root, ora possiamo ordinare in ordine alfabetico il 
contenuto del file (directory root)  con il comando <I>sort</I> in questo modo:
<pre>sort miofile</pre>
oppure possiamo direttamente visualizzare il contenuto di una directory in ordine alfabetico:
<pre>ls | sort</pre>
in questo modo abbiamo creato una <I>pipeline</I>, ovvero abbiamo passato i dati da un' istruziona ad
un' altra. Le combinazioni sono infinite, ad esempio e' possibile visualizzare  la directory schermata alla volta
sfruttando tale caratteristica di <I>more</I>:
<pre>ls | sort | more </pre>
 
Un ultima cosa, l' istruzione che abbiamo utilizzato in precedenza per trasferire il contenuto di <I>miofile</I> in <I>tuofile</I>
(<I>cat miofile &gt; tuofile</I>) e' detta un' istruzione <I>distruttiva</I> in quanto avrebbe definitivamente cancellato l'eventuale
contenuto del file <I>tuofile</I> sovrascrivendovi il risultato, se si fosse utilizzato:
<pre>cat miofile &gt;&gt; tuofile</pre>
il contenuto di <I>miofile</I> sarebbe stato appeso a <I> tuofile</I> senza cancellarne il contenuto.
<BR><BR>
<font=+1><B>Variabili d'ambiente e script</B></font><BR>

Come in tutti (o quasi) i sistemi operativi anche in linux e' possibile dichiarare e gestire delle variabili
che sono utilizzabili dalla shell o volendo anche dai programmi in esecuzione, sono variabili d'ambiente
ad esempio:
<pre>
USER=<I>nome</I>
HOME=/home/<I>nome</I>
PATH=.:/bin:/usr/bin
PWD=/
.....
</pre>
per definire una variabile in <I>bash</I> e' sufficiente un comando come il seguente:<br>
<pre>mionome=Enrico</pre>
in questo caso la variabile <I>mionome</I> assume il valore <I>Enrico</I>, 
ora se pero' voglio stampare il valore della variabile <I>mionome</I> devo scrivere:<br>
<pre>echo $mionome</pre>
il carattere '$' indica alla shell che cio' che segue e' il nome di una variabile e non una stringa.<br><BR>
<BR>

Ultimo passo e' la creazione di uno script, uno script non e' altro che un file (come i file BAT del <I>DOS</I>)
di testo al quale si e' dato il permesso di esecuzione.

Di norma conviene nella prima riga di uno script definire per quale <I> shell </I> lo si sta' scrivendo,
L' esempio che faro' e' uno script in Bash, e anche se la sua utilita' e' da dimostrare (anzi sono convinto che sia
lo script inutile per eccellenza :-)), credo che vada benissimo per far capire in che modo si puo'
scrivere uno script (anche perche' ho gia' testato tutto:-)).<br>
Il nome dello script (tenetevi stretti) e' ... <I>dir</I>, la sua utilita?<br>
descrivere la directory dettagliatamente, a colori, e con in principio la path della directory
in questione.<br> 
Allora facciamo partire il nostro editor preferito (jed, elvis, vi, pico ecc.)<br>
poi scriviamo:<br>
<pre>
#!/bin/bash
if [$* = ""] 2> /dev/null
then
dir=$PWD
else
dir=$1
fi
if 
  test -d $dir
then
echo "-----------------------------------------------------"
echo "  Questa "$USER" e' la directory: " 
echo "  "$dir                
echo "-----------------------------------------------------"
ls --8bit --color=tty -Fa -T 0 $dir
else
echo " ATTENZIONE LA DIRECTORY "$dir" E' INESISTENTE!"
fi
</pre>
Vediamo come funziona questo script:<br>
nella prima linea viene (come gia' annunciato) dichiarata la shell che elaborera' lo script.
nella seconda riga vediamo un' <B>istruzione di controllo del flusso</B>, tale istruzione
controlla che la variabile <I>$*</I> (che equivale alla somma di tutti i parametri chiamati
insieme allo script) sia nulla in tal caso assegna alla variabile <I>$dir</I> il valore della
directory corrente (<I>$PWD</I>) altrimenti vi assegna il valore del primo parametro <I>$1</I>.
Da notare che l' errore generato dall' istruzione <I>IF</I> (seconda riga) viene deviato su /dev/null,
ovvero viene gettato via (non viene considerato). La seconda istruzione <I>IF</I> (riga 8) controlla
l' esistenza della directory con l' istruzione <I>test</I>, nel caso esista lo script puo' essere terminato
generando nello standard output la directory, altrimenti viene visualizzato un errore.<BR>
Vi consiglio di utilizzare lo script appena descritto solo come esperimento, per la visualizzazione
delle directory continuate ad utilizzare <I> ls</I>!
<BR>
<BR>

<I>Nel prossimo articolo osserveremo i LINK tra i file, il controllo dei job e qualche altro nuovo comando....  arrivederci...</i>
