<!--
	rubini.html
	Last modification: Tue, 15 Oct 1996 15:51:23 EET DST
	rubini.		Device Drivers nr.3	PJ 6: Device Drivers nr.3	Articoli
  -->
<font size=+2 color="#0000ff">Device Drivers #3</font>
<em>
	<p align=right>
	<font size=+0>
	di
	Georg v. Zezschwitz and Alessandro Rubini
	</font>
	</p>
</em>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=bottom width=50%>
	<font size=-1 color="purple">
	Ristampato con il permesso del 
	<a href="http://www.ssc.com/lj/"> Linux Journal</a>.
	</font>
<td valign=bottom width=50%>
	<font size=-1 color="purple">
	This material is reprinted with permission of 
	<a href="http://www.ssc.com/lj/"> Linux Journal</a>.
	</font>
<tr>
<td valign=top width=50%>
	<hr>	<!-- +++++++++++++++++++ -->

	<font size=+1 color="#0000ff">
	Il Dèmone è nei Dettagli
	</font>
<p>
	<font size=+0 color="black">
	Questo articolo è il terzo di cinque parti sulla scrittura di device
	driver a carattere, e introduce i concetti riguardanti la lettura e la
	scrittura del dispositivo, come pure l'implementazione di
	<code>ioctl()</code>.
<p>
	Sulla base dell'ambiente che abbiamo predisposto nei due precedenti
	articoli, cercheremo questa volta di riempire la struttura con il
	materiale relativo alle interrupt. Straordinariamente, Linux ci nasconde
	la maggior parte delle questioni problematiche, così che non dovremo
	scrivere nemmeno una linea di assembler.

<td valign=top width=50%>
	<hr>	<!-- +++++++++++++++++++ -->

	<font size=+1 color="#0000ff">
	The Devil's in the Details
	</font>
<p>
	<font size=+0 color="black">
	This article, the third of four sections on writing character device
	drivers, introduces the different concepts of reading, writing, and
	<code>ioctl</code>-calls, and how to form them into concrete code.
<p>
	Based on the clean code environment of the two previous articles, we
	will now fill the mold with all the nasty interrupt stuff.
	Astonishingly, Linux hides most of this from us, so we do not need a
	single line of assembler...

<tr>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Leggere e scrivere
	</font>
<p>
	Finora il nostro driver per la <code>skel</code>-machine è in grado di
	agganciarsi e sganciarsi dal kernel senza problemi, ma non siamo ancora
	stati in grado di leggere o scrivere nemmeno un carattere.  Inizieremo
	quindi fornendo il codice per le funzioni <code>skel_read()</code> e
	<code>skel_write()</code>, che abbiamo presentato nel precedente
	articolo, sotto il paragrafo <strong>Fops e filp</strong>. Ad entrambe
	le funzioni vengono passati quattro argomenti:

<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Reading and writing
	</font>
<p>
	Right now, our magic <code>skel</code>-machine driver can load and even
	unload (painlessly, unlike in dos), but we have neither read nor written
	a single character. So we will start filling the
	<code>skel_read()</code> and <code>skel_write()</code> functions
	introduced in the previous article (under <strong>fops and
	filp</strong>) with content. Both function are supplied with four
	arguments: 

</table>

<pre>
	Static int skel_read (struct inode *inode,
	                      struct file *file,
	                      char *buf, int count)
	Static int skel_write (struct inode *inode,
	                       struct file *file,
	                       char *buf, int count)
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	La struttura <code>inode</code> ci fornisce le informazioni che abbiamo
	già usato all'interno di <code>skel_open()</code>. Per esempio, avevamo
	determinato quale scheda l'utente sta aprendo (ricordiamo che il nostro
	driver supporta dispositivi multipli) usando <code>inode->i_rdev</code>;
	avevamo poi trasferito questa informazione, insieme all'indirizzo di I/O
	della scheda e il numero di IRQ, nel campo <code>private_data</code>
	della struttura <code>file</code>. Possiamo quindi ignorare queste
	informazioni nella <code>read()</code>, ma se non avessimo usato
	<code>private_data</code> l'unico modo per sapere a quale scheda stiamo
	per parlare sarebbe la lettura di <code>inode</code>.

<td valign=top width=50%>

	The <code>inode</code> structure supplies us with information we used
	already during the <code>skel_open()</code> call. For example, we
	determined from <code>inode->i_rdev</code> which of perhaps multiple
	boards the user wants to open, and transfered this information, together
	with information about this board's base address and interrupt to the
	<code>private_data</code> entry of the file descriptor. Therefore, we
	might ignore this information now, but if we did not use this hack,
	<code>inode</code> is our only chance to find out to which board we are
	talking.  

<tr>
<td valign=top width=50%>

	La struttura <code>file</code>, invece,  contiene informazioni
	probabilmente più utili: si possono esplorare tutti i suoi campi in
	<code>&lt;linux/fs.h></code>.  Se si vuole usare il campo
	<code>private_data</code> lo si trova qui; anche il campo
	<code>f_flags</code> spesso utile in quanto rivela, per esempio, se il
	programma desidera operare in modo bloccante o non-bloccante -- questo
	argomento verrà spiegato dettagliatamente più avanti.

<td valign=top width=50%>

	The <code>file</code> structure contains information that is probably
	more valuable. You can explore all its elements in its definition in
	<code>&lt;linux/fs.h></code>. If you use the <code>private_data</code>
	entry, you find it here, and you should also make use of the
	<code>f_flags</code> entry, revealing to you, for instance, if the user
	wants blocking or non-blocking mode.  (We explain this topic in more
	detail later on.)

<tr>
<td valign=top width=50%>

	Gli argomenti <code>buf</code> e <code>count</code> dicono dove mettere
	i dati che leggiamo (o dove trovare i dati che dobbiamo scrivere), e
	quanti bytes ci sono. Bisogna però ricordare che ogni processo ha il suo
	spazio di indirizzamento privato, mentre il codice del kernel risiede in
	uno spazio di indirizzamento che è comune a tutti i processi. Quando le
	chiamate di sistema eseguono per conto di uno specifico processo,
	eseguono nello spazio del kernel ma devono (e possono) accedere allo
	spazio utente. Storicamente lo spazio utente veniva indirizzato in
	assembler usando il registro <code>fs</code>; le versioni attuali di
	linux nascondono le istruzioni specifiche all'interno di funzioni
	chiamate <code>get_user_byte()</code> per leggere un byte dallo spazio
	utente, <code>put_user_byte()</code> per scriverne uno, eccetera.
	Queste funzioni si chiamavano precedentemente con nomi come
	<code>get_fs_byte</code>, mentre adesso solo <code>memcpy_tofs()</code>
	e <code>memcpy_fromfs()</code> revelano la vecchia implementazione,
	anche su piattaforme diverse da x86. Chi volesse esplorare tutte queste
	funzioni può trovarne le definizioni in <code><asm/segment.h></code>.

<td valign=top width=50%>

	The <code>buf</code> and <code>count</code> arguments tell us where to
	put the bytes we read (or where to find the bytes we shall write) and
	how many bytes there are. But you must remember that every process has
	its own private address space. When in kernel code, you have an address
	space which is common to all the processes. When system calls execute on
	behalf of a specific process, they run in kernel address space, but are
	still able to access the user space. Historically, this was done through
	assembler using the <code>fs</code> register; current linux kernels hide
	the specific code within functions called <code>get_user_byte()</code>
	for reading a byte from user address space, <code>put_user_byte()</code>
	for writing one, and so on.  They were formerly known as
	<code>get_fs_byte</code> and similar, and only
	<code>memcpy_tofs()</code> and <code>memcpy_fromfs()</code> reveal these
	old days even on a DEC Alpha. If you want to explore them all, you'll
	find the definition in <code><asm/segment.h></code>.

<tr>
<td valign=top width=50%>

	Immaginiamo ora un hardware ideale che non aspetta altro che di ricevere
	i nostri dati, legge e scrive velocemente, e viene visto attraverso una
	semplice porta dati da 8 bit all'indirizzo base della nostra
	interfaccia. Nonostante questo non sia realistico, il programmatore
	impaziente può provare il codice seguente:

<td valign=top width=50%>

	Let us imagine ideal hardware that is always hungry to receive our data,
	reads and writes quickly, and is accessed through a simple 8-bit
	data-port at the base address of our interface.  Though it is
	unrealistic, the impatient of you might try the following code:

</table>

<pre>
	Static int skel_read (struct inode *inode,
	                      struct file *file,
			      char *buf, int count) { 
		int n = count;
		char *port = PORT0 ((struct Skel_Hw*)(file->private_data));

		while (n--) { 
			<em>Wait till device is ready
			aspetta che la periferica sia pronta</em>
			put_user_byte (inb_p (port), buf);
			buf++; 
		} 
		return count; 
	}
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Occorre spendere alcune parole sulla funzione <code>inb_p()</code>:
	questa è la funzione di lettura dei dati dall'hardware. Si può decidere
	di usare il suo equivalente veloce, <code>inb()</code>, che omette una
	minima attesa che può essere necessaria quando si pilota dell'hardware
	lento, ma noi preferiamo l'approccio più cauto.

<td valign=top width=50%>

	Notice the <code>inb_p()</code> function call. This is the actual I/O
	read from the hardware. You might decide to use its fast equivalent,
	<code>inb()</code>, which omits a minimal delay some slow hardware might
	need, but I prefer the safe way.

<tr>
<td valign=top width=50%>

	La funzione equivalente <code>skel_write()</code> è quasi uguale, tranne
	che bisogna rimpiazzare la linea contenente <code>put_user_byte()</code>
	con la seguente:

<td valign=top width=50%>

	The equivalent <code>skel_write()</code> function is nearly the same.
	Just replace the <code>put_user_byte()</code> line by the following:

</table>

<pre>
	outb_p (get_user_byte (buf), port);
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	C'è da dire, però che questa implementazione ha un sacco di svantaggi.
	Cosa succede se il kernel si ferma in una di queste funzioni aspettando
	per un dispositivo che non diventerà mai pronto a ricevere/restuire
	dati?

<td valign=top width=50%>

	However, these lines have a lot of disadvantages. While using them, what
	if Linux sticks in them while waiting for a device that never becomes
	ready? 

<tr>
<td valign=top width=50%>

	Torniamo per un attimo ai discorsi teorici: cosa ci aspettiamo dal
	nostro driver? Certamente dovrebbe dedicare il tempo di attesa ad altri
	processi che usino il nostro costoso processore, e dovrebbe avere un
	buffer di ingresso e uno di uscita in modo da gestire i dati che
	arrivano mentre i processi non sono in <code>skel_read()</code> o
	<code>skel_write()</code>. Dovrebbe avere un time-out per riconoscere
	gli errori, e dovrebbe supportare operazioni bloccanti e non bloccanti.

<td valign=top width=50%>

	Let us return back to theory for a short time. What do we expect from
	our driver? It should dedicate the time in the waiting loop to other
	processes making use of our expensive CPU, and it should have an input
	and output buffer for bytes arriving while we are not in
	<code>skel_read()</code> and corresponding <code>skel_write()</code>
	calls. It should have a time-out in case of errors, and it should
	support blocking and non-blocking modes.

<tr>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Modo bloccante e non bloccante 
	</font>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Blocking and Non-Blocking Mode
	</font>

<tr>
<td valign=top width=50%>

	Immaginiamo un processo che voglia leggere 256 bytes. Sfortunatamente,
	in nostro buffer di ingresso è vuoto quando <code>skel_read()</code>
	viene chiamata. Cosa dovremmo fare allora: ritornare dicendo che non ci
	sono ancora dati, o aspettare finchè non arriva almeno <em>qualche</em>
	byte?

<td valign=top width=50%>

	Imagine a process which would like to read 256 bytes.  Unfortunately,
	our input buffer is empty when <code>skel_read()</code> is called. So
	what shall we do: return and say that there is no data yet, or wait till
	at least <em>some</em> bytes have arrived?

<tr>
<td valign=top width=50%>

	La risposta è <strong>entrambe le cose</strong>. Il modo
	<em>blocking</em> significa che l'utente vuole attendere finchè non ci
	sono dati da leggere. Il modo <em>non-blocking</em> significa che il
	driver deve ritornare il più presto possibile -- deve solo leggere
	tutti i bytes che sono disponibili.  Regole simili si applicano alla
	scrittura: una scrittura <em>bloccante</em> significa "non ritornare
	finchè non puoi accettare <i>alcuni</i> dati", mentre una <em>non
	bloccante</em> significa "ritorna anche se non puoi accettare niente".

<td valign=top width=50%>

	The answer is <strong>both</strong>. <em>Blocking</em> mode means the
	user wants us to wait till some bytes are read. <em>Non-blocking</em>
	mode means to return as soon as possible---just read all the bytes that
	are available.  Similar rules apply to writing: <em>Blocking</em> mode
	means ``Don't return till you can accept some data,'' while
	<em>non-blocking</em> mode means: ``Return even if nothing is
	accepted.'' 

<tr>
<td valign=top width=50%>

	Le chiamate <code>read()</code> e <code>write()</code> di solito
	ritornano il numero di bytes trasferiti. Se, però, l'operazione è
	`non-blocking' e non possono essere trasferiti dati, bisogna ritornare
	<code>-EAGAIN</code> che significa <em>``Play it again, Sam''</em>. Una
	volta si ritornava <code>-EWOULDBLOCK</code>, che in Linux è la stessa
	cosa che <code>-EAGAIN</code>.

<td valign=top width=50%>

	The <code>read()</code> and <code>write()</code>calls usually return the
	number of data bytes successfully read or written.  If, however, the
	device is non-blocking and no bytes can be transferred,
	<code>-EAGAIN</code> should be returned (meaning: <em>``Play it again,
	Sam''</em>).  Some old code returns <code>-EWOULDBLOCK</code>, which is
	the same as <code>-EAGAIN</code> under Linux.

<tr>
<td valign=top width=50%>

	Forse adesso state sorridendo felici come quando io ho sentito per la
	prima volta di questi due modi. Se questi concetti sono nuovi per voi,
	potrete trovare utili i seguenti suggerimenti. Ogni dispositivo viene
	aperto per default in modo `blocking', ma l'utente può scegliere di
	usare il modo `non-blocking' settando <code>O_NONBLOCK</code> nella
	chiamata <code>open()</code>. Si può anche cambiare il comportamento di
	un file più avanti usando la funzione <code>fcntl()</code>.  La
	chiamata <code>fcntl()</code> è abbastanza semplice, e la pagina del
	manuale fornisce informazioni sufficienti per un programmatore.

<td valign=top width=50%>

	Maybe now you are smiling as happily as I did when I first heard about
	these two modes. If these concepts are new for you, you might find the
	following hints helpful. Every device is opened by default in blocking
	mode, but you may choose non-blocking mode by setting the
	<code>O_NONBLOCK</code> flag in the <code>open()</code> call. You can
	even change the behaviour of your files later on with the
	<code>fcntl()</code> call. The <code>fcntl()</code> call is an easy one,
	and the man page will be sufficient for any programmer.

<tr>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	La bella addormentata
	</font>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Sleeping Beauty
	</font>

<tr>
<td valign=top width=50%>

	C'era una volta una bella pricipessa che era stata posta in un lungo e
	profondo sonno da una strega. Il mondo quasi si era dimenticato di lei e
	del suo castello circondato ormai dalle rose; finchè un giorno un bel
	principe venne e la baciò, svegliandola dal suo sonno... e successero
	tutte le altre belle cose di cui parlano le fiabe.

<td valign=top width=50%>

	Once upon a time, a beautiful princess was sent by a witch into a long,
	deep sleep, lasting for a hundred years. The world nearly forgot her and
	her castle, twined about by roses, until one day, a handsome prince came
	and kissed her, waking her up...and all the other nice things happened
	that fairy tales tell about.

<tr>
<td valign=top width=50%>

	Il nostro driver mentre attende i dati deve fare esattamente quello che
	faceva la bella addormentata: dormire, lasciando girare il mondo per
	conto suo. Linux offre un meccanismo per questo, chiamato
	<code>interruptible_sleep_on()</code>. Ogni processo che chiama questa
	funzione cade addormentato e lascia il suo tempo al resto del mondo. Il
	processo rimane all'interno di questa funzione finchè un altro processo
	chiama  <code>wake_up_interruptible()</code>. Questo `principe' è di
	solito un gestore di interrupt che ha ricevuto o spedito dati; oppure
	Linux stesso, se viene raggiunta una condizione di timeout.

<td valign=top width=50%>

	Our driver should do exactly what she did while it is waiting for data:
	sleep, leaving the world spinning around. Linux provides a mechanism for
	that, called <code>interruptible_sleep_on()</code>. Every process
	reaching this call will fall asleep and contribute its time slices to
	the rest of the world. It will stay in this function till another
	process calls <code>wake_up_interruptible()</code>, and this prince is
	usually an interrupt handler which has successfully received or sent
	data, or Linux itself, if a time-out condition has occured.

<tr>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Installazione di un gestore di interrupt
	</font>
<td valign=top width=50%>
	<font size=+1 color="#0000ff">
	Installing an interrupt handler
	</font>

<tr>
<td valign=top width=50%>

	Il precedente numero di questa rubrica aveva mostrato un gestore di
	interruzione minimale, chiamato <code>skel_trial_fn()</code>, ma il suo
	funzionamento non era stato spiegato. Presentiamo qui un gestore di
	interrupt completo, che gestirà sia l'input che l'output al dispositivo
	hardware.  Quando il driver attende in modo `blocking' che il
	dispositivo diventi pronto, si addormenta chiamando
	<code>interruptible_sleep_on()</code>. Una interruzione valida termina
	il sonno, facendo ripartire  <code>skel_write()</code>.

<td valign=top width=50%>

	The previous issue of this column showed a minimal interrupt handler,
	which was called <code>skel_trial_fn()</code>, but its workings were not
	explained. Here, a ``complete'' interrupt handler is introduced, which
	will handle both input and output to the actual hardware device. Figure
	1 explains a simple version of its concept: When the driver is waiting
	for the device to get ready (blocking), it goes to sleep by calling
	<code>interruptible_sleep_on()</code>. A valid interrupt ends this
	sleep, restarting <code>skel_write()</code>.

<tr>
<td valign=top width=50%>

	Non vi e` doppio ciclo che occorre quando si lavora con in buffer
	interno di output. La ragione è che se possiamo scrivere solo
	dall'interno di <code>skel_write()</code> non c'è bisogno di un buffer
	di output.  Ma il nostro driver deve anche essere in grado di ricevere
	dati anche quando non si trova in  <code>skel_read()</code>, a dovrebbe
	spedire i dati di output in background anche quando non si trova in
	<code>skel_write()</code>.  Perciò, cambieremo <code>skel_write()</code>
	in modo da sostituire la scrittura diretta all'hardware con il
	salvataggio in un buffer di output, e lascieremo al gestore di
	interruzione il compito di fare il trasferimento reale verso l'hardware.
	L'interrupt e <code>skel_write()</code> saranno poi collegati dal
	`meccanismo della bella addormentata' e dal buffer di output.

<td valign=top width=50%>

	Figure 1 does not include the double-nested loop structure we need when
	working with an internal output buffer. The reason is that if we can
	only perform writing within the <code>skel_write()</code> function there
	is no need for an internal output buffer. But our driver should catch
	data even while not in <code>skel_read()</code> and should write out our
	data in the background even when not in <code>skel_write()</code>.
	Therefore, we will change the hardware writing in
	<code>skel_write()</code> to write to an output buffer and let the
	<em>interrupt handler</em> perform the real writing to the hardware. The
	interrupt and <code>skel_write()</code> will now be linked by the
	``Sleeping Beauty'' mechanism and the output buffer.

<tr>
<td valign=top width=50%>

	Il gestore di interruzione viene installato e disiinstallato durante le
	chiamate di apertura e chiusura del dispositivo, come suggerito
	nell'articolo precedente. Il compito viene gestito dalle seguenti
	funzioni del kernel:

<td valign=top width=50%>

	The interrupt handler is installed and uninstalled during the
	<code>open()</code> and <code>close()</code> calls to the device, as
	suggested in the previous issue. This task is handled by the following
	kernel calls: 

</table>

<pre>
	#include &lt;linux/sched.h>
	int request_irq(unsigned int irq,
	                void (*handler)(int, struct pt_regs *),
	                unsigned long flags,
	                const char *device);
	void free_irq(unsigned int irq);
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	<code>handler</code> è la funzione che vogliamo installare. Il ruolo
	dell'argomento <code>flags</code> è di selezionare le caratterische del
	gestore di interruzione, la più importante è se il gestore di
	interruzione è veloce (<code>SA_INTERRUPT</code> è settato in
	<code>flags</code>) oppure lento (<code>SA_INTERRUPT</code> <em>non</em> è
	settato). Un gestore veloce viene fatto girare con tutte le interruzioni
	disabilitate, mentre uno lento viene eseguito con tutte le altre
	interruzione (tranne la sua stessa) abilitate.

<td valign=top width=50%>

	<code>handler</code> is the actual interrupt handler we wish to install.
	The role of the <code>flags</code> argument is to set a few features of
	the handler, the most important being its behaving as a <em>fast</em>
	(<code>SA_INTERRUPT</code> is set in <code>flags</code>) or as a
	<em>slow</em> (<code> SA_INTERRUPT</code> is <em>not</em> set) handler. A fast
	handler is run with all interrupts disabled, while a slow one is
	executed with all interrupts except itself enabled.

<tr>
<td valign=top width=50%>

	Infine, l'argomento <code>device</code> viene usato per identificare il
	gestore quando si legge <code>/proc/interrupts</code>.

<td valign=top width=50%>

	Finally, the <code>device</code> argument is used to identify our
	handler when looking at <code>/proc/interrupts</code>.

<tr>
<td valign=top width=50%>

	<font size="-1">
	<b>
	NdT: <br>
	Con la versione 1.3.70 del kernel viene aggiunto un argomento a
	</b>
	<code>request_interrupt()</code>
	<b>
	, a 
	</b>
	<code>free_interrupt()</code>
	<b>
	e al gestore di interruzione vero e proprio. Purtroppo non ho tempo di
	specificare le differenze prima che questa versione del Pluto Journal
	venga pubblicata

	<br> -- mea culpa.
	</b>
	</font>

<td valign=top width=50%>

<tr>
<td valign=top width=50%>

	Il gestore di interruzione installato tramite <code>request_irq()</code>
	riceve come argomenti solo il numero di interruzione e il contenuto,
	spesso inutile, dei registri del processore.

<td valign=top width=50%>

	The handler function installed by <code>request_irq()</code> is only
	passed the interrupt number and the (often useless) contents of the
	processor registers.

<tr>
<td valign=top width=50%>

	Il nostro gestore di interruzione dovrà quindi come prima cosa
	determinare a quale scheda l'interruzione si riferisce. Se non possiamo
	trovare di quale scheda si tratta, chiameremo questa situazione
	<em>interruzione spuria</em> e la ignoreremo. Nella maggior parte dei
	casi le interruzioni sono usate per dire che il dispositivo è pronto o
	per accettare una lettura o una scrittura, quindi dovremo trovare
	tramite dei test hardware cosa il dispositivo si aspetta che noi
	facciamo.

<td valign=top width=50%>

	Therefore, we'll first determine which board the calling interrupt
	belongs to. If we can't find any boards, a situation called a
	<em>spurious</em> interrupt has occured, and we should ignore it. Mostly
	interrupts are used to tell the device is ready either for reading
	<em>or</em> writing, so we have to find out by some hardware tests what the
	device wants us to do.

<tr>
<td valign=top width=50%>

	Naturalmente, dovremo lasciare il nostro gestore di interruzione il più
	velocemente possibile; stranamente, però, <code>printk()</code> (e
	quindi <code>PDEBUG()</code>), sono permesse anche all'interno di un
	gestore di interruzione <em>veloce</em>. Questa è una caratteristica
	molto comoda della implementazine di Linux. Guardando in
	<code>kernel/printk.c</code> si troverà che l'implementazione è basata,
	ancora una volta, su code di attesa, in quanto la effettiva consegna dei
	messaggi ai files di log viene gestita da un processo esterno
	(solitamente klogd).

<td valign=top width=50%>

	Of course, we should leave our interrupt handler quickly.  Strangely
	enough, <code>printk()</code> (and thus the <code>PDEBUG</code> line) is
	allowed even within fast interrupt handlers. This is a very useful
	feature of the linux implementation. If you look at
	<code>kernel/printk.c</code> you'll find out that the implementation is
	based on wait queues, as the actual delivery of messages to log files is
	handled by an external process (usually klogd).

<tr>
<td valign=top width=50%>

	Linux può gestire un timeout durante
	<code>interruptible_sleep_on()</code>. Per esempio, se si stanno
	mandando dei dati ad un dispositivo che dovrebbe rispondere entro un
	tempo limitato, la gestione di un timeout al fine di segnalare un errore
	di I/O (ritornando <code>-EIO</code>) al processo che sta usando il
	dispositivo potrebbe essere una buona scelta.

<td valign=top width=50%>

	As shown in figure 2, Linux can care for a timeout when in
	<code>interruptible_sleep_on()</code>. For example, if you have are
	using a device you send an answer to, and it is expected to reply within
	a limited time, causing a time-out to signal an I/O error
	(<code>-EIO</code>) in the return value to the user process might be a
	good choice.

<tr>
<td valign=top width=50%>

	Certamente il processo utente potrebbe gestire la cosa da solo, usando
	il mecchanismo di <code>alarm()</code>, ma risulta decisamente più
	comodo gestire la cosa nel driver stesso. Il tempo limite (il timeout)
	viene specificato da <code>SKEL_TIMEOUT</code>, che viene contato in
	`jiffies'.  Un `jiffy' è il tempo del battito del cuore di un sistema
	Linux, e la variabile <code>jiffies</code> viene incrementata ad ogni
	battito.  La frequenza dell'interruzione del clock (il battito in
	questione) è <code>HZ</code>, definito in <code><asm/param.h></code>
	(incluso da <code>&lt;linux/sched.h></code>). Tale frequenza varia tra
	le differenti architetture supportate e vale, per esempio, 100 Hz su x86
	e 1kHz su Alpha). Per definire un timeour prima di
	<code>interruptible_sleep_on()</code> bastano le seguenti linee:

<td valign=top width=50%>

	Certainly the user process could care for this, too, using the alarm
	mechanism. But it is definitly easier to handle this in the driver
	itself. The timeout criteria is specified by <code>SKEL_TIMEOUT</code>,
	which is counted in jiffies. Jiffies are the steady heartbeat of a Linux
	system, a steady timer being incremented every few milliseconds. The
	frequency is defined by <code>HZ</code> in <code><asm/param.h></code>
	(included by <code>&lt;linux/sched.h></code>) and varies on the
	different architectures (100 Hz Intel, 1 kHz Alpha). You just have to
	set

</table>

<pre>
	#define SKEL_TIMEOUT (timeout_seconds * HZ)
	/* ... */
	current->timeout = jiffies + SKEL_TIMEOUT
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	se  <code>interruptible_sleep_on</code> dovesse protrarsi oltre il
	timeout, <code>current->timeout</code> verrebbe azzerato prima che la
	funzione ritorni, un controllo di <code>current->timeout</code> è quindi
	sufficiente per riconoscere la condizione di  errore.

<td valign=top width=50%>

	and if <code>interruptible_sleep_on</code> timed out,
	<code>current->timeout</code> will be cleared after return.

<tr>
<td valign=top width=50%>

	Bisogna fare attenzione al fatto che le interruzioni possono venire
	generate anche durante l'esecuzione di <code>skel_read()</code> e
	<code>skel_write()</code>.  Le variabili che possono essere cambiate
	all'interno di un gestore di interruzione devono perciò essere
	dichiarate <code>volatile</code>, e devono essere protette contro le
	corse critiche (race conditions).  La classica sequenza di codice per
	proteggere le regioni critiche è la seguente:

<td valign=top width=50%>

	Be aware that interrupts might happen right within
	<code>skel_read()</code> and <code>skel_write()</code>. Variables that
	might be changed within the interrupt should be declared as
	<code>volatile</code>. They also need to be protected to avoid race
	conditions. The classic code sequence to protect a critical region is
	the following:

</table>

<pre>
		unsigned long flags;
		save_flags (flags);
		cli ();
		<em>critical region
		regione_critica</em>
		restore_flags (flags);
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Ed ecco, infine, il codice vero e proprio per la lettura e la scrittura.

<td valign=top width=50%>

	Finally, the code itself:

</table>

<pre>
#define SKEL_IBUFSIZ 512
#define SKEL_OBUFSIZ 512
#define SKEL_TIMEOUT (5*HZ)	/* for 5 seconds timeout */

/* This should be inserted in the Skel_Hw structure */
typedef struct Skel_Hw {
	volatile int ibuf_wpos;	/* write position in input-buffer */
	int ibuf_rpos;		/* read position in input-buffer */
	char *ibuf;		/* the input-buffer itself */
	int obuf_wpos;		/* write position in output-buffer */
	volatile int buf_rpos;	/* read position in output-buffer */
	char *obuf;
	struct wait_queue *skel_wait_iq;
	struct wait_queue *skel_wait_oq;
	...
}

#define SKEL_IBUF_EMPTY(b)	((b)->ibuf_rpos==(b)->ibuf_wpos)
#define SKEL_OBUF_EMPTY(b)	((b)->obuf_rpos==(b)->obuf_wpos)
#define SKEL_IBUF_FULL(b)	(((b)->ibuf_wpos+1)%SKEL_IBUFSIZ==(b)->ibuf_rpos)
#define SKEL_OBUF_FULL(b)	(((b)->obuf_wpos+1)%SKEL_OBUFSIZ==(b)->obuf_rpos)

Static int skel_open (struct inode *inode, struct file *filp) {
	/* .... */
	/* First we allocate the buffers */
	board->ibuf = (char*) kmalloc (SKEL_IBUFSIZ, GFP_KERNEL);
	if (board->ibuf == NULL)
		return -ENOMEM;
	board->obuf = (char*) kmalloc (SKEL_OBUFSIZ, GFP_KERNEL);
	if (board->obuf == NULL) {
		kfree_s (board->ibuf, SKEL_IBUFSIZ);
		return -ENOMEM;
	}
	/* Now we clear them */
	ibuf_wpos = ibuf_rpos = 0;
	obuf_wpos = obuf_rpos = 0;
	board->irq = board->hwirq;
	if ((err=request_irq(board->irq, skel_interrupt, SA_INTERRUPT, "skel")))
		return err;
}


Static void skel_interrupt(int irq, struct pt_regs *unused) {
	int i;
	Skel_Hw *board;

	for (i=0, board=skel_hw; i<skel_boards; board++, i++)
		if (board->irq==irq)	break;	/* spurious */
	if (i==skel_boards)	return;
	if (board_is_ready_for_input())
		skel_hw_write (board);
	if (board_is_ready_for_output())
		skel_hw_read (board);
}


Static inline void skel_hw_write (Skel_Hw *board){
	int rpos;
	char c;

	while (! SKEL_OBUF_EMPTY (board) && board_ready_for_writing()) {
		c = board->obuf [board->obuf_rpos++];
		write_byte_c_to_device();
		board->obuf_rpos %= SKEL_OBUF_SIZ;
	}
	/* Sleeping Beauty */
	wake_up_interruptible (board->skel_wait_oq);
}


Static inline void skel_hw_read (Skel_Hw *board) {
	char c;

	/* If space left in the input buffer & device ready: */
	while (! SKEL_IBUF_FULL (board) && board_ready_for_reading()) {
		read_byte_c_from_device();
		board->ibuf [board->ibuf_wpos++] = c;
		board->ibuf_wpos %= SKEL_IBUFSIZ;
	}
	wake_up_interruptible (board->skel_wait_iq);
}


Static int skel_write (struct inode *inode,
		       struct file *file,
		       char *buf, int count) {
	int n;
	int written=0;
	Skel_Hw board = (Skel_Hw*) (file->private_data);

	for (;;) {
		while (written<count && ! SKEL_OBUF_FULL (board)) {
			board->obuf [board->obuf_wpos] = get_user_byte (buf);
			buf++; board->obuf_wpos++;
			written++;
			board->obuf_wpos %= SKEL_OBUFSIZ;
		}
		if (written)	return written;
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;
		current->timeout = jiffies + SKEL_TIMEOUT;
		interruptible_sleep_on ( &(board->skel_wait_oq));
		/* Why did we return? */
		if (current->signal & ~current->blocked)
			/* If the signal is not not being blocked */
			return -ERESTARTSYS;
		if (!current->timeout)
			/* no write till timout: i/o-error */
			return -EIO;
	}
}


Static int skel_read (struct inode *inode,
		      struct file *file,
		      char *buf, int count) {
	Skel_Hw board = (Skel_Hw*) (file->private_data);
	int bytes_read = 0;

	if (!count)	return 0;

	if (SKEL_IBUF_EMPTY (board)) {
		if (file->f_flags & O_NONBLOCK)
			/* Non-blocking */
			return	-EAGAIN;

		current->time_out = jiffies+SKEL_TIMEOUT;

		for (;;) {
			skel_tell_hw_we_ask_for_data();
			interruptible_sleep_on ( &(board->skel_wait_iq));
			if (current->signal & ~current->blocked)
				return	-ERESTARTSYS;
			if (! SKEL_IBUF_EMPTY (board))
				break;
			if (!current->timeout)
				/* Got timeout: return -EIO */
				return	-EIO;
		}
	}
	/* if some bytes are here, return them */

	while (! SKEL_IBUF_EMPTY (board)) {
		put_user_byte (board->ibuf [board->ibuf_rpos], buf);
		buf++; board->ibuf_rpos++;
		bytes_read++;
		board->ibuf_rpos %= SKEL_IBUFSIZ;
		if (--count == 0)	break;
	}
	if (count) /* still looking for some bytes */
		skel_tell_hw_we_ask_for_data();
	return bytes_read;
}
</pre>

<table border=0 cellpadding=10 width=100%>

<tr>
<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	Come usare <code>select()</code>
	</font>

<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	Handling <code>select()</code>
	</font>

<tr>
<td valign=top width=50%>

	L'ultima importante funzione di I/O che mostriamo è
	<code>select()</code>, una delle parti più interessanti di Unix, nella
	nostra opinione.

<td valign=top width=50%>

	The last important I/O function to be shown is <code>select()</code>,
	one of the most interesting parts of Unix, in my opinion.

<tr>
<td valign=top width=50%>

	La chiamata di sistema <code>select()</code> viene usara per attendere
	che qualche dispositivo diventi pronto, ed è una delle funzioni più
	difficili per il novello programmatore C. Mentre il suo uso dall'interno
	dell'applicazione non viene mostrato qui, la parte dell'implementazione
	specifica del device driver è mostrata qui sotto, e la sua
	caratteristica che colpise di più è la sua compattezza.

<td valign=top width=50%>

	The <code>select()</code> call is used to wait for some device to become
	ready, and is one of the most scary functions for the novice C
	programmer. While its use from within the application is not shown here,
	the driver-specific part of the system call is shown, and its most
	impressive feature is its compactness.  

<tr>
<td valign=top width=50%>

	Ecco il codice completo:

<td valign=top width=50%>

	Here's the full code:

</table>

<pre>
Static int skel_select(struct inode *inode,
                       struct file *filp,
                       int sel_type,
                       select_table *wait) {
	Skel_Clientdata *data=filp->private_data;
	Skel_Hw *board=data->board;

	if (sel_type==SEL_IN) {
		if (! SKEL_IBUF_EMPTY (board))
			return 1;	/* readable */
		skel_tell_hw_we_ask_for_data();
		select_wait(&(board->skel_wait_iq), wait);
		/* not readable */
		return 0;
	}
	if (sel_type==SEL_OUT) {
		if (! SKEL_OBUF_FULL (board))
			return 1;	/* writable */
		/* hw knows */
		select_wait (&(board->skel_wait_oq), wait);
		return 0;
	}
	return 0;	/* exception condition: cannot happen */
}        
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Come si vede, il kernel si prende cura di tutti i problemi della
	gestione delle code di attesa, e occurre solo controllare che il
	dispositivo sia pronto.

<td valign=top width=50%>

	As you see, the kernel takes care of all the hassle of managing wait
	queues, and you have only to check for readiness.


<tr>
<td valign=top width=50%>

	Quando abbiamo scritto la prima implementazione di <code>select()</code>
	per il nostro driver, non avevamo ancora capito la implementazione delle
	pre id attesa, ma questo in effetti non serve ad un programmatore.
	Occorre solo sapere che il codice mostrato funziona. Le code di attesa
	<em>sono</em> problematiche, e di solito durante la scrittura di un driver
	non si ha il tempo di affrontare il problema nei dettagli.

<td valign=top width=50%>

	When we first wrote a <code>select()</code> call for a driver, we didn't
	understand the wait_queue implementation, and you don't need to either.
	You only have to know that the code works.  <code>wait_queue</code>s
	<em>are</em> challenging, and usually when you write a driver you have no
	time to accept the challenge.

<tr>
<td valign=top width=50%>

	In effetti, <code>select()</code> è compresa meglio nelle sue relazioni
	con <code>read()</code> e <code>write()</code>: se <code>select()</code>
	dice che il file è leggibile, allora la prossima <code>read()</code> non
	si bloccherà (indipendentemente da <code>O_NONBLOCK</code>). Questo
	significa che occorre dire all'hardware di ritornare qualche dato.
	L'interruzione raccoglierà i dati e sveglierà la coda di attesa. Se
	l'utente sta selezionando per la scrittura, la situazione è simile: il
	driver deve dire se la prossima <code>write()</code> si bloccherà o no.
	Se il buffer è pieno si bloccherà, ma non occorre riferire questo evento
	all'hardware in quanto <code>write()</code> doverbbe averlo già
	notificato (durante il riempimento del buffer). Se il buffer non è
	pieno, <code>write()</code> non si bloccherà, quindi
	<code>select()</code> ritornerà 1.

<td valign=top width=50%>

	Actually, select is better understood in its relationships with read and
	write: if <code>select()</code> says that the file is readable, the next
	read must not block (independently of <code>O_NONBLOCK</code>), and this
	means you have to tell the hardware to return data. The interrupt will
	collect data, and awake the queue. If the user is selecting for writing,
	the situation is similar: the driver must tell if <code>write()</code>
	will block or not. If the buffer is full it will block, but you don't
	need to tell the hardware about it, since <code>write()</code> has
	already told it (when it filled the buffer). If the buffer is not full,
	the write won't block, so you return 1.


<tr>
<td valign=top width=50%>

	Questo modo di pensare <code>select()</code> per la scrittura può
	sembrare strano, in quanto capita di aver bisogno di scritture sincrone,
	e un programmatore si aspetterebbe che un dispositivo sia scrivibile
	quando ha già accettato tutto l'output precedente. Sfortunatamente,
	questo modo di implementare le cose romperrebbe tutto il macchinario
	delle operazioni blocking/non-blocking, e quindi viene fornita al
	programmatore esigente una chiamata di sistema extra: il driver dovrebbe
	in questo caso offrire una operazione <code>fsync()</code> all'interno
	delle sue <code>fops</code>. L'applicazione invocherà allora
	<code>fops->fsync</code> attraverso la chiamata di sistema
	<code>fsync</code>, e se il driver non supporta tale funzione,
	<code>-EINVAL</code> verrà ritornato al programma.

<td valign=top width=50%>

	This way to think of selecting for write may appear strange, as there
	are times when you need synchronous write, and you may expect that a
	device is writable when it has already accepted pending input.
	Unfortunately, this way of doing things will break the
	blocking/nonblocking machinery, and thus an extra call is provided: if
	you need synchronous write, the driver must offer (within its
	<code>fops</code>) the <code>fsync()</code>call.  The application
	invokes <code>fops->fsync</code> through the <code>fsync()</code> system
	call, and if the driver doesn't support it, <code>-EINVAL</code> is
	returned.


<tr>
<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	<code>ioctl()</code> <br> Passaggio di informazioni di controllo
	</font>

<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	<code>ioctl()</code> <br> Passing Control Information
	</font>

<tr>
<td valign=top width=50%>

	Immaginiamo di voler cambiare la baud-rate della scheda serialie
	multiporta che abbiamo costruito. O che dobbiamo dire al frame grabber
	di cambiare la risoluzione. O quasiasi altra cosa....  Si potrebbero
	impacchettare queate istruzxioni all'interno di sequenze di escape,
	come, per esempio, si fa per posizionare il cursore sui terminali ansi,
	ma ill metodo comunemente usato è la funzione <code>ioctl()</code>.

<td valign=top width=50%>

	Imagine that you want to change the baud-rate of your self-built serial
	multiport card. Or tell your frame grabber to change the resolution. Or
	whatever else... You could wrap these instructions into some escape
	sequences, like, for example, the screen positioning in ansi emulation.
	But, the normal method for this is making an <code>ioctl()</code> call.

<tr>
<td valign=top width=50%>

	Le chiamate <code>ioctl()</code> sono definite in
	<code><sys/ioctl.h></code> e hanno la forma

<td valign=top width=50%>

	<code>ioctl()</code> calls as defined in <code><sys/ioctl.h></code> have
	the form

</table>

<pre>
	ioctl (int file_handle, int command, ...)
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	dove i puntini indicano un argimento di tipo <code>char *</code> (in
	base alla pagina del manuale). Stranamente, il kernel riceve questi
	argomenti tipizzati diversamente in <code>fs/ioctl.c</code>, dove appare
	la forma:

<td valign=top width=50%>

	where <em>...<em> is considered to be one argument of the type
	<code>char *</code> (according to the ioctl man page). Strange as things
	sometimes are, the kernel receives these arguments in
	<code>fs/ioctl.c</code> in the form:

</table>

<pre>
	int sys_ioctl (unsigned int fd, unsigned int cmd,
	               unsigned long arg);
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Per aumentare la confusione, <code>&lt;linux/ioctl.h></code> dà le
	regole dettagliate riguardo a come devono essere costruiti i comandi che
	appaiono come secondo parametro, ma nonostante ciò sono ancora pochi i
	driver che seguono queste buone idee -- principalemente perchè i vecchi
	driver devono mantenere i vecchi comandi, per non creare grosse
	incompatibilità con le applicazioni.

<td valign=top width=50%>

	To enlarge this confusion, <code>&lt;linux/ioctl.h></code> gives
	detailed rules how the commands in the second parameter should be built,
	but nobody in all the drivers is actually following these (good) ideas
	yet.

<tr>
<td valign=top width=50%>

	Invece di pulire i sorgenti del kernel cerchiamo di capire
	l'<em>idea</em> generale delle chiamate <code>ioctl()</code>; il modo
	più corretto per definire i comandi di ioctl è descritto bene in
	<code>Documentation/ioctl-number.txt</code>, ma noi ci limiteremo qui
	alla forma semplice, anche se è sconsigliata.

<td valign=top width=50%>

	Anyway, instead of cleaning up the Linux source tree, lets concentrate
	on the general <em>idea</em> of <code>ioctl()</code> calls.  As the user,
	you pass the file handle and a command in the first two arguments and
	pass a pointer to a data structure the driver should read, write, or
	read <em>and</em> write as the third parameter.

<tr>
<td valign=top width=50%>

	Il programma passa al kernel come primi argomenti di una chiamata
	<code>ioctl()</code> il file descriptor e un numero di comando, un
	puntatore ad una struttura dati che deve essere letta, scritta, o
	letta-e-scritta, dal driver viene passato come terzo parametro
	(opzionale).
	
<tr>
<td valign=top width=50%>

	Alcuni comandi vengono interpretati dal kernel prima di passare il
	controllo al dirver, come  <code>FIONBIO</code>, che cambia il valore
	del flag blocking/non-blocking per il file. Il resto dei comandi, la
	maggior parte, vengono passati alla nostra funzione <code>ioctl()</code>
	all'interno del driver. Il prototipo di tale funzione è il seguente:

<td valign=top width=50%>

	A few commands are interpreted by the kernel itself, for example,
	<code>FIONBIO</code>, which changes the blocking/non-blocking flag of
	the file. The rest is passed to our own, driver-specific
	<code>ioctl()</code> call, and will arrive here in the form:

</table>

<pre>
	int skel_ioctl (struct inode *inode,
	                struct file *file,
	                unsigned int cmd,
	                unsigned long arg)
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Prima di mostrare un breve esempio di implementazione per
	<code>skel_ioctl()</code>, diamo la regola per costruire i numeri dei
	comandi (ma ricordiamo che questo è il metodo sconsigliato: un
	programmatore attento dovrebbe seguire le regole in
	<code>ioctl-number.txt</code>).

<td valign=top width=50%>

	Before we show a small example of a <code>skel_ioctl()</code>
	implementation, the commands you define should obey the following rule:

<tr>
<td valign=top width=50%>

<ol type="a" compact>
<li>
	Si scelga un numero <strong>magico</strong> libero usando la lista in
	<code>Documentation/ioctl-number.txt</code>, questo numero cosituirà gli
	otto bit alti del numero a 16 bit che constituisce il comando.

<li>
	Si numerino sequenzialmente i comandi negli otto bit più bassi.

</ol>

<td valign=top width=50%>

<ol type="a" compact>
<li>
	Pick up a free MAGIC number from <code>/usr/src/linux/MAGIC</code> and
	make this number the upper eight bits of your 16-bit command word.

<li>
	Enumerate your commands in the lower eight bits.

</ol>

<tr>
<td valign=top width=50%>

	Perchè questo? Immaginiamo che Pierino faccia partire il suo favorito
	programma di comunicazione per connettersi alla sua casella postale
	favorita. Pierino ha casualmente cambiato la linea seriale usata da
	<code>minicom</code> da <code>/dev/ttyS0</code> a
	<code>/dev/skel0</code> (è stata una mossa abbastanza stupida, in
	effetti). La prima operazione effettuata da <code>minicom</code> è
	inizializzare la `linea seriale', usando una <code>ioctl()</code> per
	passare il comando <code>TCGETA</code>.  Sfortunatamente, il nostro
	driver che sta dietro <code>/dev/skel0</code> usa lo stesso numero per
	controllare il voltaggio di un esperimento che sta girando da giorni nel
	laboratorio...

<td valign=top width=50%>

	Why this? Imagine ``Silly Billy'' starts his favorite terminal program
	minicom to connect to his favorite mailbox.  ``Silly Billy''
	accidentally changed the serial line <code>minicom</code> uses from
	<code>/dev/ttyS0</code> to <code>/dev/skel0</code> (he is quite silly).
	The next thing <code>minicom</code> does is initialise the ``serial
	line'' with an <code>ioctl()</code> using <code>TCGETA</code> as
	command. Unfortunately, your device driver being hidden behind
	<code>/dev/skel0</code> uses that number to control the voltage for a
	long-term experiment in the lab...

<tr>
<td valign=top width=50%>

	Se gli otto bit alti dei comandi di  <code>ioctl()</code> sono diversi
	da un driver all'altro, ogni  <code>ioctl()</code> che si riferisca ad
	un device inappropriato fara ritornare il valore <code>-EINVAL</code>,
	proteggendoci da risultati inaspettati come quello descritto sopra.

<td valign=top width=50%>

	If the upper eight bits in the commands for <code>ioctl()</code> differ
	from driver to driver, every <code>ioctl()</code> to an inappropriate
	device will result in an <code>-EINVAL</code> return, protecting us from
	extremely unexpected results.

<tr>
<td valign=top width=50%>

	Per finire questa sezione implementeremo ora una funzione
	<code>ioctl()</code> per leggere o modificare il valore attuale del
	timeout del nostro driver. Se si vuole usare questa funzione occorre
	però introdurre una nuova variabile nel driver dopo la definizione di
	<code>SKEL_TIMEOUT</code>:

<td valign=top width=50%>

	Now, to finish this section, we will implement an <code>ioctl()</code>
	call reading or changing the timeout delay in our driver. If you want to
	use it, you have to introduce a new variable

</table>

<pre>
	unsigned long skel_timeout = SKEL_TIMEOUT;
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Ogni occorrenza di  <code>SKEL_TIMEOUT</code> andrà poi sostiuita con
	<code>skel_timeout</code>.

<td valign=top width=50%>

	right after the definition of <code>SKEL_TIMEOUT</code> and replace
	every later occurence of <code>SKEL_TIMEOUT</code> with
	<code>skel_timeout</code>.

<tr>
<td valign=top width=50%>

	Abbiamo poi scelto il numero <strong>magico</strong> <code>'4'</code>
	(il codice ascii per il numero 4), e abbiamo definito due comandi:

<td valign=top width=50%>

	We choose the <strong>MAGIC</strong> <code>'4'</code> (the ASCII
	character 4) and define two commands:

</table>

<pre>
	# define SKEL_GET_TIMEOUT 0x3401
	# define SKEL_SET_TIMEOUT 0x3402
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Nel nostro programma, queste linee saranno usate per raddoppiare il
	valore corrente del timeout:

<td valign=top width=50%>

	In our user process, these lines will double the time-out value:

</table>

<pre>
	/* ... */
	unsigned long timeout;

	if (ioctl (skel_hd, SKEL_GET_TIMEOUT, &timeout) < 0) {
		/* an error occured (Silly Billy?) */
		/* ... */
	}
	timeout *= 2;
	if (ioctl (skel_hd, SKEL_SET_TIMEOUT, &timeout) < 0) {
		/* another error */
		/* ... */
	}
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	Nel driver, invece, queste linee saranno quelle che compiono il lavoro:

<td valign=top width=50%>

	And in our driver, these lines will do the work:

</table>

<pre>
	int skel_ioctl (struct inode *inode,
	                struct file *file,
	                unsigned int cmd,
			unsigned long arg) {
		switch (cmd) {
		case SKEL_GET_TIMEOUT:
			put_user_long(skel_timeout, (long*) arg);
			return 0;
		case SKEL_SET_TIMEOUT:
			skel_timeout = get_user_long((long*) arg);
			return 0;
		default:
			return	-EINVAL;	/* for Silly Billy */
		}
	}
</pre>

<table border=0 cellpadding=10 width=100%>
<tr>
<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	Il prossimo numero
	</font>

<td valign=top width=50%>

	<font size=+1 color="#0000ff">
	Next Month
	</font>

<tr>
<td valign=top width=50%>

	Nelle prossime sezioni investigheremo i segreti della gestione di
	meoria, e entreremo in contatto con il DMA e <code>mmap()</code>,
	fornendo al nostro driver il meglio della gestione di memoria di Linux.

<td valign=top width=50%>

	In the next sections, we will investigate the secrets of Linux memory
	management and get in touch with DMA and <code>mmap()</code>, providing
	our driver with the ultimate throughput of Linux memory management. 

<tr>
<td valign=top width=50%>
<hr>

	Georg e Alessandro sono linuxers di 27 anni con un gusto per il lato
	pratico dell'informatica e una tendenza a dilazionare il sonno.

<td valign=top width=50%>
<hr>

	Georg and Alessandro are both 27-year-old Linuxers with a taste for the
	practical side of Computer Science and a tendancy to avoid sleep.

</table>
