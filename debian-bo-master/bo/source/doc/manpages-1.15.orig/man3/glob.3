.\" (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Wed Jul 28 11:12:17 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Mon May 13 23:08:50 1996 by Martin Schulze (joey@linux.de)
.\"
.TH GLOB 3  "May 13, 1996" "GNU" "Linux Programmer's Manual"
.SH NAME
glob, globfree \- find pathnames matching a pattern, free memory from glob()
.SH SYNOPSIS
.nf
.B #include <glob.h>
.sp
.BI "int glob(const char *" pattern ", int " flags ","
.nl
.BI "         int " errfunc "(const char * " epath ", int " eerrno ),
.nl
.BI "         glob_t " "*pglob" );
.nl
.BI "void globfree(glob_t *" pglob ");"
.fi
.SH DESCRIPTION
The
.B glob()
function searches for all the pathnames matching
.I pattern
according to the rules used by the shell (see
.BR glob (7)).
No tilde expansion or parameter substitution is done.
.PP
The
.B globfree()
function frees the dynamically allocated storage from an earlier call
to
.BR glob() .
.PP
The results of a
.B glob()
call are stored in the structure pointed to by
.IR pglob ,
which is a
.B glob_t
which is declared in
.B <glob.h>
as
.PP
.br
.nf
.in 10
typedef struct
{
.in 14
    int gl_pathc;       /* Count of paths matched so far  */
    char **gl_pathv;    /* List of matched pathnames.  */
    int gl_offs;        /* Slots to reserve in `gl_pathv'.  */
    int gl_flags;       /* Flags for globbing  */
.in 10
} glob_t;
.fi
.PP
Results are stored in dynamically allocated storage.
.PP
The parameter
.I flags
is made up of bitwise OR of zero or more the following symbolic
constants, which modify the of behaviour of
.BR glob() :
.TP
.B GLOB_ERR
which means to return upon read error (because a directory does not
have read permission, for example),
.TP
.B GLOB_MARK
which means to append a slash to each path which corresponds to a directory,
.TP
.B GLOB_NOSORT
which means don't sort the returned pathnames (they are by default),
.TP
.B GLOB_DOOFS
which means that
.I pglob->gl_offs
slots will be reserved at the beginning of the list of strings in
.IR pglob->pathv ,
.TP
.B GLOB_NOCHECK
which means that, if no pattern matches, to return the original pattern,
.TP
.B GLOB_APPEND
which means to append to the results of a previous call.  Do not set
this flag on the first invocation of
.BR glob() .
.TP
.B GLOB_NOESCAPE
which means that meta characters cannot be quoted by backslashes, and
.TP
.B GLOB_PERIOD
which means that a leading period can be matched by meta characters.
.PP
If
.I errfunc
is not
.BR NULL ,
it will be called in case of an error with the arguments
.IR epath ,
a pointer to the path which failed, and
.IR eerrno ,
the value of
.I errno
as returned from one of the calls to
.BR opendir() ", " readdir() ", or " stat() .
If 
.I errfunc
returns non-zero, or if
.B GLOB_ERR
is set, 
.B glob()
will terminate after the call to
.IR errfunc .
.PP
Upon successful return, 
.I pglob->gl_pathc
contains the number of matched pathnames and
.I pglob->gl_pathv
a pointer to the list of matched pathnames.  The first pointer after
the last pathname is
.BR NULL .
.PP
It is possible to call
.B glob()
several times.  In that case, the
.B GLOB_APPEND
flag has to be set in
.I flags
on the second and later invocations.
.SH "RETURN VALUES"
On successful completion, 
.B glob()
returns zero.
Other possible returns are:
.TP
.B GLOB_NOSPACE
for running out of memory,
.TP
.B GLOB_ABEND
for a read error, and
.TP
.B GLOB_NOMATCH
for no found matches.
.SH "EXAMPLES"
One example of use is the following code, which simulates typing
.nl
.B ls -l *.c ../*.c
.nl
in the shell.
.nf
.in 10

glob_t globbuf;

globbuf.gl_offs = 2;
glob("*.c", GLOB_DOOFS, NULL, &globbuf);
glob("../*.c", GLOB_DOOFS | GLOB_APPEND, NULL, &globbuf);
globbuf.gl_pathv[0] = "ls";
globbuf.gl_pathv[1] = "-l";
execvp("ls", &globbuf.gl_pathv[0]);
.fi
.SH "CONFORMING TO"
proposed POSIX.2
.SH "BUGS"
The
.B glob()
function may fail due to failure of underlying function calls, such as
.BR malloc() " or " opendir() .
These will store their error code in
.IR errno .
.PP
POSIX.2 is not yet an approved standard; the information in this
manpage is subject to change.
.SH "SEE ALSO"
.BR ls "(1), " sh "(1), " exec "(2), " stat "(2), " malloc (3),
.BR opendir "(3), " readdir "(3), " wordexp "(3), " glob (7)
