<!--	impaginazione di Fabrizio Polacco
	Last modification: Sun, 16 Mar 1997 22:13:18 +0200
  -->
<center>
<font size=+2 color=blue>
	Amministrazione di un server Web
</font>
        <br>
</center>

<address>
<p align=right>
        <font size=-1 color=green>
        di
	<a href="mailto:lac0658@iperbole.bologna.it">Nando Santagata</a>
        </font>
</address>

<p>
	<h2>Password, gruppi ed altro</h2>
<p>
	Ora che tutti hanno un server Web con cui giocare, magari
	qualcuno potrà essere tentato di usare il proprio patrimonio di
	informazioni per metterle a disposizione delle persone più
	fidate.
<p>
	È ovvio che, essendo informazioni private, si vuole avere un
	minimo di controllo su chi vi accederà.
	<br>
	Questo può essere ottenuto mediante un'opportuna protezione
	tramite password.
<p>
	In questo momento sto usando il server Web Apache 1.1.1, quindi
	descriverò il modo in cui questo server gestisce gli accessi.
	Altri server (ad esempio l'NCSA) agiscono in modo molto simile.
<p>
	Nel caso di Apache è possibile proteggere una directory mediante
	password creando all'interno di questa un file di nome
	<code>.htaccess</code>, che contenga queste istruzioni:
<p>

<code> <pre>
AuthType Basic
AuthName mia
AuthUserFile /etc/apache/passwd
AuthGroupFile /etc/apache/group
&ltLimit GET POST&gt
require group mio
&lt/Limit&gt
</pre> </code>

<p>
	La keyword <code>AuthType</code> serve per specificare il tipo
	di gestione delle password (inutile preoccuparsi dei vari tipi
	di autenticazione, dato che al momento è implementata solo la
	<code>Basic</code> :-)
	<br>
	La keyword <code>AuthName</code> specifica il nome
	dell'autorizzazione. In pratica, quando vi comparirà la dialog
	di richiesta della password, leggerete qualcosa come:
<p>

<code>
Enter username for mia at xxx:
</code>

<p>
	dove <code>xxx</code> è il nome della vostra macchina.
<p>
	Le keyword <code>AuthUserFile</code> e
	<code>AuthGroupFile</code> servono per definire i nomi dei
	file degli utenti e dei gruppi.
	<br>
	Esattamente come accade a livello di login al sistema, esiste un
	file che associa gli utenti alle proprie password. In questo
	caso però l'appartenenza ai gruppi viene gestita mediante un
	file in cui si associano gli utenti ai gruppi.
	<br>
	Ho scelto di sistemare il file dei gruppi e quello delle
	password in <code>/etc/apache</code>, directory in cui la
	distribuzione che uso, la Debian, inserisce i file di
	configurazione del server.
<p>
	Il passo successivo è quello di limitare l'accesso alla
	directory (e tutte le sue subdirectory) con la keyword
	<code>Limit</code>, richiedendo l'appartenenza ad uno
	specifico gruppo con la <code>require group</code>.
	<br>
	Ovviamente <code>mio</code> è il nome del gruppo di cui si
	deve fare parte per accedere alla lettura delle pagine
	riservate.
<p>
	Quando un utente cercherà di accedere ad una pagina protetta, il
	sistema richiederà l'immissione di uno username e di una
	password.
	<br>
	Ottenuti questi dati, cercherà nel file dei gruppi, per
	assicurarsi che l'utente faccia parte del gruppo autorizzato e
	verificherà nel file delle password che l'utente sia a
	conoscenza della password giusta.
<p>
	Questo meccanismo ci permette di poter specificare la nostra
	password di utente una volta per tutte e di poter girare in
	tutte le directory in cui è permesso l'accesso ad uno dei gruppi
	di cui facciamo parte, senza dover ripetere al sistema la nostra
	password.  Normalmente questa sarà <em>ricordata</em> dal nostro
	browser, che la trasmetterà al server su richiesta.
<p>
	Fin qui tutto bene.
	<br>
	Creare il file dei gruppi è molto semplice: basta elencare i
	gruppi e gli utenti che ne fanno parte. Ad esempio:
<p>

<code> <pre>
mio: nando miriam greta
admin: nando
</pre> </code>

<p>
	Il file delle password può essere creato con l'utility
	<code>htpasswd</code>, che, specificato il pathname del file
	delle password e il nome dell'utente, richiede la sua password,
	la critta e la salva nel file.
<p>
	Questa è però un'operazione da eseguire rigorosamente da riga di
	comando e loggandosi come root (se ci tenete alla
	sicurezza).
	<br>
	Se amate le interfacce grafiche o se l'amministrazione del
	vostro sito Web è affidata ad un vostro collega
	finestrodipendente a cui non dareste mai la password di root,
	potete però crearvi un vostro tool grafico di amministrazione
	con cui si possa operare anche senza essere superuser.
<p>
	Iniziamo creando una form per la modifica delle password:
<p>

<code> <pre>
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Modifica della password&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;font size=4&gt;
&lt;center&gt;
Crea un utente o modifica la sua password
&lt;/center&gt;
&lt;p&gt;

&lt;!--#include virtual=&quot;/cgi-bin/listautenti&quot;--&gt;

&lt;p&gt;
Inserisci il nome dell'utente nel campo &lt;b&gt;Nome utente&lt;/b&gt;.
&lt;p&gt;
La sua password dovr&amp;agrave; essere inserita nei campi &lt;b&gt;Password&lt;/b&gt;
e &lt;b&gt;Verifica&lt;/b&gt;. Il contenuto dei due campi dovr&amp;agrave; essere uguale,
altrimenti l'utente non sar&amp;agrave; creato o la sua password non verr&amp;agrave;
modificata.
&lt;p&gt;
Per attivare la procedura di creazione/modifica dell'utente premere il tasto
&lt;b&gt;Crea/Cambia&lt;/b&gt;.

&lt;form name=&quot;utente&quot; method=POST action=&quot;/cgi-bin/chpasswd&quot;&gt;
Nome utente: &lt;input size=20 name=utente&gt;

&lt;!--#include virtual=&quot;/cgi-bin/listagruppi&quot;--&gt;

&lt;p&gt;
Password: &lt;input type=password size=8 name=passwd&gt; &lt;br&gt;
Verifica: &lt;input type=password size=8 name=passwd2&gt;
&lt;p&gt;
&lt;input type=submit value=&quot;Crea/Cambia&quot;&gt;
&lt;input type=reset value=Cancella&gt;
&lt;input type=&quot;button&quot; value=&quot;Torna al Menu&quot; onClick=&quot;location='/admin/'&quot;&gt;
&lt;br&gt;
&lt;/font&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre> </code>

<p>
	Chiamate questa pagina con un nome del tipo
	<code>chpasswd.shtml</code>.  L'estensione <code>shtml</code> è
	importante, perché identifica le pagine che devono essere
	preprocessate dal server.
<p>
	Il server Apache permette l'uso dei <em>SSI</em> o Server Side
	Include, che sono delle particolari istruzioni, inserite come
	commenti HTML all'interno della pagina, che vengono interpretate
	dal server, che esegue il programma specificato e ne riporta
	l'output nella pagina che spedisce al browser.
	<br>
	Questa peculiarità permette quindi la costruzione di pagine
	<em>dinamiche</em>, il cui contenuto può variare di volta in
	volta.
<p>
	Per attivare l'uso dei SSI bisogna aggiungere nel file di
	configurazione di Apache <strong>srm.conf</strong> la
	direttiva:
<p>

<code> <pre>
AddType text/x-server-parsed-html .shtml
</pre> </code>

<p>
	Nella nostra form abbiamo un SSI:
<p>

<code> <pre>
&lt;!--#include virtual=&quot;/cgi-bin/listautenti&quot;--&gt;
</pre> </code>

<p>
	che lancia un programma Perl che lista tutti gli utenti e i
	relativi gruppi presenti in quel momento sul server.
	<br>
	Il programma è molto semplice:
<p>

<code> <pre>
#!/usr/bin/perl

$passwd = &quot;/etc/apache/passwd&quot;;
$group  = &quot;/etc/apache/group&quot;;

print &quot;Content-Type: text/html\r\n\r\n&quot;;

open GROUP, $group or die &quot;Non posso aprire il file dei gruppi: $!&quot;;
while(&lt;GROUP&gt;){
	($gr, $ut) = split /:/;
	@utenti = split /\s/, $ut;
	foreach $utente (@utenti){
		next if $utente eq '';
		push @{ $user{$utente} }, $gr;
	}
}
close GROUP;

open PASS, $passwd or die &quot;Non posso aprire il file delle password: $!&quot;;
print &lt;&lt;EOF;
Gli utenti attualmente abilitati e i gruppi di cui fanno parte sono:
&lt;p&gt;
&lt;ud&gt;
EOF
while(&lt;PASS&gt;){
	$utente = (split /:/)[0];
	print &quot;&lt;li&gt;&lt;font color='#ff4040'&gt;$utente&lt;/font&gt;: &lt;font color='#00ee00'&gt;&quot;,
		join(&quot; &quot;, @{ $user{$utente} }), &quot;&lt;/font&gt;\n&quot;;
}
close PASS;
print &quot;&lt;/ud&gt;\n&quot;;
</pre> </code>

<p>
	Le formalità a cui deve adempiere un programma SSI sono
	all'incirca le stesse a cui devono sottostare i programmi che
	colloquino con il server http tramite il protocollo CGI.  La
	comunicazione deve iniziare con una stringa di identificazione:
<p>

<code> <pre>
Content-Type: text/html
</pre> </code>

<p>
	seguita da due <code>CR/LF</code>.
	<br>
	Da questo punto in poi tutto l'output generato dal nostro
	programma sarà inserito nel testo della form.
<p>
	Il loop:
<p>

<code> <pre>
while(&lt;GROUP&gt;){
	($gr, $ut) = split /:/;
	@utenti = split /\s/, $ut;
	foreach $utente (@utenti){
		push @{ $user{$utente} }, $gr;
	}
}
</pre> </code>

<p>
	legge una riga dal file dei gruppi di Apache e la divide
	all'altezza del carattere <code><strong>':'</strong></code>. La
	prima parte è il nome del gruppo, la seconda è una stringa che
	contiene i nomi di tutti gli utenti appartenenti al gruppo,
	separati da spazi.
<p>
	A sua volta l'elenco degli utenti viene diviso e per ognuno
	degli utenti viene creato un array associativo la cui chiave è
	il nome dell'utente e il suo valore è l'array dei gruppi di cui
	l'utente fa parte.
<p>
	Questo genere di struttura dati è un po' complessa, quindi
	conviene spenderci qualche parola. La base è un array di tipo
	particolare (array associativo o <em>hash</em>), il cui indice,
	invece di essere un numero, può essere una qualsiasi stringa, in
	questo caso il nome dell'utente.
	<br>
	Ognuno degli elementi di questo array è a sua volta un array: la
	lista dei gruppi a cui l'utente appartiene.
	<br>
	Il nome dell'hash è <code>user</code>, un suo elemento è
	indicizzato da <code>$user{$utente}</code>, in cui
	<code>$utente</code> contiene un nome. L'elemento in questione è
	una lista, a cui appendiamo il nome del gruppo di cui l'utente
	fa parte, per mezzo dell'operatore <code>push</code>.
<p>
	L'operatore <code>push</code> accetta due argomenti: l'array in
	cui inserire l'elemento e lo scalare da inserire.
	<br>
	La forma <code>@{ $user{$utente} }</code> viene utilizzata per
	indicare che l'elemento dell'hash è un array.
<p>
	Spero che siate riusciti a seguirmi in questa complessa
	spiegazione.  In caso vi stiate perdendo d'animo devo ammettere
	che le strutture dati complesse sono una delle cose più
	difficili non solo del Perl, ma di qualsiasi linguaggio di
	programmazione.
	<br>
	L'analogo in C avrebbe comportato un'array di struct i cui
	elementi sarebbero stati un puntatore e un puntatore ad un
	array... non molto più semplice.
<p>
	Certo esistono modi più semplici di fare le cose, dal punto di
	vista dei dati, ma si deve scrivere più codice... e io sono
	pigro.
<p>
	Proseguendo con l'analisi del programma, arriviamo alla seconda
	parte, che legge il file delle password e per ogni utente
	trovato ne stampa il nome e l'elenco dei gruppi di cui fa parte,
	incapsulando il tutto con dell'HTML.
	<br>
	L'unica riga criptica di questa parte è (spero :-):
<p>

<code> <pre>
$utente = (split /:/)[0];
</pre> </code>

<p>
	La cosa può essere spiegata facilmente: l'operatore
	<code>split</code>, come la maggior parte degli operatori e
	funzioni del Perl, può agire su una variabile di default:
	<code>$_</code>.
	<br>
	In questo caso lo split agisce sulla riga corrente appena letta
	dal file delle password e la divide all'altezza del carattere
	<code><strong>':'</strong></code>, generando una lista con il
	risultato dell'operazione.
	<br>
	A noi interessa solo il primo elemento della lista, il nome
	dell'utente, e non intendiamo toccare la sua password (per il
	momento), quindi prendiamo solo l'elemento <code>[0]</code>
	di questo array.
<p>
	Ma non abbiamo ancora terminato con i SSI: ce n'è ancora uno,
	quello che nelle mie intenzioni deve produrre una serie di
	checkbox, una per ogni gruppo presente, e permettere quindi di
	assegnare l'utente creato ad uno o più gruppi:
<p>

<code> <pre>
#!/usr/bin/perl

$group  = &quot;/etc/apache/group&quot;;

print &quot;Content-Type: text/html\r\n\r\n&quot;;

open GROUP, $group or die &quot;Non posso aprire il file dei gruppi: $!&quot;;
print &quot;Gruppi: &quot;;
while(&lt;GROUP&gt;){
	$gr = (split /:/)[0];
	print &quot;$gr: &lt;input type='checkbox' name='gruppo' value='$gr'&gt;\n&quot;;
}
close GROUP;
</pre> </code>

<p>
	Se siete riusciti a seguire il programmino precedente, questo vi
	risulterà banale.
<p>
	Finito di imbellettare la nostra form, abbiamo bisogno di un
	programma che si preoccupi di modificare il file delle password,
	gestendo i dati immessi dall'utente.
<p>
	Questo programma dovrà leggere e soprattutto <em>scrivere</em>
	file di proprietà di root, in una directory che sulla mia
	macchina ha delle permission di questo tipo:
<p>

<code> <pre>
drwxr-xr-x   2 root     root         1024 Jan 10 19:46 /etc/apache/
</pre> </code>

<p>
	Questo rappresenta un problema, se si tiene conto che i programi
	CGI vengono eseguiti con le permission dell'utente
	<code>nobody</code>.
	<br>
	Il nostro programma dovrà essere suid root, per poter essere
	eseguito dall'utente proprietario dei dati da modificare.
	<br>
	Quando si parla di script suid, il discorso si fa spinoso e
	molti preferiscono dire che "non si deve", ma in casi come
	questo, a meno di non scriverci un apposito modulo per Apache,
	l'unica soluzione è quella di rilassare un po' il nostro livello
	di paranoia.
<p>
	Ci sono due modi di eseguire uno script con le permission di un
	altro utente: creare un programma C che sia suid e che si
	preoccupi di invocare il nostro script una volta entrato in
	esecuzione con le permission giuste (<em>C wrapper</em>) o usare
	il <code>suidperl</code>, una variante dell'eseguibile del
	Perl, che permette l'esecuzione suid degli script ed è molto più
	paranoico di quello che potrebbe essere l'utente normale che si
	metta a scrivere un C wrapper.
<p>
	Di solito preferisco questa ultima soluzione, quindi lo script
	che presento userà il suidperl, ma potete di cambiare la prima
	riga per puntare al normale perl e scrivervi un C wrapper.
<p>

<code> <pre>
#!/usr/bin/suidperl

use CGI::Request;
use CGI::Carp;

sub errore
{
	my($motivo) = shift;

	print &lt;&lt;EOF;
	&lt;html&gt;
	&lt;head&gt;
	&lt;title&gt;Modifica non effettuata&lt;/title&gt;
	&lt;/head&gt;
	&lt;body bgcolor=&quot;#cc0000&quot;&gt;
	$motivo
	&lt;p&gt;
	&lt;form name=&quot;indietro&quot;&gt;
	&lt;input type=&quot;button&quot; value=&quot;Torna indietro&quot; onClick=&quot;history.back()&quot;&gt;
	&lt;input type=&quot;button&quot; value=&quot;Torna al Menu&quot; onClick=&quot;location='/admin/'&quot;&gt;
	&lt;/form&gt;
	&lt;/body&gt;
	&lt;/html&gt;
EOF
}

# Legge gli elementi della form

$req       = GetRequest();
$user      = $req-&gt;param('utente');
$passwd    = $req-&gt;param('passwd');
$passwd2   = $req-&gt;param('passwd2');
@gruppi    = $req-&gt;param('gruppo');

# E` stato immesso il nome dell'utente?

if($user eq ''){
	$motivo = &lt;&lt;EOF;
	&lt;em&gt;Non&lt;/em&gt; &amp;egrave; possibile creare o modificare l'utente, perch&amp;eacute;
	non &amp;egrave stato specificato alcun nome.
EOF
	errore($motivo);
	return;
}

# E` stato immessa la password?

if($passwd eq ''){
	$motivo = &lt;&lt;EOF;
	La password dell'utente &lt;b&gt;$user&lt;/b&gt; &lt;em&gt;non&lt;/em&gt; &amp;egrave; stata creata o
	modificata, perch&amp;eacute; non &amp;egrave; stata specificata alcuna password.
EOF
	errore($motivo);
	return;
}

# Test della password immessa

if($passwd ne $passwd2){
	$motivo = &lt;&lt;EOF;
	La password dell'utente &lt;b&gt;$user&lt;/b&gt; &lt;em&gt;non&lt;/em&gt; &amp;egrave; stata creata o
	modificata, perch&amp;eacute; la password specificata e la sua replica sono
	diverse.
EOF
	errore($motivo);
	return;
}

$newfile = &quot;/etc/apache/passwd&quot;;
$oldfile = &quot;${newfile}.old&quot;;

# Muove il file delle password

unlink $oldfile or
	die &quot;Non posso cancellare il file: $!&quot;
	if -e $oldfile;
rename $newfile, $oldfile or
	die &quot;Non posso rinominare il file: $!&quot;
	if -e $newfile;

$newstring = crypt($passwd,'aa');

# Modifica o aggiunge l'utente

open PASSOLD, $oldfile  || die &quot;Non posso leggere il file: $!&quot;;
open PASSNEW, &quot;&gt;$newfile&quot; || die &quot;Non posso scrivere il file: $!&quot;;

$flag = 0;
while (&lt;PASSOLD&gt;) {
	if(s/^${user}:.*/${user}:${newstring}/){
		$flag=1;
	}
	print PASSNEW;
}

print PASSNEW &quot;${user}:$newstring\n&quot; if $flag == 0;

close PASSOLD;
close PASSNEW;

# Modifica i gruppi

$newgroup = &quot;/etc/apache/group&quot;;
$oldgroup = &quot;${newgroup}.old&quot;;

# Muove il file dei gruppi

unlink $oldgroup or
	die &quot;Non posso cancellare il file: $!&quot;
	if -e $oldgroup;
rename $newgroup, $oldgroup or
	die &quot;Non posso rinominare il file: $!&quot;
	if -e $newgroup;

open GROLD, $oldgroup  || die &quot;Non posso leggere il file: $!&quot;;
open GRNEW, &quot;&gt;$newgroup&quot; || die &quot;Non posso scrivere il file: $!&quot;;

while (&lt;GROLD&gt;) {
	chomp;
	($gr, $ut) = split /:/;
	@utenti = split /\s/, $ut;

	if(grep /$gr/, @gruppi){			# L'utente deve far parte del gruppo
		unless(grep /$user/, @utenti){	# Se non ne fa parte
			push @utenti, $user;
		}
	}else{								# L'utente non deve far parte del gruppo
		@utenti = grep {!/\b${user}\b/} @utenti;
	}
	
	print GRNEW &quot;$gr:&quot;, join(&quot; &quot;, @utenti), &quot;\n&quot;;
}

close GROLD;
close GRNEW;

# Feedback

print &lt;&lt;EOF;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Modifica effettuata&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor=&quot;#669900&quot;&gt;
La password dell'utente &lt;b&gt;$user&lt;/b&gt; &amp;egrave; stata creata o modificata
se esistente.
&lt;p&gt;
EOF

# Warnings

print &lt;&lt;EOF if $passwd eq $user;
	&lt;p&gt;
	&lt;hr&gt;
	&lt;b&gt;Attenzione&lt;/b&gt;: la password &amp;egrave; uguale al logname
	dell'utente e la cosa non &amp;egrave; considerata ottimale
	dal punto di vista della sicurezza.
	&lt;p&gt;
	&lt;hr&gt;
EOF

print &lt;&lt;EOF if length($passwd) &lt; 4;
	&lt;p&gt;
	&lt;hr&gt;
	&lt;b&gt;Attenzione&lt;/b&gt;: la password &amp;egrave; composta da meno di quattro
	caratteri e la cosa non &amp;egrave; considerata ottimale
	dal punto di vista della sicurezza.
	&lt;p&gt;
	&lt;hr&gt;
EOF

print &lt;&lt;EOF if !defined @gruppi;
	&lt;p&gt;
	&lt;hr&gt;
	&lt;b&gt;Attenzione&lt;/b&gt;: l'utente &lt;b&gt;$user&lt;/b&gt; non fa parte di nessun gruppo.
	&lt;p&gt;
	&lt;hr&gt;
EOF

# Fine pagina

print &lt;&lt;EOF;
&lt;form name=&quot;indietro&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;Torna indietro&quot; onClick=&quot;history.back()&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;Torna al Menu&quot; onClick=&quot;location='/admin/'&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
EOF
</pre> </code>

<p>
	In questo programmino uso due moduli esterni che fanno parte di
	una libreria di moduli per la programmazione con il protocollo
	CGI: la <code>CGI-modules-2.75.tar.gz</code> .  Potete
	procurarvela su un qualsiasi sito aderente al
	<strong>CPAN</strong> (Comprehensive Perl Archive Network), ad
	esempio questo è il <a
	href="ftp://cis.utovrm.it/CPAN/modules/by-module/CGI">sito
	italiano</a> del network.
<p>
	Il primo modulo, <code>CGI::Request</code>, gestisce la lettura
	dell'input contenuto nella form, il secondo,
	<code>CGI::Carp</code>, serve per redirigere tutti i nostri
	messaggi di errore generati con l'operatore <code>die</code> nel
	file di log degli errori del server Apache.
<p>
	All'inizio del programmino c'è una subroutine che serve a
	generare una pagina HTML per mostrare gli eventuali messaggi di
	errore generati dal programma.
	<br>
	Perdonatemi, ma questa volta non ho resistito e mi sono scappate
	alcune estensioni di Netscape, non propriamente standard. Del
	resto sembra che per alcune persone sia un problema dover
	cliccare il tasto nella barra degli strumenti di Netscape, così
	ho inserito un tasto <em>Torna indietro</em>.
	<br>
	L'altro tasto porta al menu dell'Amministrazione del Web, di cui
	questo programmino potrebbe essere solo una delle tante opzioni
	(ho messo questo menu nella directory <code>/admin</code>).
<p>
	Dopo aver letto i valori degli elementi della form, comincio ad
	analizzare alcune possibili condizioni di errore (almeno le più
	banali).
	<br>
	Se il test risulta positivo, come nel caso:
<p>

<code> <pre>
if($user eq ''){
</pre> </code>

<p>
	in cui il problema è quello che l'amministratore ha dimenticato
	di inserire il nome dell'utente, allora valorizzo una variabile,
	<code>$motivo</code>, usando la tecnica dell'<em>here
	document</em>:
<p>

<code> <pre>
	$motivo = &lt;&lt;EOF;
	&lt;em&gt;Non&lt;/em&gt; &amp;egrave; possibile creare o modificare l'utente, perch&amp;eacute;
	non &amp;egrave stato specificato alcun nome.
EOF
</pre> </code>

<p>
	Il Perl eredita questa sintassi dalle shell Unix, ma la estende,
	rendendola applicabile a qualsiasi situazione che implichi un
	<em>"input"</em>, quindi anche all'assegnazione di una stringa
	ad una variabile.
	<br>
	Tutto ciò che compare tra l'assegnazione e la stringa che
	abbiamo battezzato come fine dell'<em>here document</em>
	(<code>EOF</code>), viene inserito nella variabile
	<code>$motivo</code>, andate a capo comprese.
<p>
	La variabile viene poi passata alla subroutine che la inserisce
	in una pagina e la mostra all'utente.
<p>
	A questo punto inizia l'elaborazione vera e propria: elimino un
	eventuale file <code>/etc/apache/passwd.old</code> e
	rinomino l'attuale passwd in passwd.old, poi uso la funzione
	<code>crypt</code> per generare la nuova password dell'utente.
<p>
	In questo programmino uso sempre lo stesso <em>seme</em> per la
	funzione crypt, la stringa 'aa'. Questo può non essere ciò che
	si vuole, ma lascio la generazione di una stringa di due
	caratteri casuali come esercizio al lettore.
<p>
	Apro il vecchio file delle password e lo leggo riga per riga.
	Prima di stampare la riga letta cerco di modificarla:
<p>

<code> <pre>
	if(s/^${user}:.*/${user}:${newstring}/){
		$flag=1;
	}
</pre> </code>

<p>
	uso l'operatore di sostituzione <code>s///</code>. La prima
	parte è la regular expression che rappresenta la stringa da
	modificare: deve essere il nome dell'utente immesso nella form
	(<code>$user</code>), seguito da un carattere
	<code><strong>':'</strong></code>, seguito da altri caratteri
	(la password).  La seconda parte rappresenta ciò che deve essere
	sostituito: il nome dell'utente, i due punti e la nuova
	password.
<p>
	Se l'operazione di sostituzione è andata a buon fine, se quindi
	l'utente immesso dall'amministratore era già elencato nel file
	delle password, allora <em>accendo</em> un flag.
	<br>
	Alla fine del ciclo di lettura/scrittura testo il contenuto del
	flag: se risulta spento, vuol dire che l'utente è nuovo, non era
	presente nel file, quindi lo devo aggiungere.
<p>
	Passo al file dei gruppi: elimino un eventuale file
	<code>/etc/apache/group.old</code> e rinomino l'attuale
	group in group.old
	<br>
	Apro in lettura il vecchio file dei gruppi e in scrittura il nuovo.
	<br>
	Leggo ogni riga (che contiene un gruppo e l'elenco dei suoi
	utenti) e se l'utente che l'amministratore sta inserendo dovrà
	appartenere al gruppo in esame, viene inserito nell'elenco (se
	non è già presente).
	<br>
	L'elaborazione continua così fino alla fine del file.
<p>
	Non ci resta che avvisare il nostro pubblico della riuscita
	dell'operazione, non senza dimostrarci saccenti e critici verso
	le sue scelte.
<p>
	Come vedete ci vuole poco per rendere user friendly anche
	un'attività così bistrattata come l'amministrazione di sistema.
<p>
	Ho risolto questo problema con un pizzico di pigrizia, come al
	solito, e invece di scrivermi un programma in C sotto X, ho
	usato direttamente l'interfaccia utente gentilmente messami a
	disposizione dal mio browser.
<p>
	Quale può essere la morale nascosta in tutto ciò?
	<br>
	Forse l'epoca dell'object oriented programming sta per lasciare
	il passo a quella del <strong>document oriented
	programming</strong>?
<hr>
<p>
	A rileggerci al prossimo numero del Pluto Journal.
<p>
	Per dubbi, congratulazioni, correzioni, insulti &amp altro
	scrivete a <a href="mailto:lac0658@iperbole.bologna.it">Nando
	Santagata</a>.

