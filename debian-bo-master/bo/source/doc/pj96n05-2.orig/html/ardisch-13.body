<H2>3.2 In cui si da' una pennellata anche a <B>Picasso</B>.</H2>
<P>Ora proverò a configurare anche picasso, seguendo la traccia di quanto
fatto per Slackware, così da evidenziarne le differenze.</P>
<P>Intanto notiamo subito la diversa impostazione dei file di startup.
Slackware raccoglieva tutto nel direttorio <CODE>/etc/rc.d</CODE>, mentre
Red Hat aggiunge un livello intermedio <CODE>/etc/rc.d/rc?</CODE> dove 
il <CODE>?</CODE> rappresenta il numero dell'init level. Questi direttori 
contengono solo dei link simbolici agli script che invece sono posti
in <CODE>/etc/rc.d/init.d</CODE>. Questo consente di dotare ciascuno
script di un <EM><B>peso</B></EM> diverso a seconda dell'init level,
semplicemente usando nomi diversi per i link simbolici. Questo è
lo standard nel System V, ed è usato anche da Debian. Slackware invece
rimane fedele al BSD.</P>
<P>Questi script sono un bel pò più <EM>scaltri</EM> di quelli di Slackware,
infatti evitano di usare <CODE>sleep</CODE> dopo aver smontato i filesystem,
e non necessitano di modifiche per l'ora del sistema; interrogano
direttamente il bios.</P>
<P>Creo il solito <CODE>/etc/fstab</CODE>, non senza notare come Red Hat
preferisca concentrare i mount point come sottodirettori di <CODE>/mnt</CODE>
piuttosto che direttamente sotto <CODE>/</CODE>. Tutto è più pulito ed ordinato,
ma mi sembra troppo scomodo da usare. E` bello invece il fatto che non 
mi sia necessario montare esplicitamente queste nuove partizioni
aggiungendo una riga in rc. Un passo in avanti.</P>
<P>Manca invece il lancio di <CODE>gpm</CODE> che Slackware aggiunge all'installazione,
mentre tutti mancano della solita pulizia di /tmp
<BLOCKQUOTE><CODE>
<PRE>
rm -rf /tmp
if      [ ! -d /tmp ]
then    mkdir /tmp
        chmod 1777 /tmp
fi
</PRE>
</CODE></BLOCKQUOTE>

Questa è una cosa molto personale, ma io, sempre in attesa di configurare
un giorno <CODE>/tmp</CODE> come ramdisk, voglio esser certo di non 
prendere brutte abitudini, quali quella di mettere (e lasciare) cose
importanti sotto <CODE>/tmp</CODE>.</P>
<P>Vediamo il profilo della shell. Si distingue tra <CODE>/etc/profile</CODE>,
comune a tutte le shell di tipo <CODE>bourne</CODE> e <CODE>/etc/bashrc</CODE>, 
usato solo da <CODE>bash</CODE>. La cosa mi suona strana. Un'occhiata alla
pagina del manuale di bash mi conferma il sospetto, che diventa prova
certa dopo una occhiata al contenuto di <CODE>~/.bashrc</CODE>.
La lettura di <CODE>/etc/bashrc</CODE> avviene grazie ad una apposita
riga inserita in <CODE>~/.bashrc</CODE>. Sembra una cosa pulita, fatta
per consentire ad un utente di scegliere se eseguire o meno quello
script, ma ... quando si esegue una subshell l'ambiente non è più
quello proprio di <CODE>bash</CODE>, come mi aspetterei, ma quello ristretto
di <CODE>sh</CODE>, che invece mi aspetterei solo invocando <CODE>/bin/sh</CODE>.
La cosa può essere pericolosa, in quanto lo stesso script può comportarsi
diversamente a seconda del livello di nidificazione delle shell, oppure
a seconda se la shell è una shell di login oppure no.</P>
<P>Per ovviare a questo inconveniente ho posto in <CODE>/etc/bashrc</CODE> la
riga
<BLOCKQUOTE><CODE>
<PRE>
alias sh=&quot;/bin/bash&quot;
</PRE>
</CODE></BLOCKQUOTE>

in modo che ogni chiamata a <CODE>sh</CODE> da una shell di login sia convertita
in una chiamata a <CODE>bash</CODE>, mentre gli script che richiedono la possono
(e debbono) correttamente invocare come <CODE>#!/bin/sh</CODE>.</P>
<P>In questo script poniamo tutte quelle personalizzazioni che ho fatto anche 
per Slackware, con qualcosina in più:
<BLOCKQUOTE><CODE>
<PRE>
export TTY=$(tty | xargs basename)
</PRE>
</CODE></BLOCKQUOTE>

mi fornisce una variabile con la più corta parte identificante il terminale
su cui agisco. E` molto comoda in ambienti a terminali multipli, come
le console virtuali di Linux o le xterm di X. Così posso usare questo prompt:
<BLOCKQUOTE><CODE>
<PRE>
if      [ &quot;$SHELL&quot; = &quot;/bin/bash&quot; ]
then    if      [ &quot;$TERM&quot; = &quot;xterm&quot; ]
        then
                xsize()
                {
                        set -- $(stty size)
                        export SIZE=&quot;$2 x $1&quot;
                        xtitle
                }
                xtitle()
                {
                        if [ &quot;$TERM&quot; = &quot;xterm&quot; ]
                        then    echo -ne &quot;\033]2;$TTY  $SIZE     $PWD\007&quot;
                        fi
                }
                export -f xsize xtitle
                export PROMPT_COMMAND=&quot;xtitle&quot;  # esegue xtitle ad ogni prompt
                trap xsize SIGWINCH     # esegue xsize ad ogni resize 
                xsize   # solo per la prima volta
                PS1=&quot;\u@\h [\d \t]\n$SHLVL\\$ &quot;
        else    # terminale o console
                PS1=&quot;$TTY:\u@\h \w [\d \t]\n$SHLVL\\$ &quot;
        fi
fi
</PRE>
</CODE></BLOCKQUOTE>

Questo mostra al prompt le solite informazioni (più il nome del terminale),
che invece, in caso di xterm, suddivide tra prompt vero e proprio e titolo
della finestra, in cui compaiono il nome del terminale, le dimensioni della
finestra ed il direttorio corrente. C'è a chi piace.</P>
<P>Provvediamo ad un alias tra <CODE>ls</CODE> e <CODE>dircolors</CODE>. Mi piacerebbe indagare sui 
retroscena di questo <EM>divorzio</EM> che ha impedito la creazione di un
pacchetto ufficiale <B>GNU</B> per l'<CODE>ls</CODE> colorato di Linux.</P>
