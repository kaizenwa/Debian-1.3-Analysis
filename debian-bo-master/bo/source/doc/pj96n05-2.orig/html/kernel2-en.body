<H1>Dynamic Kernels</H1>
<H2>Discovery</H2>

<P ALIGN=CENTER>
This article, the second of four, introduces part of the
actual code to create custom module implementing a character
device driver. It describes the code for module initialization
and cleanup, as well as the <TT>open()</TT> and
<TT>close()</TT> system calls.
</P>

<P>
<I>by Alessandro Rubini</I>
</P>

<HR>

<P>The last <I>Kernel Korner</I> introduced problems related to
loading and unloading a custom module, but didn't uncover the
code to actually perform these tasks. This time, we are going to
look at some finer details of module-writing, in order to begin
showing the actual code for our character device driver.
</P>

<H2>
Load-time Configuration
</H2>

<P>
Although a smart driver should be able to autodetect the
hardware it looks for, autodetection is not always the most
sensible implementation, because it may be tricky to design. It
is wise to provide a way to specify as many details as possible
at load time, in order to test your driver before scratching
your head and deciding to implement autodetection. Moreover, autodetection
may fail if ``similar'' hardware is installed in the computer.
A minor project can simply avoid autodetection altogether.
</P>

<P>
To configure the driver at load time, we'll exploit insmod's
capability to assign integer values to arbitrary variables in
the driver. We'll thus declare a (public) integer variable for
each configurable item, and we'll make sure that the default
value will trigger autodetection.
</P>

<P>
Configuring multiple boards at load time is left as an exercise
to the reader (after reading the manpage for <TT>insmod</TT>);
this implementation allows specification of a single board: for
the sake of simplicity additional boards are only reachable
through autodetection.
</P>

<H2> 
Choosing Names
</H2>

<P>
The kernel is a complex application, and it is vital to keep
its namespace as tidy as possible. This means both to use
private symbols wherever it is possible, and to use a common
prefix for all the symbols you define.
</P>

<P>
A production environment will only declare
<TT>init_module()</TT> and <TT>cleanup_module()</TT>, which are
used to load and unload the driver, and any load-time
configuration variables. Nothing else needs to be public,
because the module is accessed through pointers, not by name.
</P>

<P>
However, when you are developing and testing your code, you'll
need your functions and data structures in the public symbol
table in order to access them with your favorite debugging
tool.
</P>

<P>
The easiest way to accomplish this dual need is to always use
your own prefix in names, declare all of your symbols
<TT>Static</TT> (note the capital `S'), and include the
following five lines at the top of your driver:
</P>

<PRE>
#ifdef DEBUG_<I>modulename</I>
# define Static /* nothing */
#else
# define Static static
#endif
</PRE>

<P>
Real static symbols (such as persistent local variables) may
thus be declared <TT>static</TT>, while debuggable symbols are
declared <TT>Static</TT>

<H2>
The <B><TT>init_module()</TT></B> Function
</H2>

<P>In this page, the whole code for the initialization function
is uncovered. This is skeletal code, as the <TT>skel</TT> name
suggests: a real-world device usually has slightly more than
two I/O ports.
</P>

<P>
The most important thing to remember here is to release all the
resources you already asked for whenever you find an error
condition. This kind of task is well handled by the (otherwise
unloved) <TT>goto</TT> statement: code duplication is avoided
by jumping to the resource-release part of the function in case
of error.
</P>

<P>
The fragment of code shown accepts load-time configuration for
the major number, for the base address of the board's I/O
ports, and for the IRQ number. For each ``possible'' board (in
the I/O space), the autodetection function is called. If no
boards are detected, <TT>init_module()</TT> returns
<TT>-ENODEV</TT> to tell insmod that no devices are there.
</P>

<P>
Sometimes it is wise to allow the driver to be loaded even if
its hardware is not installed in the computer. I implement
such code in order to develop most of my driver at home. The
trick is to have a configuration variable (<TT>skel_fake</TT>)
which allows you to fake a nonexistent board. You can look at the
implementation in my own drivers. ``Faking boards'' is a
powerful way to start writing code before you get the hardware,
or to test support for two boards even if you only own one of
them.
</P>

<P>
The role of <TT>cleanup_module()</TT> is to shut down the device
and release any resources allocated by <TT>init_module()</TT>.
Our sample code cycles through the array of boards and releases
I/O ports and the IRQ, if any. Finally, the major number is
released. The initial check for <TT>MOD_IN_USE</TT> is
redundant if you're running a recent kernel, but a wise thing
to put in production code, because your customers or users may
be running old Linux kernels.
</P>
The sample code for <TT>init_module()</TT> and
<TT>cleanup_module()</TT> is shown in <A HREF="#list1">Listing 1</A>. The prefix
<TT>skel_</TT> is used for all non-local names. The code here
is quite simplified, in that it lacks some error-checking,
which is vital in production-quality source code.

<H2>
Autodetecting the Device
</H2>

<P>
<TT>init_module()</TT> calls the function
<TT>skel_find()</TT> to perform the dirty task of detecting if
a board is there. The function is very device specific, because
each device must be probed for its peculiar features; thus, I
won't try to show code to perform the actual probing, but only
IRQ autodetection.
</P>

<P>
Unfortunately, some peripherals can't tell which IRQ line
they're configured to use, thus forcing the user to write the
IRQ number on the command line of insmod, or to hardcode the
number in the software itself. Both these approaches are bad
practice, because you just can't plug the board (after setting
the jumpers) and load the driver. The only way to autodetect
the IRQ line for these devices is a trial-and-error technique,
which is, of course, only viable if the hardware can be
instructed to generate interrupts.
</P>

<P>
The code in <A HREF="#list2">Listing 2</A> shows <TT>skel_find()</TT>, complete with
IRQ autodetection. Some details of IRQ handling may appear
obscure to some readers, but they will be clarified in the next
article. To summarize, this code cycles through each of the
possible IRQ lines, asking to install a handler, and looks to
see if interrupts are actually generated by the board.
</P>

<P>
The field <TT>hwirq</TT> in the hardware structure represents
the <I>useable</I> interrupt line, while the field <TT>irq</TT>
is only valid when the line is active (after
<TT>request_irq()</TT>). As explained in the last issue, it
makes no sense to keep hold of an IRQ line when the device is
not in use; that's why two fields are used.
</P>

<P>
Please note that I wrote this code as a work-around for the
limitations of one of my hardware boards; if your hardware is
able to report the IRQ line it's going to use, it's much better
to use <I>that</I> information instead. The code is quite
stable, anyway, if you are able to tailor it to your actual
hardware. Fortunately, most good hardware is able to report its
own configuration.
</P>

<H2>
<B><TT>fops</TT></B> and <B><TT>filp</TT></B>
</H2>

<P>
After the module has been loaded and the hardware has been
detected, we must see <I>how</I> the device is acted
upon. This means introducing the role of <TT>fops</TT> and
<TT>filp</TT>: these little beasts are the most important data
structures---actually, variable names---used in interfacing the
device driver with the kernel.
</P>

<P>
<TT>fops</TT> is the name usually devoted to a <TT>struct
file_operations</TT>. The structure is a <B>jump table</B>
(structure of pointers to functions), and each field refers to
one of the different operations performed on a filesystem node
(<TT>open()</TT>, <TT>read()</TT>, <TT>ioctl()</TT>, etc.).
</P>

<P>
A pointer to your own <TT>fops</TT> is passed to the kernel by
means of <TT>register_chrdev()</TT>, so that your functions
will be called whenever one of your nodes is acted upon. We
already wrote that line of code, but didn't show the actual
<TT>fops</TT>. Here it is:

<PRE>
struct file_operations skel_fops {
  skel_lseek,
  skel_read,
  skel_write,
  NULL,       /* skel_readdir */
  skel_select,
  skel_ioctl,
  skel_mmap,
  skel_open,
  skel_close
};
</PRE>
</P>

<P>
Each <TT>NULL</TT> entry in your fops means that you're not going to
offer that functionality for your device (<TT>select</TT> is special,
in this respect, but I won't expand on it), each non-<TT>NULL</TT>
entry must be a pointer to a function implementing the operation for
your device.
</P>

<P>
Actually, there exist a few more fields in the structure, but our
example will live with the default <TT>NULL</TT> value (the C compiler
fills up an incomplete structure with zero bytes without issuing any
warning).  If you are really interested in them, you can look at the
structure's definition in <TT>&lt;linux/fs.h&gt;</TT>.

<P>
<TT>filp</TT> is the name usually devoted to one of the
arguments passed by the kernel to any function in your fops,
namely a <TT>struct file *</TT>. The <TT>file</TT> structure is
used to keep all the available status information about an
``open file'', beginning with a call to <TT>open()</TT> and up
to a call to <TT>close()</TT>. If the device is opened multiple
times, different <TT>filp</TT>s will be used for each instance:
this means that you'll need to use your own data structure to
keep hardware information about your devices. The code
fragments within this installment already use an array of
<TT>Skel_Hw</TT>, to hold information about several boards
installed on the same computer.
</P>

<P>
What is missing, then, is a way to embed hardware information
in the <TT>file</TT> structure, in order to instruct the driver
to operate on the right device. The field <TT>private_data</TT>
exists in <TT>struct file</TT> just for that task, and is a
pointer to <TT>void</TT>. You'll make <TT>private_data</TT>
point to your hardware information structure when
<TT>skel_open()</TT> gets invoked. If you need to keep some
extra information private to each filp (for example, if two
device nodes access the same hardware in two different ways),
then you'll need a specific structure for
<TT>private_data</TT>, which must be <TT>kmalloc()</TT>ed on
open and <TT>kfree()</TT>ed on close. The implementations of
open() and close() that we'll see later, work in this way.
</P>

<H2>
Using Minor Numbers
</H2>

<P>
In the last article I introduced the idea of minor device
numbers, and it is now high time to expand on the topic.
</P>

<P>
If your driver manages multiple devices, or a single device but
in different ways, you'll create several nodes in the
<TT>/dev</TT> directory, each with a different minor number.
When your open function gets invoked, then, you can examine the
minor number of the node being opened, and take appropriate
actions.
</P>

<P>
The prototypes of your open and close functions are

<PRE>
int skel_open (struct inode *inode,
               struct file *filp);
void skel_close (struct inode *inode,
                 struct file *filp);
</PRE>

and the minor number (an unsigned value, currently 8 bits)
is available as <TT>MINOR(inode-&gt;i_rdev)</TT>. The
<TT>MINOR</TT> macro and the relevant structures are defined
within <TT>&lt;linux/fs.h&gt;</TT>, which in turn is included in
<TT>&lt;linux/sched.h&gt;</TT>.
</P>

<P>
Our skel code (<A HREF="#list3">Listing 3</A>) will split the minor number in
order to manage both multiple boards (using four bits of the
minor), and multiple modes (using the remaining four bits). To
keep things simple we'll only write code for two boards and two
modes. The following macros are used:

<PRE>
#define SKEL_BOARD(dev) (MINOR(dev)&0x0F)
#define SKEL_MODE(dev)  ((MINOR(dev)&gt;4)&0x0F)
</PRE>
</P>

<P>
The nodes will be created with the following commands
(within the <TT>skel_load</TT> script, see last month's article):

<PRE>
mknod skel0    c $major  0
mknod skel0raw c $major  1
mknod skel1    c $major 16
mknod skel1raw c $major 17
</PRE>
</P>

<P>
But let's turn back to the code. This <TT>skel_open()</TT>
sorts out the minor number and folds any relevant information
inside the filp, in order to avoid further overhead when read()
or write() will be invoked. This goal is achieved by using a
<TT>Skel_Clientdata</TT> structure embedding any filp-specific
information, and by changing the pointer to your <TT>fops</TT>
within the <TT>filp</TT>; namely, <TT>filp-&gt;f_op</TT>.
</P>

<P>
Changing values within <TT>filp</TT> may appear a bad practice,
and it often is; it is, however, a smart idea when the file
operations are concerned. The <TT>f_op</TT> field points to a
static object anyways, so you can modify it lightheartedly, as
long as it points to a valid structure; any subsequent
operation on the file will be dispatched using the new jump
table, thus avoiding a lot of conditionals. This technique is
used within the kernel proper to implement the different
memory-oriented devices using a single major device number.
</P>

<P>
The complete skeletal code for <TT>open()</TT> and
<TT>close()</TT> is shown in Listing 3; the <TT>flags</TT>
field in the clientdata will be used when <TT>ioctl()</TT> is
introduced.
</P>

<P>
Note that the <TT>close()</TT> function shown here should be
referred to by both <TT>fops</TT>s. If different
<TT>close()</TT> implementations are needed, this code must be
duplicated.
</P>

<H2>
Multiple- or Single-open?
</H2>

<P>
A device driver should be a policy-free program, because
policy choices are best suited to the application. Actually,
the habit of separating policy and mechanism is one of the
strong points of Unix. Unfortunately, the implementation of
<TT>skel_open()</TT> leads itself to policy issues: is it
correct to allow multiple concurrent opens? If yes, how can I
handle concurrent access in the driver?
</P>

<P>
Both single-open and multiple-open have sound advantages. The
code shown for <TT>skel_open()</TT> implements a third
solution, somewhat in-between.
</P>

<P>
If you choose to implement a single-open device, you'll greatly
simplify your code. There's no need for dynamic structures
because a static one will suffice; thus, there's no risk to have
memory leakage because of your driver. In addition, you can
simplify your <TT>select()</TT> and data-gathering
implementation because you're always sure that a single
process is collecting your data. A single-open device uses a
boolean variable to know if it is busy, and returns
<TT>-EBUSY</TT> when open is called the second time. You can
see this simplified code in the busmouse drivers and lp driver
within the kernel proper.
</P>

<P>
A multiple-open device, on the other hand, is slightly more
difficult to implement, but much more powerful to use for the
application writer. For example, debugging your applications is
simplified by the possibility of keeping a monitor constantly
running on the device, without the need to fold it in the
application proper. Similarly, you can modify the behaviour of
your device while the application is running, and use several
simple scripts as your development tools, instead of a complex
catch-all program. Since distributed computation is common
nowadays, if you allow your device to be opened several times, you
are ready to support a cluster of cooperating processes using
your device as an input or output peripheral.
</P>

<P>
The disadvantages of using a conventional multiple-open
implementation are mainly in the increased complexity of the
code. In addition to the need for dynamic structures (like the
<TT>private_data</TT> already shown), you'll face the tricky
points of a true stream-like implementation, together with
buffer management and blocking and non-blocking read and write;
but those topics will be delayed until next month's column.
</P>

<P>
At the user level, a disadvantage of multiple-open is the
possibility of interference between two non-cooperating
processes: this is similar to cat-ing a tty from another
tty---input may be delivered to the shell or to cat, and you
can't tell in advance. [For a demonstration of this, try this:
start two xterms or log into two virtual consoles. On one (A),
run the <B>tty</B> command, which tells you which tty is in use.
On the other (B), type <TT>cat /dev/<I>tty_of_A</I></TT>. Now go
to A and type normally. Depending on several things, including
which shell you use, it may work fine. However, if you run
<B>vi</B>, you will probably see what you type coming out on B,
and you will have to type <TT>^C</TT> on B to be able to
recover your session on A.---ED]
</P>

<P>
A multiple-open device can be accessed by several different
users, but often you won't want to allow different users to
access the device concurrently. A solution to this problem is
to look at the <TT>uid</TT> of the first process opening the
device, and allow further opens only to the same user or to
root. This is not implemented in the skel code, but it's as
simple as checking <TT>current->euid</TT>, and returning
<TT>-EBUSY</TT> in case of mismatch. As you see, this policy is
similar to the one used for ttys: login changes the owner of
ttys to the user that has just logged in.
</P>

<P>
The <TT>skel</TT> implementation shown here is a multiple-open
one, with a minor addition: it assures that the device is
``brand new'' when it is first opened, and it shuts the device
down when it is last closed.
</P>

<P>
This implementation is particularly useful for those devices
which are accessed quite rarely: if the frame grabber is used
once a day, I don't want to inherit strange setting from the
last time it was used. Similarly, I don't want to wear it out
by continuously grabbing frames that nobody is going to use. On
the other hand, startup and shutdown are lengthy tasks,
especially if the IRQ has to be detected, so you might not
choose this policy for your own driver. The field
<TT>usecount</TT> within the hardware structure is used to turn
on the device at the first open, and to turn it off on the last
close. The same policy is devoted to the IRQ line: when the
device is not being used, the interrupt is available to other
devices (if they share this friendly behaviour).
</P>

<P>
The disadvantages of this implementation are the overhead of
the power cycles on the device (which may be lengthy) and the
inability to configure the device with one program in order to
use it with another program. If you need a persistent state in
the device, or want to avoid the power cycles, you can simply
keep the device open by means of a command as silly as this:

<PRE>
sleep 1000000 &lt; /dev/skel0 &
</PRE>
</P>

<P>
As it should be clear from the above discussion, each possible
implementation of the <TT>open()</TT> and <TT>close()</TT>
semantics has its own peculiarities, and the choice of the
optimum one depends on your particular device and the main use
it is devoted to. Development time may be considered as well,
unless the project is a major one. The <TT>skel</TT>
implementation here may not be the best for your driver: it
is only meant as a sample case, one amongst several different
possibilities.
</P>

<HR>

<H2>
Additional Information
</H2>

<P>
The <I>Kernel Korner</I> columns in the following months
will introduce further points of module-writing. Code samples
can be found inside the kernel and on ftp sites near you.
</P>

<P>
In particular, what I describe is based on my personal experience with
device drivers: both the <TT>ceddrv-0.<I>xx</I></TT>
and
<TT>cxdrv-0.<I>xx</I></TT>
resemble the code I describe. Georg
Zezschwitz and I wrote the ceddrv, which drives a lab interface (A/D,
D/A, bells and whistles). The cxdrv driver is simpler, and drives a
memory-mapped frame grabber. The latest versions of both drivers are
available on <A HREF="ftp://iride.unipv.it/pub/linux">ftp://iride.unipv.it/pub/linux</A> for public
ftp. <B>ceddrv</B> is also on tsx-11.mit.edu, while <TT>cxdev</TT>
is on sunsite.unc.edu in apps/video.
</P>

<P>
There are quite a few books about device drivers out there, but
they're often too system-specific and describe an awkward
interface---Linux is easier.  Generic books about Unix
internals and the kernel source are the best teachers. I'd
suggest getting one of the following:

<UL>
<LI>	Maurice J. Bach, <I>The Design of the UNIX
Operating System</I>, Prentice Hall, 1986

<LI>	Andrew S. Tanenbaum, <I>Operating Systems: Design
and Implementation</I>, Prentice Hall, 1987

<LI>	Andrew S. Tanenbaum, <I>Modern Operating Systems</I>,
Prentice Hall, 1992
</UL>
</P>

<P>
<I>
Programmer by chance and Linuxer by choice, Alessandro is taking
his PhD course in computer science and is breeding two small Linux
boxes at home. Wild by his very nature, he loves trekking, canoeing,
and riding his bike. He can be reached as <A HREF="mailto rubini@ipvvis.unipv.it">rubini@ipvvis.unipv.it</A>.
</I>
</P>

<P>
Photo is available as <A HREF="ftp://iride.unipv.it/pub/info/monster2.gif">ftp://iride.unipv.it/pub/info/monster2.gif</A>
if you wish to use it.
</P>

<P>
<A
HREF="/cgi-bin/form.pl?article=Dynamic+Kernels+Discovery,+Issue+24">Article Response Form</A>
</P>

<P>
<A HREF="../copyright.html">Copyright Notice</A>
</P>


<HR>

<A NAME="list1"><H2>Listing 1: Initialization and Cleanup</H2></A>

<PRE>
int skel_major = 0;    /* default: dynamic */
int skel_base  = 0;    /* default: autodetect */
int skel_irq   = -1;   /* default: autodetect */

Static int skel_boards = 0; /* how many of them are there */

typedef struct Skel_Hw {
  int base;     /* I/O port */
  int irq;      /* IRQ being used */
  int hwirq;    /* The detected one */
  int irqcount;
  int usecount;
  /* .... */
} Skel_Hw;

Skel_Hw skel_hw[SKEL_MAX_BOARDS];

#define PORT0(board) ((board)-&gt;base+0)
#define PORT1(board) ((board)-&gt;base+1)
/* ... */

Static file_operations skel_fops; /* defined later on */

int init_module (void)
{
  int base, err, i;

  /* Look for a major */
  err = register_chrdev (skel_major, "skel", &skel_fops);
  if (err &lt; 0) {
      printk(KERN_NOTICE "skel init: error %d\n", -err);
      return err;
  }
  if (skel_major==0) skel_major=err; /* dynamic */

  /*
   * Look for ports: PORT_MIN, PORT_STEP, PORT_MAX define
   * the range of (consecutive) addresses supported by the board
   */
  base = skel_base ? skel_base : PORT_MIN;
  do {
      if (check_region(base, PORT_STEP) != 0)
          continue; /* in use */

      request_region(base, PORT_STEP, "skel");

      skel_hw[skel_boards].base=base;
      if ( (err=skel_find(skel_hw+skel_boards)) == 0) {
          /* found one */
          skel_boards++;
          continue;
      }
      release_region(base, PORT_STEP);
  }
  /* if autodetecting skel_base is 0, otherwise, do it only once */
  while (skel_base==0 && (base+=PORT_STEP) &lt; PORT_MAX);

  if (skel_boards==0) {
      printk(KERN_NOTICE "skel init: no boards found\n");
      return -ENODEV;
  }

  /* do other initialization here */
  if ( (err=<I>request_resource_1()</I>) != 0 )
      goto fail_resource_1:
  if ( (err=<I>request_resource_2()</I>) != 0 )
      goto fail_resource_2:
  if ( (err=<I>request_resource_3()</I>) != 0 )
      goto fail_resource_3:

  return 0; /* success */

  fail_resource_3: <I>free_resource_2()</I>
  fail_resource_2: <I>free_resource_1()</I>
  fail_resource_1: printk(KERN_NOTICE "skel init: error %i\n", -err);

  /* release your boards */
  for (i=0; i&lt;skel_boards; i++)
      release_region(skel_hw[i].base, PORT_STEP);

  return err; /* failure */
}

void cleanup_module (void)
{
  int b;

  if (MOD_IN_USE)
      return /* -EBUSY */;

  printk(KERN_INFO "skel driver unloaded\n");
  for (b=0; b&lt;skel_boards; b++) {
      /* shutdown the board.... */
      release_region(skel_hw[b].base, PORT_STEP);

      if (skel_hw[b].irq &gt;= 0)
          free_irq(skel_hw[b].irq);
  }

  unregister_chrdev(skel_major, "skel");
  return;

}
</PRE>

<HR>

<A NAME="list2"><H2>Listing 2: Discovery</H2></A>

<PRE>
/*
 * This function only counts interrupts, and is used for probing
 */
Static void skel_trial_fn(int irq, struct pt_regs *unused)
{
  int i;
  Skel_Hw *board;

  for (i=0, board=skel_hw; i&lt;skel_boards; board++, i++)
      if (board-&gt;irq==irq)
          break;

  if (i==cxg_boards) /* not mine... shouldn't happen */
      return;

  <I>skel_acknowledge_the_interrupt()</I>

  board-&gt;irqcount++;
}

/*
 * the autodetection function, which probes the possible interrupt lines
 */
Static int skel_find(Skel_Hw *board)
{

  if ( <I>failed_first_probe</I> )
      return -ENODEV;
  /* do any more probing here... */
  if ( <I>failed_last_probe</I> )
      return -ENODEV;

  /* found */

  if (board==skel_hw && skel_irq&gt;=0) { /* first board, and explicit irq */
      board-&gt;hwirq=skel_irq; /* trust it */
      board-&gt;irq=-1;
  } else {
      static int tryings[]={3,4,5,7,-1}; /* irq lines to try */
      int i, trial, err;

      for (i=0; (trial=tryings[i]) &gt;= 0; i++) {
          if (request_irq(trial, skel_trial_fn, SA_INTERRUPT, "skel") != 0)
              continue; /* irq line busy */
          board-&gt;hwirq = board-&gt;irq = trial;
          board-&gt;irqcount = 0;
          <I>tell_the_device_to_generate_interrupts</I>
          <I>sleep_for_enough_time</I>
          <I>tell_the_device_NOT_to_generate_interrupts</I>
          free_irq(board->irq);
          board-&gt;irq = -1;
          if (board-&gt;irqcount &gt; 0) /* did I get interrupts on this line? */
              break;
          else
              board-&gt;hwirq = -1;
      }
  }

  if (board-&gt;hwirq == -1) {
      printk(KERN_NOTICE "skel: found board but no irq line\n");
      return -EADDRNOTAVAIL; /* or accept it, at your will */
  }

  return 0; /* all right */
}
</PRE>

<HR>

<A NAME="list3"><H2>Listing 3: File Operations</H2></A>

<PRE>
typedef struct Skel_Clientdata {
  Skel_Hw *board;
  int flags;
  /* .... */
} Skel_Clientdata;

struct file_operations skel_fops;
struct file_operations skel_raw_fops;

int skel_open (struct inode *inode, struct file *filp)
{
  Skel_Hw *board;
  Skel_Clientdata *data;
  int err;

  if (SKEL_BOARD(inode-&gt;i_rdev) &gt;= skel_boards)  return -ENODEV;
  board = skel_hw + BOARDNO(inode-&gt;i_rdev);

  switch (SKEL_MODE(inode-&gt;i_rdev)) /* node selection */
      {
      case 0: break;                             /* normal mode */
      case 1: filp-&gt;f_op = skel_raw_fops; break; /* raw mode */
      default: return -ENODEV;
      }

  data = kmalloc(sizeof(Skel_Clientdata), GFP_KERNEL);
  if (!data) return -ENOMEM;

  filp-&gt;private_data = data;
  data-&gt;board = board;
  data-&gt;flags = SKEL_DEFAULT_FLAGS;
  <I>fill_any_further_field</I>

  if (board-&gt;usecount == 0) { /* first open */
      if (board-&gt;hwirq >= 0) {
          if ( (err=request_irq(board-&gt;hwirq,skel_interrupt,0,"skel")) != 0) {
              kfree(data);
              return err; /* or go on, at your will */
          }
          board-&gt;irq=board-&gt;hwirq;
      }
      <I>skel_initialize_the_board();</I>
  }

  board->usecount++;
  MOD_INC_USE_COUNT;
  return 0;
}

void skel_close (struct inode *inode, struct file *filp)
{
  Skel_Clientdata *data=filp-&gt;private_data;
  Skel_Board *board=data-&gt;board;

  if (board-&gt;usecount == 1) { /* last close */
      if (board-&gt;irq) {
          free_irq(board-&gt;irq);
          board-&gt;irq = -1;
      }
      <I>skel_shutdown_board</I>
  }
  kfree(data);
  filp-&gt;private_data=NULL;
  board->usecount--;
  MOD_DEC_USE_COUNT;
  return;

}
</PRE>
