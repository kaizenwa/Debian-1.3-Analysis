<br>
<font size=+2 color="#0000ff">
NO NEWS IS A GOOD NEWS.
</font>
<br>
<p>
<font size=+4 color="#0000ff"><b>N</b></font>essuna
notizia e' una buona notizia, recita un famoso detto inglese.
<br>
Spesso per noi che dipendiamo dalle News per avere la nostra dose
quotidiana di informazioni &egrave difficile anche renderci conto che non
c'&egrave; proprio niente di interessante da leggere!
<br>
La quantit&agrave di notizie che ci arrivano tramite Internet
&egrave spesso cos&igrave
elevata da scoraggiare anche il pi&ugrave inpavido lettore.
<br>
Anche i filtri che i News readers ci mettono a disposizione sono
spesso troppo grossolani e corriamo il rischio di perdere qualche
informazione interessante o di averne cos&igrave tante da non riuscire a
trovare quella giusta per noi.
<br>
La soluzione, da bravi Linux-men, &egrave quella di fabbricarci i nostri
filtri su misura, interfacciandoci direttamente alle News, tramite il
NNTP (Net News Transfer Protocol), il protocollo utilizzato per il
trasferimento degli articoli tra news servers.
<p>
In questo articolo user&ograve il linguaggio Perl e
prender&ograve in esame un
modulo aggiuntivo, che mette a disposizione del programmatore una
classe che rende estremamente facile interfacciarsi al protocollo
NNTP.
<p>
Supponendo che sulla vostra macchina sia installato il Perl, in una
versione abbastanza recente (l'ultima versione al momento della
scrittura di questo articolo &egrave la 5.003), il componente che dovrete
procurarvi &egrave <a href="#appendice">libnet-1.00.tar.gz</a> .
<p>
L'installazione di questo modulo &egrave molto semplice, come del resto
quella di tutti i moduli aggiuntivi del Perl: basta scompattare il
file, entrare nella directory creata e dare i seguenti comandi:
<p>
<code>
<pre>
$ perl Makefile.PL
$ make
$ su -c 'make install'
</pre>
</code>
<p>
A questo punto i moduli aggiuntivi e i relativi manuali saranno
installati nelle opportune directory (che il Perl desume dai dati
registrati nella sua installazione corrente).<br>
Per leggere la pagina di manuale riguardante il modulo di interfaccia
al protocollo NNTP basta dare il comando:
<p>
<code>
$ man Net::NNTP
</code>
<p>
Ovviamente dovrete avere nel vostro <cite>$MANPATH</cite> o nel vostro
<cite>/etc/manpath.config</cite> anche la directory dei manuali del
Perl, che di solito &egrave <b>/usr/lib/perl5/man</b>.
<p>
<p>
<font size=+1 color="#0000ff">PRIMI PASSI: LA LISTA DEI NEWSGROUPS.</font>
<p>
Chiunque abbia scritto un programma che si interfacci ad un protocollo
di rete ha sicuramente presente la quantit&agrave di istruzioni necessarie
per l'apertura di un socket su di una porta TCP/IP.
<br>
Tutto questo lavoro &egrave ora incapsulato in una singola chiamata,
esattamente nella chiamata usata per l'inizializzazione di un oggetto
Net::NNTP.
<p>
Praticamente basta scrivere:
<p>
<code>
<pre>
$c = new Net::NNTP('mio.news.server');
</pre>
</code>
<p>
per aprire la connessione con la macchina specificata dalla stringa
'mio.news.server'.
<p>
Il primo programmino che possiamo scrivere ci pu&ograve servire per leggere
la lista dei newsgroups disponibili sul nostro News Server:
<p>
<code>
<pre>
#!/usr/bin/perl

use Net::NNTP;

$ARGV[0] = 'localhost' if !defined $ARGV[0];
$c = new Net::NNTP($ARGV[0]);
$lista = $c-&gt;list();
foreach $newsgroup (keys %$lista){
	print &quot;$newsgroup\n&quot;;
}
</pre>
</code>
<p>
Esaminiamolo riga per riga.
La prima riga:
<p>
<code>
use Net::NNTP;
</code>
<p>
richiede al Perl di caricare il modulo che utilizzaremo. La riga:
<p>
<code>
$ARGV[0] = 'localhost' if !defined $ARGV[0];
</code>
<p>
Specifica un default ragionevole: se non sono presenti argomenti sulla
riga di comando (if !defined $ARGV[0]), allora assegna al primo
elemento dell'array in cui il Perl immagazzina la riga di comando, il
nome del server di default, in questo caso 'localhost': il nostro
server locale.
<br>
La riga:
<p>
<code>
$c = new Net::NNTP($ARGV[0]);
</code>
<p>
crea esplicitamente un oggetto della classe Net::NNTP. Dietro
questa riga, come abbiamo detto, si nasconde tutto il meccanismo di
connessione tramite socket alla porta NNTP del TCP/IP.
<br>
A questo punto non ci resta che inoltrare la richiesta della lista dei
newsgroups attivi sul server e stampare il risultato.
<br>
Tutto il colloquio tra il Server e il nostro client &egrave sintetizzato
nella riga:
<p>
<code>
$lista = print $c-&gt;list();
</code>
<p>
che attiva la funzione membro 'list' dell'oggetto $c della classe
Net::NNTP.
<br>
La chiamata a questo metodo ritorna una reference (puntatore per i
fans del C) ad un array
associativo, le cui chiavi sono i nomi dei newsgroups presenti.
<br>
Le righe seguenti:
<p>
<code>
<pre>
foreach $newsgroup (keys %$lista){
	print &quot;$newsgroup\n&quot;;
}
</pre>
</code>
<p>
stampano i nomi dei newsgroups.
<br>
Il costrutto <cite>%$lista</cite> serve a dereferenziare l'intero l'array
associativo puntato dalla variabile <cite>$lista</cite>.
<p>
Se chiamiamo questo programma 'lista' e lo rendiamo eseguibile (chmod
u+x lista), possiamo lanciarlo con il comando:
<p>
<code>
<pre>
$ lista
</pre>
</code>
<p>
e otterremo su standard output l'elenco dei newsgroup attivi sulla
nostra macchina.
<p>
<font size=+1 color="#0000ff">QUANTI ARTICOLI CI SONO NEL NEWSGROUP</font>
<p>
Fin qui niente di particolarmente interessante, ma andiamo avanti.
Scriviamo ora un programmino (si parla sempre di programmini: questo
modulo ci consente di scrivere programmi complessi in pochissime
righe!) per rilevare il numero del primo e dell'ultimo articolo
presente in un newsgroup sul server specificato:
<p>
<code>
<pre>
#!/usr/bin/perl

use Net::NNTP;

if(!defined $ARGV[0]){
	print &quot;Uso: $0 nome_gruppo [server]\n&quot;;
	exit;
}
$ARGV[1] = 'localhost' if !defined $ARGV[1];
$c = new Net::NNTP($ARGV[1]);
print &quot;(&quot;, join(&quot;,&quot;, $c-&gt;group($ARGV[0])), &quot;)\n&quot;;
</pre>
</code>
<p>

Esaminiamo anche questo programma riga per riga.
Le prime righe sono simili a quello del programma 'lista', poi le
quattro righe:
<p>
<code>
<pre>
if(!defined $ARGV[0]){
	print &quot;Uso: $0 nome_gruppo [server]\n&quot;;
	exit;
}
</pre>
</code>
<p>
verificano che al programma sia stato passato almeno un parametro
sulla riga di comando: il nome del gruppo che vogliamo esaminare. In
caso contrario il programma esce dopo aver stampato la sintassi con
cui dovrebbe essere richiamato.
<br>
Le due righe successive:
<p>
<code>
<pre>
$ARGV[1] = 'localhost' if !defined $ARGV[1];
$c = new Net::NNTP($ARGV[1]);
</pre>
</code>
<p>
come abbiamo gi&agrave visto definiscono un default per il nome del server
da contattare e stabiliscono la connessione NNTP.
<p>
Vi sarete certamente resi conto che se l'utente per errore passa al
programma il nome dell'host e dimentica il nome del newsgroup &egrave
probabile che si verifichi un errore, ma passatemi lo scarso controllo
sui parametri, del resto questo &egrave solo un programmino dimostrativo!
<p>
A questo punto, in un solo colpo, abbiamo la risposta:
<p>
<code>
<pre>
print &quot;(&quot;, join(&quot;,&quot;, $c-&gt;group($ARGV[0])), &quot;)\n&quot;;
</pre>
</code>
<p>
La funzione membro 'group' ritorna una lista di quattro elementi: il
numero di articoli presenti nel newsgroup, il
numero del primo e dell'ultimo articolo presenti e il nome nel newsgroup
specificato. La funzione join lega gli elementi della lista in una
unica stringa, separandoli con delle virgole.
<br>
Reso eseguibile questo programma e lanciato con il comando:
<p>
<code>
<pre>
$ estremi_gruppo it.comp.linux
</pre>
</code>
<p>
ottengo dal mio server una risposta del tipo:
<p>
<code>
<pre>
(217,3511,3727,it.comp.linux)
</pre>
</code>
<p>
<font size=+1 color="#0000ff">GLI HEADERS DEGLI ARTICOLI.</font>
<p>
Il passo successivo nella nostra esplorazione dei newsgroups &egrave
rappresentato da questo programma:
<p>
<code>
<pre>
#!/usr/bin/perl

use Net::NNTP;
use Getopt::Std;
getopt('pu');

if(!defined $ARGV[0]){
	print &quot;Uso: $0 [-pprimo] [-uultimo] nome_gruppo [server]\n&quot;;
	exit;
}
$ARGV[1] = 'localhost' if !defined $ARGV[1];
($c = new Net::NNTP($ARGV[1])) || die $!; # die on timeout

(($num_arts, $primo, $ultimo, $nome) = ($c-&gt;group($ARGV[0]))) || die $!;
$primo = $opt_p if defined $opt_p;
$ultimo = $opt_u if defined $opt_u;
$heads = $c-&gt;xhdr(&quot;Subject&quot;, $primo, $ultimo);

foreach $head (keys %$heads){
	print &quot;$head $heads-&gt;{$head}\n&quot;;
}
</pre>
</code>
<p>
che serve per ottenere un elenco dei soli soggetti degli articoli presenti
in un newsgroup specificato. Esaminiamolo.
<br>
La prima righa:
<p>
<code>
<pre>
use Net::NNTP;
</pre>
</code>
<p>
come al solito serve per caricare il modulo che useremo. Le righe successive:
<p>
<code>
<pre>
use Getopt::Std;
getopt('pu');

if(!defined $ARGV[0]){
	print &quot;Uso: $0 [-pprimo] [-uultimo] nome_gruppo [server]\n&quot;;
	exit;
}
</pre>
</code>
<p>
servono per caricare e usare una libreria compresa nella distribuzione
standard del Perl, che serve per esaminare la riga di comando alla
ricerca di opzioni.
<br>
Le opzioni che cerchiamo sono '-p' e '-u', entrambe seguite da un
valore numerico, il cui scopo &egrave definire il numero del primo e
dell'ultimo articolo da esaminare.
<p>
Se la linea di comando &egrave vuota, usciamo dal programma, proponendo un
messaggio chiarificatore sull'uso.
<p>
La riga successiva:
<p>
<code>
<pre>
$ARGV[1] = 'localhost' if !defined $ARGV[1]; 
</pre>
</code>
<p>
definisce un default ragionevole per il nome del server da contattare.
<br>
La riga:
<p>
<code>
<pre>
($c = new Net::NNTP($ARGV[1])) || die $!; # die on timeout
</pre>
</code>
<p>
avvia la connessione con il server, questa volta controllando anche il
risultato dell'operazione e uscendo in caso di errore o timeout.
<br>
Le righe successive:
<p>
<code>
<pre>
(($num_arts, $primo, $ultimo, $nome) = ($c-&gt;group($ARGV[0]))) || die $!;
$primo = $opt_p if defined $opt_p;
$ultimo = $opt_u if defined $opt_u;
</pre>
</code>
<p>
leggono il numero del primo e dell'ultimo articolo presenti nel
newsgroup specificato, per utilizzarli come defaults, in caso l'utente
non abbia specificato il numero del primo e dell'ultimo articolo da
esaminare.
<br>
Alla fine le righe:
<p>
<code>
<pre>
$heads = $c-&gt;xhdr(&quot;Subject&quot;, $primo, $ultimo);

foreach $head (keys %$heads){
	print &quot;$head $heads-&gt;{$head}\n&quot;;
}
</pre>
</code>
<p>
stampano tutti i soggetti degli articoli specificati.
<br>
La funzione membro <cite>xdhr()</cite> torna una reference ad un array
associativo, le cui chiavi sono i numeri degli articoli e i cui valori
sono l'header richiesto per l'articolo.
<br>
Il costrutto <cite>$heads-&gt;{$head}</cite> serve per dereferenziare
un elemento dell'array a partire dal suo reference.
<p>
Reso eseguibile questo programma e lanciatolo con il comando:
<p>
<code>
<pre>
$ headers_articoli -p34000 -u34010 comp.databases.oracle
</pre>
</code>
<p>
ottengo dal mio server la risposta:
<p>
<code>
<pre>
34000 Cursor: does the job but doesn't come back
34001 Re: Database writing architecture
34002 Help w/ D-2000 connection
34003 Re: Cursor: does the job but doesn't come back
34004 Re: Oracle 7.3 features
34005 Applications Programmers-Twin Cities-RTP NC
34006 Re: Java-Oracle are there any classes available?
34007 Re: PO7 upgrade to Win95.
34008 US-IL-ORACLE/ORACLE FINANCIALS DEVELOPERS &amp; DBA'S
34009 Excellent Opportunities-RTP NCWash DCMinneapolis
34010 BIND variables?
</pre>
</code>
<p>
<font size=+1 color="#0000ff">UNA RICERCA!</font>
<p>
Ma tutto ci&ograve pu&ograve essere fatto da un qualsiasi news reader!
<br>
Le cose cominciano a diventare utili se modifichiamo una sola riga del
nostro programma in modo che stampi il numero di tutti gli
articoli il cui soggetto contiene una certa stringa:
<p>
<code>
<pre>
#!/usr/bin/perl

use Getopt::Std;
getopt('pu');
use Net::NNTP;

if(!defined $ARGV[1]){
	print "Uso: $0 [-pprimo] [-uultimo] nome_gruppo stringa [server]\n";
	exit;
}
$ARGV[2] = 'localhost' if !defined $ARGV[2];
($c = new Net::NNTP($ARGV[2])) || die $!; # die on timeout

(($num_arts, $primo, $ultimo, $nome) = ($c->group($ARGV[0]))) || die $!;
$primo = $opt_p if defined $opt_p;
$ultimo = $opt_u if defined $opt_u;
$heads = $c->xpat("Subject", $ARGV[1], $primo, $ultimo);

foreach $head (keys %$heads){
	print "$head $heads->{$head}\n";
}
</pre>
</code>
<p>
Il programma cerca_articoli ora, lanciato cos&igrave;:
<p>
<code>
<pre>
$ cerca_articoli comp.lang.perl.misc '*UNIX*'
</pre>
</code>
<p>
genera sulla mia macchina questo output:
<p>
<code>
<pre>
18263 Simple UNIX program scheduling...
18264 UNIX Symlinks and -i.bak
18266 Re: Simple UNIX program scheduling...
18273 Re: Simple UNIX program scheduling...
</pre>
</code>
<p>
Ci sono due cose da notare: la prima &egrave che il pattern viene
interpretato dal server NNTP, quindi si usano dei metacaratteri
diversi da quelli delle regular expression del Perl, pi&ugrave; simili
ai metacaratteri della shell.
<br>
La seconda cosa &egrave che il pattern deve matchare <b>tutta</b> la
stringa cercata: nel caso si compia una ricerca sul
&quot;Subject&quot; dell'articolo, il pattern deve corrispondere
all'intero soggetto, non ad una parte di esso.
<br>
Questo spiega gli asterischi prima e dopo la stringa da cercare.
<p>
Ovviamente usando lo stesso metodo posso cercare una stringa
all'interno di qualsiasi altra riga dell'header, specificandone il
nome al posto del <cite>&quot;Subject&quot;</cite>,
cos&igrave;, per cercare gli articoli scritti
dal signor Rossi:
<p>
<code>
<pre>
$heads = $c-&gt;xpat(&quot;From&quot;, &quot;*Rossi*&quot;, $primo, $ultimo);
</pre>
</code>
<p>
A questo punto abbiamo gi&agrave il modo di selezionare un po' gli articoli
prima della lettura, ma vogliamo raffinare ancora il nostro
programmino. Facciamo in modo che la nostra creatura possa leggere
anche il testo dell'articolo e che possa &quot;decidere&quot;
cosa ci interessa.
<p>
Qualche altra riga di codice e otteniamo:
<p>
<code>
<pre>
#!/usr/bin/perl

use Getopt::Std;
getopt('pu');
use Net::NNTP;

if(!defined $ARGV[1]){
	print &quot;Uso: $0 [-pprimo] [-uultimo] nome_gruppo stringa_header stringa_body [server]\n&quot;;
	exit;
}
$ARGV[3] = 'localhost' if !defined $ARGV[3];
($c = new Net::NNTP($ARGV[3])) || die $!; # die on timeout

(($num_arts, $primo, $ultimo, $nome) = ($c-&gt;group($ARGV[0]))) || die $!;
$primo = $opt_p if defined $opt_p;
$ultimo = $opt_u if defined $opt_u;
$heads = $c-&gt;xpat(&quot;Subject&quot;, $ARGV[1], $primo, $ultimo);

foreach $numero (keys %$heads){
	$art = $c-&gt;article($numero);
	$testo = join &quot;&quot;, @$art;
	if($testo =~ /$ARGV[2]/o){
		print &quot;$testo\n\n&quot;;
	}
}
</pre>
</code>
<p>
Qualche commento: il numero dei parametri
richiesti dal programma &egrave cresciuto: oltre alla stringa da cercare
nell'header ora ci aspettiamo dall'utente anche una stringa da cercare
all'interno del testo dell'articolo.
<br>
Dopo la chiamata alla funzione membro <cite>xpath()</cite>
scorriamo tutte le righe dell'array, leggendo il testo dell'articolo
mediante la funzione membro <cite>article()</cite>.
<br>
Questa funzione torna una reference ad un array che contiene tutte le
righe dell'articolo (variabile <cite>$art</cite>).
<br>
Uniamo tutte le righe dell'array con una <cite>join</cite> per formare
un'unica variabile, all'interno della quale cercheremo poi il secondo
testo specificato sulla riga di comando.
<p>
Invocando il programma in questo modo:
<p>
<code>
<pre>
$ cerca -p18254 -u18280 comp.lang.perl.misc '*UNIX*' 'crontab'
</pre>
</code>
<p>
ottengo questo l'output:
<p>
<code>
<pre>
Path: nanux!comune.bologna.it!sirio.cineca.it!serra.unipi.it!swidir.switch.ch!in2p3.fr!oleane!tank.news.pipex.net!pipex!news.mathworks.com!newsfeed.internetmci.com!info.ucla.edu!ihnp4.ucsd.edu!munnari.OZ.AU!mel.dit.csiro.au!carlton.acci.COM.AU!gavin
 From: gavin@acci.COM.AU (Gavin Cameron)
 Newsgroups: comp.lang.perl.misc,comp.unix.programmer
 Subject: Re: Simple UNIX program scheduling...
 Date: 11 Apr 96 00:35:28 GMT
 Organization: Australian Computing and Communications Institute
 Lines: 23
 Message-ID: &lt;gavin.829182928@carlton.acci.COM.AU&gt;
 References: &lt;4khh0i$fv2@solaris.cc.vt.edu&gt;
 NNTP-Posting-Host: tawonga.acci.com.au
 X-Newsreader: NN version 6.5.0 #6 (NOV)
 Xref: nanux comp.lang.perl.misc:18273 comp.unix.programmer:5376
 
 Use crontab, see the crontab(5) man page for all the details you'll ever
 need to know.
 
 Gavin
 
 
 sms@magenta.com (SMS/Christian Fowler) writes:
 
 &gt;I have a simple program, written with PERL, I want to schedule execution
 &gt;for. What is the simplest way to do this? Should I have the program 
 &gt;reschedule itself, every time it runs?
 
 &gt;I simply want it to run, say every monday morning at 7 am.
 
 &gt;Thanks for any info...
 
 
 &gt;--
 &gt;  =-=
 &gt;=-=+=-=  Sound Machine Sound - The Music Makers Net Directory
 &gt;=-=%=-=     Christian Fowler - sHAPE FACTOR MOMENt
 &gt;=-=+=-=    sms@magenta.com  http://magenta.com/~sms/
 &gt;  =-=
</pre>
</code>
<p>
Purtroppo questa volta le stringhe che esprimono i pattern da cercare
seguono due standard diversi: la prima stringa viene interpretata dal
server NNTP e segue uno standard <i>pseudo-shell</i>, mentre la
seconda stringa, interpretata dal Perl pu&ograve; essere una regular
expression.
<br>
Spiacente per la confusione, ma a servizi diversi corrispondono
formalismi diversi... fino a quando qualcuno non scriver&agrave; un
server NNTP in Perl (oops!).
<p>
&Egrave comunque
un buon risultato per un programma di venticinque righe, comprese righe
vuote e commenti!
C'&egrave da dire che il programmino non ha molte pretese,
che pu&ograve essere migliorato, ma &egrave sufficiente a dimostrare
cosa si pu&ograve fare con questo
modulo e spero che possa fornirvi degli spunti per creare qualcosa di
pi&ugrave complesso... interfacce News-Web? risponditori intelligenti?
<br>
Si potrebbe usare il modulo che si interfaccia al protocollo SMTP per
spedire mails di biasimo automatiche a chi scrive sciocchezze... ma
questa &egrave un'altra storia e va raccontata un'altra volta.  
<p>
Nel frattempo vi auguro felice hacking sulla vostra Linux box e se
realizzate qualcosa di interessante non mancate di farmelo sapere e
magari scrivete un'articolo per il <b>Pluto Journal</b>.
<p>
A rileggerci alla prossima. Nel frattempo
per dubbi, congratulazioni, correzioni, insulti &amp; altro scrivete
a <a href="mailto:lac0658@iperbole.bologna.it">Nando Santagata</a>.
<hr>
<font size=+1 color="#0000ff"><a name="appendice">APPENDICE</a></font>
<p>
Il modulo citato si pu&ograve; trovare in uno dei siti del CPAN
(Comprehensive Perl Archive Network) di cui vi elenco i siti in Europa:
<p>
<code>
<pre>
Austria
	ftp://ftp.tuwien.ac.at/pub/languages/perl/CPAN/
Belgium
	ftp://ftp.kulnet.kuleuven.ac.be/pub/mirror/CPAN/
Czech Republic
	ftp://sunsite.mff.cuni.cz/MIRRORS/ftp.funet.fi/pub/languages/perl/CPAN/
Denmark
	ftp://sunsite.auc.dk/pub/languages/perl/CPAN/
Finland
	ftp://ftp.funet.fi/pub/languages/perl/CPAN/
France
	ftp://ftp.ibp.fr/pub/perl/CPAN/
	ftp://ftp.pasteur.fr/pub/computing/unix/perl/CPAN/
Germany
	ftp://ftp.leo.org/pub/comp/programming/languages/perl/CPAN/
	ftp://ftp.rz.ruhr-uni-bochum.de/pub/CPAN/
Greece
	ftp://ftp.ntua.gr/pub/lang/perl/
Hungary
	ftp://ftp.kfki.hu/pub/packages/perl/CPAN/
Poland
	ftp://ftp.pk.edu.pl/pub/lang/perl/CPAN/
	ftp://sunsite.icm.edu.pl/pub/CPAN/
Portugal
	ftp://ftp.ci.uminho.pt/pub/lang/perl/
Slovenia
	ftp://ftp.arnes.si/software/perl/CPAN/
Spain
	ftp://ftp.etse.urv.es/pub/mirror/perl/
	ftp://ftp.rediris.es/mirror/CPAN/
Sweden
	ftp://ftp.sunet.se/pub/lang/perl/CPAN/
Switzerland
	ftp://ftp.switch.ch/mirror/CPAN/
the Netherlands
	ftp://ftp.cs.ruu.nl/pub/PERL/CPAN/
UK
	ftp://ftp.demon.co.uk/pub/mirrors/perl/CPAN/
	ftp://sunsite.doc.ic.ac.uk/packages/CPAN/
	ftp://unix.hensa.ac.uk/mirrors/perl-CPAN/
</pre>
</code>
<p>
L'Italia non ha un sito CPAN (qualche volontario?).
<p>
Il modulo in questione si trova, a partire dalla directory del CPAN
indicata per ogni server, in:
<p>
<code>
<pre>
modules/by-module/Net
</pre>
</code>
<address>
<p align=right>
<font size=+0>
di
<a href="mailto:lac0658@iperbole.bologna.it">
Nando Santagata</a>
</p>
</address>
