<H2>3.1 In cui, <EM>(come negli inferi)</EM>, si scende nel dettaglio</H2>
<P>La Slackware, gloriosa e benemerita distribuzione, è famosa per installare
un sistema completo e precompilato, ma poi per poter aggiungere un pezzo, 
per upgradare un pacchetto, ti devi procurare la confezione sorgente e,
dopo una sapiente decantazione a suon di <CODE>configure</CODE>, distillare con amore 
(e pazienza) nell'alambicco del <CODE>make</CODE>.</P>
<P>Molto divertente, stimolante ed istruttivo. Ma, quando qualcosa va male,
se lo spiritello dispettoso ci mette lo zampino, allora diventa un <B>inferno</B>.
Bisogna leggersi tonnellate di documentazione scritta frettolosamente nella
convinzione che tanto nessuno l'avrebbe letta, scrutare entro <CODE>script</CODE>
scritti da smaliziati <CODE>hacker</CODE> forgiati ad ogni asprezza da lunga pratica
del <CODE>forth</CODE>,  coltivando religiosamente ogni carattere <CODE>ASCII</CODE> per
coglierne ogni più recondito aspetto.</P>
<P>Così, tanto per divertirmi, decido di compilarmi non uno, ma ben due kernel,
<EM>crepi l'avarizia!</EM> Un 1.2.13, nella speranza che mi dia quella stabilità
che mi sembra di avere smarrito con l'inizio di questa avventura, e l'1.3.20,
non perchè sia meglio, ma perchè questo mi propone lo Slackware.</P>
<P>Creiamo <CODE>/etc/lilo.conf</CODE>, e ci mettiamo tutti i kernel possibili 
che ho a disposizione: il vecchio Slack2, sia 1.2.8 che 1.2.13, ma entrambi
<CODE>a.out</CODE>, lo Slack3, sia 1.2.13 (<CODE>ELF</CODE>) che 1.3.20, 
il Picasso, anch'esso 1.3.20, lasciando spazio per il Debian a cui resta 
tuttora riservata la <CODE>hdb3</CODE>.</P>
<P><CODE>/etc/fstab</CODE>. Dovrebbe essere creato automaticamente dal programma
di installazione, e lo è, ma ... manca sempre qualcosa, inoltre, chissà 
perchè, le colonne vengono separate da un numero fisso di spazi (invece 
che <CODE>Tab</CODE>), creando quell'effetto a fisarmonica che, sinceramente, sembra
proprio fatto apposta per urtare i nervi ad un maniaco paranoico come me.</P>
<P>Così mi sono abituato a riscrivere sempre tutto il file 
(in realtà non faccio altro che copiarlo da una partizione all'altra, 
modificandolo di volta in volta per la bisogna).
<BLOCKQUOTE><CODE>
<PRE>
# device:       mount:          fs-type:        options:        dump:   fsck:
# _______       ______          _______         ________        ____    ____
#
/dev/hdb5       none            swap            sw              0       0
/dev/hdb1       /               ext2            defaults        1       1
/dev/hdb6       /usr            ext2            defaults        1       2
/dev/hdb7       /usr            ext2            defaults        1       2
/dev/hdb8       /home           ext2            defaults        1       2
/proc           /proc           proc            defaults        0       0
#
/dev/hdc        /cdrom          iso9660         user,ro,noauto  0       0
/dev/fd0        /a              msdos           user,noauto     0       0
/dev/fd0        /floppy         ext2            user,noauto     0       0
#
# altre installazioni
#
# Slackware 2           1.2.8   1.2.13  a.out
/dev/hda1       /slack2         ext2            defaults        0       2
#
# Slackware 3           1.2.13  1.3.20  ELF
#/dev/hdb1      /slack3         ext2            defaults        0       2
#/dev/hdb6      /slack3/usr     ext2            defaults        0       2
#/dev/hdb7      /slack3/var     ext2            defaults        0       2
#/dev/hdb8      /slack3/home    ext2            defaults        0       2
#
# Picasso (Red Hat 3.0.3)       1.3.20  ELF
/dev/hdb2       /picasso        ext2            defaults        0       2
#/dev/hdb8      /picasso/home   ext2            defaults        0       2
/dev/hdb9       /picasso/usr    ext2            defaults        0       2
/dev/hdb10      /picasso/opt    ext2            defaults        0       2
#
# Debian 0.93   1.2.13  ELF
#/dev/hdb3      /debian         ext2            defaults        0       2
#
</PRE>
</CODE></BLOCKQUOTE>

Non sembra tutto più ordinato e metodico?</P>
<P>Ovviamente tocca anche ricordarsi di creare i <CODE>mount point</CODE> per
tutte queste partizioni (<CODE>/slack2 /slack3 /picasso /debian /a
/fd0</CODE>, invece <CODE>/cdrom</CODE> c'è già, bontà loro).</P>
<P>Ora tocca alle seriali. Ho quattro seriali, due parallele e tre o
quattro <CODE>IRQ</CODE>. Oh, come mi piacerebbe mettere le mani sul
kernel 1.4 (siamo già all'1.99, quindi toccherà al 2.0). Dicono 
abbia supporto per condivider gli <CODE>IRQ</CODE> tra seriali!
Per l'intanto accontentiamoci di dire in <CODE>/etc/rc.d/rc.serial</CODE>
che <CODE>cua2</CODE> usa l'<CODE>irq5</CODE>, così il modem può funzionare.</P>
<P>Bisogna anche ricordarsi di far partire questo <CODE>/etc/rc.d/rc.serial</CODE>,
scommentando adeguatamente in <CODE>/etc/rc.d/rc.S</CODE>. Già che ci siamo
qui si deve anche aggiungere il flag <CODE>-u</CODE> al comando
<CODE>/sbin/clock -s</CODE>, per consentire all'orologio del kernel di leggere
l'ora dell'hardware usandola come <B>Universal Time</B>, che altro 
non è che il buon vecchio <B>Greenwich</B>. Il settaggio di default, 
<EM>orrore!</EM>, presuppone che voi usiate MS-Dos con l'orologio locale.</P>
<P><CODE>/etc/profile</CODE> è il posto dove far confluire tutte le
personalizzazioni dell'ambiente della shell che voglio trascinarmi 
dietro tra i vari utenti che uso correntemente 
(<EM>sono uno dalle multiple personalità, io</EM>).
Oltre al solito diluvio di variabili volute da questo o quel programma,
io sono solito settare con cura la variabile <CODE>PAGER</CODE> per accedere
di default a <CODE>less</CODE> invece che a <CODE>more</CODE>, <CODE>LESSCHARSET</CODE> posta
al solito <CODE>latin1</CODE>, ma soprattutto mi costruisco una spaventosa
<BLOCKQUOTE><CODE>
<PRE>
PS1=&quot;\u@\h:\w [\d \t]\n\$SHLVL$ &quot;
</PRE>
</CODE></BLOCKQUOTE>

che mi consente di sfoggiare un prompt cervellotico a due righe come
<BLOCKQUOTE><CODE>
<PRE>
fabrizio@pongo:~/work/pluto-journal/sgml [Fri Jun 21 00:45:50]
1$ _
</PRE>
</CODE></BLOCKQUOTE>

dove si incontrano (nell'ordine) l'utente, l'host, la working-dir, 
data e ora, il numero di shell nidificate e il prompt vero e proprio 
(# in caso di superuser). Ora che ci penso, manca il nome del terminale.
Bisognerà rimediare.</P>
<P>Le mie funzioni preferite:
<BLOCKQUOTE><CODE>
<PRE>
function h()    { history | less +G ; }
export -f h 
function l()    { ls -CoAF $* | less -E ; }
export -f l 
function ll()   { ls -loAF $* | less -E ; }
export -f ll 
function pg()   { less -E $*; }
export -f pg
</PRE>
</CODE></BLOCKQUOTE>

Preferisco usare funzioni piuttosto che alias in quanto le funzioni
si possono esportare (dalla <CODE>ksh</CODE> in poi), mentre gli alias no
(<EM>oddio, saranno 5 anni che non provo, ma non credo che la cosa
sia cambiata</EM>); questo è molto comodo quando da shell si lancia
un'altra istanza della shell, magari <CODE>su</CODE>.</P>
<P>Passiamo ora a <CODE>X</CODE>. Anche se c'è un programmino apposta, io preferisco 
editarmi a manina il file <CODE>/etc/XF86Config</CODE>. Questo di come
configurarsi il monitor e la scheda video è un discorso lungo, che
andrebbe approfondito. Meglio rimandare. State sintonizzati!
Idem con patate, per gli altri due file canonici, 
<CODE>/var/lib/X11/fvwm/system.fvwmrc</CODE> ed il personalissimo
<CODE>~/.xinitrc</CODE>.</P>
<P>Non pensate che Slackware 3 sia esente da errori. Per esempio
<CODE>/usr/bin/sleep</CODE> viene usato in fase di spegnimento e/o
reboot anche <EM>dopo</EM> che il file system è stato smontato.
Con quali risultati potete immaginarlo. O eliminano lo sleep
dall'<CODE>rc</CODE> oppure spostano <CODE>sleep</CODE> in <CODE>/bin</CODE>.
In attesa di un intervento di Patrick (o del <B>fsstnd</B> che se ne è 
subito interessato), mi sono copiato il file.
Un altro piccolo problema viene dai messaggi visualizzati durante
il reboot quando questo è esguito mediante la solita tripletta
<CODE>CtrlAltDel</CODE> su una console <B>fuori</B> login. Dovete sapere che
la mappatura del <CODE>\n</CODE> in LF-CR viene eseguita modificando
il settaggio (disciplina) della linea seriale <B>dopo</B> il <CODE>login</CODE>.
Pertanto ogni messaggio inviato ad un terminale non loggato va condito
con la solita coppia <CODE>\n\r</CODE> come in Dos. 
Questo non avviene nelle <CODE>echo</CODE> dello script <CODE>/etc/rc.d/rc.6</CODE>,
per cui occorre aggiungere <CODE>\r</CODE> alla fine di ogni stringa. 
E poichè la <CODE>echo</CODE> builtin nella bash non accetta di default 
questo carattere, occorre anche aggiungere l'opzione <CODE>-e</CODE>.</P>
