<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Draft//EN">
<HTML>
<HEAD>
<TITLE> Linux from DOS to Linux HOWTO : Un po' di programmazione</TITLE>
</HEAD>
<BODY>
<A HREF="DOStoLinux-HOWTO-5.html">Precedente</A>
<A HREF="DOStoLinux-HOWTO-7.html">Successivo</A>
<A HREF="DOStoLinux-HOWTO.html#toc6">Indice</A>
<HR>
<H2><A NAME="s6">6. Un po' di programmazione</A></H2>

<P>
<P>
<H2><A NAME="ss6.1">6.1 Shell script: super file .BAT</A></H2>

<P>
<P>Se usavate i file .BAT per creare diminutivi di lunghe linee di comando (io
lo facevo spesso), questo si pu&ograve; ottenere inserendo degli alias in
<CODE>profile</CODE> o <CODE>.profile</CODE>. Ma se i vostri .BAT erano pi&ugrave; complessi, vi
piacer&agrave; il linguaggio di scripting della shell: &egrave; potente come il QBasic, se
non di pi&ugrave;. Ha variabili, strutture come while,
for, case, if... then... else, e molte altre caratteristiche: pu&ograve; essere una
buona alternativa ad un ``vero'' linguaggio di programmazione.
<P>Per scrivere un file script---l'equivalente di un .BAT file sotto DOS---non
si fa altro che scrivere un file ASCII contenente le istruzioni, lo si salva
e poi lo si rende eseguibile col comando <CODE>chgmod +x &lt;scriptfile></CODE>. Per
eseguirlo si scrive il suo nome.
<P>Attenzione per&ograve;. L'editor di sistema si chiama <CODE>vi</CODE>, e ho visto che molti
nuovi utenti lo trovano molto difficile da usare. Non spiegher&ograve; come usarlo
perch&eacute; non mi piace e non lo uso; consultate ``Linux installation...'' di
Matt Welsh, a pag. 109. (Fareste meglio a procurarvi un altro editor come
<CODE>joe</CODE> o <CODE>emacs</CODE> per X.) Basti dire che:
<P>
<UL>
<LI> per inserire del testo, premete 'i' e poi il testo;</LI>
<LI> per uscire da <CODE>vi</CODE> senza salvare, premete ESC e poi :q!</LI>
<LI> per salvare e uscire, premete ESC e poi :wq</LI>
</UL>
<P>Scrivere script sotto <CODE>bash</CODE> &egrave; un argomento cos&igrave; vasto che richiederebbe
un libro per conto suo, e non dar&ograve; spiegazioni ma solo un esempio piuttosto
completo di shell script, dal quale potrete intuire le regole di base:
<P>
<HR>
<PRE>

#!/bin/sh
# esempio.sh
# Io sono un commento
# non cambiate la prima linea, deve restare cosi' com'e'
echo &quot;Questa macchina e': `uname -a`&quot; # usa l'output del comando
echo &quot;Il mio noem e' $0&quot; # variabile interna
echo &quot;Mi hai dato i seguenti $# argomenti: &quot; $*
echo &quot;Il primo argomento e': &quot; $1
echo -n &quot;Come ti chiami? &quot; ; read nome
echo guarda la differenza: &quot;ciao $nome&quot; # meccanismo di quoting con &quot;
echo guarda la differenza: 'ciao $nome' # meccanismo di quoting con '
DIRS=0 ; FILES=0
for file in `ls .` ; do
  if [ -d ${file} ] ; then # se file &egrave; una directory
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  elif [ -f ${file} ] ; then
    FILES=`expr $FILES + 1`
  fi
  case ${file} in
    *.gif|*jpg) echo &quot;${file}: file grafico&quot; ;;
    *.txt|*.tex) echo &quot;${file}: file di testo&quot; ;;
    *.c|*.f|*.for) echo &quot;${file}: file sorgente&quot; ;;
    *) echo &quot;${file}: file generico&quot; ;;
  esac
done
echo &quot;ci sono ${DIRS} directories e ${FILES} files&quot;
ls | grep &quot;ZxY--!!!WKW&quot;
if [ $? != 0 ] ; then # exit code dell'ultimo comando
  echo &quot;non ho trovato ZxY--!!!WKW&quot;
fi
echo &quot;basta cosi'... scrivi 'man bash' se vuoi altre informazioni.&quot;
</PRE>
<HR>
<P>

<H2><A NAME="ss6.2">6.2 Programmare in C</A></H2>

<P>
<P>Sotto Unix, il linguaggio di programmazione per eccellenza &egrave; il C, vi
piaccia o no. Ci sono anche molti altri linguaggi a disposizione (FORTRAN,
Pascal, Lisp, Basic, Perl, awk...).
<P>Dato per scontato che conosciate il C, ecco qui un paio di linee guida per
quelli di voi che sono stati viziati dal Turbo C++ o analogo compilatore. Il
compilatore C di Linux si chiama <CODE>gcc</CODE> e non ha tutte quelle cose che di
solito accompagnano un compilatore per DOS: niente IDE, aiuto in linea,
debugger integrato e cos&igrave; via. &Egrave; solo un compilatore a linea di comando,
molto potente ed efficiente. Per compilare il classico <CODE>hello.c</CODE> si fa
cos&igrave;:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>che produce di default un eseguibile chiamato <CODE>a.out</CODE>. Per dargli un nome
diverso:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o ciao hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>Per linkare una libreria al programma, si aggiunge lo switch
-l&lt;libname&gt;. Per esempio, per linkare la libreria matematica:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o mathprog mathprog.c -lm
</PRE>
</CODE></BLOCKQUOTE>
<P>(Lo switch <CODE>-l&lt;libname&gt;</CODE> fa linkare a <CODE>gcc</CODE> la libreria
<CODE>/usr/lib/lib&lt;libname&gt;.a</CODE>; quindi <CODE>-lm</CODE> linka
<CODE>/usr/lib/libm.a</CODE>).
<P>Finora, tutto bene. Ma se il vostro programma &egrave; composto da molti file
sorgenti, vi servir&agrave; l'utility <CODE>make</CODE>. Supponiamo che avete scritto un
parser per espressioni: il sorgente si chiama <CODE>parser.c</CODE> e #include
due file header, <CODE>parser.h</CODE> e <CODE>xy.h</CODE>. Volete usare le routine di
<CODE>parser.c</CODE> in un programma, diciamo <CODE>calc.c</CODE>, che a sua volta
#include <CODE>parser.h</CODE>. Che casino! Cosa bisogna fare per compilare
<CODE>calc.c</CODE>?
<P>Dovrete scrivere un cosiddetto <CODE>makefile</CODE>, che insegna al compilatore
quali sono le dipendenze tra sorgenti e files oggetto. Nel nostro caso:
<P>
<HR>
<PRE>

# Questo e' makefile, usato per compilare calc.c
# Premere il tasto &lt;TAB&gt; dove indicato

calc: calc.o parser.o
&lt;TAB&gt;gcc -o calc calc.o parser.o -lm
# calc dipende da due files oggetto: calc.o e parser.o

calc.o: calc.c parser.h
&lt;TAB&gt;gcc -c calc.c
# calc.o dipende da due files sorgenti

parser.o:  parser.c parser.h xy.h
&lt;TAB&gt;gcc -c parser.c
# parser.o dipende da tre files sorgenti

# end of makefile.
</PRE>
<HR>
<P>Salvate questo file come <CODE>makefile</CODE> e scrivete
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ make
</PRE>
</CODE></BLOCKQUOTE>
<P>per compilare il programma; in alternativa, salvatelo come <CODE>calc.mak</CODE> e 
scrivete
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ make -f calc.mak
</PRE>
</CODE></BLOCKQUOTE>
<P>Ovviamente, LMP.
<P>Potete ottenere aiuto sulle funzioni del C, che sono illustrate da pagine
man, sezione 3; per esempio,
<BLOCKQUOTE><CODE>
<PRE>
$ man 3 printf
</PRE>
</CODE></BLOCKQUOTE>
<P>Ci sono tantissime librerie disponibili; tra le prime che vorrete usare ci
sono <CODE>ncurses</CODE>, per gestire effetti in modo testo, e <CODE>svgalib</CODE>, per
fare grafica. Se vi sentite abbastanza coraggiosi da affrontare la
programmazione sotto X, procuratevi 
<CODE>XForms</CODE> (<CODE> 
<A HREF="ftp://bloch.phys.uwm.edu/pub/xforms">bloch.phys.uwm.edu/pub/xforms</A></CODE>) e/o <CODE>MGUI</CODE> 
(<CODE> 
<A HREF="http://www.volftp.vol.it/IT/IT/ITALIANI/MORELLO/index.htm">www.volftp.vol.it/IT/IT/ITALIANI/MORELLO/index.htm</A></CODE>), due
magnifiche librerie che rendono facile la programmazione sotto X. Inoltre,
se non potete fare a meno di una IDE alla Borland, procuratevi <CODE>xwpe</CODE>
da <CODE>
<A HREF="ftp://sunsite.unc.edu:/pub/Linux/apps/editors/">sunsite.unc.edu:/pub/Linux/apps/editors/</A></CODE>. &Egrave; probabile che vi
piacer&agrave;.
<P>
<P>

<HR>
<A HREF="DOStoLinux-HOWTO-5.html">Precedente</A>
<A HREF="DOStoLinux-HOWTO-7.html">Successivo</A>
<A HREF="DOStoLinux-HOWTO.html#toc6">Indice</A>
</BODY>
</HTML>
