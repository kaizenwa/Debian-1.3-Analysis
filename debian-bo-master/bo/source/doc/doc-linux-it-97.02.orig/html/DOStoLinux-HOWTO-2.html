<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Draft//EN">
<HTML>
<HEAD>
<TITLE> Linux from DOS to Linux HOWTO : File e programmi</TITLE>
</HEAD>
<BODY>
<A HREF="DOStoLinux-HOWTO-1.html">Precedente</A>
<A HREF="DOStoLinux-HOWTO-3.html">Successivo</A>
<A HREF="DOStoLinux-HOWTO.html#toc2">Indice</A>
<HR>
<H2><A NAME="s2">2. File e programmi</A></H2>

<P>
<P>
<H2><A NAME="ss2.1">2.1 File: nozioni preliminari</A></H2>

<P>
<P>Linux ha un file system---intendendo con cio' ``la struttura delle 
directory e dei file in esse contenuti''---molto simile a quello 
del DOS. I file hanno dei nomi che seguono certe regole, sono messi 
in directory, alcuni sono eseguibili, e tra questi ultimi molti 
hanno degli switch. Inoltre, ci sono i caratteri wildcards, la 
redirezione e il piping. Ci sono solo alcune piccole differenze:
<P>
<UL>
<LI> sotto DOS, i nomi dei file seguono la regola dell'8.3; per 
esempio, ILMIOFIL.TXT. Sotto Linux si pu&ograve; fare meglio. Se avete 
installato Linux con un filesystem come ext2 o umsdos, potete usare 
nomi pi&ugrave; lunghi, e con pi&ugrave; di un punto: per esempio, 
<CODE>Ecco.un_NOME_molto.LUNGO</CODE>. Notare che ho usato lettere maiuscole e
minuscole: infatti...
</LI>
<LI> maiuscole e minuscole sono considerate diverse. Quindi, 
<CODE>FILENAME.tar.gz</CODE> e <CODE>filename.tar.gz</CODE> sono due file diversi. 
<CODE>ls</CODE> &egrave; un comando, <CODE>LS</CODE> &egrave; un errore;
</LI>
<LI> non ci sono estensioni obbligatorie come .COM ed .EXE per i
programmi, o .BAT per i file batch. I files eseguibili sono contrassegnati
da un asterisco <CODE>'*'</CODE> alla fine del loro nome quando si d&agrave; il comando 
<CODE>ls -F</CODE>. Per esempio: 

<BLOCKQUOTE><CODE>
<PRE>
$ ls -F
lettera.txt   cindy.jpg   cjpg*   Direttorio/   script*   old~
</PRE>
</CODE></BLOCKQUOTE>


I files  <CODE>cjpg*</CODE> e <CODE>script*</CODE> sono eseguibili---``programmi''. 
Sotto DOS, i file di backup hanno il nome che finisce in .BAK, sotto Linux
finiscono con una tilde '<CODE>~</CODE>'. Inoltre, un file il cui nome inizia
con un punto viene considerato un file nascosto. Per esempio, il file
<CODE>.Io.sono.nascosto</CODE> non apparir&agrave; dopo il comando <CODE>ls</CODE>.
</LI>
<LI> gli switch dei programmi DOS si ottengono con <CODE>/switch</CODE>, con i
programmi Linux si ottengono con <CODE>-switch</CODE> or <CODE>--switch</CODE>. Esempio:
<CODE>dir /s</CODE>  diventa <CODE>ls -R</CODE>. Notare che molti programmi DOS, come
PKZIP o ARJ, hanno gli switch in stile Unix.
</LI>
</UL>
<P>Ora potete saltare alla sezione 
<A HREF="#Files">Tradurre i comandi dal DOS a Linux</A>, ma se fossi in voi continuerei a leggere.
<P>

<H2><A NAME="ss2.2">2.2 Link simbolici</A></H2>

<P>
<P>Unix ha un tipo di file che il DOS non ha: il link simbolico. Questo &egrave; un
puntatore ad un file o directory, e pu&ograve; essere usato al posto del file o
directory a cui punta; &egrave; molto simile a XXXXX di Windows 95. Esempi di link
simbolici sono <CODE>/usr/X11</CODE>, che punta a <CODE>/usr/X11R6</CODE>; 
<CODE>/dev/modem</CODE>, che punta a <CODE>/dev/cua0</CODE> o <CODE>/dev/cua1</CODE>.
<P>Per fare un link simbolico:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s &lt;file_o_dir&gt; &lt;nomelink&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>Esempio:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</PRE>
</CODE></BLOCKQUOTE>
<P>Ora potete riferirvi a <CODE>g77manual.txt</CODE> al posto di 
<CODE>/usr/doc/g77/DOC</CODE>.
<P>

<H2><A NAME="Permessi"></A> <A NAME="ss2.3">2.3 Permessi e Propriet&agrave; </A></H2>

<P>
<P>I file e le directory DOS hanno i seguenti attributi: A (archivio), H
(hidden, nascosto), R (read-only, solo lettura), and S (system, file di
sistema). Solo H e R hanno senso sotto Linux: i files nascosti iniziano con
un punto, e per quanto riguarda l'attributo R, continuate a leggere.
<P>Sotto Unix un file ha dei ``permessi'' e un proprietario, che appartiene ad
un ``gruppo''. Guardate questo esempio:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</PRE>
</CODE></BLOCKQUOTE>
<P>Il primo campo contiene i permessi del file <CODE>/bin/ls</CODE>, 
che appartiene a root, gruppo bin. Tralasciando le altre informazioni (il
libro di Matt Welsh &egrave; l&igrave; per quello), ricordate che <CODE>-rwxr-xr-x</CODE> 
significa (da sinistra a destra):
<P><CODE>-</CODE> &egrave; il tipo di file (- = file normale, d = directory, l = link, 
etc.); <CODE>rwx</CODE> sono i permessi per il proprietario del file (read, write, 
execute); <CODE>r-x</CODE> sono i permessi per il gruppo cui il proprietario del
file appartiene (non spiegher&ograve; il concetto di gruppo, ne potete fare a meno
finch&eacute; siete principianti ;-) <CODE>r-x</CODE> sono i permessi per tutti gli altri
utenti (read, execute).
<P>Ecco perch&eacute; non potete cancellare il file <CODE>/bin/ls</CODE>, a meno che non
siate root: non avete i permessi necessari. Per cambiare i permessi di un
file, il comando &egrave;:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod &lt;whoXperm&gt; &lt;file&gt;
</PRE>
</CODE></BLOCKQUOTE>
<P>dove who &egrave; <CODE>u</CODE> (user, cio&egrave; proprietario), <CODE>g</CODE> (group, gruppo), <CODE>o</CODE>
(other, altri), X &egrave; <CODE>+</CODE> o <CODE>-</CODE>, perm &egrave; <CODE>r</CODE> (read, lettura), <CODE>w</CODE>
(write, scrittura), o <CODE>x</CODE> (execute, esecuzione). Esempi:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod u+x file
</PRE>
</CODE></BLOCKQUOTE>
<P>setta il permesso di esecuzione per il proprietario. Scorciatoia: 
<CODE>chmod +x file</CODE>.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod go-wx file
</PRE>
</CODE></BLOCKQUOTE>
<P>toglie i permessi di scrittura ed esecuzione per tutti tranne il 
proprietario.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod ugo+rwx file
</PRE>
</CODE></BLOCKQUOTE>
<P>d&agrave; a tutti i permessi di lettura, scrittura ed esecuzione.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# chmod +s file
</PRE>
</CODE></BLOCKQUOTE>
<P>rende un file ``setuid'' o ``suid'': ciascuno lo pu&ograve; eseguire con i
permessi di root.
<P>Una maniera pi&ugrave; breve di riferirsi ai permessi &egrave; con i numeri:
<CODE>rwxr-xr-x</CODE> pu&ograve; essere espresso con 755 (ogni lettera corrisponde a un
bit: <CODE>---</CODE> &egrave; 0, <CODE>--x</CODE> &egrave; 1, <CODE>-w-</CODE> &egrave; 2, <CODE>-wx</CODE> &egrave; 3...). Sembra
difficile, ma con un po' di pratica capirete il concetto.
<P>root, essendo il cossiddetto superutente, pu&ograve; cambiare i permessi di ogni
file. C'&egrave; molto di pi&ugrave; sull'argomento---LMP.
<P>

<H2><A NAME="Files"></A> <A NAME="ss2.4">2.4 Convertire i comandi dal DOS a Linux </A></H2>

<P>
<P>Alla sinistra, i comandi DOS; a destra, i corrispondenti comandi Linux.
<P>
<BLOCKQUOTE><CODE>
<PRE>
COPY:           cp
DEL:            rm
MOVE:           mv
REN:            mv
TYPE:           more, less, cat
</PRE>
</CODE></BLOCKQUOTE>
<P>Operatori per la redirezione e il plumbing: <CODE> < > >> |</CODE>
<P>Wildcards: <CODE>* ?</CODE>
<P><CODE>nul:   /dev/null</CODE>
<P><CODE>prn, lpt1:     /dev/lp0 or /dev/lp1; lpr</CODE>
<P>- EXAMPLES -
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO&gt;copy joe.txt joe.doc           $ cp joe.txt joe.doc
C:\GUIDO&gt;copy *.* total                 $ cat * &gt; total
C:\GUIDO&gt;copy fractals.doc prn          $ lpr fractals.doc
C:\GUIDO&gt;del temp                       $ rm temp
C:\GUIDO&gt;del *.bak                      $ rm *~
C:\GUIDO&gt;move paper.txt tmp\            $ mv paper.txt tmp/
C:\GUIDO&gt;ren paper.txt paper.asc        $ mv paper.txt paper.asc
C:\GUIDO&gt;print letter.txt               $ lpr letter.txt
C:\GUIDO&gt;type letter.txt                $ more letter.txt
C:\GUIDO&gt;type letter.txt                $ less letter.txt
C:\GUIDO&gt;type letter.txt &gt; nul          $ cat letter.txt &gt; /dev/null
        n/a                             $ more *.txt *.asc
        n/a                             $ cat section*.txt | less
</PRE>
</CODE></BLOCKQUOTE>
<P>Note:
<P>
<UL>
<LI> * &egrave; migliore sotto Linux: * prende tutti i file tranne quelli
nascosti; .* tutti i file nascosti; *.* prende tutti i file che hanno un
`.' nel mezzo, seguito da altri caratteri; p*a prende sia `pera' che
`palla'; *l* prende sia `mela' che `filo';
</LI>
<LI> usando <CODE>more</CODE>, premere SPAZIO per leggere il file, 
`q' o CTRL-C per uscire. <CODE>less</CODE> &egrave; pi&ugrave; intuitivo, si possono usare i tasti
freccia;
</LI>
<LI> non c'&egrave; <CODE>UNDELETE</CODE>, quindi <EM>pensarci bene</EM> prima di cancellare;
</LI>
<LI> oltre a <CODE>&lt; &gt; &gt;&gt;</CODE> del DOS, Linux ha <CODE>2&gt;</CODE> per
redirigere i messaggi di errore (stderr); inoltre, <CODE>2&gt;&amp;1</CODE> redirige
stderr su stdout, mentre <CODE>1&gt;&amp;2</CODE> redirige stdout su stderr;
</LI>
<LI> Linux ha un altro wildcard: la coppia <CODE>[]</CODE>. Uso: <CODE>[abc]*</CODE>
prende i file che cominciano con a, b, c; <CODE>*[I-N,1,2,3]</CODE> prende i file
che finiscono con I, J, K, L, M, N, 1, 2, 3;
</LI>
<LI> non c'&egrave; un <CODE>RENAME</CODE> alla DOS; cio&egrave;, <CODE>mv</CODE> *.xxx *.yyy 
non funziona;
</LI>
<LI> usare <CODE>cp -i</CODE> e <CODE>mv -i</CODE> per essere avvisati se un file sta per
essere sovrascritto.
</LI>
</UL>
<P>

<H2><A NAME="ss2.5">2.5 Programmi: Multitasking e Sessioni</A></H2>

<P>
<P>Per far partire un programma, si scrive il suo nome come col DOS. Se la
directory (Sezione 
<A HREF="DOStoLinux-HOWTO-3.html#Directories">Directories</A>) dove il
programma risiede &egrave; nel PATH (Sezione 
<A HREF="DOStoLinux-HOWTO-5.html#Files di inizializzazione">Files di inizializzazione</A>), il programma parte. Eccezione: sotto
Linux, un programma che sta nella directory corrente non parte se la
directory non &egrave; inclusa nel PATH. Scappatoia: se <CODE>prog</CODE> &egrave; il programma,
scrivere <CODE>./prog</CODE>.
<P>Questa &egrave; una tipica linea di comando:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ command -s1 -s2 ... -sn par1 par2 ... parn &lt; input &gt; output
</PRE>
</CODE></BLOCKQUOTE>
<P>dove <CODE>-s1</CODE>, ..., <CODE>-sn</CODE> sono gli switch del programma,
<CODE>par1</CODE>, ..., <CODE>parn</CODE> sono gli argomenti del programma. Si possono dare
pi&ugrave; comandi sulla stessa linea:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ command1 ; command2 ; ... ; commandn
</PRE>
</CODE></BLOCKQUOTE>
<P>Tutto qui per quanto riguarda i programmi, ma &egrave; facile fare dei passi
avanti. Uno dei vantaggi di Linux &egrave; il multitasking: pu&ograve; far girare pi&ugrave;
programmi (d'ora in poi, processi) allo stesso tempo. Si possono lanciare
programmi in background e continuare a lavorare. Inoltre, Linux mette a
disposizione pi&ugrave; sessioni di lavoro contemporanee: &egrave; come avere tanti
computer allo stesso tempo!
<P>
<UL>
<LI> Per passare di sessione in sessione (1..6):
<BLOCKQUOTE><CODE>
<PRE>
$ ALT-F1 ... ALT-F6
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per far partire un'altra sessione senza lasciare quella corrente:
<BLOCKQUOTE><CODE>
<PRE>
 $ su - &lt;loginname&gt; 
</PRE>
</CODE></BLOCKQUOTE>
 Esempio:
<BLOCKQUOTE><CODE>
<PRE>
 $ su - root 
</PRE>
</CODE></BLOCKQUOTE>
 Questo &egrave; utile, tra l'altro,
per usare i floppy (Sezione 
<A HREF="DOStoLinux-HOWTO-4.html#Floppies">Floppies</A>): 
normalmente, solo root lo pu&ograve; fare.
</LI>
<LI> Per chiudere una sessione:
<BLOCKQUOTE><CODE>
<PRE>
$ exit
</PRE>
</CODE></BLOCKQUOTE>


Se ci sono dei job sospesi (vedi pi&ugrave; avanti) si viene avvisati.
</LI>
<LI> Per lanciare un processo in primo piano:

<BLOCKQUOTE><CODE>
<PRE>
$ progname [-switches] [parameters] [&lt; input] [&gt; output]
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per lanciare un processo in background, aggiungere una `e commerciale'
'<CODE>&amp;</CODE>' alla fine della linea di comando:
<BLOCKQUOTE><CODE>
<PRE>
 
$ progname [-switches] [parameters] [&lt; input] [&gt; output] &
[1] 123
</PRE>
</CODE></BLOCKQUOTE>
 
la shell identifica i processi dando loro un numero (es. <CODE>[1]</CODE>; vedi
sotto) e un PID (123 nel nostro esempio).
</LI>
<LI> Per vedere quanti processi ci sono:
<BLOCKQUOTE><CODE>
<PRE>
$ ps -a
</PRE>
</CODE></BLOCKQUOTE>

Questo comando d&agrave; una lista dei processi attualmente in esecuzione.
</LI>
<LI> Per uccidere (terminare) un processo:
<BLOCKQUOTE><CODE>
<PRE>
$ kill &lt;PID&gt;
</PRE>
</CODE></BLOCKQUOTE>

Potreste dover uccidere un processo se non sapete come uscire normalmente...
;-). A volte, un processo si pu&ograve; uccidere solo con uno dei comandi seguenti:
<BLOCKQUOTE><CODE>
<PRE>
$ kill -15 &lt;PID&gt;
$ kill -9 &lt;PID&gt;
</PRE>
</CODE></BLOCKQUOTE>

Oltre a questo, la shell consente di fermare o sospendere un processo,
mandare un processo in background, e portare un processo dal background in
primo piano. In questo contesto, i processi sono chiamati `job'.
</LI>
<LI> Per vedere quanti job ci sono:
<BLOCKQUOTE><CODE>
<PRE>
$ jobs
</PRE>
</CODE></BLOCKQUOTE>

qui i job sono identificati dal loro numero, non dal PID.
</LI>
<LI> Per fermare un job che gira in primo piano (non sempre funziona):
<BLOCKQUOTE><CODE>
<PRE>
$ CTRL-C
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per sospendere un processo che gira in primo piano (idem):
<BLOCKQUOTE><CODE>
<PRE>
$ CTRL-Z
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per mandare in background un processo sospeso:
<BLOCKQUOTE><CODE>
<PRE>
$ bg &lt;job&gt;
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per portare un job in primo piano:
<BLOCKQUOTE><CODE>
<PRE>
$ fg &lt;job&gt;
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Per uccidere un job:
<BLOCKQUOTE><CODE>
<PRE>
$ kill &lt;%job&gt;
</PRE>
</CODE></BLOCKQUOTE>

dove &lt;job&gt; pu&ograve; essere 1, 2, 3, ...  Usando questi comandi si pu&ograve;
formattare un disco, zippare dei files, compilare un programma e
decompattare un archivio tutto allo stesso tempo, e ancora avere il prompt a
disposizione. Provate a farlo col DOS! E provate con Windows, giusto per
vedere la differenza in performance.
</LI>
</UL>
<P>

<H2><A NAME="ss2.6">2.6 Eseguire programmi su computer remoti</A></H2>

<P>
<P>Per eseguire un programma su un computer remoto il cui indirizzo IP &egrave;
<CODE>remote.bigone.edu</CODE>, si fa:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ telnet remote.bigone.edu
</PRE>
</CODE></BLOCKQUOTE>
<P>Dopo il login, si fa partire il programma. Ovviamente, bisogna avere un
account sul computer remoto.
<P>Se avete X11, si possono far girare anche applicazioni X sul computer
remoto, e queste verranno visualizzate sul vostro schermo. Siano
<CODE>remote.bigone.edu</CODE> il computer remoto e <CODE>local.linux.box</CODE> il vostro
PC. Per far girare da <CODE>local.linux.box</CODE> un programma X che sta su
<CODE>remote.bigone.edu</CODE>, si fa:
<P>
<UL>
<LI> far partire X11 ed un <CODE>xterm</CODE> o equivalente emulatore di
terminale, poi digitare:
<BLOCKQUOTE><CODE>
<PRE>
$ xhost +remote.bigone.edu
$ telnet remote.bigone.edu
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> dopo il login, digitare:
<BLOCKQUOTE><CODE>
<PRE>
remote:$ DISPLAY=local.linux.box:0.0
remote:$ progname &
</PRE>
</CODE></BLOCKQUOTE>

(invece di <CODE>DISPLAY...</CODE>, potreste dover scrivere: <CODE>setenv DISPLAY local.linux.box:0.0</CODE>. Dipende dalla shell remota.)</LI>
</UL>
<P>Et voila! Ora <CODE>progname</CODE> parte su <CODE>remote.bigone.edu</CODE> e viene
visualizzato sulla vostra macchina. &Egrave; per&ograve; meglio non provarci tramite PPP.
<P>
<P>

<HR>
<A HREF="DOStoLinux-HOWTO-1.html">Precedente</A>
<A HREF="DOStoLinux-HOWTO-3.html">Successivo</A>
<A HREF="DOStoLinux-HOWTO.html#toc2">Indice</A>
</BODY>
</HTML>
