<!--
	www4.html
	Last modification: Sun, 3 Nov 1996 10:12:53 +0200
	www4.	Linux e il WWW	PJ 4: Linux e il WWW	Articoli
  -->
<font size=+2 color="#0000ff"> Interludio: l'mSQL </font>

<address>
	<p align=right>
	<font size=+0>
	di
	<a href="mailto:lac0658@iperbole.bologna.it">
	Nando Santagata</a>
	</font>
	</p>
</address>

<p>
Questa volta parliamo di databases e dell'interfacciamento al Web.<br>
È spesso utile disporre di insiemi di dati da lasciar
interrogare agli utenti e la soluzione di buttare tutto in un file
ASCII ed usare il <i>grep</i> non è sempre la soluzione
migliore: le relazioni tra i dati possono essere complesse e può
essere necessario usare un modello relazionale per descriverle.
<p>
Data la natura del Web, dovendo scegliere un gestore di dati è
opportuno porre attenzione più alla velocità di risposta,
che alla potenza del prodotto.<br>
Personalmente ho provato qualche gestore di dati disponibile per Linux
(Postgres, Lincks, mSQL), e il più veloce mi è sembrato
essere <a href="ftp://Bond.edu.au/pub/Minerva/msql/msql-1.0.13.tar.gz">
mSQL</a>.
<p>
mSQL, pur essendo un gestore di database relazionale SQL, è
molto parco nell'uso delle risorse del sistema ed è molto veloce.<br>
Di contro però l'SQL che implementa è molto stringato:
scordatevi le sofisticatezze di RDBMS blasonati come Oracle o
Informix!<p>
Mancano completamente le funzioni che possono normalmente essere
utilizzate nella clausola SELECT (<i>implicit functions</i>), non si
possono innestare più SELECTs una dentro l'altra, mancano anche
la clausola GROUP BY e il tipo di dati DATE...<br>
È il prezzo che si deve pagare per un codice più agile,
più adatto ai problemi che andremo ad affrontare, che,
anche se non esattamente real-time, richiedono tempi di risposta
comunque contenuti.<p>
L'mSQL è facilmente utilizzabile da molti
scripting languages, tra cui il Perl, cosa che lo rende molto
appetibile per chi scrive programmi CGI.<br>
Inutile dire che poter usare la potenza di strumenti come il Perl,
rende facile supplire alle relative debolezze del linguaggio di
interrogazione.
<p>
Supponiamo che vi siate già procurati i sorgenti dell'mSQL.
<br>
Entrate nella directory che è stata creata scompattando il pacchetto
e date il comando:
<p>
<kbd>$ make target</kbd>
<p>
A questo punto nella mia
installazione è stata creata la sottodirectory
<b>targets/Linux-1.2.13-i486</b> (ovviamente se avete una diversa versione
del Kernel o del processore, il nome della directory sarà diverso).
<br>
Spostatevi nella directory appena creata e date il comando:
<p>
<kbd>$ ./setup</kbd>
<p>
Dovrete rispondere a qualche domanda sulla
configurazione che desiderate dare al pacchetto: è possibile
accettare i defaults proposti (io faccio così di solito).
<br>
A questo punto potete far partire il make, che compilerà il
pacchetto.
<br>
Terminata la compilazione installate il tutto come utente root:
entrate come root o eseguite il comando:
<p>
<kbd>$ su -c 'make install'</kbd>
<p>
A questo punto, sempre come utente root, dovete creare l'Access
Control List (ACL).
<br>
Il modo più rapido di costruirsi un ACL è quello di
rinominare quello di esempio che è stato installato. Ovviamente
in futuro potrete studiarvi il manuale, che si trova in
<b>/usr/local/Minerva/doc</b> e decidere quali privilegi dare ai
singoli utenti.
<p>
Spostatevi nella directory <b>/usr/local/Minerva</b>. Troverete un
file <b>msql.acl.sample</b>, rinominatelo in <b>msql.acl</b>.
A questo punto, sempre da root, lanciate il demone mSQL:
<p>
<kbd>$ /usr/local/Minerva/bin/msqld &amp</kbd>
<p>
Se tutto è andato bene fino a questo momento dovreste avere il
server in memoria, quindi siete pronti a creare un database.
<br>
In una installazione dell'mSQL possono convivere più databases
e all'interno di un database mSQL possono esserci diverse tavole, ognuna
contenente i suoi dati: è un po' come una gerarchia di
directories.
<p>
Lanciamo il comando:
<p>
<kbd>$ /usr/local/Minerva/bin/msqladmin create prova</kbd>
<p>
in modo da creare un database di prova, in cui costruiremo le nostre
tavole. Il sistema dovrebbe rispondervi:
<p>
<b>Database "prova" created.</b>
<p>
Ora possiamo tornare ad operare come <i>utente vulgaris</i>: non
abbiamo più bisogno dei privilegi di root.<br>
Da questo punto in poi useremo spesso i comandi contenuti nella
directory <b>/usr/local/Minerva/bin</b>, quindi per evitare di dover
scrivere tutte le volte il path completo, ammettiamo che abbiate
aggiunto questa directory all'elenco contenuto nella variabile PATH.
<p>
Per assicurarci che tutto sia stato eseguito a dovere diamo il
comando:
<p>
<kbd>$ relshow</kbd>
<p>
Questo è lo <i>Schema Viewer</i> di cui si parla nella
documentazione. Lanciato senza parametri elenca i databases presenti
nella vostra installazione, dando come paramentro un database elenca
le tavole al suo interno, dando due parametri (database e tavola)
elenca i campi presenti nella tavola.
<p>
Il sistema dovrebbe rispondere:
<p>
<b>
<pre>
  +-----------------+
  |    Databases    |
  +-----------------+
  | prova           |
  +-----------------+
</pre></b><p>
Ora creiamo una prima tavola. Dato che abbiamo installato un database
SQL, dobbiamo rivolgerci a lui nella sua lingua, utilizzando un
interprete di comandi SQL.
<br>
L'interprete fornito, o Terminal Monitor, come viene chiamato nella
documentazione, si chiama... indovinato: <b>msql</b>.
<p>
Lanciamo il Terminal Monitor, specificandogli il database su cui
andremo ad operare:
<p>
<kbd>$ msql prova</kbd>
<p>
Il Monitor risponderà:
<p>
<b>
<pre>
Welcome to the miniSQL monitor.  Type \h for help.


mSQL > 
</pre></b>
Ora possiamo scrivere al prompt le nostre frasi SQL, terminandole con
un <b>\g</b> per mandarle in esecuzione.<br>
Come prima cosa creiamo una tavola. Proviamo a reimplementare
la rubrica telefonica di cui ci eravamo serviti in uno dei primi articoli di
questa serie.  Mentre l'altra volta usammo un file ASCII, questa volta
inseriremo i nostri dati in un vero database relazionale.<br>
La tavola che creeremo conterrà il nome e cognome della persona,
il suo indirizzo e il numero di telefono. Lo statement SQL che serve
per creare questa tavola è il seguente:
<p>
<kbd>
<pre>
mSQL > create table indirizzi
    -> ( id        int      primary key,
    ->   nome      char(40) not null,
    ->   indirizzo char(80),
    ->   tel       char(20) not null
    -> )\g
</pre></kbd>
<p>
Il Monitor risponderà così:
<p>
<b>
Query OK.
</b><p>
A questo punto abbiamo creato la struttura della tavola. Questa
conterrà un campo <b>id</b> che sarà la chiave univoca
e avrà un indice univoco associato, il <b>nome</b>, che
ovviamente dovrà essere non nullo, l'<b>indirizzo</b>, che
possiamo ammettere anche di non conoscere, e quindi non imporremo
l'attributo <i>not null</i> e il numero di telefono, <b>tel</b>, che
sarà ovviamente non nullo (altrimenti perché creare una
rubrica telefonica?-).
<p>
Verifichiamo che tutto sia andato per il verso giusto, usando il
comando <i>relshow</i> per esplorare il nostro database:
<p>
<kbd>$ relshow prova</kbd>
<p>
Il sistema dovrebbe rispondere:
<p>
<b><pre>
Database = prova

  +---------------------+
  |       Table         |
  +---------------------+
  | indirizzi           |
  +---------------------+
</pre></b><p>
Ora che abbiamo una tavola possiamo permetterci di essere curiosi e
chiedere delucidazioni sulla struttura di <b>indirizzi</b>:
<p>
<kbd>$ relshow prova indirizzi</kbd>
<p>
Il sistema dovrebbe rispondere:
<p>
<b><pre>

Database = prova

Table    = indirizzi

 +-----------------+----------+--------+----------+-----+
 |     Field       |   Type   | Length | Not Null | Key |
 +-----------------+----------+--------+----------+-----+
 | id              | int      | 4      | Y        | Y   |
 | nome            | char     | 40     | Y        | N   |
 | indirizzo       | char     | 80     | N        | N   |
 | tel             | char     | 20     | Y        | N   |
 +-----------------+----------+--------+----------+-----+
</pre></b><p>
Possiamo vedere che il campo <b>id</b>, che avevamo dichiarato
<i>primary key</i> è stato automaticamente dichiarato anche
<i>Not Null</i>.
<p>
Proviamo ora ad inserire qualche record, sempre usando il Terminal
Monitor, questa volta in modo non interattivo.<br>
Aprite il vostro editor preferito e scrivete:
<p>
<pre>
insert into indirizzi (id, nome, indirizzo, tel)
values (1, 'Andrea Bianchi', 'V. dei ciclamini, 42', '01 123456')
\g
insert into indirizzi (id, nome, indirizzo, tel)
values (2, 'Franco Neri', 'V. dei salici, 69', '02 234567')
\g
insert into indirizzi (id, nome, indirizzo, tel)
values (3, 'Mario Rossi', 'V. delle rose, 13', '03 345678')
\g
insert into indirizzi (id, nome, indirizzo, tel)
values (4, 'Filippo Verdi', 'V.le dei pini, 17', '04 456789')
\g
</pre>
<p>
Diamo a questo file il nome indirizzi.sql e al prompt scriviamo:
<p>
<kbd>$ msql prova &ltindirizzi.sql</kbd>
<p>
Il Monitor risponderà così:
<p><b><pre>

Welcome to the miniSQL monitor.  Type \h for help.


mSQL >     ->     -> 
Query OK.




mSQL >     ->     -> 
Query OK.




mSQL >     ->     -> 
Query OK.




mSQL >     ->     -> 
Query OK.




mSQL > 
Bye!

$
</pre></b><p>
Non molto eloquente, ma probabilmente avrà fatto il suo lavoro.
Seguendo la nostra tradizione, siamo malfidi ed andiamo a controllare
l'operato del Monitor, cercando di verificare che le righe siano
effettivamente state immesse nella tavola. Lanciamo il monitor
un'altra volta e diamo il comando:
<p>
<kbd>select * from indirizzi\g</kbd>
<p>
Il Monitor risponderà così:
<p><b><pre>

Query OK.

4 rows matched.

 +----------+------------------------------------------+------------------------
----------------------------------------------------------+---------------------
-+
 | id       | nome                                     | indirizzo
| tel                  |
 +----------+------------------------------------------+------------------------
----------------------------------------------------------+---------------------
-+
 | 1        | Andrea Bianchi                           | V. dei
ciclamini, 42               
|
 | 2        | Franco Neri                              | V. dei
salici, 69
| 02 234567            |
 | 3        | Mario Rossi                              | V. delle
rose, 13
| 03 345678            |
 | 4        | Filippo Verdi                            | V.le dei
pini, 17
| 04 456789            |
 +----------+------------------------------------------+------------------------
----------------------------------------------------------+---------------------
-+
</pre></b><p>
Questo è ciò che appare sul mio schermo largo 80
caratteri: il risultato non è molto comprensibile, ma possiamo
almeno verificare che siano state rilevate quattro righe e, a parte la
formattazione pietosa a causa della lunghezza del record, i dati sono
proprio quelli immessi.<br>
Se vogliamo una formattazione migliore dobbiamo munirci di una
finestra con righe di circa 150 caratteri, o scriverci un programma
che si interfacci al database e ci formatti i dati in modo da
soddisfare il nostro delicato senso estetico.
<p>
Come abbiamo detto ci si può interfacciare all'mSQL attraverso
vari linguaggi e questo è esattamente ciò che faremo nel
prossimo articolo.<br>
Nel frattempo, se non siete ferrati in SQL, avrete tempo di acquistare
un libro sull'argomento (ce ne sono di ottimi in commercio) e di
leggervelo.
<p>
A rileggerci alla prossima puntata.
<p>
Per dubbi, congratulazioni, correzioni, insulti &amp altro scrivete
a <a href="mailto:lac0658@iperbole.bologna.it">Nando Santagata</a>.
