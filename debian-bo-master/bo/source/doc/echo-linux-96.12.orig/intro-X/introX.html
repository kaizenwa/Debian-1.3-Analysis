<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>Introduction &agrave; X Window System</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (X11; I; SunOS 5.5 sun4u) [Netscape]">
</HEAD>
<BODY>

<P><IMG SRC="xlogo.gif" HSPACE=10 HEIGHT=128 WIDTH=110 ALIGN=LEFT></P>


<H1>
<P>Histoire d'X</P>
</H1>
L'Echo de Linux (<B><I>Juillet 1996</I></B>)

<ADDRESS><A HREF="http://www.inria.fr/koala/jml/jml.html">Jean-Michel L&eacute;on
(Jean-Michel.Leon@sophia.inria.fr)</A><BR CLEAR=left>
</ADDRESS>

<BR CLEAR=left>
<HR>

<H1>Introduction</H1>

<H4>Syst&egrave;mes de fen&ecirc;trage</H4>

<UL>
<P>Le principe des syst&egrave;mes de fen&ecirc;trage est de d&eacute;couper
un &eacute;cran physique en plusieurs zones logiques, appel&eacute;es <B>fen&ecirc;tres</B>,
chacune d'entre elles &eacute;tant affect&eacute;e &agrave; une application.
Diff&eacute;rentes applications peuvent donc s'ex&eacute;cuter parall&egrave;lement
sur une machine et s'afficher sur un m&ecirc;me &eacute;cran, le syst&egrave;me
de fen&ecirc;trage &eacute;tant charg&eacute; de g&eacute;rer et maintenir
la coh&eacute;rence de chaque zone logique. Le dispositif de pointage (commun&eacute;ment
la souris) sert &agrave; d&eacute;signer les diff&eacute;rentes zones,
pour par exemple, sp&eacute;cifier quelle est celle qui doit recevoir les
caract&egrave;res tap&eacute;s au clavier. </P>

<P>Les principales avanc&eacute;es dans le domaine des syst&egrave;mes
de fen&ecirc;trage furent r&eacute;alis&eacute;es au centre de recherche
Xerox PARC (<I>Palo Alto Research Center</I>), o&ugrave; furent d&eacute;velopp&eacute;s
les premiers syst&egrave;mes alliant &eacute;crans &agrave; points, dispositif
de pointage et multi fen&ecirc;trage. Xerox commercialisa tout d'abord
les stations de travail Star en 1981, puis la soci&eacute;t&eacute; Apple
commercialisa sur ce m&ecirc;me principe la machine Lisa en 1983 et enfin
le Macintosh en 1984. </P>
</UL>

<H4>Le projet Athena</H4>

<OL>
<P>Ce projet d&eacute;marra en 1983, au MIT (<I>Massachusetts Institute
of Technology</I>), son but &eacute;tait de fournir l'acc&egrave;s en libre
service aux ressources informatiques du campus &agrave; tous les &eacute;tudiants,
aussi simplement et naturellement qu'ils avaient acc&egrave;s au t&eacute;l&eacute;phone.
Pour ce faire, il fallait installer 4000 stations de travail Unix connect&eacute;es
entre elles, mais aussi imaginer et d&eacute;velopper les logiciels n&eacute;cessaires
&agrave; leur fonctionnement <A HREF="biblio.doc.html#REF91395">[TXJ 93]</A>.
</P>

<P>Cette entreprise sans pr&eacute;c&eacute;dent fut largement support&eacute;e
et financ&eacute;e par les grands constructeurs informatiques de l'&eacute;poque
tels que Dec, IBM, Motorola,... qui fournirent &agrave; la fois le mat&eacute;riel
et l'essentiel de la main d'&amp;oe;uvre, le projet &eacute;tant dirig&eacute;
par les chercheurs du MIT, dont Bob Scheifler, qui dirigeait le <I>MIT
X Consortium</I>. L'int&eacute;r&ecirc;t des constructeurs &eacute;tait
de d&eacute;velopper des technologies portables sur l'ensemble des architectures
&agrave; base d'Unix. </P>

<P>De la diversit&eacute; des sponsors, le projet Athena tira l'exp&eacute;rience
de l'h&eacute;t&eacute;rog&eacute;n&eacute;it&eacute; des environnements
informatiques; l'&eacute;poque &eacute;tait encore aux grands syst&egrave;mes
propri&eacute;taires et ces notions n'&eacute;taient encore que peu explor&eacute;es.
La volont&eacute; d'interconnections, de partage des ressources et surtout
l'&eacute;chelle &agrave; laquelle celui-ci devait &ecirc;tre op&eacute;rationnel,
sont quant &agrave; elles, &agrave; la base de l'orientation r&eacute;solument
distribu&eacute;e de toutes les retomb&eacute;es du projet <A HREF="biblio.doc.html#REF50971">[Champine
91]</A>. </P>

<P>Athena regroupa en fait un grand nombre de projets, li&eacute;s &agrave;
l'objectif initial. Parmi ceux ayant abouti &agrave; des technologies utilis&eacute;es
&agrave; l'heure actuelle, citons le syst&egrave;me d'authentification
Kerberos <A HREF="biblio.doc.html#REF61913">[Garfinkel 91]</A>, le syst&egrave;me
de gestion de fichiers Andrew (<I>Andrew File System</I>) et bien entendu,
le syst&egrave;me de fen&ecirc;trage X (<I>X Window System</I>). </P>
</OL>

<H1>&quot;The X Window System&quot; : X</H1>

<OL>
<P>Bas&eacute; initialement sur le syst&egrave;me W, d&eacute;velopp&eacute;
&agrave; Stanford par Paul Asente et Brian Reid, <B>X</B> <A HREF="biblio.doc.html#REF24114">[Scheifler
86]</A> fut tout d'abord &eacute;pur&eacute; puis &agrave; nouveau &eacute;tendu.
Entre 1983 et 1985, les versions se succ&eacute;d&egrave;rent rapidement,
pour aboutir en 1985 &agrave; la premi&egrave;re version publique : X10.
En F&eacute;vrier 1987, naquit X11R1 (X Version 11, Release 1) et depuis,
les &eacute;volutions (<I>releases</I>) se succ&egrave;dent, tout en gardant
une totale compatibilit&eacute; arri&egrave;re; alors que chaque changement
de version (X10, X11) introduisait une incompatibilit&eacute;. </P>

<P>L'ouverture de X l'a fait adopter par l'ensemble des constructeurs actuels
et toute station Unix achet&eacute;e maintenant est livr&eacute;e avec
le Syst&egrave;me X Window. A l'occasion de la derni&egrave;re &eacute;volution
(X11R6 sortie en mai 1994) l'ancien &quot;MIT X Consortium&quot; a &eacute;t&eacute;
dissout <A HREF="biblio.doc.html#REF50343">[X 93]</A>, ses dirigeants estimant
que leur travail &eacute;tait termin&eacute; et une nouvelle entit&eacute;
nomm&eacute;e &quot;X Consortium Inc.&quot; <A HREF="biblio.doc.html#REF99699">[Scheifler
94]</A> a &eacute;t&eacute; fond&eacute;e, dont la charge est de promouvoir
le syst&egrave;me. </P>

<P>La prochaine version de X (nom de code Broadway) sera X11R7 qui sortira
en D&eacute;cembre 1996. Ce sera la derniere version d&eacute;velopp&eacute;e
par &quot;X Consortium Inc.&quot; qui vivra son dernier hiver. X sera alors
transf&eacute;r&eacute; dans le giron de l'Open Group qui prendra en charge
sa maintenance.</P>

<P>D'un point de vue technique, X ne subira plus maintenant que du support
de maintenance. Il demeure cependant une forte activit&eacute; de recherche
et de d&eacute;veloppement &quot;autour de X&quot; dans le domaine des
extensions telles que le son, la vid&eacute;o, l'internationalisation,...
</P>

<P>Dans le monde Unix, X n'a plus de concurrent. Le dernier en lice, NeWS
(<I>Network Window System</I>), d&eacute;velopp&eacute; par Sun a &eacute;t&eacute;
d&eacute;finitivement abandonn&eacute;. </P>

<P>La plus grande confusion r&eacute;gnant au sujet du v&eacute;ritable
nom de X, voici un court extrait du manuel X :</P>
</OL>

<CENTER><P><I>&quot;The X Consortium requests that the following names
be used when referring to this software : <BR>
X <BR>
X Window System <BR>
X Version 11 <BR>
X Window System, Version 11 <BR>
X11 <BR>
<BR>
X Window System is a trademark of X Consortium, Inc.&quot; </I></P></CENTER>

<H1><I><FONT SIZE=+4>Le syst&egrave;me X Window</FONT></I></H1>

<UL>
<P>Le syst&egrave;me X Window est un syst&egrave;me distribu&eacute; :
Son principal concepteur, Bob Scheifler, chercheur en syst&egrave;mes d'exploitation
et applications distribu&eacute;s, d&eacute;sirait pouvoir afficher plusieurs
programmes sur un seul &eacute;cran afin de les mettre au point. De ce
d&eacute;sir d'utilisateur naquit la fonctionnalit&eacute; la plus importante
du syst&egrave;me : une application peut &ecirc;tre ex&eacute;cut&eacute;e
sur une machine et s'afficher sur une autre machine. </P>
</UL>

<H2>Architecture</H2>

<UL>
<P>L'architecture g&eacute;n&eacute;rale du syst&egrave;me est repr&eacute;sent&eacute;e
figure 1. Il s'agit d'une architecture de type Client-Serveur. </P>

<CENTER><P><IMG SRC="archi.gif" HEIGHT=239 WIDTH=498><BR>
<I>Figure 1 : </I>Architecture du syst&egrave;me X </P></CENTER>
</UL>

<UL>
<DL>
<DD>o Le <B>client X</B>, est une application qui a besoin d'afficher des
informations sur un &eacute;cran. <BR>
</DD>

<DD>o Le <B>serveur X</B> est un programme, ex&eacute;cut&eacute; sur une
machine (&quot;machine h&ocirc;te&quot;) connect&eacute;e habituellement
&agrave; un &eacute;cran, un clavier et une souris. Il offre des services
d'affichage aux clients qui en ont besoin. <BR>
</DD>
</DL>

<P>Un client X et un serveur X, sont donc deux programmes. Ils peuvent
&ecirc;tre ex&eacute;cut&eacute;s sur des machines diff&eacute;rentes et
communiquent entre eux par l'interm&eacute;diaire d'un r&eacute;seau, la
plupart du temps, un r&eacute;seau de type Ethernet <A HREF="biblio.doc.html#REF50081">[Metcalfe
76]</A> utilisant la couche de transport TCP/IP <A HREF="biblio.doc.html#REF85067">[Postel
81]</A>. Cette communication suit un certain nombre de conventions (que
l'on pourrait assimiler &agrave; une langue) appel&eacute;e protocole de
communication : le <B>protocole X</B>. Ainsi, tout programme sachant demander
des services graphiques en &quot;parlant&quot; le protocole X peut se connecter
&agrave; un serveur &quot;comprenant&quot; le m&ecirc;me protocole que
lui. Un PC utilisant MS-Windows (Microsoft Windows) ou un Macintosh utilisant
Syst&egrave;me 7, peuvent par exemple faire tourner un serveur X qui affiche
des programmes provenant de stations Unix. </P>

<H2>Client-Serveur ?</H2>

<UL>
<P>L'int&eacute;r&ecirc;t de l'architecture client-serveur est multiple.
</P>
</UL>
</UL>

<DL>
<DL>
<UL>
<UL>
<LI>H&eacute;t&eacute;rog&eacute;n&eacute;it&eacute; et transparence :
le r&eacute;seau ins&eacute;r&eacute; entre un client et un serveur assure
une totale ind&eacute;pendance des deux parties : leur seule contrainte
est le respect du protocole de communication, moyennant quoi, n'importe
quel type de machine respectant le protocole client peut s'afficher sur
n'importe quel type de machine respectant le protocole serveur. Un cas
remarquable est l'utilisation de terminaux X, qui sont des machines sp&eacute;ciales,
dont la seule fonction est d'agir en serveur X. Il s'agit l&agrave; d'une
des rares industries, produisant du mat&eacute;riel (<I>hardware</I>),
directement g&eacute;n&eacute;r&eacute;e par un produit logiciel (<I>software</I>).
</LI>

<LI>Centralisation des ressources : le serveur X est le seul programme
qui acc&egrave;de physiquement aux ressources de la machine (&eacute;cran,
clavier, souris,...). Il impl&eacute;mente la logique permettant d'arbitrer
le partage de ces ressources entre ses diff&eacute;rents clients, ce qui
r&eacute;sout les probl&egrave;mes d'acc&egrave;s concurrents &agrave;
celles-ci. </LI>
</UL>

<P>Lors des d&eacute;buts de X, cette architecture constituait un apport
notable, notamment du point de vue de la centralisation, mais ces choix
peuvent para&icirc;tre maintenant discutables. </P>

<UL>
<LI>L'utilisation du r&eacute;seau ralentit l'affichage. Il faut garder
en m&eacute;moire qu'&agrave; l'&eacute;poque de la conception de X, les
machines co&ucirc;taient encore tr&egrave;s cher. Il n'&eacute;tait pas
envisageable de donner une station graphique (ni m&ecirc;me un simple PC)
&agrave; chaque &eacute;tudiant. L'architecture centralis&eacute;e d'alors,
compos&eacute;e de serveurs et de terminaux X, semblait donc int&eacute;ressante
(les programmes tournent sur un serveur et s'affichent sur les terminaux
X). <BR>
De nos jours, la tendance est invers&eacute;e. Les architectures centralis&eacute;es
disparaissent au profit de r&eacute;seaux locaux de petites machines (mais
dont la puissance est cependant bien sup&eacute;rieure &agrave; celle des
gros ordinateurs de 1983). Le cas le plus fr&eacute;quent devient l'affichage
sur une machine unique (les clients et le serveur tournent sur la m&ecirc;me
machine) et dans ce cas, la p&eacute;nalit&eacute; apport&eacute;e par
l'insertion du r&eacute;seau est injustifiable, bien qu'incontournable.
Signalons que certains constructeurs remplacent dans ce cas la couche de
transport TCP/IP par une couche utilisant de la m&eacute;moire partag&eacute;e,
ce qui procure un gain de vitesse important, mais n'&eacute;limine pas
les p&eacute;nalisations de codage et d&eacute;codage du protocole. </LI>
</UL>
</UL>

<UL>
<UL>
<LI>Evolution des technologies : la plupart des machines et des syst&egrave;mes
d'exploitation actuels ont des m&eacute;canismes de m&eacute;moire partag&eacute;e,
ainsi que les m&eacute;canismes d'arbitrage associ&eacute;s. Il semble
maintenant possible de refaire X en tant que biblioth&egrave;que partag&eacute;e
utilisant ces m&eacute;canismes <A HREF="biblio.doc.html#REF36088">[Kilgard
95]</A>. </LI>
</UL>
</UL>
</DL>
</DL>

<H2>Le serveur X</H2>

<UL>
<P>Le serveur X offre les services graphiques de base n&eacute;cessaires
&agrave; tout syst&egrave;me de fen&ecirc;trage : </P>
</UL>

<DL>
<DL>
<UL>
<LI>gestion des fen&ecirc;tres;</LI>

<LI>primitives de dessin ;</LI>

<LI>arbitrage des ressources.</LI>
</UL>

<P>C'est essentiellement dans l'arbitrage que se situent les difficult&eacute;s
de conception : un serveur X est susceptible d'avoir plusieurs clients.
Ces clients tournent concurremment et utilisent les m&ecirc;mes ressources.
Le serveur X doit donc prendre en charge la gestion, le partage et la distribution
de celles-ci. </P>

<P>De part la volont&eacute; de son concepteur (Bob Scheifler), le serveur
X n'offre que des services de tr&egrave;s bas niveau. D'autres syst&egrave;mes
tels que MS-Windows permettent de cr&eacute;er d'un seul appel un bouton
ou un menu. Le serveur X, lui, ne sait qu'ouvrir et fermer des fen&ecirc;tres,
sans d&eacute;coration, nues. C'est l'application qui devra, dans le cas
du bouton, dessiner la bordure et le label. </P>
</DL>
</DL>

<H3>Requ&ecirc;tes et &eacute;v&eacute;nements</H3>

<UL>
<P>Le protocole de communication entre un client X et un serveur X n'est
pas sym&eacute;trique. Un serveur est (comme son nom l'indique) au service
du (ou des) client(s). Le client quant &agrave; lui veut tirer parti des
services propos&eacute;s par le serveur; il envoie pour ce faire des requ&ecirc;tes
au serveur et re&ccedil;oit &eacute;ventuellement des r&eacute;ponses ou
des erreurs (figure 2). Le serveur peut aussi envoyer des &eacute;v&eacute;nements
au client, pour lui signaler des modifications ou des actions de l'utilisateur.
</P>
</UL>

<CENTER><P><IMG SRC="requetes.gif" HEIGHT=77 WIDTH=453><BR>
<I>Figure 3 : </I>Requ&ecirc;tes et Ev&eacute;nements </P></CENTER>

<UL>
<P>Lorsqu'il re&ccedil;oit une requ&ecirc;te, le serveur X l'ex&eacute;cute.
Si par exemple on lui demande de dessiner une ligne dans une fen&ecirc;tre
A, il va faire les v&eacute;rifications d'usage sur l'existence de la fen&ecirc;tre
A et tracer la ligne d&eacute;sir&eacute;e &agrave; l'int&eacute;rieur.
</P>

<P>Pour chaque requ&ecirc;te re&ccedil;ue, le serveur va soit : </P>

<DL>
<UL>
<LI>l'ex&eacute;cuter si toutes les v&eacute;rifications se sont r&eacute;v&eacute;l&eacute;es
correctes ; </LI>

<LI>renvoyer une erreur pour signaler que la requ&ecirc;te ne peut &ecirc;tre
ex&eacute;cut&eacute;e. </LI>
</UL>
</DL>

<P>Dans tous les cas, il ne garde aucune m&eacute;moire des requ&ecirc;tes
qu'il re&ccedil;oit, pas plus que des trac&eacute;s qu'il a effectu&eacute;s.
Ceci implique que lorsque le contenu d'une fen&ecirc;tre est effac&eacute;,
que ce soit par programme ou par une manipulation de fen&ecirc;tres, le
serveur X ne sait pas restaurer son contenu; il appartient donc au programmeur
de le faire.</P>

<P>Parmi les requ&ecirc;tes qu'un client peut exprimer &agrave; un serveur
X, nous trouvons principalement : </P>

<DL>
<UL>
<LI>requ&ecirc;tes de manipulation de fen&ecirc;tres : cr&eacute;ation,
destruction, d&eacute;placement, retaillage,... ;</LI>

<LI>requ&ecirc;tes de dessin : lignes, rectangles, arcs de cercles, images,...
;</LI>

<LI>requ&ecirc;tes d'administration : utilis&eacute;es pour la gestion
des ressources du serveur. </LI>
</UL>
</DL>
</UL>

<DD>Les &eacute;v&eacute;nements quant &agrave; eux peuvent &ecirc;tre
class&eacute;s en 2 cat&eacute;gories : </DD>

<UL>
<DL>
<UL>
<LI>&eacute;v&eacute;nements de manipulation de fen&ecirc;tres : le serveur
X, en r&eacute;ponse aux requ&ecirc;tes ou &agrave; des actions externes
(d&eacute;placement d'une fen&ecirc;tre par l'utilisateur, par exemple),
envoie des &eacute;v&eacute;nements de notification sur la vie des fen&ecirc;tres
(cr&eacute;ation, destruction, etc...) ;</LI>

<LI>&eacute;v&eacute;nements utilisateur : lorsque l'utilisateur d&eacute;place
la souris ou appuie sur une touche, le serveur X envoie un &eacute;v&eacute;nement
pour le signaler. </LI>
</UL>
</DL>

<P>Les erreurs sont trait&eacute;es par le syst&egrave;me et ne sont pas
directement destin&eacute;es au programmeur. </P>

<P>Bien &eacute;videmment, un client X n'&eacute;crit pas directement les
requ&ecirc;tes X sur le r&eacute;seau. Une interface de programmation et
sa biblioth&egrave;que associ&eacute;e sont fournies, permettant d'envoyer
des requ&ecirc;tes &agrave; un serveur X par un simple appel de fonction.
C'est la <B>biblioth&egrave;que X</B> ou <B>Xlib</B> <A HREF="biblio.doc.html#REF86719">[Nye
88]</A>. De plus, d'autres librairies de programmation appell&eacute;es
boites a outils ou <I>toolkits </I>fournissent des abstractions de plus
haut niveau permettant d'acc&eacute;lerer les d&eacute;veloppements.</P>
</UL>

</BODY>
</HTML>
