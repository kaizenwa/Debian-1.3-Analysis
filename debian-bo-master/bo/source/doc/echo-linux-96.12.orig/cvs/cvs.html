<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN//2.0">
<HTML>
<HEAD>
<!-- Document generated by Thot -->
<TITLE>CVS, le gestionnaire de sources</TITLE>
<LINK HREF="cvs.toc.html" REL="PARENT">
</HEAD>
<BODY>

<H1>CVS, le gestionnaire de sources</H1>
<P>
Article pour l'Echo de Linux (<em><b>Septembre 1996</b></em>) 
<ADDRESS><A HREF="mailto:reymond@ct03.frlv.bull.fr">Jean-Max REYMOND</A></ADDRESS>
<DL>
<DT><B>R&eacute;sum&eacute; :</B>
<DD>
<P>CVS, propos&eacute; par la FSF foundation est un outil permettant la
gestion de sources ainsi que de versions. Il permet entre autres de
g&eacute;rer  la modification simultan&eacute;e de m&ecirc;mes fichiers par
plusieurs utilisateurs.</P>
</DL>

<HR>

<H2><A NAME="secta1">1</A> Introduction</H2>

<P>CVS, (Concurrent Version System) est un outil  permettant de g&eacute;rer
l'&eacute;volution dans le temps d'un ensemble de fichiers (au sens UNIX de
suite d'octets, mais plus fr&eacute;quemment des sources). CVS, s'appuyant sur
RCS permet donc au minimum d'extraire des sources, de les modifier, de
soumettre ses modifications, de garder l'historique des modifications et de
restaurer n'importe quelle version pr&eacute;c&eacute;dente. Mais l'atout
majeur de CVS est de permettre &agrave; plusieurs d&eacute;veloppeurs de
travailler sur le m&ecirc;me groupe de fichiers: chacun travaille de
mani&egrave;re ind&eacute;pendante dans son environnement personnel et CVS
g&egrave;re l'ensemble.</P>

<H2><A NAME="secta2">2</A> Principes g&eacute;n&eacute;raux de CVS</H2>

<P>Voici une explication sommaire des grands principes qui gouvernent CVS. Que
le lecteur veuille bien m'excuser pour les anglicismes, mais quelquefois les
traductions fran&ccedil;aises sont laborieuses.</P>

<H3><A NAME="sectb21">2.1</A> La repository</H3>

<P>CVS maintient dans un r&eacute;pertoire point&eacute; par la variable
d'environnement CVSROOT, une arborescence correspondant &agrave;
l'arborescence de d&eacute;veloppement. Cette arborescence abrite des fichiers
RCS, chacun  contenant le source d'origine ainsi que tous les
diff&eacute;rentiels &agrave; appliquer pour passer &agrave; une version plus
r&eacute;cente. De m&ecirc;me, on retrouve les commentaires &agrave; saisir
lors d'une demande de modification. Cette repository n'est pas
forc&eacute;ment sur la machine de d&eacute;veloppement et peut se trouver sur
un autre serveur afin de totalement isoler les sources des developpeurs.</P>

<H3><A NAME="sectb22">2.2</A> Le mode client-serveur</H3>

<P>Pour les cas o&ugrave; plusieurs machines doivent partager les m&ecirc;mes
sources ou dans le but d'isoler les sources des d&eacute;veloppeurs, un mode
client serveur permet de s'affranchir de NFS et de ne passer sur le
r&eacute;seau que les informations utiles sous forme de patch. Ce mode
client/serveur est de 4 &agrave; 10 fois  plus rapide que par NFS et permet
donc la gestion des sources entre deux sites tr&egrave;s
&eacute;loign&eacute;s via des modems. Les acc&egrave;s se font par des
commandes "remote-shells" qui doivent satisfaire aux conditions
impos&eacute;es par ce protocole (.rhost, host.equiv, ...). </P>

<H3><A NAME="sectb23">2.3</A> La gestion des d&eacute;veloppements en
parall&egrave;le</H3>

<P>Classiquement, d&egrave;s que plusieurs developpeurs modifient les
m&ecirc;mes fichiers, les probl&egrave;mes commencent. Une m&eacute;thode
classique est de verrouiller le fichier afin d'emp&ecirc;cher les autres de
faire des modifications. Malheureusement, cette m&eacute;thode, si elle
fonctionne, pr&eacute;sente de nombreux inconv&eacute;nients:         </P>

<P>- Le bloquage int&eacute;gral du fichier m&ecirc;me pour modifier une
ligne,</P>

<P>- le risque que l'emprunteur verrouille " advitam eternam " le fichier par
exemple  par une destruction du r&eacute;pertoire contenant le fichier.</P>

<P>Avec CVS, par contre, l'utilisateur poss&egrave;de une copie du fichier, le
modifie comme il le veut et c'est au moment de soumettre ses
modifications("commit") que CVS va faire une fusion (un "merge") de la version
courante avec la version pr&eacute;c&eacute;demment commit&eacute;e. S'il y a
un conflit d&ucirc;  &agrave;  une modification  simultan&eacute;e et non
identique de la m&ecirc;me ligne, alors CVS le signale en entourant les lignes
litigieuses.</P>

<P>        Cette approche originale a entra&icirc;n&eacute;e des d&eacute;bats
passionn&eacute;s mais force est de reconna&icirc;tre que tr&egrave;s
g&eacute;n&eacute;ralement, cela marche finement. A l'usage, il faut
simplement faire tr&egrave;s attention lorsque CVS refuse la livraison du
fichier et demande une fusion pr&eacute;alable: il faut bien regarder ce que
la fusion entra&icirc;ne.</P>

<H3><A NAME="sectb24">2.4</A> Les tags</H3>

<P>De fa&ccedil;on interne, CVS maintient des num&eacute;ros de version pour
chaque fichier. Ainsi, par exemple le fichier parserv.c pourra &ecirc;tre
num&eacute;rot&eacute; 5.3, alors que le fichier scan.c sera &agrave; l'indice
1.12. CVS permet d'associer un nom symbolique &agrave; un ensemble de fichiers
ayant des indices diff&eacute;rents. Ainsi, le nom symbolique "release_V1"
pourra &ecirc;tre appliqu&eacute; &agrave; parserv.c  [1.3] et scan.c [1.12].
Plus tard, on pourra au besoin extraire la version  release_V1 dans son
int&eacute;gralit&eacute;, m&ecirc;me si la version est beaucoup plus
avanc&eacute;e.</P>

<H3><A NAME="sectb25">2.5</A> Les branches de d&eacute;veloppement</H3>

<P>Elles correspondent, en particulier,  &agrave; un soucis tr&egrave;s 
fr&eacute;quent en informatique: la maintenance. Supposons que quelque mois
apr&egrave;s la sortie d'une version tagg&eacute;e release_V1, une correction
s'impose. H&eacute;las, depuis la release V1, les sources ont
&eacute;t&eacute; profond&eacute;ment modifi&eacute;s et ne sont pas livrables
dans l'&eacute;tat. Dans ce cas l&agrave;, on peut &agrave; partir de la
version tagg&eacute;e release_V1 faire une branche de d&eacute;veloppement qui
va permettre en  // de travailler sur la correction, de la tester et de la
livrer. Plus tard, le patch reviendra sur la branche principale, CVS assurant
la fusion de la version corrig&eacute;e et de la version en
d&eacute;veloppement.</P>

<H3><A NAME="sectb26">2.6</A> Un outil graphique tkcvs</H3>

<P>CVS est caract&eacute;ris&eacute; par un jeu de commandes 
commen&ccedil;ant toutes par cvs et avec une multitude d'options. Un
remarquable outil graphique tkcvs, &eacute;crit en Tcl/Tk,  permet avec des
icones et des &eacute;crans de bien visualiser l'arbre de d&eacute;veloppement
(avec ses branches) ainsi que les diff&eacute;rences entre deux versions d'un
m&ecirc;me fichier.</P>

<H2><A NAME="secta3">3</A> Quelques commandes CVS</H2>

<P>Nous d&eacute;crivons ici quelques commandes CVS parmi les plus
usit&eacute;es</P>

<H3><A NAME="sectb31">3.1</A> cvs update</H3>

<P>Cette commande permet de mettre &agrave; jour son arborescence CVS par
rapport &agrave; la repository. Si des modifications ont &eacute;t&eacute;
commit&eacute;es depuis le pr&eacute;c&eacute;dent cvs update, elles seront
automatiquement report&eacute;es chez soi. Si un conflit arrive, il faut le
r&eacute;soudre chez soi &agrave; l'aide d'un &eacute;diteur.</P>

<H3><A NAME="sectb32">3.2</A> cvs commit</H3>

<P>Cette commande permet de soumettre une modification. Lors d'un cvs commit,
CVS v&eacute;rifie d'abord qu'il n'y a pas de conflit avec la version
stock&eacute;e dans la repository, puis  il passe le  fichier &agrave; un
shell-script user qui pourra v&eacute;rifier si des r&egrave;gles de
programmation sont bien respect&eacute;es. Puis, CVS appellera
l'&eacute;diteur favori pour faire saisir un texte explicitant la
modification. Enfin, apr&egrave;s incr&eacute;ment du num&eacute;ro interne 
de version, CVS le stocke dans  la repository. A partir de ce moment, toute
personne faisant un cvs update aura son fichier mis &agrave; jour.</P>

<H3><A NAME="sectb33">3.3</A> cvs add</H3>

<P>Cette commande est n&eacute;cessaire pour ajouter un fichier dans la
repository. En effet, par d&eacute;faut un fichier n'est pas connu de CVS.
Ceci permet d'avoir dans l'arborescence des fichiers hors CVS, par exemple des
fichiers g&eacute;n&eacute;r&eacute;s automatiquement (un .c issu de
yacc).</P>

<H3><A NAME="sectb34">3.4</A> cvs history</H3>

<P>Cette commande permet de trouver l'historique des modifications pour tout
un module (ensemble de fichiers). Par exemple, on peut demander l'ensemble des
fichiers modifi&eacute;s depuis 4 jours:</P>
<TT>
<P>osirisv3 cvs history -a -xM '-D  4 days ago' </P>
</TT><TT>
<P>M 08/20 10:00 +0000 gfv22 1.5.2.1 listener.c  Coriolis/Src/Noyau/Unix/Main 
 == ~/Coriolis/Src/Noyau/Unix/Main </P>
</TT><TT>
<P>M 08/20 10:00 +0000 gfv22 1.2.2.2 testcorio.c Coriolis/Src/Noyau/Unix/Main 
 == ~/Coriolis/Src/Noyau/Unix/Main </P>
</TT><TT>
<P>M 08/20 14:45 +0000 gfv22 1.3.2.1 SYSTFONC.c 
Coriolis/Src/Noyau/Unix/Commun == ~/Coriolis/Src/Noyau</P>
</TT>
<H3><A NAME="sectb35">3.5</A> cvs log</H3>

<P>Cette commande permet de voir l'ensemble des modifications apport&eacute;es
&agrave; un ou plusieurs fichiers. Ainsi cvs log parser.c donnera pour le
fichier parser.c chaque modification apport&eacute;e ainsi que le commentaire
associ&eacute;:</P>
<TT>
<P>osirisv3 cvs log parser.c </P>
</TT><TT>
<P>RCS file: /coriolis/gcode/Gcode/Coriolis/Tools/Doc/Essai/parser.c,v </P>
</TT><TT>
<P>Working file: parser.c</P>
</TT><TT>
<P>head: 1.2 branch:</P>
</TT><TT>
<P>locks: strict</P>
</TT><TT>
<P>access list:</P>
</TT><TT>
<P>symbolic names:</P>
</TT><TT>
<P>keyword substitution: kv </P>
</TT><TT>
<P>total revisions: 2;     selected revisions: 2</P>
</TT><TT>
<P>description:</P>
</TT><TT>
<P> ----------------------------</P>
</TT><TT>
<P> revision 1.2 date: 1996/08/23 06:38:12;  author: gfv3;  state: Exp; 
lines: +1 -1 </P>
</TT><TT>
<P>adaptation aux nouvelles API's</P>
</TT><TT>
<P> ---------------------------- </P>
</TT><TT>
<P>revision 1.1 date: 1996/08/23 06:37:47;  author: gfv3;  state: Exp; </P>
</TT><TT>
<P>Cr&eacute;ation
==========================================================</P>
</TT>
<H2><A NAME="secta4">4</A> LINUX en serveur de sources</H2>

<P>Dans notre projet, nous avons eu &agrave; mettre en place CVS afin
d'assurer la coh&eacute;rence des sources sur lesquels travaillaient les
d&eacute;veloppeurs. En effet, notre projet reposant sur un concept
client/serveur, les personnes d&eacute;veloppants la partie cliente en Visual
Basic 3.0 ont rapidement eu des probl&egrave;mes de gestion des sources
(modifications r&eacute;guli&egrave;rement &eacute;gar&eacute;es). La solution
a &eacute;t&eacute; de leur faire voir le disque d'un serveur Linux
gr&acirc;ce &agrave; Samba et de  mettre leurs arborescences de
d&eacute;veloppement sur ce disque. Alors,  avec quelques commandes CVS, ils
pouvaient voir l'historique des fichiers, les modifications et soumettre leurs
propres modifications (ceci n&eacute;cessite la sauvegarde des sources VB au
format texte). De m&ecirc;me, pour les sources serveurs, nous disposions de
deux petits serveurs AIX, g&eacute;ographiquement tr&egrave;s
&eacute;loign&eacute;s. Les disques co&ucirc;tant fort cher pour ce type de
plate-forme, tous la repository a &eacute;t&eacute; stock&eacute;e sur le
serveur Linux, les deux serveurs AIX acc&eacute;dants le serveur Linux via le
mode client/serveur de CVS, tr&egrave;s efficace m&ecirc;me sur une ligne
TRANSFIX &agrave; 64 kbits/s. </P>

<H2><A NAME="secta5">5</A> Conclusion</H2>

<P>Linux et CVS donnent pleine satisfaction pour la gestion de ce gros projet
comportant 439 &eacute;crans et 4000 fichiers sources serveurs. Depuis la mise
en place du duo, nous n'avons pas eu &agrave; d&eacute;plorer de pertes de
sources ou de r&eacute;gression. Avec des outils du type tkcvs, on obtient un
remarquable outil de gestion de source et de version qui n'a rien &agrave;
envier &agrave; des solutions dites professionnelles et qui sont
propos&eacute;es &agrave; des co&ucirc;ts prohibitifs.</P>

</BODY>
</HTML>
