<!--        Article sur les modules chargeables    -->
<!--       (c) Eric Dumas 1996 dumas@freenix.fr -->

<html>
  <head>
    <title>Les modules chargeables</title>
  </head>

<body>
<h1> <IMG ALIGN=CENTER SRC="modules-image.gif" alt="Saturne..."> 
Les modules chargeables</h1>
<p>
Article pour l'Echo de Linux (<em><b>Juillet 1996</b></em>) 
<address><a href="mailto:dumas@freenix.fr">Eric Dumas 
(dumas@freenix.fr)</a></address> 
<HR>
<h1><em>R&eacute;sum&eacute;</em></h1>

	Le noyau d'un syst&egrave;me Unix peut &ecirc;tre repr&eacute;sent&eacute; sous
la forme d'un objet monolythique. Toutefois, un tel objet poss&egrave;de
l'inconv&eacute;nient d'&ecirc;tre gros, statique. A chaque fois que l'on d&eacute;sire
rajouter un nouveau p&eacute;riph&eacute;rique, il est n&eacute;cessaire de recompiler le 
noyau. De plus, si l'on n'utilise certains gestionnaires particuliers
que rarement, on est oblig&eacute; de l'avoir dans le noyau, ce qui a tendance
&agrave; consommer de la m&eacute;moire.
<p>
	Les modules chargeables, permettent de joindre l'utile
&agrave; l'agr&eacute;able en ayant un noyau modulaire qui charge &agrave; la demande
ce dont il a besoin. De cette mani&egrave;re, le gain de ressources est
non n&eacute;gligeable.

<hr>

<h1> Sommaire</h1>
<ul>
        <li>1 - <a href="#1">Pr&eacute;sentation</a></li>
        <li>2 - <a href="#2">Compilation</a></li>
        <li>3 - <a href="#3">Premi&egrave;re m&eacute;thode : &agrave; la main</a></li>
        <li>4 - <a href="#4">Automatisation : <b>kerneld</b></a></li>
        <ul>
                <li> <a href="#41">Introduction</a></li>
                <li> <a href="#42">Conseils pour la compilation du noyau</a></li>
                <li> <a href="#43">Mise en place</a></li>
                <li> <a href="#44">Le fichier <tt>/etc/conf.modules</tt></a></li>
        </ul>   
        <li> <a href="#5">R&eacute;f&eacute;rences</a></li>
</ul>

<hr>
<a name=1>
<h1>1- Pr&eacute;sentation</h1><p>
	
	On peut consid&eacute;rer qu'&agrave; un instant donn&eacute;, on n'utilise pas
tous les gestionnaires de p&eacute;riph&eacute;riques inclus dans le noyau. 
Donc, la place m&eacute;moire utilis&eacute;e est inutilement g&acirc;ch&eacute;e. Le principe
des modules chargeables est de permettre au noyau de charger une
partie de son code lorsque l'un des utilisateur en a besoin.

<p>
	On peut sh&eacute;matiser le chargement/d&eacute;chargement d'un
module comme cela :
<img align=center src="modules.gif" 
alt="Sch&eacute;mas du chargement/d&eacute;chargement des modules">
<p>
Dans cette image, le noyau est compos&eacute; d'une partie <sq>monolythique</sq>
(&agrave; gauche) et d'une partie dynamique qui est compos&eacute;e de modules charg&eacute;s
ou d&eacute;charg&eacute;s. Dans cet exemple, j'ai mis en module Ms-Dos, le son et 
NFS.
<p>
	En fait, deux syst&egrave;mes cohabitent sous Linux : un chargement
manuel, et un syst&egrave;me de chargement automatique r&eacute;cement introduit 
dans Linux. Nous en reparlerons plus tard.
<p>
Dans cet article, j'utiliserai comme exemple le module NFS, mais
tout ce qui va &ecirc;tre racont&eacute; marche avec un autre module (audio, etc).
Le noyau linux utilis&eacute; est un 2.0.x et la version des modules est
la 2.0.0. Vous pouvez r&eacute;cup&eacute;rer les modules sur la page officielle
<a href="http://www.pi.se/blox/modules/index.html">
http://www.pi.se/blox/modules/index.html</a>
ou bien dans l'arborescence des sources (v2.0).

<a name=2>
<h1>2- Compilation</h1>

	La premi&egrave;re question que l'on peut se poser, c'est :
« Pourquoi deux techniques ? » <p>

La premi&egrave;re technique est manuelle : il faut charger ou d&eacute;charger les 
modules &agrave; la main. La deuxi&egrave;me est automatique, gr&acirc;ce &agrave; l'utilisation 
d'un d&eacute;mon sp&eacute;cialis&eacute; qui est l'esclave du noyau et qui charge et 
d&eacute;charge les modules pour lui.
En fait, la version 1.2 de Linux n'offrait
que la possibilit&eacute; d'un chargement manuel qui est limit&eacute; au super-utilisateur 
de la machine et qui est assez lourd &agrave; manipuler. Au fil du d&eacute;veloppement
de la version 2.0, un nouveau syst&egrave;me impl&eacute;ment&eacute; par Bjorn Ekwall permit
d'&eacute;ffectuer un chargement dynamique et automatique des modules. 
<p>
Lors de la compilation, il est n&eacute;cessaire de sp&eacute;cifier certaines options :
<HR>
<pre>
gandalf# make config
<...>
*
* Loadable module support
*
Enable loadable module support (CONFIG_MODULES) [Y/n/?] 
Set version information on all symbols for modules (CONFIG_MODVERSIONS) [N/y/?] 
Kernel daemon support (e.g. autoload of modules) (CONFIG_KERNELD) [Y/n/?] 
</pre>
<HR>
     
Voici le d&eacute;tail de ces trois options :
<ul>
	<li> <tt>CONFIG_MODULES</tt> : active le 
m&eacute;canisme de modules chargeables. Sans cette options, ils ne 
fonctionneront pas sur votre syst&egrave;me. </li>
	<li> <tt>CONFIG_MODVERSIONS</tt> : si vous laissez cette 
option &agrave; <b>N</b> (par d&eacute;faut), vous devrez recompiler les modules &agrave; 
chaque mise &agrave; jour du noyau de votre machine. Cela signifie que des 
modules compil&eacute;s pour un noyau <b>2.0.n</b> ne fonctionneront pas avec 
un module compil&eacute; pour <b>2.0.n+1</b>. Si vous activez cette option,
les modules pourront &ecirc;tre lanc&eacute;s... toutefois, ce n'est pas vraiment 
conseill&eacute;.</li> 
	<li><tt>CONFIG_KERNELD</tt> : cette option active le chargement 
automatique des modules. Vous devez &eacute;galement activer les IPC Syst&egrave;me V 
car le noyau et le d&eacute;mon communiquement via des files de messages.</li>
</ul>

	Une fois fois configur&eacute;, il vous suffit de lancer la compilation ainsi
que l'installation :
<HR>
<pre>
gandalf# make dep ; make clean
gandalf# make zImage
gandalf# make modules ; make modules_install
</pre>
<HR>

	Une fois ces op&eacute;rations effectu&eacute;es, les modules se trouvent alors dans
le r&eacute;pertoire <tt>/lib/modules/x.y.z</tt> o&ugrave; <tt>x.y.z</tt> correspond 
au num&eacute;ro de version du noyau.

      Il ne nous reste plus &agrave; voir que le chargement...

<a name=3>
<h1>3- Premi&egrave;re m&eacute;thode : &agrave; la main</h1><p>

       Le chargement manuel est bas&eacute; sur trois commandes~:
	<ul>
	<li>insmod : ins&egrave;re un module dans le noyau;</li>
	<li>rmmod : d&eacute;charge un module, s'il plus aucun processus
ne l'utilise;</li>
	<li>lsmod : affiche la liste des modules charg&eacute;s </li>
</ul>

	Leur utilisation oblige d'&ecirc;tre en super-utilisateur. voici un
exemple d'utilisation :
<hr>
<pre>
gandalf# insmod nfs.o
gandalf# lsmod
Module:        #pages:  Used by:
nfs               12            4
gandalf# mount -t nfs /truc /mnt 
gandalf# lsmod
Module:        #pages:  Used by:
nfs               12            5
gandalf# cd /mnt
...
gandalf# cd /
gandalf# umount /mnt
Module:        #pages:  Used by:
nfs               12            4
gandalf# ps axu | grep nfs
root      5535  0.0  0.0     0     0  q2 SW  17:15   0:00 (nfsiod)
root      5536  0.0  0.0     0     0  q2 SW  17:15   0:00 (nfsiod)
root      5537  0.0  0.0     0     0  q2 SW  17:15   0:00 (nfsiod)
root      5538  0.0  0.0     0     0  q2 SW  17:15   0:00 (nfsiod)
root      5557  0.0  0.4   864   300  q2 S   17:16   0:00 grep nfs 
Gandalf(gandalf)--> kill -9 5535 5536 5537 5538
gandalf# lsmod
gandalf# rmmod nfs.o
</pre>
<hr>
      Il est n&eacute;cessaire de "killer" les 4 d&eacute;mons nfsiod car ils sont
lanc&eacute;s d&egrave;s que NFS est activ&eacute;. Comme vous pouvez le voir, ces op&eacute;rations
deviennent relativement p&eacute;nibles. C'est pour cette raison que le syst&egrave;me
de chargement automatique a &eacute;t&eacute; cr&eacute;e.

<a name=4>
<h1>4- Automatisation : <b>kerneld</b></h1><p>


<a name=41>
<h2>4.1 - Introduction</h2><p>

	Le syst&egrave;me de chargement automatique de modules permet
de r&eacute;duire au minimum la taille de son noyau. Le principe de fonctionnement
est particuli&egrave;rement simple : un d&eacute;mon en mode utilisateur est &agrave; 
l'&eacute;coute des ordres du noyau (via une file de message de type IPC
Syst&egrave;me V). Lorsque un processus essaye d'acc&eacute;der &agrave; une ressource
syst&egrave;me (via un appel syst&egrave;me open, etc...), le noyau envoie l'ordre
de chargement du module &agrave; <b>kerneld</b>. Une fois le message re&ccedil;u, 
<b>kerneld</b> ex&eacute;cute un modprobe pour charger les modules n&eacute;cesaires :
<img align=center src="kerneld.gif" 
alt="Sch&eacute;mas du chargement/d&eacute;chargement des modules avec kerneld">

<a name=42>
<h2>4.2 - Conseils pour la compilation du noyau</h2><p>

Par contre, lors de la compilation du noyau, il est n&eacute;cessaire d'y
mettre au moins le support pour permettre l'amo&ccedil;age de la machine
et le montage de la racine de votre syst&egrave;me de fichier 
(par exemple, support IDE + ext2fs). Vous pouvez y mettre tout 
le reste en module (carte son, syst&egrave;mes de fichiers, carte SCSI, etc).

<a name=43>
<h2>4.3 - Mise en place</h2><p>

Pour r&eacute;aliser la mise en place du syst&egrave;me de chargement de modules, il est
n&eacute;cessaire d'effectuer certaines modifications au niveau de votre 
configuration. En effet, il est n&eacute;cessaire lors de l'amor&ccedil;age de la
machine de lancer le d&eacute;mon <b>kerneld</b> et de r&eacute;aliser une
esp&egrave;ce de liste des d&eacute;pendances des modules : certains modules 
ne peuvent &ecirc;tre lanc&eacute;s avant que d'autres ne le soient.
Dans un premier temps, il faut cr&eacute;er le fichier 
<tt>/etc/rc.d/rc.modules</tt> dans lequel, vous y mettez :
<HR>
<pre>
# Modules

#
# Create a generic link to the modules for the current kernel
#
# You can have generic symbolic links in /lib/modules/boot
# if you create links to: "../current/subsystem/module.o"
#
ln -sf /lib/modules/`uname -r` /lib/modules/current
if [ \! -r /lib/modules/current/modules.dep ]
then
        echo "Creating module dependencies"
        /sbin/depmod -a
fi
#
# Load the boot modules
#
if [ -x /sbin/kerneld ]
then
        if find /lib/modules/boot -type f -o type l > /dev/null 2>&1
        then
                echo "Loading boot-time modules"
                /sbin/modprobe -a -t boot \*
        fi
else
        echo "Loading modules"
        /sbin/modprobe -a \*
fi
#
# If you have any extra kerneld-type daemons, start them here
#
if [ -x /sbin/kdsound ]
then
        echo "Starting sound daemon"
        /sbin/kdsound &
fi
</pre>
<HR>
      Cela permet de g&eacute;n&eacute;rer la d&eacute;pendance de vos modules &agrave; chaque
fois que vous amorcez votre machine. Ensuite, dans le fichier 
<tt>/etc/rd.d/rc.S</tt> (peut d&eacute;pendre de votre distribution...), 
il convient de rajouter :
<HR>
<pre>
# Start update.
/sbin/update &

# *** A RAJOUTER ***
# Now, start kerneld as soon as possible, so that any disk
# driver modules can be loaded "automagically"
if [ -x /sbin/kerneld ]
then
        echo "kerneld running"
        /sbin/kerneld
fi

...

# Looks like we have to create this.
cat /dev/null > /var/adm/utmp

# Do a lot of things...
if [ -f /etc/rc.d/rc.modules ]; then
        /etc/rc.d/rc.modules
fi              
</pre>
<hr>

      Une fois ces modifications effectu&eacute;es et la machine r&eacute;amorc&eacute;e, tout
doit &ecirc;tre en place. Si <b>kerneld</b> permet de charger automatiquement 
les modules, il permet &eacute;galement de les d&eacute;charger au bout d'un certain
temps de nom utilisation. Par d&eacute;faut, si aucun processus n'acc&egrave;de 
au module pendant plus de 30 secondes, il est automatiquement
d&eacute;charg&eacute;. Il est possible de modifier cette valeur en rajoutant 
le param&egrave;tre <tt>delay=Nb_Secondes</tt> &agrave; <b>kerneld</b> o&ugrave; 
<tt>Nb_Secondes</tt> est le d&eacute;lai en nombre de secondes.

<a name=44>
<h2>4.4 - Le fichier <tt>/etc/conf.modules</tt></h2><p>

	Il peut arriver qu'il soit n&eacute;cessaire de configurer un dernier
fichier : le fichier <tt>/etc/conf.modules</tt>. Ce fichier 
contient les chemins o&ugrave; se trouvent les modules devant &ecirc;tre charg&eacute;s
et ensuite des alias pour les modules. Si vous n'avez pas 
ce fichier, vous pouvez le cr&eacute;er avec :
<hr>
<pre>
gandalf# /sbin/modprobe -c | grep -v '^path' >/etc/conf.modules
</pre>
</hr>

      Il peut arriver que lors du premier amor&ccedil;age vous ayez ce 
message : 
<hr>
<pre>
Cannot locate module for net-pf-3
Cannot locate module for net-pf-4
Cannot locate module for net-pf-5
</pre>
<hr>

      Pas de panique ! Ce message n'est pas m&eacute;chant et pour
ne plus l'avoir, rajouter dans le fichier <tt>/etc/conf.modules</tt>
<ht>
<pre>
alias net-pf-3 off 
alias net-pf-4 off 
alias net-pf-5 off 
</pre>
</hr>

	Il peut arriver que certains p&eacute;riph&eacute;rif&eacute;riques aient
besoin de certains param&egrave;tres particulier. Consultez le 
document <em>Kernel HowTo</em>.

<a name=5>
<h1>5- R&eacute;f&eacute;rences</h1><p>

Vous pouvez consulter ces r&eacute;f&eacute;rences pour plus d'information :
<ul>
	<li><a href="http://www.pi.se/blox/modules/index.html">
http://www.pi.se/blox/modules/index.html</a> : 
Site officiel pour les archives des modules</li>
	<li>tout miroir des sources Linux</li>
	<li> <a href="http://eolicom.olicom.dk/~storner/kerneld-mini-HOWTO.html">
	Kerneld Mini Howto</a></li>
</ul>

</body>