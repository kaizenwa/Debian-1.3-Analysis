<HTML>

<HEAD>
<TITLE>La gestion des ports s&eacute;ries sous Linux</TITLE>
</HEAD>

<BODY>

<H1>
<P>La gestion des ports s&eacute;ries sous Linux
</H1>

<P>
Article pour l'&Eacute;cho de Linux (<em><b>Juillet 1996</b></em>) 
<address><a href="mailto:esellin@pratique.fr">Eric Sellin</a>
(esellin@pratique.fr)</address> 

<P>
<HR>
<H1>Sommaire</H1>
<UL>
<LI>1 - <A HREF="#1">Introduction</A>
<LI>2 - <A HREF="#2">Bref rappel sur les liaisons s&eacute;ries</A>
<LI>3 - <A HREF="#3">Ouverture de la liaison</A>
<LI>4 - <A HREF="#4">Param&eacute;trage de la liaison</A>
	<UL>
	<LI>4.1 - <A HREF="#41">Les champs de la structure termios</A>
		<UL>
		<LI>4.1.1 <A HREF="#411">Les modes d'entr&eacute;e</A>
		<LI>4.1.2 <A HREF="#412">Les modes de sortie</A>
		<LI>4.1.3 <A HREF="#413">Les modes de contr&ocirc;le</A>
		<LI>4.1.4 <A HREF="#414">Les modes locaux</A>
		<LI>4.1.5 <A HREF="#415">Les caract&egrave;res de contr&ocirc;le</A>
		</UL>
	<LI>4.2 - <A HREF="#42">Mode bloquant et mode non-bloquant</A>
	</UL>
<LI>5 - <A HREF="#5">Exploitation</A>
<LI>6 - <A HREF="#6">Programme d'exemple</A>
<LI>7 - <A HREF="#7">Bibliographie</A>
</UL>
<HR>

<A NAME=1>
<H1>
Introduction
</H1>
<P>
L'ambition de cet article est bien modeste : il veut vous expliquer
comment on acc&egrave;de aux ports s&eacute;ries sous Linux, 
c'est-&agrave;-dire comment y lire des caract&egrave;res et en envoyer,
comment modifier les param&egrave;tres de la liaison, etc...
<P>
Nous entrons tout de suite dans le vif du sujet avec quelques
rappels &eacute;l&eacute;mentaires.
<P>

<A NAME=2>
<H1>
Bref rappel sur les liaisons s&eacute;ries
</H1>
Sur une liaison s&eacute;rie, les bits qui composent un caract&egrave;re
sont envoy&eacute;s les uns apr&eacute;s les autres, une tension &eacute;tant
associ&eacute;e aux 0 et aux 1. Les principaux param&egrave;tres d'une
telle liaison sont les suivants :
<UL>
	<LI>Son d&eacute;bit, exprim&eacute; en bits par seconde (bps)
	<LI>La parit&eacute; (paire, impaire ou aucune)
	<LI>Le nombre de bits par caract&egrave;re (5, 6, 7 ou 8)
	<LI>Le nombre de bits de stop (1, 1,5 ou 2)
</UL>
<P>
Le d&eacute;bit indique combien de bits circulent chaque seconde sur
la liaison. Cela peut aller de 50 &agrave; 460800 (!) bits/s.
<P>
La parit&eacute;, lorsqu'elle est utilis&eacute;e, est un bit
suppl&eacute;mentaire qui sert de contr&ocirc;le de transmission,
contr&ocirc;le qui est loin d'&ecirc;tre parfait puisqu'il n'est
efficace que si le nombre de bits &eacute;rron&eacute;s dans un
caract&egrave;re est impair.
<P>
Chaque caract&egrave;re peut &ecirc;tre compos&eacute; de 5 &agrave;
8 bits. Dans la grande majorit&eacute; des cas, on utilise 8 bits.
<P>
Le ou les bits de stop servent &agrave; marquer la fin de chaque
caract&egrave;re dans la transmission. En g&eacute;n&eacute;ral,
on n'utilise qu'un seul bit de stop.
<P>

<A NAME=3>
<H1>
Ouverture de la liaison
</H1>
Sous Linux, chaque port s&eacute;rie de votre machine est
repr&eacute;sent&eacute; par un <em>fichier de p&eacute;riph&eacute;rique</em>
situ&eacute; dans le r&eacute;pertoire /dev &agrave; c&ocirc;t&eacute;
de dizaines d'autres.
<UL>
	<LI>/dev/ttyS0 correspond &agrave; COM1
	<LI>/dev/ttyS1 correspond &agrave; COM2
	<LI>/dev/ttyS2 correspond &agrave; COM3
	<LI>/dev/ttyS3 correspond &agrave; COM4
</UL>
Au niveau d'un programme en C, on ouvre ces fichiers exactement comme
on ouvrirait n'importe quel autre fichier gr&acirc;ce &agrave;
l'appel syst&egrave;me <em>open()</em> :
<PRE>
	int fd;
	if ( (fd=open("/dev/ttyS1",O_RDWR)) == -1 ) {
		perror("open");
		exit(-1);
	}
</PRE>
Une fois que le port est ouvert, on peut y lire et y &eacute;crire
des caract&egrave;res au moyen des primitives <em>read()</em> et
<em>write()</em>.
<P>
Mais ne nous emballons pas, il faut d'abord param&eacute;trer notre
liaison.
<P>

<A NAME=4>
<H1>
Param&eacute;trage de la liaison
</H1>
Dans la norme POSIX, tous les param&egrave;tres d'une
liaison sont regroup&eacute;s dans une structure appel&eacute;e
<em>termios</em> et d&eacute;finie dans le fichier &lt;termios.h&gt;
qu'il nous faut donc inclure.
<P>
Cette structure comporte les champs suivants
<P>
<PRE>
	struct termios {
		tcflag_t c_iflag;		/* input mode flags */
		tcflag_t c_oflag;		/* output mode flags */
		tcflag_t c_cflag;		/* control mode flags */
		tcflag_t c_lflag;		/* local mode flags */
		cc_t c_line;			/* line discipline */
		cc_t c_cc[NCCS];		/* control characters */
	};
</PRE>
<P>
La fonction <em>tcgetattr</em> permet d'obtenir les param&egrave;tres
actuels d'une liaison. En voici le prototype, extrait du <em>man</em> :
<PRE>
	int tcgetattr ( int fd, struct termios *termios_p );
</PRE>
et un exemple typique d'utilisation :
<PRE>
	struct termios termios_p;
	tcgetattr(fd,&termios_p);
</PRE>
Notre structure <em>termios_p</em> &eacute;tant renseign&eacute;e,
on peut en modifier les champs, dont une description sera donn&eacute;e
au paragraphe suivant.
<P>
Une fois que ces champs ont &eacute;t&eacute; modifi&eacute;s, il faut
enregistrer ces modifications au moyen de la fonction
<em>tcsetattr</em> :
<PRE>
	tcsetattr(fd,TCSANOW,&termios_p);
</PRE>
<P>

<A NAME=41>
<P>
<H1>
Les champs de la structure termios
</H1>
Nous n'allons pas d&eacute;tailler ici l'ensemble des champs de cette
structure car ils sont trop nombreux. Seuls les champs utiles seront
abord&eacute;s.
<P>
<UL>
<A NAME=411>
<LI>
c_iflag : les modes d'entr&eacute;e
<P>
Ils d&eacute;finissent un traitement &agrave; appliquer sur les
caract&egrave;res en provenance de la liaison s&eacute;rie :
<UL>
<LI>IGNBRK : les caract&egrave;res BREAK sont ignor&eacute;s.
<LI>IGNPAR : les caract&egrave;res qui comportent une erreur de parit&eacute;
sont ignor&eacute;s.
<LI>ISTRIP : dans le cas d'une transmission sur 8 bits, le huiti&egrave;me
bit est syst&eacute;matiquement mis &agrave; z&eacute;ro.
</UL>
<P>
<A NAME=412>
<LI>
c_oflag : les modes de sortie
<P>
Ils d&eacute;finissent un traitement &agrave; appliquer sur les
caract&egrave;res envoy&eacute;s sur la liaison s&eacute;rie. On y 
trouve notamment OLCUC qui transforme les minuscules (non 
accentu&eacute;es !) en majuscules.
<P>
<A NAME=413>
<LI>
c_cflag : Les modes de contr&ocirc;le
<P>
Ce champ est important, car c'est ici que l'on d&eacute;finit le
d&eacute;bit, la parit&eacute; utilis&eacute;e, les bits de
donn&eacute;e et de stop, ...
<UL>
<LI>CLOCAL : si ce flag n'est <b>pas</b> utilis&eacute;, une
d&eacute;connexion (ie. chute du signal DCD) entra&icirc;ne la
fermeture automatique du port s&eacute;rie et les prochains
appels &agrave; <em>read()</em> renverront la valeur -1.
<LI>CS5 : chaque caract&egrave;re est compos&eacute; de 5 bits.
<LI>CS6 : chaque caract&egrave;re est compos&eacute; de 6 bits.
<LI>CS7 : chaque caract&egrave;re est compos&eacute; de 7 bits.
<LI>CS8 : chaque caract&egrave;re est compos&eacute; de 8 bits (c'est le cas
le plus fr&eacute;quent).
<LI>CSTOPB : on utilise 2 bits de stop au lieu d'un seul par d&eacute;faut
(sauf en 5 bits, o&ugrave; on utilise 1,5 bits).
<LI>HUPCL (Hang UP on CLose) : provoque la d&eacute;connexion (ie. chute des signaux DTR et
RTS) lors de la fermeture du port s&eacute;rie par l'appel syst&egrave;me
<em>close()</em>.
<LI>PARENB : activation du m&eacute;canisme de parit&eacute; paire.
<LI>PARODD : utilisation d'une parit&eacute; impaire au lieu d'une
parit&eacute; paire par d&eacute;faut.
<LI>B50 : liaison &agrave; 50 bits/s.
<LI>B75 : liaison &agrave; 75 bits/s.
<LI>...
<LI>230400 : liaison &agrave; 230400 bits/s.
<LI>460800 : liaison &agrave; 460800 bits/s.
</UL>
<P>
<A NAME=414>
<LI>
c_lflag : les modes locaux
<P>
Ce champ est d'une importance capitale : il d&eacute;finit
le mode (canonique ou non) et la gestion de l'&eacute;cho.
<UL>
<LI>ECHO : un &eacute;cho des caract&egrave;res re&ccedil;us est
effectu&eacute;.
<LI>ICANON : passage en mode canonique, c'est-&agrave;-dire
que les caract&egrave;es re&ccedil;us sont stock&eacute;s dans un
tampon et qu'ils ne sont disponibles qu'&agrave; la r&eacute;ception
d'un caract&egrave;re <em>eol</em> (de code ASCII d&eacute;cimal 10).
Les caract&egrave;res <em>erase</em> et <em>kill</em> permettent
respectivement d'effacer le dernier caract&egrave;re et tous les
caract&egrave;res de la ligne courante.
En mode non-canonique (le mode par d&eacute;faut), tous les caract&egrave;res
sont imm&eacute;diatement disponibles &agrave; la lecture.</UL>
<P>
<A NAME=415>
<LI>c_cc : les caract&egrave;res de contr&ocirc;le
<P>
C'est un tableau de caract&egrave;res. Des constantes sont
d&eacute;finies pour acc&eacute;der &agrave; quelques &eacute;l&eacute;ments
particuliers :
<UL>
<LI>VERASE : en mode canonique, c'est le caract&egrave;re <em>erase</em>,
qui provoque l'effacement du dernier caract&egrave;re.
<LI>VKILL : en mode canonique, c'est le caract&egrave;re <em>kill</em>,
qui provoque l'effacement de toute la ligne.
<LI>VEOF : en mode canonique, c'est le caract&egrave;re de fin de fichier
lorsqu'il est utilis&eacute; seul sur une ligne.
Le prochain appel &agrave; <em>read()</em> renverra une valeur nulle.
<LI>VEOL : en mode canonique, c'est le caract&egrave;re de fin de ligne. 
C'est lui qui rend disponibles &agrave; la lecture tous les caract&egrave;res
pr&eacute;c&eacute;dents.
<LI>VMIN : en mode non-canonique, sp&eacute;cifie le nombre de
caract&eacute;res que doit contenir le tampon pour &ecirc;tre 
accessible &agrave; la lecture. En g&eacute;n&eacute;ral, on fixe cette valeur &agrave; 1.
<LI>VTIME : en mode non-canonique, sp&eacute;cifie, en dixi&egrave;mes
de seconde, le temps au bout duquel un caract&egrave;re devient
accessible, m&ecirc;me si le tampon ne contient pas <em>c_cc[VMIN]</em>
caract&egrave;res. Une valeur de 0 repr&eacute;sente un temps infini.
</UL>
</UL>
<A NAME=42>
<H1>
Mode bloquant et mode non-bloquant
</H1>
Que se passe-t-il lorsqu'on appelle <em>read()</em>, et qu'il n'y a
malheureusement rien &agrave; lire ?
<P>
Deux possibilit&eacute;s s'offrent &agrave; nous :
<UL>
<LI>l'appel <em>read()</em> reste en attente d'un caract&egrave;re. C'est
le fonctionnement par d&eacute;faut.
<LI>l'appel <em>read()</em> se termine imm&eacute;diatement et
retourne la valeur -1.
</UL>
C'est &agrave; vous de choisir le mode de fonctionnement. Vous
pouvez faire ce choix &agrave; l'ouverture du port s&eacute;rie,
mais &eacute;galement &agrave; n'importe quel autre moment.
<P>
&Agrave; l'ouverture par <em>open()</em>, utilisez l'indicateur O_NONBLOCK :
<P>
<PRE>
	int fd;
	if ( (fd=open("/dev/ttyS1",O_RDWR|O_NONBLOCK)) == -1 ) {
		perror("open");
		exit(-1);
	}
</PRE>
<P>
Pour modifier le fonctionnement alors que le port s&eacute;rie est
d&eacute;j&agrave; ouvert, il faut utiliser l'appel syst&egrave;me
<em>fcntl()</em> de la façon suivante :
<P>
<PRE>
	/* Passe en mode bloquant */
        fcntl(fd,F_SETFL,fcntl(fd,F_GETFL)&~O_NONBLOCK);

	/* Repasse en mode non-bloquant */
        fcntl(fd,F_SETFL,fcntl(fd,F_GETFL)|O_NONBLOCK);
</PRE>
<P>

<A NAME=5>
<H1>
Exploitation
</H1>
<P>
Je vous rappelle qu'on peut lire et &eacute;crire avec les appels
syst&egrave;mes <em>read()</em> et <em>write()</em>.
<P>
Voici quelques informations pour mieux exploiter votre liaison :
<UL>
<LI>
Lorsque vous effectuez un appel &agrave; <em>write()</em>, les
caract&egrave;res que vous voulez envoyer sont plac&eacute;s dans un
tampon et <em>write()</em> rend la main imm&eacute;diatement. Votre
programme continue donc de s'&eacute;x&eacute;cuter pendant que des
caract&egrave;res sont envoy&eacute;s sur le port s&eacute;rie par le
noyau. Pour arr&ecirc;ter brutalement l'envoi, utilisez <em>tcflush()</em>
de la mani&egrave;re suivante :
<PRE>
	tcflush(fd,TCOFLUSH);
</PRE>
<P>
<LI>
De m&ecirc;me, pour &eacute;liminer tous les caract&egrave;res re&ccedil;us
par le noyau mais non encore lus par <em>read()</em>, faites ceci :
<PRE>
	tcflush(fd,TCIFLUSH);
</PRE>
<P>
<LI>
Pour bloquer le processus jusqu'&agrave; ce que tous les caract&egrave;res
aient effectivement &eacute;t&eacute; envoy&eacute;s, utilisez 
<em>tcdrain</em> comme suit :
<PRE>
	tcdrain(fd);
</PRE>
<PI>
<LI>
Lorsque vous &ecirc;tes en mode non-bloquant, pour attendre l'arriv&eacute;e
d'un caract&egrave;re, n'appelez surtout pas <em>read()</em> jusqu'&agrave;
ce qu'il vous renvoie une valeur diff&eacute;rente de -1. Cela charge
inutilement votre machine. Utilisez
plut&ocirc;t l'appel syst&egrave;me <em>select()</em>.
<P>
<LI>
Dans le cas d'une utilisation avec un modem, pour faire baisser le signal
DTR et ainsi provoquer la d&eacute;connexion, il suffit de passer 
&agrave; une vitesse nulle en utilisant la constante de vitesse B0.
</UL>
<P>

<A NAME=6>
<H1>
Programme d'exemple
</H1>
Voil&agrave;, on est loin d'avoir tout dit sur le sujet et vous
pouvez bien s&ucirc;r consulter <em>man termios</em> si vous voulez
plus d'informations. Mais &ccedil;a nous suffit largement pour aborder
tout de suite un petit programme d'exemple :

<PRE>

#include &lt;stdio.h&gt;
#include &lt;termios.h&gt;
#include &lt;sys/fcntl.h&gt;

void main(void)
{
	int		fd;
	char		c;
	struct termios	termios_p;

	/* Ouverture de la liaison serie */
	if ( (fd=open("/dev/ttyS1",O_RDWR)) == -1 ) {
		perror("open");
		exit(-1);
	}
	
	/* Lecture des parametres courants */
	tcgetattr(fd,&termios_p);
	/* On ignore les BREAK et les caracteres avec erreurs de parite */
	termios_p.c_iflag = IGNBRK | IGNPAR;
	/* Pas de mode de sortie particulier */
	termios_p.c_oflag = 0;
	/* Liaison a 9600 bps avec 7 bits de donnees et une parite paire */
	termios_p.c_cflag = B9600 | CS7 | PARENB;
	/* Mode non-canonique avec echo */
	termios_p.c_lflag = ECHO;
	/* Caracteres immediatement disponibles */
	termios_p.c_cc[VMIN] = 1;
	termios_p.c_cc[VTIME] = 0;
	/* Sauvegarde des nouveaux parametres */
	tcsetattr(fd,TCSANOW,&termios_p);
	
	/* Affichage sur le terminal */
	write(fd,"Tapez Ctrl-C pour quitter\n",26);

	/* Boucle de lecture */
	while ( 1 ) {
		read(fd,&c,1);
		if ( c == 0x03 )		/* Ctrl-C */
			break;
		printf("%03u %02x %c\n",c&0xff,c&0xff,c);
	}	                                                               
	
	/* Fermeture */
	close(fd);

	/* Bye... */
	exit(0);
	
}

</PRE>
<P>

<A NAME=7>
<H1>
Bibliographie
</H1>
<B>La programmation sous UNIX</B> de Jean-Marie RIFFLET aux &eacute;ditions
Ediscience, excellent ouvrage que je vous recommande chaudement ainsi
d'ailleurs que <B>La communication sous UNIX</B> du m&ecirc;me auteur. 

</HTML>

