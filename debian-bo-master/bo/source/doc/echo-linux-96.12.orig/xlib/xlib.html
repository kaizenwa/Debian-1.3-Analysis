<HEAD>
<TITLE>Introduction &agrave; la programmation Xlib</TITLE>
</HEAD>
<BODY>

<IMG SRC="xpaint.gif" ALIGN=left HSPACE=10> 
<H1>
<P>Introduction  &agrave; la programmation Xlib
</H1>
<P>
Article pour l'Echo de Linux (<em><b>Juillet 1996</b></em>) 
<address><a href="mailto:pierre@rd.lectra.fr">Pierre Ficheux 
(pierre@rd.lectra.fr)</a></address> 

<BR CLEAR=left>
<HR>

<H1>Sommaire</H1>
<UL>
<LI>1 - <A HREF="#1">Introduction</A>
<LI>2 - <A HREF="#2">Rappels sur X11</A>
	<UL>
	<LI>2.1 <A HREF="#21">Principes de base</A>
	<LI>2.2 <A HREF="#22">Structure des librairies</A>
	</UL>
<LI>3 - <A HREF="#3">Pourquoi connaitre la Xlib ?</A>
<LI>4 - <A HREF="#4">Structure d'un programme X</A>
<LI>5 - <A HREF="#5">Les concepts de base</A>
	<UL>
	<LI>5.1 <A HREF="#51">Le display</A>
	<LI>5.2 <A HREF="#52">L'&eacute;cran</A>
	<LI>5.3 <A HREF="#53">Les fen&ecirc;tres</A>
	<LI>5.4 <A HREF="#54">Les Pixmaps</A>
	<LI>5.5 <A HREF="#55">Les &eacute;v&egrave;nements</A>
	<LI>5.6 <A HREF="#56">Le contexte graphique</A>
	</UL>
<LI>6 - <A HREF="#6">Un exemple simple comment&eacute;</A>
<LI>7 - <A HREF="#7">Conclusion</A>
<LI>8 - <A HREF="#8">Bibliographie</A>
</UL>


<A NAME=1>
<H1>
Introduction
</H1>
<P>
Le but de cet article est d'initier le lecteur &agrave; la programmation sous le
syst&egrave;me graphique X11. Dans ce document, nous allons d&eacute;crire
un exemple simple utilisant la librairie <EM>Xlib</EM>. 
<P>
Cet article n´est pas un cours de programmation, son but est de permettre au 
lecteur d´&eacute;crire son premier programme en <EM>Xlib</EM> tout en introduisant 
les concepts principaux de la programmation X. Il suppose un bonne connaissance
du langage C.

<A NAME=2>
<H1>
Rappels sur X11
</H1>

<A NAME=21>
<H2>
Principes de base
</H2>

<P>
X11 est le syst&egrave;me graphique le plus populaire du syst&egrave;me d´exploitation <EM>UNIX</EM>. Sa
large distribution, le fait qu'ils soit libre de tous droits de distribution
et surtout ses qualit&eacute;s techniques exceptionnelles en ont fait un
<EM>standard</EM> de l'industrie du logiciel. Ses caract&eacute;ristiques principales
sont:
<UL>
<LI> l'utilisation d'une architecture <EM>client/serveur</EM> et cela dans une
totale h&eacute;t&eacute;rog&eacute;n&eacute;it&eacute; (le serveur et le client peuvent fonctionner sur
des architectures totalement diff&eacute;rentes). Le dialogue entre le serveur
et les clients se fait conform&eacute;ment au <EM>protocole X</EM> ce qui permet
d'assurer la <EM>transparence du dialogue</EM> .
<BR>
<LI> la <EM>portabilit&eacute;</EM> des librairies et des applications X11 (le m&ecirc;me
code tourne sur une grosse station de travail ou bien un petit PC sous
Linux)
</UL>
<P>
En d&eacute;pits des avantages de X11, il serait faux de croire que le d&eacute;veloppement
d'une application X soit une chose simple. Les concepts utilis&eacute;s sont
complexes (programmation orient&eacute;e objet, gestion d'&eacute;v&egrave;nements, ...), le
nombre de fonctions &agrave; connaitre est important et la documentation titanesque
et parfois difficile &agrave; aborder...

<A NAME=22>
<H2>
Structure des librairies
</H2>
<P>
Les librairies constituant X sont organis&eacute;es sous forme de couches en partant
du plus bas niveau (la couche protocole) au plus haut (les toolkits). Le
sch&eacute;ma ci-dessous donne l'organisation de ces couches:
<BR>
<IMG SRC="couches.xbm">
<BR>
<P>
Comme nous le voyons sur le sch&eacute;ma, la couche <EM>utilisable</EM> la plus basse 
(en l'occurence la Xlib) est accessible &agrave; partir des couches de plus haut 
niveau (manipulant des classes et des objets: boutons, menus, etc...).

<A NAME=3>
<H1>
Pourquoi connaitre la Xlib ?
</H1>
<P>
Si l'on fait une analogie entre X et les langages de programmation, on peut
consid&eacute;rer la <EM>Xlib</EM> comme une sorte de langage <EM>assembleur</EM> et les 
couches sup&eacute;rieures (Xt, toolkits - Xaw ou Motif) commes des langages 
<EM>&eacute;volu&eacute;s</EM>. On peut donc se demander si il est encore n&eacute;cessaire de
connaitre aujourd'hui un langage de bas niveau alors que des outils puissants
permettent de construire une application <EM>directement</EM> "&agrave; la souris"
(pour ne citer que certains produits: XFaceMaker II de NSL, Xcessory de
ICS, IlogViews de ILOG).
<P>
Cependant, je pense qu'il n'est pas envisageable de r&eacute;aliser une
(et de maintenir) un application <EM>complexe</EM> sous X sans avoir une 
connaissance des couches inf&eacute;rieures y compris la <EM>Xlib</EM>. En plus, de
cela, la <EM>Xlib</EM> offre des performances &agrave; l'ex&eacute;cution in&eacute;gal&eacute;es (et
in&eacute;galables) par un toolkit (c'est le propre d'un assembleur).

<A NAME=4>
<H1>
Structure d'un programme X
</H1>
<P>
Un programme X peut grossi&egrave;rement se diviser en 3 parties:
<UL>
<LI> l'ouverture d'une connexion &agrave; un <EM>serveur X</EM> (serveur local ou
bien terminal). 
<BR>
<LI> les initialisations des fen&ecirc;tres initiales (cas de la Xlib) ou des
objets initiaux (cas d'un toolkit)
<BR>
<LI> l'attente d'&eacute;v&egrave;nements (souris, clavier, ou autres...) dans une
boucle infinie dont on ne sortira qu'&agrave; la fin du programme.
</UL>
<P>
La r&eacute;ception des &eacute;v&egrave;ements d&eacute;clenchera les actions d&eacute;crites &agrave; la 
deuxi&egrave;me partie (initialisation) .

<A NAME=5>
<H1>
Les concepts de base
</H1>

<A NAME=51>
<H2>
Le <EM>display</EM>
</H2>
<P>
Le <EM>display</EM> d&eacute;finit la connexion de l'application &agrave; un serveur X. 
Une fois initialis&eacute;e, la valeur du <EM>display</EM> sera utilis&eacute;e dans tous 
les appels aux fonctions X. Le <EM>display</EM> est calcul&eacute; gr&acirc;ce &agrave; la fonction
:
<PRE>

	Display *XOpenDisplay (nom_du_display)
		char *nom_du_display;

</PRE>
<P>
Dans le cas ou le param&egrave;tre est &eacute;gal au pointeur NULL, la fonction lit
la valeur de la variable d'environnement <EM>DISPLAY</EM>, dans le cas ou l'on
passe un nom de <EM>display</EM>, il devra respecter la m&ecirc;me syntaxe que
la variable <EM>DISPLAY</EM> soit en g&eacute;n&eacute;ral:
<PRE>

  nom_du_display:0.0     pour un terminal X (exemple: Xpierre:0)
  :0.0                   pour un serveur local 

</PRE>

<A NAME=52>
<H2>
L´&eacute;cran (screen)
</H2>
<P>
Pour un <EM>display</EM> donn&eacute;, on peut avoir plusieurs <EM>screens</EM> (unit&eacute;s d´affichage 
enfait. En pratique, la valeur de l´&eacute;cran est toujours de 0.

<A NAME=53>
<H2>
Les fen&ecirc;tres
</H2>
<P>
La <EM>fen&ecirc;tre</EM> est un des  concepts les plus importants sous X. Tout objet
affich&eacute; &agrave; l'&eacute;cran  (quelle que soit sa complexit&eacute;) est d&eacute;compos&eacute; en
fen&ecirc;tres. Les fen&ecirc;tres sont en g&eacute;n&eacute;ral rectangulaires mais la release
4 (X11R4) a introduit les fen&ecirc;tres "rondes" qui sont cependant peu
utilis&eacute;es (voir les clients <EM>xeyes</EM> ou <EM>xman</EM>). Les 
caract&eacute;ristiques principales d'une fen&ecirc;tres sont:
<UL>
<LI> la fen&ecirc;tre <EM>parent</EM>
<LI> la position par rapport au parent (x, y en pixels)
<LI> les dimensions (largeur/hauteur en pixels)
<LI> la couleur du fond
<LI> la couleur du bord
<LI> l'&eacute;paisseur du bord
</UL>
<P>
Le type X correspondant &agrave; la fen&ecirc;tre est le type <EM>Window</EM>. Pour cr&eacute;er 
simplement une fen&ecirc;tre, on pourra utiliser la fonction:
<PRE>

	Window XCreateSimpleWindow (display, parent, x, y, width, height, 
			border_width, border_color, background)
		Display *display;
		Window parent;
		int x, y;
		unsigned int width, height, border_width;
		unsigned long border_color, background;
	
</PRE>
<P>
Pour afficher la fen&ecirc;tre, on utilisera la fonction :
<PRE>

       XMapWindow (display, w)
             Display *display;
             Window w;

</PRE>
<P>
Et pour l´&eacute;ffacer, on utilisera :
<PRE>

       XUnmapWindow (display, w)
             Display *display;
             Window w;

</PRE>
<P>
Le syst&egrave;me des fen&ecirc;tres a une structure arborescente avec une fen&ecirc;tre particuli&egrave;re qui
est la "m&egrave;re" de toutes les autres fen&ecirc;tres : la <EM>Root Window</EM> (fond de l´&eacute;cran).

<A NAME=54>
<H2>
Les Pixmaps
</H2>
<P>
Un <EM>Pixmap</EM> est une <EM>fen&ecirc;tre cach&eacute;e</EM> permettant de faire des trac&eacute;s en
arri&egrave;re-plan (par exemple, sauvegarde d´une partie d´&eacute;cran pour un r&eacute;-affichage 
ult&eacute;rieurement). Ils ne seront pas utilis&eacute;s dans l´exemple qui suit.

<A NAME=55>
<H2>
Les &eacute;v&egrave;nements
</H2>
<P>
Les <EM>&eacute;v&egrave;menents</EM> sont &agrave; la base du fonctionnement d´un programme sous X (on parle
de programmation <EM>&eacute;v&egrave;nementielle</EM>). Les &eacute;v&egrave;nements peuvent &ecirc;tre d´origine externe
(clic/d&eacute;placement de souris, touche du clavier, ...) ou bien interne (d&eacute;gagement d´une
partie de fen&ecirc;tre obscurcie).
<P>
Les &eacute;v&egrave;nements sont identifi&eacute;s gr&acirc;ce aux <EM>types</EM> d´&eacute;v&egrave;nement. En voici quelques
exemples :
<PRE>

	ButtonPress             appui sur le bouton de la souris
	ButtonRelease           relachement du bouton souris
	KeyPress                touche appuy&eacute;e
	KeyRelease              touche relach&eacute;e
	Expose                  d&eacute;gagement d´une fen&ecirc;tre obscurcie (ou 
                                bien premier affichage de la fen&ecirc;tre)
                                
</PRE>
<P>
Les types d´&eacute;venements sont rassembl&eacute;s en <EM>masques d´&eacute;v&egrave;nement</EM> ou 
<EM>event mask</EM>. Par exemple, le masque <EM>ButtonPressMask</EM> correspond &agrave; l´&eacute;v&egrave;nement
<EM>ButtonPress</EM>, <EM>ExposureMask</EM> correspond &agrave; l´&eacute;v&egrave;nement <EM>Expose</EM>.
<P>
Les &eacute;v&egrave;nements sont re&ccedil;us par les <EM>fen&ecirc;tre</EM> &agrave; condition que l´on ait indiqu&eacute;
l´int&eacute;r&ecirc;t de la fen&ecirc;tre pour cet &eacute;v&egrave;nement. Ceci se fait avec la fonction :
<PRE>

       XSelectInput(display, w, event_mask)
             Display *display;
             Window w;
             long event_mask;

</PRE>
<P>
Le param&egrave;tre <EM>event_mask</EM> est un masque indiquant la liste des &eacute;v&egrave;nements
int&eacute;ressant la fen&ecirc;tre (exemple: ButtonPressMask | KeyPressMask). Si un &eacute;v&egrave;nement
re&ccedil;u n´int&eacute;resse pas la fen&ecirc;tre, il est en g&eacute;n&eacute;ral pass&eacute; &agrave; la fen&ecirc;tre p&egrave;re de la
fen&ecirc;tre courante.
<P>
Comme nous l´avons d&eacute;j&agrave; indiqu&eacute;, un programme X a une structure de boucle infinie de
traitement des &eacute;v&egrave;nements re&ccedil;us. La lecture des &eacute;v&egrave;nements est souvent bloquante, elle
est r&eacute;alis&eacute;e par la fonction :
<PRE>

       XNextEvent (display, event_return)
             Display *display;
             XEvent *event_return;

</PRE>
<P>
Le type <EM>XEvent</EM> correspond &agrave; une <EM>union C</EM> pouvant contenir tous les &eacute;v&egrave;nements
possibles. La s&eacute;lection se fait sur le premier champ de l´union qui correspond au
<EM>type</EM> de l´&eacute;v&egrave;nement :
<PRE>

  typedef union _XEvent {
        int type;	
	XAnyEvent xany;
	XKeyEvent xkey;
	XButtonEvent xbutton;
	XMotionEvent xmotion;
	XCrossingEvent xcrossing;
	XFocusChangeEvent xfocus;
	...
  };

</PRE>
<P>
Pour une variable <EM>xev</EM> du type <EM>XEvent</EM>, l´acc&egrave;s aux diff&eacute;rents champs 
suivant la valeur du type se fait donc par <EM>xev.xbutton</EM> (pour un ButtonPress ou 
un ButtonRelease), <EM>xev.xexpose</EM> (pour Expose), etc...

<A NAME=56>
<H2>
Le contexte graphique (GC)
</H2>
<P>
Le <EM>contexte graphique</EM> ou <EM>graphic context</EM> (GC) permet de 
stocker dans une structure tous les attributs d´affichage (couleur de fond, 
couleur de dessin, fonte, type d´affichages - Normal, XoR, ...). Une variable 
de type GC est toujours pass&eacute;e en param&egrave;tre des fonctions de trac&eacute;.
<P>
Par exemple, pour afficher un texte dans une fen&ecirc;tre, on utilisera la fonction:
<PRE>

       XDrawString(display, d, gc, x, y, string, length)
             Display *display;
             Drawable d;
             GC gc;
             int x, y;
             char *string;
             int length;

</PRE>
<P>
Le type <EM>Drawable</EM> peut repr&eacute;senter une <EM>Window</EM> ou bien un <EM>Pixmap</EM> (en
fait un type permettant le dessin, d´ou le nom de <EM>Drawable</EM>)

<A NAME=6>
<H1>
Un exemple simple comment&eacute;
</H1>
<P>
Ce petit exemple permet d´afficher le chaine "Hello, world" dans une fen&ecirc;tre X :
<P>
<IMG SRC="xsimple.gif">
<P>
<PRE>

/* 
 * xsimple : Affiche une chaine dans une fenetre X...
 */

#include &lt;stdio.h&gt;
#include &lt;X11/Xlib.h&gt;

</PRE>
<P>
En premier lieu, on inclut le fichier <EM>stdio.h</EM> (&ccedil;a peut toujours servir) et
surtout le fichier <EM>X11/Xlib.h</EM> qui contient les d&eacute;finitions des types et
constantes utilis&eacute;es par la Xlib.
<PRE>

GC	gc;
Display	*display;
int	screen;
Window	win, root;
unsigned long white_pixel, black_pixel;

</PRE>
<P>
On d&eacute;clare les variables globales utilis&eacute;es par le programme (contexte graphique, 
display, screen, fen&ecirc;tres et "couleurs" noir et blanc).
<PRE>

/*
 * fonction associee a l'evenement EXPOSE 
 */

void expose ()
{
    XDrawString (display, win, gc, 10, 30, "Hello, world !", 14);
}

</PRE>
<P>
Cette fonction est appel&eacute;e lorsque la fen&ecirc;tre <EM>win</EM> re&ccedil;oit l´&eacute;v&egrave;nement 
<EM>Expose</EM>. Ceci arrive dans deux cas seulement :
<UL>
<LI> lorsque la fen&ecirc;tre est affich&eacute;e &agrave; l´&eacute;cran par un <EM>XMapWindow</EM>
<BR>
<LI> lorsqu´une portion de la fen&ecirc;tre pr&eacute;cedemment couverte par une autre redevient
visible (et que le serveur X ne fait pas de gestion interne des recouvrement - ou
<EM>backing-store</EM>)
</UL>
<BR>
<P>
ATTENTION: on ne peut pas &eacute;crire dans une fen&ecirc;tre <STRONG>AVANT</STRONG> qu´elle 
n´ait 
re&ccedil;u son premier &eacute;v&egrave;nement <EM>Expose</EM>.
<BR>
<P>
Lors de la r&eacute;ception de l´&eacute;v&egrave;nement <EM>Expose</EM>, on affiche la chaine 
"Hello, world" aux coordonn&eacute;es (10, 30) de la fen&ecirc;tre <EM>win</EM>.
<PRE>

/*
 * programme principal
 */

main(ac, av)
int ac;
char **av;
{
    char *dpyn = NULL;

    /* selection du display en ligne */
    if (ac == 3) {
	if (strcmp (&av[1][1], "display") == 0) {
	    dpyn = av[2];
	}
	else {
	    fprintf (stderr, "Usage:	xsimple [-display display_name]\n");
	    exit (1);
	}
    }

    if ((display = XOpenDisplay (dpyn)) == NULL) {
	fprintf (stderr, "Can't open Display\n");
	exit (1);
    }

</PRE>
<P>
Dans le programme principal, on ouvre tout d´abord une connexion avec un serveur X
(donn&eacute; par le contenu de la variable d´environnement <EM>DISPLAY</EM>). On peut 
&eacute;galement passer la valeur du display en param&egrave;tre sur la ligne de commande (par
convention, c´est l´option <EM>-display</EM>). Il suffit ensuite d´appeler la fonction
<EM>XOpenDisplay</EM> qui renvoit un pointeur de <EM>Display</EM> si il existe.
<PRE>

    gc = DefaultGC (display, screen);
    screen = DefaultScreen (display);
    root = RootWindow (display, screen);
    white_pixel = WhitePixel (display, screen);
    black_pixel = BlackPixel (display, screen);

</PRE>
<P>
On r&eacute;cup&egrave;re les valeurs par d&eacute;faut des diff&eacute;rentes variables (contexte graphique, 
screen, ...). Pour cel&agrave;, on utilise des <EM>macros-instructions</EM> d&eacute;finies dans
<EM>X11/Xlib.h</EM> .
<PRE>

    win = XCreateSimpleWindow (display, root, 0, 0, 100, 90, 2, black_pixel, white_pixel);

    XSelectInput (display, win, ExposureMask);

    XStoreName (display, win, "xsimple");
    XMapWindow (display, win);

</PRE>
<P>
On cr&eacute;e ensuite la fen&ecirc;tre <EM>win</EM> par la fonction <EM>XCreateSimpleWindow</EM>. 
Cette fen&ecirc;tre a pour parent la <EM>root-window</EM>, ses dimensions sont 100 sur 90
pixels, 2 pixels d´&eacute;paisseur pour le bord, fond blanc, bord noir. 
<P>
L´appel &agrave; <EM>XSelectInput</EM> indique que la fen&ecirc;tre ne s´int&eacute;resse qu´&agrave; l´&eacute;v&egrave;nement 
<EM>Expose</EM> (ExposureMask). 
<P>
La fonction <EM>XStoreName</EM> permet de nommer la fen&ecirc;tre pour le 
<EM>window-manager</EM> (dans notre cas, le nom <EM>xsimple</EM> s´affichera dans le
bandeau du window-manager).
<P>
Enfin, la fonction <EM>XMapWindow</EM> affiche la fen&ecirc;tre &agrave; l´&eacute;cran.
<PRE>

    for (;;) {
	XEvent ev;
	char c;

	XNextEvent (display, &ev);

	switch (ev.type) {

	  case Expose :
	    
	    expose ();
	    break;

	    default :

	      break;
	    
	}
    }
}

</PRE>
<P>
Voici la partie "active"du programme. C´est une boucle infinie de lecture des 
&eacute;v&egrave;nements X (appel &agrave; la fonction <EM>XNextEvent</EM>). Les &eacute;v&egrave;nements sont ensuite 
trait&eacute;s suivant leur type (ev.type) dans un <EM>switch</EM> (dans notre cas, seul
l´&eacute;v&egrave;nement <EM>Expose</EM> est associ&eacute; &agrave; une fonction)
<BR>
<P>
Pour compiler ce programme sous l´environnement de d&eacute;veloppement X, on pourra 
utiliser le fichier Imakefile suivant :
<PRE>

    LDLIBS = $(XLIB)
 SimpleProgramTarget(xsimple)

</PRE>
<P>
avec la s&eacute;quence suivante :
<UL>
<LI> "xmkmf" pour g&eacute;n&eacute;rer le Makefile &agrave; partir de l´Imakefile
<BR>
<LI> "make depend"pour g&eacute;n&eacute;rer les d&eacute;pendances des fichiers &agrave; la fin du Makefile
<BR>
<LI> "make all" pour compiler le programme
</UL>

<A NAME=7>
<H1>
Conclusions
</H1>
<P>
La programmation en <EM>Xlib</EM> est loin d´&ecirc;tre simple et il est peu concevable de
r&eacute;aliser aujourd´hui une application compl&egrave;te sans utiliser de toolkit (OSF-Motif,
Widgets Athena) ou m&ecirc;me d´outil de prototypage d´applications. La compr&eacute;hension
des m&eacute;canismes de base la la Xlib reste cependant une assurance pour la fiabilit&eacute;
des applications d&eacute;velopp&eacute;es.

<A NAME=8>
<H1>
Bibliographie
</H1>
<UL>
<LI> Volumes 1 et 2 de la s&eacute;rie <EM>X Window System</EM> de chez <EM>O´Reilly & 
associates</EM>
<LI> Documentation Xlib de la distribution X11R6 (sur ~/xc/doc/hardcopy/X11 en 
PostScript ou bien ~/xc/specs/X11 en sources TROFF)
</UL>
 
