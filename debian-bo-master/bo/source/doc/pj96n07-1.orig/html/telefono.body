<!--
	telefono.html
	Last modification: Tue, 19 Nov 1996 23:01:51 +0200
	telefono.	Telefoni e pigrizia	PJ 7: Telefoni e pigrizia	Articoli
  -->
<br>
<body bgcolor="#ffffff">
<font size=+2 color="#0000ff">Linux, telefoni e pigrizia.</font>
<address>
<p align=right>
<font size=+0>
di
<a href="mailto:lac0658@iperbole.bologna.it">
Nando Santagata</a>
</p>
</address>
<p>
La pigrizia è la madre della creazione.
<p>
Se c'è una cosa che mi dà fastidio è dover
spostare le mani dalla tastiera del computer, cercare i numeri di
telefono nelle varie agende e comporre il numero.<br>
Pensate quello che volete, ma sono pigro.
<p>
Per rimediare a questo terribile stato di fatto mi sono posto
l'obiettivo di far fare al computer ciò che non ho voglia di
fare io stesso.<br>
Dopo un po' di <cite>mumble mumble</cite> ho deciso di realizzare un piccolo
database di nomi e numeri di telefono e un programmino che
legga dalla mia cara riga di comando il nome della persona a cui
voglio telefonare, componga il numero usando il modem e attenda la
pressione di un tasto, per resettare il modem dopo che io abbia alzato
la cornetta.
<p>
Partiamo dal database di nomi: non ho molte pretese e penso che possa
bastarmi un elenco del tipo:
<p>
<code>
<cite>
<pre>
nome1,numero1
nome2,numero2
...,...
</pre>
</cite>
</code>
<p>
Dopo aver riempito un file con questi dati, ho scritto un
pezzetto di codice per leggerlo e trovare il numero di telefono
giusto.<br>
Il codice Perl che fa questa ricerca è il seguente:
<p>
<code>
<pre>
#!/usr/bin/perl -w

die &quot;Uso: $0 nome&quot; if ! defined @ARGV;

open(TEL, &quot;$ENV{'HOME'}/.tel.numbers&quot;) ||
			die &quot;Non trovo i numeri di telefono: $!&quot;;
$nomei = shift @ARGV;
$trovato = 0;
while(&lt;TEL&gt;){
	chomp;
	($nome, $tel) = split /,/;
	if($nome eq $nomei){
		$trovato = 1;
		last;
	}
}
close TEL;

die &quot;Numero non trovato\n&quot; if ! $trovato;
print &quot;Chiamo $nome al numero $tel\n&quot;;
</pre>
</code>
<p>
Ho cercato di scrivere qualcosa che fosse almeno indipendente
dall'utente che lo usa, così il file dei nomi-numeri di
telefono lo apro come:
<p>
<code>
<pre>
open(TEL, &quot;$ENV{'HOME'}/.tel.numbers&quot;)
</pre>
</code>
<p>
Il Perl definisce un array associativo, <strong>%ENV</strong>, che
contiene come indici i nomi delle variabili di environment e come
elementi i loro rispettivi valori.<br>
Quindi <strong>$ENV{'HOME'}</strong> è il valore della variabile
di environment <strong>HOME</strong>, che contiene la path della home
directory dell'utente.<br>
Il file da consultare l'ho chiamato <strong>.tel.numbers</strong>, per
evitare che mi disturbasse ad ogni ls.
<p>
Un altro array <cite>magico</cite> definito dal Perl è
<strong>@ARGV</strong>. Questo array contiene la riga di comando,
quindi si può verificare che l'utente abbia immesso almeno un
parametro, testando semplicemente l'esistenza dell'array, che
altrimenti risulterebbe indefinito:
<p>
<code>
<pre>
die &quot;Uso: $0 nome&quot; if ! defined @ARGV;
</pre>
</code>
<p>
e si può leggere il primo elemento facendolo
<cite>sgusciare</cite> fuori dall'array :
<p>
<code>
<pre>
$nomei = shift @ARGV;
</pre>
</code>
<p>
A questo punto possiamo scorrere il file, alla ricerca del nome che
si suppone l'utente abbia immesso sulla riga di comando:
<p>
<code>
<pre>
while(&lt;TEL&gt;){
	chomp;
	($nome, $tel) = split /,/;
	if($nome eq $nomei){
		$trovato = 1;
		last;
	}
}
</pre>
</code>
<p>
L'istruzione onomatopeica <strong>chomp</strong> <cite>mangia</cite>
l'eventuale carattere di fine riga, mentre lo <strong>split</strong>
spezza la riga all'altezza della virgola e restituisce una lista che
viene assegnata alle variabili <strong>$nome</strong> e
<strong>$tel</strong>.<br>
Se la riga in esame contiene proprio il nome che cerchiamo, usciamo
dal loop e assegnamo il valore 1 alla variabile-flag
<strong>$trovato</strong>.
<p>
A questo punto non ci resta che comunicare al modem i nostri
desideri:
<p>
<code>
<pre>
open(MODEM, &quot;+&gt;/dev/cua1&quot;) ||
			die &quot;Non posso usare il modem: $!&quot;;
system &quot;/bin/stty raw -echo &lt;/dev/cua1&quot;;
$in='';
$out=&quot;atz\r&quot;;
syswrite(MODEM, $out, length($out));
sleep 2;
sysread(MODEM, $in, 1000);
$out=&quot;atdt$tel\r&quot;;
syswrite(MODEM, $out, length($out));
sleep 2;
sysread(MODEM, $in, 1000);
&lt;&gt;;
close MODEM;
system &quot;/bin/stty cooked echo &lt;/dev/cua1&quot;;
</pre>
</code>
<p>
Innanzi tutto dobbiamo <cite>aprire</cite> il modem.<br>
Sotto Unix qualsiasi
cosa è un file, anche una seriale. Quindi per comunicare con
la seriale (alla quale è attacato il modem) devo aprire il suo
pseudo-file:
<p>
<code>
<pre>
open(MODEM, &quot;+&gt;/dev/cua1&quot;)
</pre>
</code>
<p>
Il simbolo <strong>+&gt</strong> indica che il file deve essere
aperto in lettura e scrittura, cosa che ci serve per poter leggere le
risposte del modem ai nostri comandi.
<p>
Ciò di cui abbiamo ora bisogno è qualche
informazione sulle seriali: per poter comunicare con il modem senza
interferenze si deve configurare la linea in <cite>row
mode</cite>.<br>
Questa operazione può essere fatta comodamente usando un
comando esterno, che Linux (come ogni altro Unix) è così
gentile da metterci a disposizione:
<p>
<code>
<pre>
system &quot;/bin/stty raw -echo &lt;/dev/cua1&quot;;
</pre>
</code>
<p>
In questo modo ho configurato il tty che mi interessa in
modalità <cite>raw</cite> e <cite>noecho</cite> (incidentalmente
uso /dev/cua1, perché ho il modem sulla seconda seriale).
<p>
Avrei potuto programmare la linea seriale direttamente in Perl, ma essendo
cosa lunga e tediosa, ho preferito usare un comando esterno,
probabilmente anche più portabile (ricordate, sono pigro).
<p>
A questo punto si può cominciare il colloquio con il modem:
ogni comando viene spedito con una <strong>syswrite</strong> e il
risultato letto con una <strong>sysread</strong>.<br>
Ho usato la <strong>syswrite</strong> al posto della <strong>print</strong>
per essere sicuro che i miei comandi non siano bufferizzati.
<p>
Ho aggiunto qualche <strong>sleep</strong> per dare al modem il tempo
di capire cosa gli chiedo e spedirmi la risposta.
<p>
Dopo aver composto il numero, aspetto un input dall'utente:
<p>
<code>
<pre>
&lt;&gt;;
</pre>
</code>
<p>
l'utente a questo punto può sollevare la cornetta e premere
enter per <cite>staccare</cite> il modem.<br>
L'operazione di esclusione del modem si ottiene semplicemente
chiudendo il file aperto, poi, perché non si dica che siamo
scortesi, rimettiamo le cose a posto sulla linea con un altro
<strong>stty</strong>:
<p>
<code>
<pre>
system &quot;/bin/stty cooked echo &lt;/dev/cua1&quot;;
</pre>
</code>
<p>
Tutto qui.<br>
C'è ancora un discorsetto da fare sulle persmissions: non
tutti possono permettersi di sparare comandi così ad un
modem.<br>
Nel mio sistema la seconda linea seriale appare così:
<p>
<code>
<pre>
$ ls -l /dev/cua1

crw-rw----   1 root     dialout    5,  65 Oct 21 17:28 /dev/cua1
</pre>
</code>
<p>
Come si può vedere solo <cite>root</cite> e gli utenti del
gruppo <cite>dialout</cite> possono leggere e scrivere questo
file.<br>
La soluzione è quella di listare tutti gli utenti che vogliono
usare questo programmino, in <strong>/etc/group</strong>, come membri
del gruppo <cite>dialout</cite>.
<p>
Infatti il mio <strong>/etc/group</strong> recita:
<p>
<code>
<pre>
...
dialout:*:20:nando
...
</pre>
</code>
<p>
A questo punto il mio utente personale fa parte anche del gruppo
dialout e io posso scrivere inpunemente sulla seconda seriale,
comunicare con il mio modem e telefonare senza usare la tastiera del
telefono.
<p>
Ovviamente ci sono molte migliorie che si possono apportare a questo
programmino: si potrebbe ad esempio controllare che non ci siano
locks sulla seriale che stiamo per usare, controllando
<strong>/var/lock/</strong>, si potrebbe cercare il primo modem
libero tra quelli collegati, ecc.
<p>
Una possibilità interessante sarebbe quella di chiamare un
certo numero di telefono usando una form sul Web. Questo telefono
potrebbe essere collegato ad un relais, che potrebbe accendere...
ooops!
<p>
Bhe, torniamo con i piedi per terra ;-)
<p>
A rileggerci al prossimo numero del Pluto Journal.
