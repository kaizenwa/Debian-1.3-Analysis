.\" Traduzione di Christian K. Franzone -- Copyright (C) 1996.
.PU
.TH COMPRESS 1 local
.SH NOME
compress, uncompress, zcat \- comprime ed espande dati
.SH SINTASSI
.ll +8
.B compress
[
.B \-f
] [
.B \-v
] [
.B \-c
] [
.B \-V
] [
.B \-b
.I bits
] [
.I "name \&..."
]
.ll -8
.br
.B uncompress
[
.B \-f
] [
.B \-v
] [
.B \-c
] [
.B \-V
] [
.I "name \&..."
]
.br
.B zcat
[
.B \-V
] [
.I "name \&..."
]
.SH DESCRIZIONE
.I Compress
riduce la grandezza dei file usando la codifica adattativa di Lempel-Ziv.
Quando possibile,
ogni file viene sostituito da uno con estensione 
.B "\&.Z,"
mentre vengono mantenuti gli stessi permessi di possesso, accesso e modifica.
Se non vengono specificati file, lo standard input viene compresso sullo 
standard output.
I  file compressi possono essere ripristinati alla loro forma originale usando
.I uncompress
o
.I zcat.
.PP
L'opzione 
.B \-f
forzerà la compressione di 
.I name.
Questo è utile per la compressione di una intera directory,
anche se alcuni dei file non si rimpiccioliscono effettivamente.
Se 
.B \-f    
non viene specificato e 
.I compress
viene eseguito in foreground,
all'utente viene chiesto se il file esistente debba essere sovrascritto.
.PP
L'opzione 
.B \-c
fa si che 
.I compress/uncompress
scriva sullo standard output; nessun file viene cambiato.
Il comportamento non distruttivo di 
.I zcat
è identico a quello di 
.I uncompress
.B \-c.
.PP
.I Compress
usa l'algoritmo modificato Lempel-Ziv divulgato in 
"A Technique for High Performance Data Compression",
Terry A. Welch,
.I "IEEE Computer,"
vol. 17, no. 6 (June 1984), pp. 8-19.
Le sottostringhe comuni nel file vengono prima sostituite dai codici a 9 bit da 257 in poi.
Quando viene raggiunto il codice 512, l'algoritmo passa ai codici a 10 bit e  
continua a usare più bit fino a quando 
il limite specificato dal flag 
.B \-b
viene raggiunto (per default pari a 16).  I
.I bit
devono essere compresi tra 9 e 16. Il default può essere cambiato nel sorgente per permettere a 
.I compress
di essere eseguito su una macchina più piccola.
.PP
Dopo che il limite dei
.I bit
viene raggiunto,
.I compress
periodicamente controlla il rapporto di compressione.  Se sta aumentando,
.I compress
continua a usare l'esistente dizionario del codice. Tuttavia,
se il rapporto di compressione diminuisce,
.I compress
scarta  la tabella di sottostringhe e la ricostruisce da capo.  Questo permette 
all'algoritmo di adattarsi al prossimo "blocco" del file.
.PP
Notare che il flag 
.B \-b
è omesso per 
.I uncompress,
poiché il parametro dei
.I bit
specificato durante la compressione 
è codificato dentro l'output, assieme a 
un numero magico per assicurare che non venga tentata né la decompressione di dati random né
la recompressione di dati compressi. 
.PP
.ne 8
La quantità di compressione ottenuta dipende dalla grandezza
dell'input, dal numero dei 
.I bit
per codice e dalla distribuzione di sottostringhe comuni.
Tipicamente, un testo come il codice sorgente o un testo inglese
viene accorciato del  50\-60%.
La compressone è generalmente molto migliore di quella raggiunta dalla 
codifica di Huffman  (come quella usata in 
.IR pack ),
o la codifica adattativa di Huffman
.RI ( compact ),
e impiega meno tempo per computare.
.PP
Sotto l'opzione 
.BR \-v ,
viene stampato un messaggio dando la percentuale di riduzione
per ogni file compresso.
.PP
Se viene specificata l'opzione 
.BR \-V ,
vengono stampate su stderr l'attuale versione e opzioni di compilazione.
.PP
Il codice di uscita è normalmente 0;
se l'ultimo file è più grande dopo una (tentata) compressione, il codice è 2;
se capita un errore, il codice è 1.
.SH "VEDERE ANCHE"
pack(1), compact(1)
.SH "DIAGNOSTICA"
Utilizzo: compress [\-dfvcV] [\-b maxbits] [file ...]
.in +8
Sono state specificate opzioni non valide nella riga di comando.
.in -8
Manca il parametro maxbits
.in +8
Maxbits deve seguire
.BR \-b \.
.in -8
.IR file :
non in formato compresso.
.in +8
Il file specificato a 
.I uncompress
non è stato compresso.
.in -8
.IR file :
compresso con 
.I xx
bit, può solo gestire
.I yy
bit
.in +8
.I Il file
è stato compresso con un programma che potrebbe manipolare più 
.I bit
del codice di  compress su questa macchina.
Ricomprimere il file con  meno 
.IR bit \.
.in -8
.IR file :
ha già il suffisso .Z  -- niente cambiamenti
.in +8
Il file si suppone sia già compresso.
Rinomina il file e prova di nuovo.
.in -8
.IR file :
nome del file troppo lungo per aggiungere .Z
.in +8
Il file non può essere compresso perché il suo nome è più lungo di 
12 caratteri.
Rinomina il file e prova di nuovo.
Questo messaggio non capita sui sistemi BSD.
.in -8
.I Il file
esiste già ; vuoi sovrascriverlo (s o n)?
.in +8
Rispondi "y" se vuoi che il file di output venga sostituito; "n" altrimenti.
.in -8
uncompress: input corrotto.
.in +8
Una violazione SIGSEGV è stata rilevata che di solito significa che il file di input è stato
corrotto.
.in -8
Compressione: 
.I "xx.xx%"
.in +8
Percentuale dell'input salvata dalla compressione.
(Rilevante solo per 
.BR \-v \.)
.in -8
-- non è un file regolare: immutato.
.in +8
Quando il file di input non è un file regolare,
(p.e. una directory), viene lasciato 
inalterato.
.in -8
-- ha  
.I xx 
altri links: immutato.
.in +8
Il file di input ha dei link; viene lasciato immutato.  Vedere
.IR ln "(1)"
per ulteriori informazioni.
.in -8
-- file immutato.
.in +8
Nessun salvataggio raggiunto dalla 
compressione.  L'input rimane intatto.
.in -8
.SH "BUG"
Sebbene i files compressi siano compatibili tra macchine con la memoria grande,
.BR \-b \12
dovrebbe essere usato per il trasferimento di file verso  architetture con 
un piccolo spazio per i dati del processo (64KB o meno, come mostrato dalle macchine della serie  DEC PDP, dall'Intel 80286, ecc.)
