This is Info file guile-programmer.info, produced by Makeinfo version
1.67 from the input file guile-programmer.texi.

INFO-DIR-SECTION Guile -- GNU extension language
START-INFO-DIR-ENTRY
* guile-programmer: (guile-programmer).         The Guile Programmer's Manual.
END-INFO-DIR-ENTRY

   Guile Programmer's Manual Copyright (C) 1996 Cygnus Support

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: guile-programmer.info,  Node: Top,  Next: What goes in this manual,  Prev: (dir),  Up: (dir)

The Guile Programmers Manual
****************************

* Menu:

* What goes in this manual::
* Guile Tk reference::
* Guile Posix reference::
* Guile threads reference::
* Libguile - high level interface reference::
* Libguile - low level interface reference::
* Where to find more Guile/Scheme resources::
* Concept Index::
* Procedure Index::
* Types Variables Constants::

 -- The Detailed Node Listing --

What goes in this manual

* What does NOT go in this manual::
* Other notes::

Guile Tk reference

* Guile Tk reference


Guile Posix reference

* Posix preliminaries::
* I/O extensions to standard Scheme::
* Posix system and library calls::
* UNIX system and library calls::

Guile threads reference

* Low level thread primitives::
* Higher level thread procedures::

Libguile - high level interface reference

* gh preliminaries::
* Data types and constants defined by gh::
* Starting and controlling the interpreter::
* Error messages::
* Executing Scheme code::
* Defining new Scheme procedures in C::
* Converting data between C and Scheme::
* Type predicates::
* Equality predicates::
* Memory allocation and garbage collection::
* Calling Scheme procedures from C::
* Mixing gh and scm APIs::

Converting data between C and Scheme

* C to Scheme::
* Scheme to C::

Libguile - low level interface reference

* Organization and paradigms::
* Data types::
* Starting the interpreter::

Where to find more Guile/Scheme resources

* Online resources::
* Books and papers::
* Other documents shipped with Guile::


File: guile-programmer.info,  Node: What goes in this manual,  Next: Guile Tk reference,  Prev: Top,  Up: Top

What goes in this manual
************************

   You might be wondering why there are two separate manuals for Guile.

   It is customary to split the documentation for major packages into a
*user manual* (a gentle and introductory document) and a *reference
manual*.  Sometimes people go a step farther and make a separate
*tutorial*; other times the tutorial is part of the user manual.

   In this framekwork, what you are supposed to do is: use the user
manual until you have understood all that it has to offer you, and then
use the reference manual for the rest of your life (except when you are
teaching).

   This *Guile Programmer's Manual* is indeed a *reference manual*, so
I assume that you know everything that's in the *Guile User Manual*,
and you are using this manual to look up the exact detailed
specification of what a procedure does, or what a variable means.

* Menu:

* What does NOT go in this manual::
* Other notes::


File: guile-programmer.info,  Node: What does NOT go in this manual,  Next: Other notes,  Up: What goes in this manual

What does NOT go in this manual
===============================

   You will find that this Programmer's Manual is mostly filled with
detailed reference on what each procedure that Guile adds to Scheme.
More precisely: in a reductionist view, Guile could be viewed as a sum
of its parts:
     guile   =       standard Scheme (R4RS)
             PLUS    extensions to R4RS offered by SCM
             PLUS    some extra primitives offered by Guile
             PLUS    portable Scheme library (SLIB)
             PLUS    embeddable Scheme interpreter library (libguile)
             PLUS    high level interface to libguile (gh)
             PLUS    Tk toolkit
             PLUS    threads
             PLUS    Posix library (goonix)
             PLUS    OpenGL library (mesa)
             PLUS    OpenGL toolkit (glut)
             PLUS    Regular expression library (rx)
             PLUS    Applet formalism
             PLUS    Tcl library

   So a complete reference on Guile would have to describe the tools
given to the programmer by *each of these aspects of Guile!*

   Fortunately many of these things have already been documented
elsewhere, so we will skip them; some (like Tk) are described
elsewhere, but there are language-related subtelties when they are used
with Guile, so we document Tk here.

   We will completely leave out the documentation of standard Scheme,
SLIB, mesa, glut and Tcl.

   The bibliography in the Programmer's Manual is the same as that in
the User manual (*note Where to find more Guile/Scheme resources::.).


File: guile-programmer.info,  Node: Other notes,  Prev: What does NOT go in this manual,  Up: What goes in this manual

Other notes
===========

   Other notes.


File: guile-programmer.info,  Node: Guile Tk reference,  Next: Guile Posix reference,  Prev: What goes in this manual,  Up: Top

Guile Tk reference
******************

* Menu:


* Guile Tk reference

   This is a very minimal discussion of the Scheme interface to the Tk
and Tcl libraries.  These procedures are documented only for the sake of
completeness: the Guile interface to Tk will almost certainly be
completely overhauled soon.

 - Tk: tk-init-main-window
     bla


File: guile-programmer.info,  Node: Guile Posix reference,  Next: Guile threads reference,  Prev: Guile Tk reference,  Up: Top

Guile Posix reference
*********************

* Menu:

* Posix preliminaries::
* I/O extensions to standard Scheme::
* Posix system and library calls::
* UNIX system and library calls::


File: guile-programmer.info,  Node: Posix preliminaries,  Next: I/O extensions to standard Scheme,  Up: Guile Posix reference

Posix preliminaries
===================

   Guile offers a *posix-compliant* (`John S. Quarterman and Susanne
Willhelm: "UNIX, POSIX, and Open Systems", Addison-Wesley Publishing
Co, Inc. 1993') library for systems programming in Scheme.  It allows
the Scheme programmer to use the same calls available to C programmers
in a posix environment.

   This chapter is written assuming that you are running the *Guile*
program directly.  If you are writing a C program instead, and linking
with *libguile*, you can follow the instructions in *Note Libguile -
high level interface reference:: to initialize Posix correctly, and
then follow this section when you write Scheme code.

   Unlike the Tk package, no special Scheme code is required to
initialize Posix: all Posix procedures are primitive, and available as
long as Posix has been initialized with the correct libguile calls.

   When documenting the procedures in this chapter, I use the convention
[ARG] to indicate that the argument is optional, and [ARGS ...] to
indicate that the optional argument can be repeated.

   You will notice that most of these procedures closely mirror the
equivalent UNIX system or library calls.  If you want to know more
detail about how these procedures behave, you can read the relevant UNIX
man page.


File: guile-programmer.info,  Node: I/O extensions to standard Scheme,  Next: Posix system and library calls,  Prev: Posix preliminaries,  Up: Guile Posix reference

I/O extensions to standard Scheme
=================================

   These *I/O Extensions* to Scheme provide many of the UNIX file
system calls, thus allowing sophisticated file manipulation and
directory traversal.  This is mostly done using UNIX's `stdio' layer,
rather than the raw `open', `read', `write' layer.

   Standard I/O *file pointers* are directly translated to Scheme
*ports*.  Ports are described in great detail in all the Scheme
references (*note Guile User Manual: (guile-user)Where to find more
Guile/Scheme resources.), so I will simply remind you that an input
port is a Scheme object which can deliver characters, and an output
port is a Scheme object which can accept characters.  It is OK to think
of ports as file pointers, even though there are some subtelties in
ports related to Scheme's unique control structure.

   In the following read/write routines, if PORT is omitted, standard
input (or standard output) is assumed.

 - I/O Extensions: read-line [PORT]
     Reads a line of text from the given input port, and returns the
     string.  If PORT is not specified, standard input is assumed.

 - I/O Extensions: read-line! STR [PORT]
     A destructive version of the above: puts the string in STR; return
     value is unspecified.

 - I/O Extensions: write-line OBJ [PORT]
     Writes a representation of OBJ to PORT.  If port is not specified,
     it is assumed to be standard output.

 - I/O Extensions: ftell PORT
     Returns the current seek pointer of the given port.

 - I/O Extensions: fseek PORT OFFSET WHENCE
     Sets the seek pointer for PORT to the position OFFSET.  If WHENCE
     is 0, that offset is with respect to the beginning of the file.
     If WHENCE is 1, the offset is with respect to the current
     position.  If WHENCE is 2, the offset is with respect to the end
     of the file.

 - I/O Extensions: freopen FILENAME MODES PORT
     Opens FILENAME with the specified MODES, and associates PORT with
     that file.

 - I/O Extensions: duplicate-port OLD-PORT MODES
     Returns a new port having the same open file as OLD-PORT.

 - I/O Extensions: redirect-port INTO-PORT FROM-PORT
     Redirects I/O from FROM-PORT to INTO-PORT: from here on, INTO-PORT
     will refer to the same file as FROM-PORT.  If INTO-PORT already
     refers to an open file, it will be closed.

 - I/O Extensions: opendir DIRNAME
     Opens the directory DIRNAME, returning a directory port which can
     be used with `readdir' and `closedir'.

 - I/O Extensions: readdir DIRP
     Gets the next file name from the directory port DIRP.

 - I/O Extensions: rewinddir DIRP
     Repositions the directory port DIRP to the beginning of the stream.

 - I/O Extensions: closedir DIRP
     Closes the directory port DIRP.

 - I/O Extensions: mkdir DIRNAME [MODE]
     Makes a new directory with name DIRNAME.  The directory
     permissions are given by the optional argument MODE, or by the
     current UMASK if MODE is not specified.

 - I/O Extensions: rmdir DIRNAME
     Removes the directory with path DIRNAME.

 - I/O Extensions: chdir PATH
     Changes the current working directory to PATH.

 - I/O Extensions: getcwd
     Returns a string with the current working directory.

 - I/O Extensions: chmod FILENAME MODE
     Sets the permission mode on FILENAME to MODE.

 - I/O Extensions: utime PATH [ACTIME [MODTIME]]
     Sets the access and modification times of the file at PATH.  The
     time values ACTIME and MODTIME are given in standard UNIX time:
     the number of seconds since 00:00:00 GMT, Jan. 1 1970.  If ACTIME
     and MODTIME are not given, the current time is used.

 - I/O Extensions: umask [MASK-VALUE]
     Sets the user's `umask' to be the specified value MASK-VALUE.  The
     new setting is returned.  If no MASK-VALUE is given, `umask' will
     return the current setting.

     Notice that the UNIX `umask' command interprets the MASK-VALUE to
     be an octal integer, whereas the Guile `umask' call does not make
     any such conversion, so you have to explicitly tell Scheme to use
     an octal radix, or think about permissions in decimal!

 - I/O Extensions: rename OLD-FNAME NEW-FNAME
     Renames the file from OLD-FNAME to NEW-FNAME.  This is analogous
     to the UNIX `mv' command and the `rename' system call.

 - I/O Extensions: fileno PORT
     Returns the integer file descriptor associated with PORT.  In case
     of error, `#f' is returned.

 - I/O Extensions: isatty PORT
     Returns `#t' if the port is associated with a terminal device, and
     `#f' otherwise.

 - I/O Extensions: fdopen FD TYPE
     Returns an I/O port associated with the numeric file descriptor FD
     (which is assumed to be already open).  The TYPE argument is a
     standard I/O character string specifying whether the file should be
     opened for reading, writing, or appending:
                    r         open for reading
          
                    w         truncate or create for writing
          
                    a         append: open for writing at end of  file,  or
                              create for writing
          
                    r+        open for update (reading and writing)
          
                    w+        truncate or create for update
          
                    a+        append; open or create for update at EOF

 - I/O Extensions: primitive-move->fdes PORT FD
     Moves the file descriptor that underlies PORT to the given value
     FD.

     Returns `#f' for error, 0 if the file descriptor is already equal
     to FD, and 1 if the file descriptor is successfully moved.

 - I/O Extensions: access PATH HOW
     Determines the accessibility of the file in PATH.  The HOW
     variable can take on any of the following values:
                    R_OK           test for read permission
          
                    W_OK           test for write permission
          
                    X_OK           test for execute or search permission
          
               The following value may also be supplied for mode:
          
                    F_OK           test whether the directories leading  to
                                   the  file  can  be searched and the file
                                   exists.

 - I/O Extensions: stat FILENAME
     Gets typical UNIX *stat* information on FILENAME, and returns that
     information in a Scheme vector, where the UNIX `stat' structure
     values are stored in the following order: `#(st_dev st_ino st_mode
     st_nlink st_uid st_gid st_rdev st_size st_atime st_mtime st_ctime
     st_blksize st_blocks)'

 - I/O Extensions: getpid
     Returns the current process ID.

 - I/O Extensions: putenv STR
     Takes a string STR of the form `"VARIABLE=value"' and adds that to
     the user's environment.


File: guile-programmer.info,  Node: Posix system and library calls,  Next: UNIX system and library calls,  Prev: I/O extensions to standard Scheme,  Up: Guile Posix reference

Posix system and library calls
==============================

 - POSIX Calls: chown PATH OWNER GROUP
     Changes the ownership of PATH to the specified OWNER and GROUP.

 - POSIX Calls: link OLDPATH NEWPATH
     Adds NEWPATH as a hard link to OLDPATH.

 - POSIX Calls: pipe
     Creates a pipe, and returns a Scheme pair with the *read* port in
     its `car' and the *write* port in its *cdr*.  If the pipe creation
     fails, `pipe' returns `#f'.

 - POSIX Calls: open-pipe PIPE-STR MODE
     Opens a pipe to a new process by running PIPE-STR, and returns a
     port which can be used to write to the process (if MODE is `"w"')
     or read from it (if MODE is `"r"').

 - POSIX Calls: open-input-pipe PIPE-STR
     A shortcut for running `(open-pipe pipe-str "r")'.

 - POSIX Calls: open-output-pipe PIPE-STR
     A shortcut for running `(open-pipe pipe-str "w")'.

 - POSIX Calls: getgroups
     Returns a vector with all the supplementary group IDs of the
     current user process.

 - POSIX Calls: getpwuid [NAME]
     Given the login-name or uid in NAME, `getpwuid' returns a vector
     with the following data: `#(login-name password uid gid GEGOS
     home-dir shell)'.

     If NAME is not specified, the first entry in the password file is
     returned (or the *next* entry, upon successive invocations).

 - POSIX Calls: setpwent [ARG]
     If called with an argument, `setpwent' rewinds the password file so
     the next call to `getpwuid' will start from the beginning.

     Without arguments, `setpwent' will close the password file; it can
     be used when processing is complete.

 - POSIX Calls: getgrgid [WHICH-GROUP]
     If the argument WHICH-GROUP (either the group name or the gid) is
     given, `getgrgid' returns the group file entry for that group.  If
     WHICH-GROUP is not given, the first entry in the group file is
     returned (or the *next* entry, upon successive invocations).

 - POSIX Calls: setgrent [ARG]
     This is analogous to `setpwent', but for the group file.

     If called with an argument, `setgrent' rewinds the group file so
     the next call to `getgrgid' will start from the beginning.

     Without arguments, `setgrent' will close the group file; it can be
     used when processing is complete.

 - POSIX Calls: kill PID SIG
     Sends a signal SIG to the process PID.  The possible values for
     SIG are the usual UNIX signal types.  Notice the order of
     arguments: this is the order of the UNIX `kill' system call, not
     the order of the `kill' command usually typed at the shell.

 - POSIX Calls: waitpid PID [OPTIONS]
     Waits for some or all child processes to exit or return a status.

     If PID is -1, `waitpid' will wait on any of its children.  This is
     equivalent to the traditional UNIX `wait' system call.

     If PID is greater than 0, `waitpid' will wait on that particular
     child process.

     If PID is equal to 0, `waitpid' will wait on any children in its
     own process group.

     If PID is less than -1, `waitpid' will wait on any children in the
     process group of the particular child `abs(pid)'.

     The OPTIONS argument is a bitwise OR of any of the flags:

          WNOHANG Tells `waitpid' to not suspend if status is not
          immediately available for one of the relevant child processes.


          WUNTRACED Also reports status of children that are stopped
          and have not yet been reported.

     The value returned by `waitpid' is a Scheme pair of the child pid
     and the status returned for that child.

 - POSIX Calls: getppid
     Returns the process id of the current process's parent.

 - POSIX Calls: getuid
 - POSIX Calls: geteuid
 - POSIX Calls: getgid
 - POSIX Calls: getegid
     Returns the real or effective user or group id of the current
     process.

 - POSIX Calls: setuid ID
 - POSIX Calls: seteuid ID
 - POSIX Calls: setgid ID
 - POSIX Calls: setegid ID
     Sets the real or effective user or group id of the current process.

 - POSIX Calls: ttyname PORT
     Returns a string with the path of the terminal device associated
     with the PORT, or `#f' if the device is not a terminal.  Notice
     how this also serves the function of the UNIX `isatty()' call.

 - POSIX Calls: execl COMMAND-STR [EXEC-ARGS ...]
 - POSIX Calls: execlp COMMAND-STR [EXEC-ARGS ...]
     Similar to `execl', except that if FILENAME does not contain a
     slash it searches for the file in the directories listed in the
     `PATH' environment variable.

     execlp is similar, but returns `#f' if an error occurs.

 - POSIX Calls: fork
     This is a raw interface to the UNIX `fork()' system call.  It
     creates a new process with the same core image as the current
     process.  `fork' returns `#f' upon failure; otherwise the child
     gets a return value of 0, and the parent gets the child's pid.

     See the UNIX `fork' man page for some of the subtelties of `fork'
     (open file descriptors, directory streams, semaphores, TMS_
     values, file locks, ...).

 - POSIX Calls: select READS WRITES EXCEPTS SECS MSECS
     The `select' call is used to examine a set of file descriptors
     (passed as Scheme lists of non-negative integers in READFDS,
     WRITEFDS and EXCEPTFDS).

     The purpose of this examination is to determine if the descriptors
     are ready for the requested operation (reading or writing or
     treatment of exception).  The return value is a list of 3 lists;
     the three lists are the original lists stripped down to only the
     *ready* file descriptors.

     A timeout can be specified (in seconds plus miliseconds) with the
     SECS and MSECS are used.


 - POSIX Calls: uname
     This is an interface to the UNIX `uname()' system call.  Upon
     successful completion it returns a list of 5 strings describing the
     system name and OS version: `(list OSname nodename OSrelease
     OSversion MachineType)'.  Upon failure it returns `#f'.

 - POSIX Calls: environ [ENV-LIST]
     With no argument, returns the current environment as a Scheme list
     of `"VAR=val"' strings.  It can be called with a list of
     `"VAR=val"' strings, and then the environment will be set to those
     values.


File: guile-programmer.info,  Node: UNIX system and library calls,  Prev: Posix system and library calls,  Up: Guile Posix reference

UNIX system and library calls
=============================

 - UNIX Calls: mknod PATH MODE DEV
     Creates a new file named by the string PATH.  The file permissions
     are specified in MODE, and some special *file type* bits can also
     be OR-ed in (see the `mknod()' man page for details on the file
     type bits).

     The DEV argument is ignored unless MODE is a block or character
     special file, in which case DEV is a *configuration-dependent
     specification of a character or block I/O device*.

 - UNIX Calls: acct PATH
     Turns on or off process accounting.  The accounting information
     will be reported in the file named by the string PATH.  If PATH is
     `#f', accounting will be turned off.

     Must be super user to use this call.

 - UNIX Calls: nice INCREMENT
     Changes the *nice* value of a UNIX process by INCREMENT (remember:
     a large nice value means *less* priority).  Only the super user
     can set a negative increment.

     The value of INCREMENT should be between -20 and 20; if it is
     outside these bounds it will be silently adjusted to the extreme
     value.

 - UNIX Calls: sync
     Schedules a write to disk of all information in core memory that
     should be on disk, such as super blocks, inodes and buffered disk
     I/O.

 - UNIX Calls: symlink OLDPATH NEWPATH
     Makes NEWPATH be a symbolic link to OLDPATH.

 - UNIX Calls: readlink PATH
     Returns a string with the *contents of the symlink* at PATH.  The
     *contents* is the path to the real file.  Returs `#f' on any error
     condition.

 - UNIX Calls: lstat PATH
     Like `stat' except that if PATH is a symlink, `lstat' will return
     information about the symlink, whereas `stat' will look at the
     referenced file.  The rationale behind this is that symlinks
     should be transparent to the traditional UNIX file system calls,
     but extra calls (like `lstat' and `readlink') are provided to get
     more information.


File: guile-programmer.info,  Node: Guile threads reference,  Next: Libguile - high level interface reference,  Prev: Guile Posix reference,  Up: Top

Guile threads reference
***********************

   *[NOTE: this chapter was written for Cygnus Guile and has not yet
been updated for the Guile 1.0 release.]*

   Here is a the reference for Guile's threads.  In this chapter I
simply quote verbatim Tom Lord's description of the low-level primitives
written in C (basically an interface to the POSIX threads library) and
Anthony Green's description of the higher-level thread procedures
written in scheme.

   When using Guile threads, keep in mind that each guile thread is
executed in a new dynamic root.

* Menu:

* Low level thread primitives::
* Higher level thread procedures::


File: guile-programmer.info,  Node: Low level thread primitives,  Next: Higher level thread procedures,  Up: Guile threads reference

Low level thread primitives
===========================

 - Function: with-new-thread THUNK ERROR-THUNK
     Evaluate (THUNK) in a new thread, and new dynamic context,
     returning a new thread object representing the thread.

     If an error occurs during evaluation, call error-thunk, passing it
     an error code describing the condition.  [Error codes are currently
     meaningless integers.  In the future, real values will be
     specified.] If this happens, the error-thunk is called outside the
     scope of the new root - it is called in the same dynamic context
     in which with-new-thread was evaluated, but not in the callers
     thread.

     All the evaluation rules for dynamic roots apply to threads.

 - Function: join-thread THREAD
     Suspend execution of the calling thread until the target THREAD
     terminates, unless the target THREAD has already terminated.

 - Function: yield
     If one or more threads are waiting to execute, calling yield
     forces an immediate context switch to one of them. Otherwise,
     yield has no effect.

 - Function: make-mutex
     Create a new mutex object.

 - Function: lock-mutex MUTEX
     Lock MUTEX. If the mutex is already locked, the calling thread
     blocks until the mutex becomes available. The function returns when
     the calling thread owns the lock on MUTEX.

 - Function: unlock-mutex MUTEX
     Unlocks MUTEX if the calling thread owns the lock on MUTEX.
     Calling unlock-mutex on a mutex not owned by the current thread
     results in undefined behaviour. Once a mutex has been unlocked,
     one thread blocked on MUTEX is awakened and grabs the mutex lock.


File: guile-programmer.info,  Node: Higher level thread procedures,  Prev: Low level thread primitives,  Up: Guile threads reference

Higher level thread procedures
==============================

 - Function: with-new-thread THUNK ERROR-THUNK
     Evaluate (THUNK) in a new thread, and new dynamic context,
     returning a new thread object representing the thread.

     If an error occurs during evaluation, call error-thunk, passing it
     an error code describing the condition.  [Error codes are currently
     meaningless integers.  In the future, real values will be
     specified.] If this happens, the error-thunk is called outside the
     scope of the new root - it is called in the same dynamic context
     in which with-new-thread was evaluated, but not in the callers
     thread.

     All the evaluation rules for dynamic roots apply to threads.

 - Function: join-thread THREAD
     Suspend execution of the calling thread until the target THREAD
     terminates, unless the target THREAD has already terminated.

 - Function: yield
     If one or more threads are waiting to execute, calling yield
     forces an immediate context switch to one of them. Otherwise,
     yield has no effect.

 - Function: make-mutex
     Create a new mutex object.

 - Function: lock-mutex MUTEX
     Lock MUTEX. If the mutex is already locked, the calling thread
     blocks until the mutex becomes available. The function returns when
     the calling thread owns the lock on MUTEX.

 - Function: unlock-mutex MUTEX
     Unlocks MUTEX if the calling thread owns the lock on MUTEX.
     Calling unlock-mutex on a mutex not owned by the current thread
     results in undefined behaviour. Once a mutex has been unlocked,
     one thread blocked on MUTEX is awakened and grabs the mutex lock.


File: guile-programmer.info,  Node: Libguile - high level interface reference,  Next: Libguile - low level interface reference,  Prev: Guile threads reference,  Up: Top

Libguile - high level interface reference
*****************************************

   The Guile interpreter is essentially Aubrey Jaffer's *SCM*
interpreter (*note SCM: a portable Scheme interpreter: (scm)Overview.)
with some modifications to make it suitable as an embedded interpreter.

   Part of the modification has been to provide a restricted interface
to limit access to the SCM internals; this is called the `gh_'
interface, or *libguile* interface.

   If you are *programming with Guile*, you should only use the C
subroutines described in this manual, which all begin with `gh_'.

   If instead you are *extending Guile*, you have the entire SCM source
to play with.  This manual will not help you at all, but you can
consult Aubrey Jaffer's SCM manual (*note SCM: a portable Scheme
interpreter: (scm)Internals.).

   If you are *adding a module to Guile*, I recommend that you stick to
the `gh_' interface: this interface is guaranteed to not change
drastically, while the SCM internals might change as Guile is developed.

* Menu:

* gh preliminaries::
* Data types and constants defined by gh::
* Starting and controlling the interpreter::
* Error messages::
* Executing Scheme code::
* Defining new Scheme procedures in C::
* Converting data between C and Scheme::
* Type predicates::
* Equality predicates::
* Memory allocation and garbage collection::
* Calling Scheme procedures from C::
* Mixing gh and scm APIs::


File: guile-programmer.info,  Node: gh preliminaries,  Next: Data types and constants defined by gh,  Up: Libguile - high level interface reference

gh preliminaries
================

   To use gh, you must have the following toward the beginning of your C
source:
     #include <guile/gh.h>

   When you link, you will have to add at least `-lgh -lguile' to the
list of libraries.  If you are using more of Guile than the basic Scheme
interpreter, you will have to add more libraries.

   * If you use the *Tk toolkit*, add `-lgtcltk -ltk -ltcl -lX11'.

   * If you use the posix library *goonix*, add `-lgoonix' [NOTE:
     currently goonix is bundled with `-lguile', but they will be split
     eventually].

   * If you use the *C syntax for Scheme*, add `-lctax'.

   * If you use the *threads package*, add `-lthreads'.

   If you use these extra packages, make sure you look at *Note
Starting and controlling the interpreter::: it will show you what
startup code you need to initialize each of these extra libraries.
[NOTE: this is in a state of flux right now.]


File: guile-programmer.info,  Node: Data types and constants defined by gh,  Next: Starting and controlling the interpreter,  Prev: gh preliminaries,  Up: Libguile - high level interface reference

Data types and constants defined by gh
======================================

   The following C constants and data types are defined in gh:

 - Data type: SCM
     This is a C data type used to store all Scheme data, no matter
     what the Scheme type.  Values are converted between C data types
     and the SCM type with utility functions described below (*note
     Converting data between C and Scheme::.).

 - Constant: SCM_BOOL_T
 - Constant: SCM_BOOL_F

 - Constant: SCM_UNSPECIFIED


File: guile-programmer.info,  Node: Starting and controlling the interpreter,  Next: Error messages,  Prev: Data types and constants defined by gh,  Up: Libguile - high level interface reference

Starting and controlling the interpreter
========================================

   In almost every case, your first `gh_' call will be

 - Function: void gh_enter (int argc, char *argv[], void (*main_prog)())
     Starts up a Scheme interpreter with all the standard packages.
     `gh_enter()' never exits, and the user's code should all be in the
     `main_prog()' function.  `argc' and `argv' will be passed to
     `main_prog'.

      - Function: void main_prog (int argc, char *argv[])
          This is the user's main program.  It will be invoked by
          `gh_enter()' after Guile has been started up.



File: guile-programmer.info,  Node: Error messages,  Next: Executing Scheme code,  Prev: Starting and controlling the interpreter,  Up: Libguile - high level interface reference

Error messages
==============

   [*NOT YET EVEN IN THE DESIGN; skip this section for now*]

   If a routine returns a value of type `GH_status', we can get a
human-readable representation of what the error condition was by
invoking:

 - Function: char * gh_error_msg (GH_status status)
     This routine returns a string which can be printed directly.  Note
     that the string will be trashed and reallocated with the next
     invocation of `gh_error_msg'.  Here's the typical example of the
     use of `GH_status':
          status = gh_some_function_returning_status(...);
          if (status != GH_OK) {
            fputs(gh_error_msg(status), stderr);
            fputc('\n', stderr);
            exit(1);
          }

   Here is how the various possible error codes are defined in `gscm.h':
     #define GH_OK                         0
     #define GH_QUIT                       1
     #define GH_RESTART                    2
     #define GH_ILLEGALLY_REENTERED        3
     #define GH_OUT_OF_MEM                 4
     #define GH_ERROR_OPENING_FILE         5
     #define GH_ERROR_OPENING_INIT_FILE    6


File: guile-programmer.info,  Node: Executing Scheme code,  Next: Defining new Scheme procedures in C,  Prev: Error messages,  Up: Libguile - high level interface reference

Executing Scheme code
=====================

   Once you have an interpreter running, you can ask it to evaluate
Scheme code.  There are two calls that implement this:

 - Function: void gh_eval_str (char *Scheme_code)
     This asks the interpreter to evaluate a single line of Scheme code.

     Note that the line of code in SCHEME_CODE must be a well formed
     Scheme expression.  If you have many lines of code you must either
     concatenate them into one string, or use `gh_eval_file()'.

 - Function: void gh_eval_file (char *fname)
     Completely analogous to `gh_eval_str()', except that a whole file
     is evaluated instead of a string.


File: guile-programmer.info,  Node: Defining new Scheme procedures in C,  Next: Converting data between C and Scheme,  Prev: Executing Scheme code,  Up: Libguile - high level interface reference

Defining new Scheme procedures in C
===================================

   The real interface between C and Scheme comes when you can write new
Scheme procedures in C.  This is done through the routine

 - Libguile high: SCM gh_new_procedure (char *PROC_NAME, SCM (*FN)(),
          int N_REQUIRED_ARGS, int N_OPTIONAL_ARGS, int RESTP)
     `gh_new_procedure' defines a new Scheme procedure.  Its Scheme name
     will be PROC_NAME, it will be implemented by the C function
     (*FN)(), it will take at least N_REQUIRED_ARGS arguments, and at
     most N_OPTIONAL_ARGS extra arguments.

     When the RESTP parameter is 1, the procedure takes a final
     argument: a list of remaining parameters.

     `gh_new_procedure' returns an SCM value representing the procedure.

     The C function FN should have the form

      - Libguile high: SCM fn (SCM REQ1, SCM REQ2, ..., SCM OPT1, SCM
               OPT2, ..., SCM REST_ARGS)
          The arguments are all passed as SCM values, so the user will
          have to use the conversion functions to convert to standard C
          types.

          Examples of C functions used as new Scheme primitives can be
          found in the sample programs `learn0' and `learn1'.


   *Rationale:* this is the correct way to define new Scheme procedures
in C.  The ugly mess of arguments is required because of how C handles
procedures with variable numbers of arguments.

   *Note:* what about documentation strings?

   There are several important considerations to be made when writing
the C routine (*FN)().

   First of all the C routine has to return type `SCM'.

   Second, all arguments passed to the C funcion will be of type `SCM'.

   Third: the C routine is now subject to Scheme flow control, which
means that it could be interrupted at any point, and then reentered.
This means that you have to be very careful with operations such as
allocating memory, modifying static data ...

   Fourth: to get around the latter issue, you can use `GH_DEFER_INTS'
and `GH_ALLOW_INTS'.

 - Macro: GH_DEFER_INTS
 - Macro: GH_ALLOW_INTS
     These macros disable and reenable Scheme's flow control.  They


File: guile-programmer.info,  Node: Converting data between C and Scheme,  Next: Type predicates,  Prev: Defining new Scheme procedures in C,  Up: Libguile - high level interface reference

Converting data between C and Scheme
====================================

   Guile provides mechanisms to convert data between C and Scheme.  This
allows new builtin procedures to understand their arguments (which are
of type `SCM') and return values of type `SCM'.

* Menu:

* C to Scheme::
* Scheme to C::


File: guile-programmer.info,  Node: C to Scheme,  Next: Scheme to C,  Up: Converting data between C and Scheme

C to Scheme
-----------

 - Function: SCM gh_bool (int x)
     Returns `#f' if x is zero, `#t' otherwise.

 - Function: SCM gh_ulong2scm (unsigned long x)
 - Function: SCM gh_long2scm (long x)
 - Function: SCM gh_double2scm (double x)
 - Function: SCM gh_char2scm (char x)
 - Function: SCM gh_str2scm (char *x, int len)
 - Function: SCM gh_str02scm (char *x)
     Returns a Scheme object with the value of the C quantity X.


File: guile-programmer.info,  Node: Scheme to C,  Prev: C to Scheme,  Up: Converting data between C and Scheme

Scheme to C
-----------

 - Function: int gh_scm2bool (SCM obj)
 - Function: unsigned long gh_scm2ulong (SCM obj)
 - Function: long gh_scm2long (SCM obj)
 - Function: double gh_scm2double (SCM obj)
 - Function: int gh_scm2char (SCM obj)
 - Function: void gh_scm2str (char **str_out, int *len_out, SCM *obj)
 - Function: void gh_scm2str0 (char **str_out, int *len_out, SCM *obj)
     These routines convert the Scheme object to the given C type.

     Note the distinction between the *str* and *str0*: the former
     returns with C null-terminated strings; the latter returns a Scheme
     string.

     Also note that the string procedures take a pointer to the Scheme
     object OBJ, and that they return the string in a volatile location
     *STR_OUT.


File: guile-programmer.info,  Node: Type predicates,  Next: Equality predicates,  Prev: Converting data between C and Scheme,  Up: Libguile - high level interface reference

Type predicates
===============

 - Function: int gh_boolean_p (SCM val)
     Returns 1 if VAL is a boolean, 0 otherwise.

 - Function: int gh_symbol_p (SCM val)
     Returns 1 if VAL is a symbol, 0 otherwise.

 - Function: int gh_char_p (SCM val)
     Returns 1 if VAL is a char, 0 otherwise.

 - Function: int gh_vector_p (SCM val)
     Returns 1 if VAL is a vector, 0 otherwise.

 - Function: int gh_pair_p (SCM val)
     Returns 1 if VAL is a pair, 0 otherwise.

 - Function: int gh_procedure_p (SCM val)
     Returns 1 if VAL is a procedure, 0 otherwise.

 - Function: int gh_list_p (SCM val)
     Returns 1 if VAL is a list, 0 otherwise.

 - Function: int gh_inexact_p (SCM val)
     Returns 1 if VAL is an inexact number, 0 otherwise.

 - Function: int gh_exact_p (SCM val)
     Returns 1 if VAL is an exact number, 0 otherwise.


File: guile-programmer.info,  Node: Equality predicates,  Next: Memory allocation and garbage collection,  Prev: Type predicates,  Up: Libguile - high level interface reference

Equality predicates
===================

 - Function: int gh_eq_p (SCM x, SCM y)
     Returns 1 if X and Y are equal in the sense of Scheme's `eq?'
     predicate, 0 otherwise.

 - Function: int gh_eqv_p (SCM x, SCM y)
     Returns 1 if X and Y are equal in the sense of Scheme's `eqv?'
     predicate, 0 otherwise.

 - Function: int gh_equal_p (SCM x, SCM y)
     Returns 1 if X and Y are equal in the sense of Scheme's `equal?'
     predicate, 0 otherwise.


File: guile-programmer.info,  Node: Memory allocation and garbage collection,  Next: Calling Scheme procedures from C,  Prev: Equality predicates,  Up: Libguile - high level interface reference

Memory allocation and garbage collection
========================================

 - Function: SCM gh_mkarray (int size)
     Allocate memory for a Scheme object in a garbage-collector-friendly
     manner.


File: guile-programmer.info,  Node: Calling Scheme procedures from C,  Next: Mixing gh and scm APIs,  Prev: Memory allocation and garbage collection,  Up: Libguile - high level interface reference

Calling Scheme procedures from C
================================

   Many of the Scheme primitives are available in the `gh_' interface;
they take and return objects of type SCM, and one could basically use
them to write C code that mimics Scheme code.

   I will list these routines here without much explanation, since what
they do is the same as documented in *Note R4RS: (r4rs)Standard
Procedures.  But I will point out that when a procedure takes a
variable number of arguments (such as `gh_list'), you should pass the
constant SCM_EOL from C to signify the end of the list.

 - Function: SCM gh_define (char *name, SCM val)
     Corresponds to the Scheme `(define name val)': it binds a value to
     the given name (which is a C string).

 - Function: SCM gh_cons (SCM a, SCM b)

 - Macro: SCM GH_LIST (SCM L0, SCM L1, ... , GH_EOL_MARKER)
     These correspond to the Scheme `(cons a b)' and `(list l0 l1 ...)'
     procedures.

 - Function: SCM gh_ilength (SCM ls)
     Returns the length of the list.

 - Function: SCM gh_set_car (SCM obj, SCM val)
 - Function: SCM gh_set_cdr (SCM obj, SCM val)
     These correspond to the Scheme `(set-car! ...)' and `(set-cdr!
     ...)' procedures.

 - Function: SCM gh_car (SCM obj)
 - Function: SCM gh_cdr (SCM obj)
     ...

 - Function: SCM gh_c[ad][ad][ad][ad]r (SCM obj)
     These correspond to the Scheme `(caadar ls)' procedures etc ...

 - Function: SCM gh_symbol (SCM str, SCM len)
 - Function: SCM gh_tmp_symbol (SCM str, SCM len)
     Takes the given string STR of length LEN and returns a symbol
     corresponding to that string.

 - Function: SCM gh_vector (SCM n, SCM fill)
 - Function: SCM gh_vref (SCM v, SCM i)
 - Function: SCM gh_vset (SCM v, SCM i, SCM val)
 - Function: SCM gh_vector_length (SCM v)
     These correspond to the Scheme `(vector n fill)', `(vref v i)' and
     `(vset v i value)' `(vector-length v)' procedures.

 - Function: SCM gh_make_subr (SCM (*fn)(), int req, int opt, int varp,
          char *doc
 - Function: SCM gh_curry (SCM proc, SCM first_arg)
     These routines create new Scheme procedures; the first form
     corresponds to `(lambda (...) (...))'; the second curries a
     procedure by fixing the first argument.

 - Function: SCM gh_apply (SCM proc, SCM args)
     Corresponds to the Scheme `(apply proc args ...)'

 - Function: SCM gh_catch (SCM key, SCM thunk, SCM handler)
 - Function: SCM gh_throw (SCM key, SCM args)
     Corresponds to the Scheme `catch' and `throw' procedures, which in
     Guile are provided as primitives.

 - Function: SCM gh_is_eq (SCM a, SCM b)
 - Function: SCM gh_is_eqv (SCM a, SCM b)
 - Function: SCM gh_is_equal (SCM a, SCM b)
     These correspond to the Scheme `eq?', `eqv?' and `equal?'
     predicates.

 - Function: int gh_obj_length (SCM obj)
     Returns the raw object length.


File: guile-programmer.info,  Node: Mixing gh and scm APIs,  Prev: Calling Scheme procedures from C,  Up: Libguile - high level interface reference

Mixing gh and scm APIs
======================


File: guile-programmer.info,  Node: Libguile - low level interface reference,  Next: Where to find more Guile/Scheme resources,  Prev: Libguile - high level interface reference,  Up: Top

Libguile - low level interface reference
****************************************

   This chapter documents the lower-level interface to libguile, also
called the `scm_' interface.  It has evolved from Aubrey Jaffer's SCM
interpreter (*note SCM: a portable scheme interpreter: (scm)Overview.),
but has now divered, so the Guile API has to be documented separately.

   The place for the `scm_' interface is when the `gh_' interface is
not sufficient bla...

* Menu:

* Organization and paradigms::
* Data types::
* Starting the interpreter::


File: guile-programmer.info,  Node: Organization and paradigms,  Next: Data types,  Up: Libguile - low level interface reference

Organization and paradigms
==========================


File: guile-programmer.info,  Node: Data types,  Next: Starting the interpreter,  Prev: Organization and paradigms,  Up: Libguile - low level interface reference

Data types
==========


File: guile-programmer.info,  Node: Starting the interpreter,  Prev: Data types,  Up: Libguile - low level interface reference

Starting the interpreter
========================

   [I just put in one function to sort get it going and get something in
the function index.]

 - Function: static int scm_boot_guile (SCM_STACKITEM *base, char
          **result, int argc, char **argv, FILE *in, FILE *out, FILE
          *err, void (*init_func)(), char *boot_cmd)
     Starts up a Scheme interpterter ... bla ... meaning of arguments
     ... all the work is really done by scm_boot_guile_1()...


File: guile-programmer.info,  Node: Where to find more Guile/Scheme resources,  Next: Concept Index,  Prev: Libguile - low level interface reference,  Up: Top

Where to find more Guile/Scheme resources
*****************************************

* Menu:

* Online resources::
* Books and papers::
* Other documents shipped with Guile::


File: guile-programmer.info,  Node: Online resources,  Next: Books and papers,  Up: Where to find more Guile/Scheme resources

Online resources
================

*[FSF]*
     The Free Software Foundation home page `http://www.gnu.ai.mit.edu/'

*[R4RS]*
     William Clinger and Jonathan Rees, Editors.  Revised(4) Report on
     the Algorithmic Language Scheme.  In `ACM Lisp Pointers IV'
     (July-September 1991).

     This can be found at URL
     `http://www-swiss.ai.mit.edu/~jaffer/r4rs_toc.html' *Note
     Revised(4) Report on the Algorithmic Language Scheme:
     (r4rs)Standard procedures.

*[SCM]*
     Aubrey Jaffer.  SCM: a Portable Scheme Interpreter.  Version 1a5,
     April 1994.

     This can be found at URL
     `http://www-swiss.ai.mit.edu/~jaffer/scm_toc.html'; the reference
     is *Note Overview: (scm)Overview.

*[SLIB]*
     Todd R. Eigenschink, Dave Love, and Aubrey Jaffer.  SLIB, The
     Portable Scheme Library.  Edition 2.01, for SLIB version 2a2,
     January 1995.

     This can be found at URL
     `http://www-swiss.ai.mit.edu/~jaffer/slib_toc.html'.  The reference
     is *Note Overview: (slib)Overview.

*[JACAL]*
     Aubrey Jaffer.  JACAL Symbolic Mathematics System.  Version 1a5,
     April 1994.

     This can be found at URL
     `http://www-swiss.ai.mit.edu/~jaffer/jacal_toc.html'.  The
     reference is *Note Overview: (jacal)Overview.

*[GNUDL]*
     The Gnudl documentation can be found at
     `http://nis-www.lanl.gov/~rosalia/mydocs/', and the anonymous ftp
     directory with the latest Gnudl snapshot is
     `ftp://nis-ftp.lanl.gov/pub/users/rosalia/'

*[INTRO]*
     An online introduction to Scheme.  Brief, easy, gives a flavor for
     the language.  It can be found at
     `ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/intro.txt'

*[GUILE-USER]*
*[GUILE-PROGRAMMER]*
     The online master version of this documentation can be found at URL
     `http://nis-www.lanl.gov/~rosalia/mydocs/'

*[GUILE-MAILING-LIST]*
     The hypermail archive of the (misnamed) GEL mailing list:
     <gel@cygnus.com> can be found at `http://www.cygnus.com/ml/guile/'

*[TCL-WAR]*
     The network traffic triggered by Stallman's article "Why you
     should not use Tcl"; can be found at URL
     `http://www.utdallas.edu/acc/glv/Tcl/war/'

*[GUILE-PLANS]*
     The network traffic triggered by Stallman's article "GNU Extension
     Language Plans"; can be found at URL
     `http://www.utdallas.edu/acc/glv/Tcl/war2/'

*[LORD-GUILE-PAPER]*
     Tom Lord's technical paper on Guile can be found at
     `http://www.cygnus.com/library/ctr/guile.html'

*[YAHOO-SCHEME]*
     Yahoo Scheme index
     `http://www.yahoo.com/Computers/Languages/Scheme/'

*[YAHOO-TCL]*
     Yahoo Tcl/Tk index
     `http://www.yahoo.com/Computers/Languages/Tcl_Tk/'

*[JAFFER]*
     Aubrey Jaffer's home page `http://www-swiss.ai.mit.edu/~jaffer/'

*[GALASSI]*
     Mark Galassi's home page, `http://nis-www.lanl.gov/~rosalia/'

*[POSIX]*
     The POSIX programmer's guide
     `http://intertain.com/store/POSIX_desc.html'

*[YAHOO-OpenGL]*
     Yahoo OpenGL index
     `http://www.yahoo.com/Computers_and_Internet/Graphics/OpenGL/'

*[GLUT]*
     The GLUT home page
     `http://reality.sgi.com/employees/mjk_asd/glut3/glut3.html'

*[STK]*
     The STk home page, at URL `http://kaolin.unice.fr/html/STk.html'

*[SURFIT]*
     The Surfit! home page, at URL `http://pastime.anu.edu.au/SurfIt/'

*[SCSH]*
     The SCSH home page, at URL
     `http://www-swiss.ai.mit.edu/scsh/scsh.html'


File: guile-programmer.info,  Node: Books and papers,  Next: Other documents shipped with Guile,  Prev: Online resources,  Up: Where to find more Guile/Scheme resources

Books and papers
================

*[IEEE]*
     `IEEE Standard 1178-1990.  IEEE Standard for the Scheme
     Programming Language.'  IEEE, New York, 1991.

*[SICP]*
     Harold Abelson and Gerald Jay Sussman with Julie Sussman.
     `Structure and Interpretation of Computer Programs.' MIT Press,
     Cambridge, 1985.

*[Simply]*
     Brian Harvey and Matthew Wright.  `Simply Scheme: Introducing
     Computer Science' MIT Press, 1994 ISBN 0-262-08226-8

*[SchemeAndArt]*
     George Springer and Daniel P. Friedman.  `Scheme and the Art of
     Programming' MIT Press and McGraw-Hill, 1989 ISBN 0-262-19288-8
     (MIT Press) ISBN 0-07-060522-X (McGraw-Hill).

*[LittleSchemer]*
     Daniel P. Friedman and Matthias Felleisen.  `The Little Schemer.'
     MIT Press, Cambridge, 1996 ISBN 0-262-56099-2.

*[SeasonedSchemer]*
     Daniel P. Friedman and Matthias Felleisen.  `The Seasoned Schemer.'
     MIT Press, Cambridge, 1996 ISBN 0-262-56100-X.

*[AdvancedProgrammingUNIX]*
     W. Richard Stevens.  `Advanced Programming in the UNIX
     Environment.' Addison Wesley, Reading, Massachussetts, 1992 ISBN
     0-201-56317-7.

*[UNIXThreads]*
     Charles J. Northrup.  `Programming with UNIX Threads.' Wiley, New
     York, 1996 ISBN 0-471-13751-0.


File: guile-programmer.info,  Node: Other documents shipped with Guile,  Prev: Books and papers,  Up: Where to find more Guile/Scheme resources

Other documents shipped with Guile
==================================

   Guile ships with many other documents, beyond the User and Programmer
manuals.  You can find them in miscellaneous subdirectories of
`$srcdir/doc' in the Guile distribution.  Some of these are useful,
others are hopelessly out of date.


File: guile-programmer.info,  Node: Concept Index,  Next: Procedure Index,  Prev: Where to find more Guile/Scheme resources,  Up: Top

Concept Index
*************

* Menu:

* arguments:                             Posix preliminaries.
* bibliography:                          What does NOT go in this manual.
* converting data:                       Converting data between C and Scheme.
* data conversion:                       Converting data between C and Scheme.
* documentation:                         What goes in this manual.
* dynamic roots:                         Guile threads reference.
* error messages in libguile:            Error messages.
* exclusions form manual:                What does NOT go in this manual.
* executing Scheme:                      Executing Scheme code.
* extending Guile:                       Libguile -- high level interface reference.
* extensions to R4RS:                    What does NOT go in this manual.
* extensions to standard Scheme:         What does NOT go in this manual.
* gh:                                    Libguile -- high level interface reference.
* gh - headers:                          gh preliminaries.
* gh - linking:                          gh preliminaries.
* gh - reference manual:                 Libguile -- high level interface reference.
* gh_ interface:                         Libguile -- high level interface reference.
* GNU Extension Language:                What goes in this manual.
* goonix:                                Posix preliminaries.
* Green, Anthony:                        Guile threads reference.
* Guile:                                 What goes in this manual.
* Guile - extending:                     Libguile -- high level interface reference.
* Guile threads:                         Guile threads reference.
* I/O extensions:                        I/O extensions to standard Scheme.
* Jaffer, Aubrey:                        Libguile -- high level interface reference.
* libguile <1>:                          Libguile -- low level interface reference.
* libguile:                              Libguile -- high level interface reference.
* libguile - converting data:            Converting data between C and Scheme.
* libguile - data types:                 Data types and constants defined by gh.
* libguile - error messages:             Error messages.
* libguile - executing Scheme:           Executing Scheme code.
* libguile - new procedures:             Defining new Scheme procedures in C.
* libguile - start interpreter:          Starting and controlling the interpreter.
* libguile interface:                    Libguile -- high level interface reference.
* Lord, Tom:                             Guile threads reference.
* new primitives:                        Defining new Scheme procedures in C.
* new procedures:                        Defining new Scheme procedures in C.
* ports:                                 I/O extensions to standard Scheme.
* Posix:                                 Posix preliminaries.
* posix calls:                           Posix system and library calls.
* Posix compliance:                      Posix preliminaries.
* Posix initialization:                  Posix preliminaries.
* posix threads:                         Guile threads reference.
* primitives, new:                       Defining new Scheme procedures in C.
* procedures, new:                       Defining new Scheme procedures in C.
* reference manual:                      What goes in this manual.
* references:                            What does NOT go in this manual.
* Scheme extensions:                     What does NOT go in this manual.
* scm:                                   Libguile -- low level interface reference.
* scm - reference manual:                Libguile -- low level interface reference.
* SCM data type:                         Data types and constants defined by gh.
* SCM internals:                         Libguile -- high level interface reference.
* SCM interpreter:                       Libguile -- high level interface reference.
* system calls:                          UNIX system and library calls.
* threads:                               Guile threads reference.
* tutorial:                              What goes in this manual.
* UNIX library calls:                    UNIX system and library calls.
* UNIX system calls:                     UNIX system and library calls.
* user manual:                           What goes in this manual.
* user versus programmer's manual:       What goes in this manual.


File: guile-programmer.info,  Node: Procedure Index,  Next: Types Variables Constants,  Prev: Concept Index,  Up: Top

Procedure Index
***************

   This is an alphabetical list of all the procedures and macros in
Guile.

* Menu:

* access:                                I/O extensions to standard Scheme.
* acct:                                  UNIX system and library calls.
* chdir:                                 I/O extensions to standard Scheme.
* chmod:                                 I/O extensions to standard Scheme.
* chown:                                 Posix system and library calls.
* closedir:                              I/O extensions to standard Scheme.
* duplicate-port:                        I/O extensions to standard Scheme.
* environ:                               Posix system and library calls.
* execl:                                 Posix system and library calls.
* execlp:                                Posix system and library calls.
* fdopen:                                I/O extensions to standard Scheme.
* fileno:                                I/O extensions to standard Scheme.
* fn:                                    Defining new Scheme procedures in C.
* fork:                                  Posix system and library calls.
* freopen:                               I/O extensions to standard Scheme.
* fseek:                                 I/O extensions to standard Scheme.
* ftell:                                 I/O extensions to standard Scheme.
* getcwd:                                I/O extensions to standard Scheme.
* getegid:                               Posix system and library calls.
* geteuid:                               Posix system and library calls.
* getgid:                                Posix system and library calls.
* getgrgid:                              Posix system and library calls.
* getgroups:                             Posix system and library calls.
* getpid:                                I/O extensions to standard Scheme.
* getppid:                               Posix system and library calls.
* getpwuid:                              Posix system and library calls.
* getuid:                                Posix system and library calls.
* GH_ALLOW_INTS:                         Defining new Scheme procedures in C.
* gh_apply:                              Calling Scheme procedures from C.
* gh_bool:                               C to Scheme.
* gh_boolean_p:                          Type predicates.
* gh_c:                                  Calling Scheme procedures from C.
* gh_car:                                Calling Scheme procedures from C.
* gh_catch:                              Calling Scheme procedures from C.
* gh_cdr:                                Calling Scheme procedures from C.
* gh_char2scm:                           C to Scheme.
* gh_char_p:                             Type predicates.
* gh_cons:                               Calling Scheme procedures from C.
* gh_curry:                              Calling Scheme procedures from C.
* GH_DEFER_INTS:                         Defining new Scheme procedures in C.
* gh_define:                             Calling Scheme procedures from C.
* gh_double2scm:                         C to Scheme.
* gh_enter:                              Starting and controlling the interpreter.
* gh_eq_p:                               Equality predicates.
* gh_equal_p:                            Equality predicates.
* gh_eqv_p:                              Equality predicates.
* gh_error_msg:                          Error messages.
* gh_eval_file:                          Executing Scheme code.
* gh_eval_str:                           Executing Scheme code.
* gh_exact_p:                            Type predicates.
* gh_ilength:                            Calling Scheme procedures from C.
* gh_inexact_p:                          Type predicates.
* gh_is_eq:                              Calling Scheme procedures from C.
* gh_is_equal:                           Calling Scheme procedures from C.
* gh_is_eqv:                             Calling Scheme procedures from C.
* gh_list_p:                             Type predicates.
* gh_long2scm:                           C to Scheme.
* gh_make_subr:                          Calling Scheme procedures from C.
* gh_mkarray:                            Memory allocation and garbage collection.
* gh_new_procedure:                      Defining new Scheme procedures in C.
* gh_obj_length:                         Calling Scheme procedures from C.
* gh_pair_p:                             Type predicates.
* gh_procedure_p:                        Type predicates.
* gh_scm2bool:                           Scheme to C.
* gh_scm2char:                           Scheme to C.
* gh_scm2double:                         Scheme to C.
* gh_scm2long:                           Scheme to C.
* gh_scm2str:                            Scheme to C.
* gh_scm2str0:                           Scheme to C.
* gh_scm2ulong:                          Scheme to C.
* gh_set_car:                            Calling Scheme procedures from C.
* gh_set_cdr:                            Calling Scheme procedures from C.
* gh_str02scm:                           C to Scheme.
* gh_str2scm:                            C to Scheme.
* gh_symbol:                             Calling Scheme procedures from C.
* gh_symbol_p:                           Type predicates.
* gh_throw:                              Calling Scheme procedures from C.
* gh_tmp_symbol:                         Calling Scheme procedures from C.
* gh_ulong2scm:                          C to Scheme.
* gh_vector:                             Calling Scheme procedures from C.
* gh_vector_length:                      Calling Scheme procedures from C.
* gh_vector_p:                           Type predicates.
* gh_vref:                               Calling Scheme procedures from C.
* gh_vset:                               Calling Scheme procedures from C.
* isatty:                                I/O extensions to standard Scheme.
* join-thread <1>:                       Higher level thread procedures.
* join-thread:                           Low level thread primitives.
* kill:                                  Posix system and library calls.
* link:                                  Posix system and library calls.
* lock-mutex <1>:                        Higher level thread procedures.
* lock-mutex:                            Low level thread primitives.
* lstat:                                 UNIX system and library calls.
* main_prog:                             Starting and controlling the interpreter.
* make-mutex <1>:                        Higher level thread procedures.
* make-mutex:                            Low level thread primitives.
* mkdir:                                 I/O extensions to standard Scheme.
* mknod:                                 UNIX system and library calls.
* nice:                                  UNIX system and library calls.
* open-input-pipe:                       Posix system and library calls.
* open-output-pipe:                      Posix system and library calls.
* open-pipe:                             Posix system and library calls.
* opendir:                               I/O extensions to standard Scheme.
* pipe:                                  Posix system and library calls.
* primitive-move->fdes:                  I/O extensions to standard Scheme.
* putenv:                                I/O extensions to standard Scheme.
* read-line:                             I/O extensions to standard Scheme.
* read-line!:                            I/O extensions to standard Scheme.
* readdir:                               I/O extensions to standard Scheme.
* readlink:                              UNIX system and library calls.
* redirect-port:                         I/O extensions to standard Scheme.
* rename:                                I/O extensions to standard Scheme.
* rewinddir:                             I/O extensions to standard Scheme.
* rmdir:                                 I/O extensions to standard Scheme.
* SCM:                                   Calling Scheme procedures from C.
* scm_boot_guile:                        Starting the interpreter.
* select:                                Posix system and library calls.
* setegid:                               Posix system and library calls.
* seteuid:                               Posix system and library calls.
* setgid:                                Posix system and library calls.
* setgrent:                              Posix system and library calls.
* setpwent:                              Posix system and library calls.
* setuid:                                Posix system and library calls.
* stat:                                  I/O extensions to standard Scheme.
* symlink:                               UNIX system and library calls.
* sync:                                  UNIX system and library calls.
* tk-init-main-window:                   Guile Tk reference.
* ttyname:                               Posix system and library calls.
* umask:                                 I/O extensions to standard Scheme.
* uname:                                 Posix system and library calls.
* unlock-mutex <1>:                      Higher level thread procedures.
* unlock-mutex:                          Low level thread primitives.
* utime:                                 I/O extensions to standard Scheme.
* waitpid:                               Posix system and library calls.
* with-new-thread <1>:                   Higher level thread procedures.
* with-new-thread:                       Low level thread primitives.
* write-line:                            I/O extensions to standard Scheme.
* yield <1>:                             Higher level thread procedures.
* yield:                                 Low level thread primitives.


File: guile-programmer.info,  Node: Types Variables Constants,  Prev: Procedure Index,  Up: Top

Types Variables Constants
*************************

   This is an alphabetical list of all the important data types,
variables and constants defined in the Guile Programmer's Manual.
Note: you should also look at the indices in the Guile User Manual.

* Menu:

* GH_ERROR_OPENING_FILE:                 Error messages.
* GH_ERROR_OPENING_INIT_FILE:            Error messages.
* GH_ILLEGALLY_REENTERED:                Error messages.
* GH_OK:                                 Error messages.
* GH_OUT_OF_MEM:                         Error messages.
* GH_QUIT:                               Error messages.
* GH_RESTART:                            Error messages.
* SCM:                                   Data types and constants defined by gh.
* SCM_BOOL_F:                            Data types and constants defined by gh.
* SCM_BOOL_T:                            Data types and constants defined by gh.
* SCM_UNSPECIFIED:                       Data types and constants defined by gh.



Tag Table:
Node: Top1026
Node: What goes in this manual2658
Node: What does NOT go in this manual3719
Node: Other notes5390
Node: Guile Tk reference5554
Node: Guile Posix reference6031
Node: Posix preliminaries6347
Node: I/O extensions to standard Scheme7769
Node: Posix system and library calls14745
Node: UNIX system and library calls21130
Node: Guile threads reference23241
Node: Low level thread primitives24030
Node: Higher level thread procedures25825
Node: Libguile - high level interface reference27626
Node: gh preliminaries29235
Node: Data types and constants defined by gh30308
Node: Starting and controlling the interpreter31002
Node: Error messages31819
Node: Executing Scheme code33118
Node: Defining new Scheme procedures in C33949
Node: Converting data between C and Scheme36297
Node: C to Scheme36799
Node: Scheme to C37338
Node: Type predicates38211
Node: Equality predicates39224
Node: Memory allocation and garbage collection39864
Node: Calling Scheme procedures from C40270
Node: Mixing gh and scm APIs43297
Node: Libguile - low level interface reference43495
Node: Organization and paradigms44229
Node: Data types44416
Node: Starting the interpreter44604
Node: Where to find more Guile/Scheme resources45201
Node: Online resources45539
Node: Books and papers49067
Node: Other documents shipped with Guile50495
Node: Concept Index50953
Node: Procedure Index55523
Node: Types Variables Constants65508

End Tag Table
