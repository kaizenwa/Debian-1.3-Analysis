@node Libguile -- high level interface reference
@chapter Libguile -- high level interface reference
@cindex libguile
@cindex gh
@cindex gh - reference manual

The Guile interpreter is essentially Aubrey Jaffer's @emph{SCM}
interpreter (@pxref{Overview, SCM: a portable Scheme interpreter,
Overview, scm, SCM: a portable Scheme interpreter}) with some
modifications to make it suitable as an embedded interpreter.
@cindex SCM interpreter
@cindex Jaffer, Aubrey

Part of the modification has been to provide a restricted interface to
limit access to the SCM internals; this is called the @code{gh_}
interface, or @emph{libguile} interface.
@cindex gh_ interface
@cindex libguile interface

If you are @emph{programming with Guile}, you should only use the C
subroutines described in this manual, which all begin with
@code{gh_}.

If instead you are @emph{extending Guile}, you have the entire SCM
source to play with.  This manual will not help you at all, but you can
consult Aubrey Jaffer's SCM manual (@pxref{Internals, SCM: a portable
Scheme interpreter, Internals, scm, SCM: a portable Scheme
interpreter}).
@cindex Guile - extending
@cindex extending Guile
@cindex SCM internals

If you are @emph{adding a module to Guile}, I recommend that you stick
to the @code{gh_} interface: this interface is guaranteed to not
change drastically, while the SCM internals might change as Guile is
developed.


@menu
* gh preliminaries::            
* Data types and constants defined by gh::  
* Starting and controlling the interpreter::  
* Error messages::              
* Executing Scheme code::       
* Defining new Scheme procedures in C::  
* Converting data between C and Scheme::  
* Type predicates::             
* Equality predicates::         
* Memory allocation and garbage collection::  
* Calling Scheme procedures from C::  
* Mixing gh and scm APIs::      
@end menu

@node gh preliminaries
@section gh preliminaries

To use gh, you must have the following toward the beginning of your C
source:
@smallexample
#include <guile/gh.h>
@end smallexample
@cindex gh - headers

When you link, you will have to add at least @code{-lgh -lguile} to the
list of libraries.  If you are using more of Guile than the basic Scheme
interpreter, you will have to add more libraries.
@cindex gh - linking

@itemize @bullet
@item
If you use the @emph{Tk toolkit}, add @code{-lgtcltk -ltk -ltcl -lX11}.

@item
If you use the posix library @emph{goonix}, add @code{-lgoonix} [NOTE:
currently goonix is bundled with @code{-lguile}, but they will be split
eventually].

@item
If you use the @emph{C syntax for Scheme}, add @code{-lctax}.

@item
If you use the @emph{threads package}, add @code{-lthreads}.

@end itemize

If you use these extra packages, make sure you look at @ref{Starting and
controlling the interpreter}: it will show you what startup code you
need to initialize each of these extra libraries.  [NOTE: this is in a
state of flux right now.]


@node Data types and constants defined by gh
@section Data types and constants defined by gh
@cindex libguile - data types

The following C constants and data types are defined in gh:

@c @deftp {Data type} GH_status
@c A data type returned by many @code{gh_} routines.  Its value is meant
@c to be interpreted by @code{gh_error_msg()} if it is not
@c @code{GH_OK}.
@c @end deftp

@deftp {Data type} SCM
This is a C data type used to store all Scheme data, no matter what the
Scheme type.  Values are converted between C data types and the SCM type
with utility functions described below (@pxref{Converting data between C
and Scheme}).
@end deftp
@cindex SCM data type

@c @deftp {Constant} GH_OK
@c A constant returned by @code{gh_} calls when there was no error.
@c @end deftp

@defvr Constant SCM_BOOL_T
@defvrx Constant SCM_BOOL_F
@end defvr

@defvr Constant SCM_UNSPECIFIED
@end defvr



@node Starting and controlling the interpreter
@section Starting and controlling the interpreter
@cindex libguile - start interpreter

In almost every case, your first @code{gh_} call will be

@deftypefun void gh_enter (int argc, char *argv[], void (*main_prog)())
Starts up a Scheme interpreter with all the standard packages.
@code{gh_enter()} never exits, and the user's code should all be in the
@code{main_prog()} function.  @code{argc} and @code{argv} will be passed
to @code{main_prog}.

@deftypefun void main_prog (int argc, char *argv[])
This is the user's main program.  It will be invoked by
@code{gh_enter()} after Guile has been started up.
@end deftypefun

@end deftypefun


@node Error messages
@section Error messages
@cindex libguile - error messages
@cindex error messages in libguile

[@strong{NOT YET EVEN IN THE DESIGN; skip this section for now}]

If a routine returns a value of type @code{GH_status}, we can get a
human-readable representation of what the error condition was by
invoking:

@deftypefun {char *} gh_error_msg (GH_status status)
This routine returns a string which can be printed directly.  Note that
the string will be trashed and reallocated with the next invocation of
@code{gh_error_msg}.  Here's the typical example of the use of
@code{GH_status}:
@smallexample
status = gh_some_function_returning_status(...);
if (status != GH_OK) @{
  fputs(gh_error_msg(status), stderr);
  fputc('\n', stderr);
  exit(1);
@}
@end smallexample
@end deftypefun

Here is how the various possible error codes are defined in
@file{gscm.h}:
@smallexample
#define GH_OK                         0
#define GH_QUIT                       1
#define GH_RESTART                    2
#define GH_ILLEGALLY_REENTERED        3
#define GH_OUT_OF_MEM                 4
#define GH_ERROR_OPENING_FILE         5
#define GH_ERROR_OPENING_INIT_FILE    6
@end smallexample
@vindex GH_OK
@vindex GH_QUIT
@vindex GH_RESTART
@vindex GH_ILLEGALLY_REENTERED
@vindex GH_OUT_OF_MEM
@vindex GH_ERROR_OPENING_FILE
@vindex GH_ERROR_OPENING_INIT_FILE



@node Executing Scheme code
@section Executing Scheme code
@cindex libguile - executing Scheme
@cindex executing Scheme

Once you have an interpreter running, you can ask it to evaluate Scheme
code.  There are two calls that implement this:

@deftypefun void gh_eval_str (char *Scheme_code)
This asks the interpreter to evaluate a single line of Scheme code.

Note that the line of code in @var{Scheme_code} must be a well formed
Scheme expression.  If you have many lines of code you must either
concatenate them into one string, or use @code{gh_eval_file()}.
@end deftypefun

@deftypefun void gh_eval_file (char *fname)
Completely analogous to @code{gh_eval_str()}, except that a whole file
is evaluated instead of a string.
@end deftypefun



@node Defining new Scheme procedures in C
@section Defining new Scheme procedures in C
@cindex libguile - new procedures
@cindex new procedures
@cindex procedures, new
@cindex new primitives
@cindex primitives, new

The real interface between C and Scheme comes when you can write new
Scheme procedures in C.  This is done through the routine


@deftypefn {Libguile high} SCM gh_new_procedure (char *@var{proc_name}, SCM (*@var{fn})(), int @var{n_required_args}, int @var{n_optional_args}, int @var{restp})
@code{gh_new_procedure} defines a new Scheme procedure.  Its Scheme name
will be @var{proc_name}, it will be implemented by the C function
(*@var{fn})(), it will take at least @var{n_required_args} arguments,
and at most @var{n_optional_args} extra arguments.

When the @var{restp} parameter is 1, the procedure takes a final
argument: a list of remaining parameters.

@code{gh_new_procedure} returns an SCM value representing the procedure.

The C function @var{fn} should have the form
@deftypefn {Libguile high} SCM fn (SCM @var{req1}, SCM @var{req2}, ..., SCM @var{opt1},  SCM @var{opt2}, ...,  SCM @var{rest_args})
The arguments are all passed as SCM values, so the user will have to use
the conversion functions to convert to standard C types.

Examples of C functions used as new Scheme primitives can be found in
the sample programs @code{learn0} and @code{learn1}.
@end deftypefn

@end deftypefn

@strong{Rationale:} this is the correct way to define new Scheme
procedures in C.  The ugly mess of arguments is required because of how
C handles procedures with variable numbers of arguments.

@strong{Note:} what about documentation strings?

@cartouche
There are several important considerations to be made when writing the C
routine @var{(*fn)()}.

First of all the C routine has to return type @code{SCM}.

Second, all arguments passed to the C funcion will be of type
@code{SCM}.

Third: the C routine is now subject to Scheme flow control, which means
that it could be interrupted at any point, and then reentered.  This
means that you have to be very careful with operations such as
allocating memory, modifying static data @dots{}

Fourth: to get around the latter issue, you can use
@code{GH_DEFER_INTS} and @code{GH_ALLOW_INTS}.
@end cartouche

@defmac GH_DEFER_INTS
@defmacx GH_ALLOW_INTS
These macros disable and reenable Scheme's flow control.  They 
@end defmac


@c [??? have to do this right; maybe using subsections, or maybe creating a
@c section called Flow control issues...]

@c [??? Go into exhaustive detail with examples of the various possible
@c combinations of required and optional args...]

@node Converting data between C and Scheme
@section Converting data between C and Scheme
@cindex libguile - converting data
@cindex data conversion
@cindex converting data

Guile provides mechanisms to convert data between C and Scheme.  This
allows new builtin procedures to understand their arguments (which are
of type @code{SCM}) and return values of type @code{SCM}.


@menu
* C to Scheme::                 
* Scheme to C::                 
@end menu

@node C to Scheme
@subsection C to Scheme

@deftypefun SCM gh_bool (int x)
Returns @code{#f} if x is zero, @code{#t} otherwise.
@end deftypefun

@deftypefun SCM gh_ulong2scm (unsigned long x)
@deftypefunx SCM gh_long2scm (long x)
@deftypefunx SCM gh_double2scm (double x)
@deftypefunx SCM gh_char2scm (char x)
@deftypefunx SCM gh_str2scm (char *x, int len)
@deftypefunx SCM gh_str02scm (char *x)
Returns a Scheme object with the value of the C quantity @var{x}.
@end deftypefun


@c ??? this still needs to be implemented in libgscm.a
@c @deftypefun {char *} scm_stat2scm (struct stat stat_structure)
@c @end deftypefun


@node Scheme to C
@subsection Scheme to C

@deftypefun int gh_scm2bool (SCM obj)
@deftypefunx {unsigned long} gh_scm2ulong (SCM obj)
@deftypefunx long gh_scm2long (SCM obj)
@deftypefunx double gh_scm2double (SCM obj)
@deftypefunx int gh_scm2char (SCM obj)
@deftypefunx void gh_scm2str (char **str_out, int *len_out, SCM *obj)
@deftypefunx void gh_scm2str0 (char **str_out, int *len_out, SCM *obj)
These routines convert the Scheme object to the given C type.

Note the distinction between the @emph{str} and @emph{str0}: the former
returns with C null-terminated strings; the latter returns a Scheme
string.

Also note that the string procedures take a pointer to the Scheme object
@var{obj}, and that they return the string in a volatile location
@var{*str_out}.
@end deftypefun

@node Type predicates
@section Type predicates

@deftypefun int gh_boolean_p (SCM val)
Returns 1 if @var{val} is a boolean, 0 otherwise.
@end deftypefun

@deftypefun int gh_symbol_p (SCM val)
Returns 1 if @var{val} is a symbol, 0 otherwise.
@end deftypefun

@deftypefun int gh_char_p (SCM val)
Returns 1 if @var{val} is a char, 0 otherwise.
@end deftypefun

@deftypefun int gh_vector_p (SCM val)
Returns 1 if @var{val} is a vector, 0 otherwise.
@end deftypefun

@deftypefun int gh_pair_p (SCM val)
Returns 1 if @var{val} is a pair, 0 otherwise.
@end deftypefun

@deftypefun int gh_procedure_p (SCM val)
Returns 1 if @var{val} is a procedure, 0 otherwise.
@end deftypefun

@deftypefun int gh_list_p (SCM val)
Returns 1 if @var{val} is a list, 0 otherwise.
@end deftypefun

@deftypefun int gh_inexact_p (SCM val)
Returns 1 if @var{val} is an inexact number, 0 otherwise.
@end deftypefun

@deftypefun int gh_exact_p (SCM val)
Returns 1 if @var{val} is an exact number, 0 otherwise.
@end deftypefun


@node Equality predicates
@section Equality predicates

@deftypefun int gh_eq_p (SCM x, SCM y)
Returns 1 if @var{x} and @var{y} are equal in the sense of Scheme's
@code{eq?} predicate, 0 otherwise.
@end deftypefun

@deftypefun int gh_eqv_p (SCM x, SCM y)
Returns 1 if @var{x} and @var{y} are equal in the sense of Scheme's
@code{eqv?} predicate, 0 otherwise.
@end deftypefun

@deftypefun int gh_equal_p (SCM x, SCM y)
Returns 1 if @var{x} and @var{y} are equal in the sense of Scheme's
@code{equal?} predicate, 0 otherwise.
@end deftypefun



@node Memory allocation and garbage collection
@section Memory allocation and garbage collection

@c [FIXME: flesh this out with some description of garbage collection in
@c scm/guile]

@deftypefun SCM gh_mkarray (int size)
Allocate memory for a Scheme object in a garbage-collector-friendly
manner.
@end deftypefun


@node Calling Scheme procedures from C
@section Calling Scheme procedures from C

Many of the Scheme primitives are available in the @code{gh_}
interface; they take and return objects of type SCM, and one could
basically use them to write C code that mimics Scheme code.

I will list these routines here without much explanation, since what
they do is the same as documented in @ref{Standard Procedures, R4RS, ,
r4rs, R4RS}.  But I will point out that when a procedure takes a
variable number of arguments (such as @code{gh_list}), you should pass
the constant @var{SCM_EOL} from C to signify the end of the list.

@deftypefun SCM gh_define (char *name, SCM val)
Corresponds to the Scheme @code{(define name val)}: it binds a value to
the given name (which is a C string).
@end deftypefun


@deftypefun SCM gh_cons (SCM a, SCM b)
@end deftypefun
@defmac SCM gh_list (SCM l0, SCM l1, ... , GH_EOL_MARKER)
These correspond to the Scheme @code{(cons a b)} and @code{(list l0 l1
...)} procedures.
@end defmac

@deftypefun SCM gh_ilength (SCM ls)
Returns the length of the list.
@end deftypefun

@deftypefun SCM gh_set_car (SCM obj, SCM val)
@deftypefunx SCM gh_set_cdr (SCM obj, SCM val)
These correspond to the Scheme @code{(set-car! ...)} and @code{(set-cdr!
...)} procedures.
@end deftypefun


@deftypefun SCM gh_car (SCM obj)
@deftypefunx SCM gh_cdr (SCM obj)
@dots{}

@deftypefunx SCM gh_c[ad][ad][ad][ad]r (SCM obj)
These correspond to the Scheme @code{(caadar ls)} procedures etc @dots{}
@end deftypefun

@deftypefun SCM gh_symbol (SCM str, SCM len)
@deftypefunx SCM gh_tmp_symbol (SCM str, SCM len)
Takes the given string @var{str} of length @var{len} and returns a
symbol corresponding to that string.
@end deftypefun

@deftypefun SCM gh_vector (SCM n, SCM fill)
@deftypefunx SCM gh_vref (SCM v, SCM i)
@deftypefunx SCM gh_vset (SCM v, SCM i, SCM val)
@deftypefunx SCM gh_vector_length (SCM v)
These correspond to the Scheme @code{(vector n fill)}, @code{(vref v i)}
and @code{(vset v i value)} @code{(vector-length v)} procedures.
@end deftypefun

@deftypefun SCM gh_make_subr (SCM (*fn)(), int req, int opt, int varp, char *doc
@deftypefunx SCM gh_curry (SCM proc, SCM first_arg)
These routines create new Scheme procedures; the first form corresponds
to @code{(lambda (...) (...))}; the second curries a procedure by fixing
the first argument.
@end deftypefun

@deftypefun SCM gh_apply (SCM proc, SCM args)
Corresponds to the Scheme @code{(apply proc args ...)}
@end deftypefun

@deftypefun SCM gh_catch (SCM key, SCM thunk, SCM handler)
@deftypefunx SCM gh_throw (SCM key, SCM args)
Corresponds to the Scheme @code{catch} and @code{throw} procedures,
which in Guile are provided as primitives.
@end deftypefun

@c [FIXME: must add the I/O section in gscm.h]

@deftypefun SCM gh_is_eq (SCM a, SCM b)
@deftypefunx SCM gh_is_eqv (SCM a, SCM b)
@deftypefunx SCM gh_is_equal (SCM a, SCM b)
These correspond to the Scheme @code{eq?}, @code{eqv?} and @code{equal?}
predicates.
@end deftypefun

@deftypefun int gh_obj_length (SCM obj)
Returns the raw object length.
@end deftypefun

@node Mixing gh and scm APIs
@section Mixing gh and scm APIs
