@node Libguile reference, Concept Index, Guile applet specification, Top
@chapter Libguile reference
@cindex libguile
@cindex libguile - reference manual

The Guile interpreter is essentially Aubrey Jaffer's @emph{SCM}
interpreter (@pxref{Overview, SCM: a portable scheme interpreter,
Overview, scm, SCM: a portable scheme interpreter}) with some
modifications to make it suitable as an embedded interpreter.
@cindex SCM interpreter
@cindex Jaffer, Aubrey

Part of the modification has been to provide a restricted interface to
limit access to the SCM internals; this is called the @code{gscm_}
interface, or @emph{libguile} interface.
@cindex gscm_ interface
@cindex libguile interface

If you are @emph{programming with Guile}, you should only use the C
subroutines described in this manual, which all begin with
@code{gscm_}.

If instead you are @emph{extending Guile}, you have the entire SCM
source to play with.  This manual will not help you at all, but you can
consult Aubrey Jaffer's SCM manual (@pxref{Internals, SCM: a portable
scheme interpreter, Internals, scm, SCM: a portable scheme
interpreter}).
@cindex Guile - extending
@cindex extending Guile
@cindex SCM internals

If you are @emph{adding a module to Guile}, I recommend that you stick
to the @code{gscm_} interface: this interface is guaranteed to not
change drastically, while the SCM internals might change as Guile is
developed.

@menu
* Preliminaries::               
* Data types defined by libguile::  
* Starting and controlling the interpreter::  
* Error messages::              
* Executing scheme code::       
* Defining new scheme procedures in C::  
* Converting data between C and scheme::  
* Memory allocation and garbage collection::  
* Calling scheme procedures from C::  
@end menu

@node Preliminaries, Data types defined by libguile, Libguile reference, Libguile reference
@section Libguile preliminaries

To use libguile, you must have the following toward the beginning of
your C source:
@smallexample
#include <guile/gscm.h>
@end smallexample
@cindex libguile - headers

When you link, you will have to add at least @code{-lguile} to the list
of libraries.  If you are using more of Guile than the basic scheme
interpreter, you will have to add more libraries.
@cindex libguile - linking

@itemize @bullet
@item
If you use the @emph{Tk toolkit}, add @code{-lgtcltk -ltk4.1 -ltcl7.5
-lX11}.

@item
If you use the posix library @emph{goonix}, add @code{-lgoonix}.

@c @item
@c If you use the @emph{C syntax for scheme}, add @code{-lctax}.
@item
If you use the @emph{threads package}, add @code{-lthreads}.

@end itemize

If you use these extra packages, make sure you look at @ref{Starting and
controlling the interpreter}: it will show you what startup code you
need to initialize each of these extra libraries.


@node Data types defined by libguile, Starting and controlling the interpreter, Preliminaries, Libguile reference
@section Data types defined by libguile
@cindex libguile - data types

The following C constants and data types are defined in libguile:

@deftp {Data type} GSCM_status
A data type returned by many @code{gscm_} routines.  Its value is meant
to be interpreted by @code{gscm_error_msg()} if it is not
@code{GSCM_OK}.
@end deftp


@deftp {Data type} GSCM_top_level
The data type used to store information about the scheme top levels.
@end deftp

@deftp {Data type} SCM
This is a C data type used to store all scheme data, no matter what the
scheme type.  Values are converted between C data types and the SCM type
with utility functions described below (@pxref{Converting data between C
and scheme}).
@end deftp
@cindex SCM data type

@deftp {Constant} GSCM_OK
A constant returned by @code{gscm_} calls when there was no error.
@end deftp



@node Starting and controlling the interpreter, Error messages, Data types defined by libguile, Libguile reference
@section Starting and controlling the interpreter
@cindex libguile - start interpreter

In almost every case, your first @code{gscm_} call will be

@deftypefun GSCM_status gscm_run_scm (int argc, char **argv, FILE stdin, FILE stdout, FILE stderr, (GSCM_status init_proc)(), int boh, char *boh)
Starts up a scheme interpreter, passing @var{argc} and @var{argv}, with
the given assignment of @var{stdin}, @var{stdout}, @var{stderr}.  The
routine @code{init_proc()} is invoked to initialize particular Guile
packages.
@end deftypefun

This next batch of routines are the ones that can be included in the
routine @code{init_proc()} passed to @code{gscm_run_scm}.

@deftypefun void gscm_threads_init_all ()
Initializes Guile threads.
@end deftypefun

@c @deftypefun void scm_init_ctax ()
@c Initializes @emph{ctax}, the C-like syntax for Guile.
@c @end deftypefun

@deftypefun void scm_init_unix ()
@end deftypefun
@deftypefun void scm_init_posix ()
@end deftypefun
@deftypefun void scm_init_ioext ()
These three initialize the @emph{posix} library for scheme.
@end deftypefun

@deftypefun void scm_init_gtcl ()
Initializes @emph{tcl} support for Guile.
@end deftypefun

@deftypefun void scm_init_gtk ()
Initializes @emph{Tk} support for Guile.
@end deftypefun

After initializing the interpreter with @code{gscm_run_scm}, you need to
create a top level.  The @emph{top level} variable you obtain will be
used for most future libguile calls.
@cindex top level

@deftypefun GSCM_status gscm_create_top_level (GSCM_top_level *toplev)
This routine creates a top level of the interpreter in which to evaluate
scheme expressions.
@end deftypefun

At the end, when you are done with scheme, you can invoke:

@deftypefun void gscm_destroy_top_level (GSCM_top_level toplev)
This routine releases all the resources associated with that top level,
thus allowing the top level to be garbage collected.
@end deftypefun



@node Error messages, Executing scheme code, Starting and controlling the interpreter, Libguile reference
@section Error messages
@cindex libguile - error messages
@cindex error messages in libguile

If a routine returns a value of type @code{GSCM_status}, we can get a
human-readable representation of what the error condition was by
invoking:

@deftypefun {char *} gscm_error_msg (GSCM_status status)
This routine returns a string which can be printed directly.  Note that
the string will be trashed and reallocated with the next invocation of
@code{gscm_error_msg}.  Here's the typical example of the use of
@code{GSCM_status}:
@smallexample
status = gscm_some_function_returning_status(...);
if (status != GSCM_OK) @{
  fputs(gscm_error_msg(status), stderr);
  fputc('\n', stderr);
  exit(1);
@}
@end smallexample
@end deftypefun

Here is how the various possible error codes are defined in
@file{gscm.h}:
@smallexample
#define GSCM_OK                         0
#define GSCM_QUIT                       1
#define GSCM_RESTART                    2
#define GSCM_ILLEGALLY_REENTERED        3
#define GSCM_OUT_OF_MEM                 4
#define GSCM_ERROR_OPENING_FILE         5
#define GSCM_ERROR_OPENING_INIT_FILE    6
@end smallexample
@vindex GSCM_OK
@vindex GSCM_QUIT
@vindex GSCM_RESTART
@vindex GSCM_ILLEGALLY_REENTERED
@vindex GSCM_OUT_OF_MEM
@vindex GSCM_ERROR_OPENING_FILE
@vindex GSCM_ERROR_OPENING_INIT_FILE



@node Executing scheme code, Defining new scheme procedures in C, Error messages, Libguile reference
@section Executing scheme code
@cindex libguile - executing scheme
@cindex executing scheme

Once you have an interpreter running, and you have created a top level
environment, you can ask the interpreter to evaluate scheme code.  There
are two calls that implement this:

@deftypefun GSCM_status gscm_eval_str (char **answer, GSCM_top_level toplev, char *scheme_code)
This asks the interpreter to evaluate a single line of scheme code.  The
result of the evaluation is placed in the string @var{*answer}.  Note
that answer is @code{malloc}-ed by @code{gscm_eval_str}, so after using
the value of @var{*answer}, you should free it.  If @var{answer} is
NULL, the evaluation result is not returned to the caller

Also note that the line of code in @var{scheme_code} must be a well
formed scheme expression.  If you have many lines of code you must
either concatenate them into one string, or use @code{gscm_eval_file()}.
@end deftypefun

@deftypefun GSCM_status gscm_eval_file (char **answer, GSCM_top_level toplev, char *fname)
Completely analogous to @code{gscm_eval_str()}, except that a whole file
is evaluated instead of a string.
@end deftypefun



@node Defining new scheme procedures in C, Converting data between C and scheme, Executing scheme code, Libguile reference
@section Defining new scheme procedures in C
@cindex libguile - new procedures
@cindex new procedures
@cindex procedures, new
@cindex new primitives
@cindex primitives, new

The real interface between C and scheme comes when you can write new
scheme procedures in C.  This is done through the routine

@deftypefun void gscm_define_procedure (char *name, SCM (*fn)(), int req, int opt, int varp, char *doc)
This routine makes a scheme procedure out the C procedure
@code{(*fn)()}.  The scheme procedure will require @var{req} arguments,
and accept @var{opt} optional arguments.  The procedure will be
documented by the documentation string @var{doc}.  [Note: it is not yet
clear how documentation strings will evolve in Guile.]
@end deftypefun

@cartouche
There are several important considerations to be made when writing the C
routine @var{(*fn)()}.

First of all the C routine has to return type @code{SCM}.

Second, all arguments passed to the C funcion will be of type
@code{SCM}.

Third: the C routine is now subject to scheme flow control, which means
that it could be interrupted at any point, and then reentered.  This
means that you have to be very careful with operations such as
allocating memory, modifying static data @dots{}

Fourth: to get around the latter issue, you can use
@code{GSCM_DEFER_INTS} and @code{GSCM_ALLOW_INTS}.
@end cartouche

@defmac GSCM_DEFER_INTS
@defmacx GSCM_ALLOW_INTS
These macros disable and reenable scheme's flow control.  They 
@end defmac


@c [??? have to do this right; maybe using subsections, or maybe creating a
@c section called Flow control issues...]

@c [??? Go into exhaustive detail with examples of the various possible
@c combinations of required and optional args...]

@node Converting data between C and scheme, Memory allocation and garbage collection, Defining new scheme procedures in C, Libguile reference
@section Converting data between C and scheme
@cindex libguile - converting data
@cindex data conversion
@cindex converting data

Guile provides mechanisms to convert data between C and scheme.  This
allows new builtin procedures to understand their arguments (which are
of type @code{SCM}) and return values of type @code{SCM}.

@menu
* C to scheme::                 
* Scheme to C::                 
@end menu

@node C to scheme, Scheme to C, Converting data between C and scheme, Converting data between C and scheme
@subsection C to scheme

@deftypefun SCM gscm_bool (int x)
Returns @code{#f} if x is zero, @code{#t} otherwise.
@end deftypefun

@deftypefun SCM gscm_ulong (unsigned long x)
@deftypefunx SCM gscm_long (long x)
@deftypefunx SCM gscm_double (double x)
@deftypefunx SCM gscm_char (char x)
@deftypefunx SCM gscm_str (char *x, int len)
@deftypefunx SCM gscm_str0 (char *x)
Returns a scheme object with the value of the C quantity @var{x}.
@end deftypefun


@c ??? this still needs to be implemented in libgscm.a
@c @deftypefun {char *} scm_stat2scm (struct stat stat_structure)
@c @end deftypefun


@node Scheme to C,  , C to scheme, Converting data between C and scheme
@subsection Scheme to C

@deftypefun int gscm_2_bool (SCM obj)
@deftypefunx {unsigned long} gscm_2_ulong (SCM obj)
@deftypefunx long gscm_2_long (SCM obj)
@deftypefunx double gscm_2_double (SCM obj)
@deftypefunx int gscm_2_char (SCM obj)
@deftypefunx void gscm_2_str (char **str_out, int *len_out, SCM *obj)
@deftypefunx void gscm_2_str0 (char **str_out, int *len_out, SCM *obj)
These routines convert the scheme object to the given C type.

Note the distinction between the @emph{str} and @emph{str0}: the former
returns with C null-terminated strings; the latter returns a scheme
string.

Also note that the string procedures take a pointer to the scheme object
@var{obj}, and that they return the string in a volatile location
@var{*str_out}.
@end deftypefun


@node Memory allocation and garbage collection, Calling scheme procedures from C, Converting data between C and scheme, Libguile reference
@section Memory allocation and garbage collection

@c [FIXME: flesh this out with some description of garbage collection in
@c scm/guile]

@deftypefun SCM gscm_mkarray (int size)
Allocate memory for a scheme object in a garbage-collector-friendly
manner.
@end deftypefun


@node Calling scheme procedures from C,  , Memory allocation and garbage collection, Libguile reference
@section Calling scheme procedures from C

Many of the scheme primitives are available in the @code{gscm_}
interface; they take and return objects of type SCM, and one could
basically use them to write C code that mimics scheme code.

I will list these routines here without much explanation, since what
they do is the same as documented in @ref{Standard Procedures, R4RS, ,
r4rs, R4RS}.  But I will point out that when a procedure takes a
variable number of arguments (such as @code{gscm_list}), you should pass
the constant @var{SCM_EOL} from C to signify the end of the list.

@deftypefun SCM gscm_define (char *name, SCM val)
Corresponds to the scheme @code{(define name val)}: it binds a value to
the given name (which is a C string).
@end deftypefun


@deftypefun SCM gscm_cons (SCM a, SCM b)
@deftypefunx SCM gscm_list (SCM l0, SCM l1, ... , GSCM_EOL_MARKER)
These correspond to the scheme @code{(cons a b)} and @code{(list l0 l1
...)} procedures.
@end deftypefun

@deftypefun SCM gscm_ilength (SCM ls)
Returns the length of the list.
@end deftypefun

@deftypefun SCM gscm_set_car (SCM obj, SCM val)
@deftypefunx SCM gscm_set_cdr (SCM obj, SCM val)
These correspond to the scheme @code{(set-car! ...)} and @code{(set-cdr!
...)} procedures.
@end deftypefun


@deftypefun SCM gscm_car (SCM obj)
@deftypefunx SCM gscm_cdr (SCM obj)
@dots{}

@deftypefunx SCM gscm_c[ad][ad][ad][ad]r (SCM obj)
These correspond to the scheme @code{(caadar ls)} procedures etc @dots{}
@end deftypefun

@deftypefun SCM gscm_symbol (SCM str, SCM len)
@deftypefunx SCM gscm_tmp_symbol (SCM str, SCM len)
Takes the given string @var{str} of length @var{len} and returns a
symbol corresponding to that string.
@end deftypefun

@deftypefun SCM gscm_vector (SCM n, SCM fill)
@deftypefunx SCM gscm_vref (SCM v, SCM i)
@deftypefunx SCM gscm_vset (SCM v, SCM i, SCM val)
These correspond to the scheme @code{(vector n fill)}, @code{(vref v i)}
and @code{(vset v i value)} procedures.
@end deftypefun

@deftypefun SCM gscm_make_subr (SCM (*fn)(), int req, int opt, int varp, char *doc
@deftypefunx SCM gscm_curry (SCM proc, SCM first_arg)
These routines create new scheme procedures; the first form corresponds
to @code{(lambda (...) (...))}; the second curries a procedure by fixing
the first argument.
@end deftypefun

@deftypefun SCM gscm_apply (SCM proc, SCM args)
Corresponds to the scheme @code{(apply proc args ...)}
@end deftypefun

@deftypefun SCM gscm_catch (SCM key, SCM thunk, SCM handler)
@deftypefunx SCM gscm_throw (SCM key, SCM args)
Corresponds to the scheme @code{catch} and @code{throw} procedures,
which in Guile are provided as primitives.
@end deftypefun

@c [FIXME: must add the I/O section in gscm.h]

@deftypefun SCM gscm_is_eq (SCM a, SCM b)
@deftypefunx SCM gscm_is_eqv (SCM a, SCM b)
@deftypefunx SCM gscm_is_equal (SCM a, SCM b)
These correspond to the scheme @code{eq?}, @code{eqv?} and @code{equal?}
predicates.
@end deftypefun

@deftypefun int gscm_obj_length (SCM obj)
Returns the raw object length.
@end deftypefun
