\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile.info
@settitle Guile Scheme
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Guile Scheme
@subtitle Version 1.0b0
@subtitle December 1995
@author Tom Lord
@author with excerpts from the SCM manual by Aubrey Jaffer

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995, 1996 Free Software Foundation, Inc.

Copyright @copyright{} 1990, 1991, 1992, 1993, 1994, 1995 Aubrey Jaffer

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@node Top, Copying, (dir), (dir)
@top
@ifinfo

This is the reference manual for Guile Scheme.

@end ifinfo

@menu
* Copying::                     
* Acknowledgements::            
* Booleans::                    
* Characters::                  
* Strings::                     
* Read Only Strings::           
* Shared Substrings::           
* Numbers::                     
* Cons Pairs and Lists::        
* Vectors::                     
* Symbols::                     
* Keywords::                    
* Arbiters::                    
* Procedures::                  
* Ports::                       
* Equality::                    
* Hash Values::                 
* Tag Values::                  
* Dictionaries in General::     
* Weak References::             
* Evaluation::                  
* Exception Handling with Catch and Throw::  
* Dynamic Wind::                
* First-class Variables::       
* eval2; User Defined Top Levels::  
* First-class Modules::         
* Recursive Namespaces::        
* Declaring Modules::           
* Auto-Loading Modules::        
* Using Emacs and Guile::       
* Records::                     
* Structures::                  
* Arrays::                      
* Object Properties::           
* Low-Level Syntax Extensions::  
* Time::                        
* GC::                          
* Dynamic Roots::               
* System Exceptions::           
* Libc procedures::             
* Procedure and Macro Index::   
* Variable Index::              
@end menu

@node Copying, Acknowledgements, Top, Top
@chapter Copying

@center Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995
@center Free Software Foundation, Inc.
@center 675 Mass Ave, Cambridge, MA 02139, USA

@noindent
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

@center NO WARRANTY

@noindent
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@noindent
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


@node Acknowledgements, Booleans, Copying, Top
@chapter Acknowledgements

@noindent
Guile is derived from SCM, by Aubrey Jaffer and others.  Most of this
section derives from the SCM manual.

@menu
* Guile History::               
* SCM Authors::                 
* Bibliography::                
@end menu

@node Guile History, SCM Authors, Acknowledgements, Acknowledgements
@section Guile History

Here is a very, very brief history of this interpreter.  I hope that
people involved in its past will contribute more to this document.

SIOD:

George Carrette wrote SIOD, the earliest version.  Although most of this
code as been rewritten or replaced over time, the garbage collector from
SIOD is still an important part of Guile.

SIOD is still actively developed and freely available (search for
"siod").  It has a very small footprint.



SCM:

Aubrey Jaffer seriously tuned performance and added features.  He
designed many hairy parts of the tag system and evaluator.  He added and
facilitated the addition of many new run-time primitives and assembled
slib, a useful library of Scheme code.


Guile:

Guile is a GNU volunteer project, initiated by Richard Stallman. The
project has evolved SCM into a library, added some features to make the
interpreter more flexible, and added some new types and extension
packages.  The goal is to make a small, portable, powerfully scalable
extension langauge library.

The name Guile was first suggested in a Usenet discussion by Lee Thomas.


@node SCM Authors, Bibliography, Guile History, Acknowledgements
@section Authors

@table @b
@item Aubrey Jaffer (jaffer@@ai.mit.edu)
Most of SCM.
@item Radey Shouman
Arrays. @code{gsubr}s, compiled closures, and records.
@item Jerry D. Hedden
Real and Complex functions.  Fast mixed type arithmetics.
@item Hugh Secker-Walker
Syntax checking and memoization of special forms by evaluator.  Storage
allocation strategy and parameters.
@item George Carrette
@dfn{Siod}, written by George Carrette, was the starting point for SCM.
The major innovations taken from Siod are the evaluator's use of the
C-stack and being able to garbage collect off the C-stack.
@end table

[Mention Mikael Djurfeldt, Gary Houston, Mark Galassi, Tom Lord, Anthony
Green.]

@noindent
There are many other contributors to SCM.  They are acknowledged in the
file @file{ChangeLog}, a log of changes that have been made to scm.
[This file is called @file{libguile/ChangeLog.scm} in Guile distributions]

@node Bibliography,  , SCM Authors, Acknowledgements
@section Bibliography

@table @asis

@item [IEEE]
@pindex IEEE
@cite{IEEE Standard 1178-1990.  IEEE Standard for the Scheme
Programming Language.}  IEEE, New York, 1991.

@item [Simply]
@pindex Simply
Brian Harvey and Matthew Wright.
@cite{Simply Scheme: Introducing Computer Science}
MIT Press, 1994 ISBN 0-262-08226-8

@item [SICP]
@pindex SICP
Harold Abelson and Gerald Jay Sussman with Julie Sussman.
@cite{Structure and Interpretation of Computer Programs.}
MIT Press, Cambridge, 1985.

@item [R4RS]
@pindex R4RS
William Clinger and Jonathan Rees, Editors.
Revised(4) Report on the Algorithmic Language Scheme.
In @cite{ACM Lisp Pointers IV} (July-September 1991).

@item [SLIB]
@pindex SLIB
Todd R. Eigenschink, Dave Love, and Aubrey Jaffer.

@item [JACAL]
@pindex JACAL
Aubrey Jaffer.
@end table

@table @file
@item scm.texi
@itemx scm.info
Documentation of @code{scm} extensions (beyond Scheme standards).
Documentation on the internal representation and how to extend or
include @code{scm} in other programs.
@end table

@node  Booleans, Characters, Acknowledgements, Top
@chapter Booleans

There are two values which are called booleans, written: 

@example
@code{#t} 	;; used to represent "true"
@code{#f}	;; used to represent "false"
@end example

Only one value in the system, @code{#f} represents "false".
All other values, including @code{#t}, are interpreted as "true".

@defun boolean?   obj
Return @code{#t} only if @var{obj} is either @code{#f} or @code{#t}. 

Otherwise, return @code{#f}
@end defun

@defun not a
@defunx null? obj
Return @code{#t} only if @var{obj} is @code{#f}, @code{#f} otherwise.

In Guile, the "reference to no object", @code{()} or @code{nil}
is the same value as "false", @code{#f}.
@end defun


Boolean values are also important to some special forms such as
@code{if}, @code{cond}, and @code{and}; see @xref{Flow of Control}.


@node Characters, Strings, Booleans, Top
@chapter Characters

Individual character constants are written:

@example
#\<character-name>
@end example

For example, upper-case "A" is written:

@example
#\A
@end example

lower-case:

@example
#\a
@end example

Characters can be written in terms of their ASCII 
representation by using octal numbers:

@example
#\101
 => #\A
@end example

Some special characters are given mnemonic names:

@example
#\space
#\newline
#\nl
#\tab
#\backspace
#\return
#\page
#\null
#\del
@end example

Other special character names include: 

@example
nul soh stx etx eot enq ack bel bs ht vt np cr so 
si dle dc1 dc2 dc3 dc4 nak syn etb can em sub esc 
fs gs rs us
@end example

@defun char?   obj
Return @code{#t} if @var{obj} is a character, @code{#f} otherwise.
@end defun

@defun char=?  &rest objs
@defunx char<? &rest objs
@defunx char<=? &rest objs
@defunx char>? &rest objs
@defunx char>=? &rest objs
@defunx char-ci=? &rest objs
@defunx char-ci<? &rest objs
@defunx char-ci<=? &rest objs
@defunx char-ci>? &rest objs
@defunx char-ci>=? &rest objs
Return @code{#t} if the @var{objs} are in the indicated relation.

The "-ci" forms compare characters without regard to case.
@end defun

@defun char-alphabetic?   obj
@defunx char-numeric?   obj
@defunx char-whitespace?   obj
@defunx char-upper-case?   obj
@defunx char-lower-case?   obj
Return @code{#t} if @var{obj} is a character of the indicated type
@code{#f} otherwise.
@end defun

@defun char->integer   obj
@defunx integer->char   obj
Convert between characters and integers.

All characters have an integer representation, but not
all integers have a character representation.  Only the
16 low-order bits of a character number are significant.

Guile allows characters in the range 0...2^16, but only
values in the range 0...127 are portable.  Values outside
of that range depend on the character set encoding in use
with Guile.
@end defun

@defun char-upcase   obj
@defunx char-downcase   obj
Convert between upper and lower case.

If @var{obj} is not alphabetic, this function returns
its argument.
@end defun

[Internationalization note: extended characters (outside of the range
0..255) are permitted, but classification and case conversion functions
currently operate meaningfully only on the range 0..127.  see
@xref{Character Set Encodings, Character Set Encodings, Character Set
Encodings, ./intspec.info}.]


@node  Strings, Read Only Strings, Characters, Top
@chapter Strings

Strings are sequences of characters.   Strings are written
using double-quotes:

@example
"Strings are used for many purposes in Emacs"
@end example

Strings can include newlines:

@example
"Strings are used for many purposes in Emacs, as can be
expected in a text editor;..."
@end example

Strings can include special "escape sequences" that represent
individual characters:

@example
"as can be\nexpected in a text editor;..."
@end example

Supported escape seqences include:

@example
Escape sequence:			Character:

\0					#\null
\f					#\ack					
\n					#\newline
\r					#\return
\t					#\tab
\a					#\bel
\v					#\vt
@end example


@defun string?   obj
Return @code{#t} if @var{obj} is a string, @var{#f} otherwise.
@end defun

Several string functions address substrings of a string.  This is always
done with a starting and ending position.  All characters from
@code{[start...end-1]} are included in the substring.  If
@code{end<=start}, the substring is empty.  String positions begin with
0.

These functions treat symbols as read-only strings.  If a function
defined in this section does not modify a string argument, then a symbol
can be passed for that argument.  The symbol name is used as the string,
in that case.


@menu
* Making Strings::              
* Examining Strings::           
* Ordering Strings::            
* Internationalization Notes::  
@end menu

@node  Making Strings, Examining Strings, Strings, Strings
@section Making Strings

@defun make-string   length &opt fill
Return a new string of size @var{length}.

If @var{fill} is specified, it should be a character.  The string is
initially @var{length} copies of that character.

There is no default @var{fill}; if no value is specified, the initial
contents of a string are unspecified.
@end defun

@defun string   &rest chars
The arguments, all characters, are concatenated to form a new string.
@end defun

@defun substring   str from to
The addressed substring of @var{str} is copied to form a new string.
@end defun

@defun string-append   &rest objs
The arguments, all strings or symbols, are concatenated to form a new string.
@end defun

@defun string-copy   str
The argument, a string or symbol, is copied to a new string.
@end defun

@defun string->list   str
A list is returned that contains all the characters of @var{str}, in order.
@end defun

@defun list->string   chars
@var{chars} is a list of characters which are concatenated to form a string.
@end defun



@node  Examining Strings, Ordering Strings, Making Strings, Strings
@section Examining Strings

@defun string-length   obj
@defunx length   obj
The number of characters in @var{obj}, a string or symbol, is returned.
@end defun

@defun string-ref   obj index
The @var{index} character of @var{obj}, a string or symbol, is returned.
@end defun

@defun string-set! obj index value
The @var{index} character of @var{obj}, a string, is set to @var{value}.
@end defun

@defun string-null?   obj
Return @code{#t} if @var{obj} is a 0 length string or symbol, @code{#f} otherwise.
@end defun

@defun string-index   str char
@defunx string-rindex   str char
Return the position of the first instance of @var{char} in @var{str}.

@var{str} may be a string or symbol.   @var{#f} is returned if the character
is not found.

@var{index} searches from the start of the string, @var{rindex} from the end.
@end defun

@defun string-fill!   str char
@defunx substring-fill!   str start end char
Set some or all of the characters of the string @var{str} to @var{char}.
@end defun

@defun substring-move-left!   str start end str2 start2
@defunx substring-move-right!  str start end str2 start2
Copy characters from @var{str} to @var{str2}.

The suffixes @code{-left} and @code{-right} refer to the order in which
characters are copied which is significant of @code{str} and @code{str2}
are the same object.
@end defun


@node  Ordering Strings, Internationalization Notes, Examining Strings, Strings
@section Ordering Strings

@defun string=?, &rest objs
@defunx string-ci=?, &rest objs
@defunx string<?, &rest objs
@defunx string<=?, &rest objs
@defunx string>?, &rest objs
@defunx string>=?, &rest objs
@defunx string-ci<?, &rest objs
@defunx string-ci<=?, &rest objs
@defunx string-ci>?, &rest objs
@defunx string-ci>=?, &rest objs
Test for a particular relation among string arguments.

The ordering of strings is lexigraphical, based on the ordering
of characters.
@end defun

@node  Internationalization Notes,  , Ordering Strings, Strings
@section Internationalization Notes

Internationalization support for strings is underway though not yet
done, see @xref{The String Representation Type, The String
Representation Type, The String Representation Type, ./intspec.info}.

@node Read Only Strings, Shared Substrings, Strings, Top
@chapter Read Only Strings

Type-checking in Guile primitives distinguishes between mutable strings
and read only strings.  Mutable strings answer @code{#t} to
@code{string?}  while read only strings may or may not.   All kinds of
strings, whether or not they are mutable return #t to this:

@defun read-only-string? OBJ
Return true of OBJ can be read as a string,

This illustrates the difference between @code{string?} and
@code{read-only-string?}:

@example
(string? "a string") => #t
(string? 'a-symbol") => #f

(read-only-string? "a string") => #t
(read-only-string? 'a-symbol") => #t
@end example
@end defun


"Read only" refers to how the string will be used, not how the string is
permitted to be used.  In particular, all strings are "read only
strings" even if they are mutable, because a function that only reads
from a string can certainly operate on even a mutable string.

Symbols are an example of read only strings.  Many string functions,
such as @code{string-append} are happy to operate on symbols.  Many
functions that expect a string argument, such as @code{open-file}, will
accept a symbol as well.

Another of example of a read-only string is a "shared substring".
Shared substrings are defined in the next chapter.

@node  Shared Substrings, Numbers, Read Only Strings, Top
@chapter Shared Substrings

Whenever you extract a substring using @code{substring}, a new string is
allocated and substring data is copied from the old string to the new
string.

Sometimes, in order avoid the expense of copying, programmers will write programs
that pass around triples:  a string, a starting position within the string, and an
ending position.  This convention is awkward, especially because many useful string
primitives operate only on full strings, not a string with substring indexes.

Guile Scheme offers another way: shared substrings.  A shared substring
is a read-only string built from an older string, and substring indexes
into that older string.  A shared substring is not a copy of the older
string, but shares the older strings data directly.  Compared to copying
substrings, shared substrings are cheap to allocate.


@defun make-shared-substring source-string start-pos ?end-pos?
Return a shared substring of @var{source-string}, 
from @var{start-pos} to @var{end-pos} or the end of the source string

@example
	(define some-string "the quick brown fox")
	(define x (make-shared-substring some-string 4 9))
	x => "quick"

	(string-set! some-string 7 #\r)
	x => "quirk"

	(string? some-string) => #t
	(string? x)
	(read-only-string? some-string) => #t
	(read-only-string? x) => #t

	(define y (make-shared-substring x 2))
	y => "irk"
@end example
@end defun

String operators which mutate their arguments do not work on shared
substrings but most other string operators do work.  For example, if you
want to compare the substring [FROM ... TO - 1] of string A to the
string B, you can use the relatively inexpensive idiom:

@example
(string=? (make-shared-substring A FROM TO) B)
@end example


@node  Numbers, Cons Pairs and Lists, Shared Substrings, Top
@chapter Numbers

Numbers are a distinct type in Guile Scheme.

@defun number?   obj
Return @code{#t} if @var{obj} is a number, @code{#f} otherwise.
@end defun

@defun number->string number &opt radix
@defunx string->number string &opt radix
Convert between numbers and strings.

The syntax of a number for @code{string->number}, which
is also the syntax of how numbers are written in programs,
is illustrated by these examples:

@example
(eq? 10 +10) => #t

(eq? -10 (- 0 10)) => #t

(eq? 10 10.0) => #f
(eq? 10 #e10) => #t   ;; exact 10
(eq? 10.0 #i10) => #t ;; inexact 10 (floating point 10.0)

(eq? #b1010 10) => #t ;; binary
(eq? #xa 10) => #t    ;; hex
(eq? #o12 10) => #t   ;; ocatal
(eq? #d12 10) => #t   ;; decimal

+i		      ;; sqrt of -1
10+4i		      ;; a complex number (currently read as inexact)
1/4		      ;; a fraction (currently read as inexact)
@end example

@end defun


@menu
* Kinds of Numbers and Conversions::  
* Ordering Numbers::            
* Basic Math::                  
* Binary Math ::                
* Transcendental Functions::    
* libc.a Math ::                
@end menu

@node  Kinds of Numbers and Conversions, Ordering Numbers, Numbers, Numbers
@section Kinds of Numbers and Conversions

@defun exact? obj
Return @code{#t} if @var{obj} is an exact number, @code{#f} otherwise.
@end defun

@defun inexact?   obj
Return @code{#t} if @var{obj} is an inexact number, @code{#f} otherwise.
@end defun

@defun inexact->exact   obj
Return the exact number closest to @var{obj}.

Odd multiple of .5 round in the positive direction.
@end defun

@defun exact->inexact obj
Return the inexact number closest to @var{obj}.
@end defun

@defun round obj
Round @var{obj} to the nearest inexact integer.

Odd multiple of .5 round in the positive direction.
@end defun

@defun floor obj
Return the greatest inexact integer less than or equal to @var{obj}.
@end defun

@defun ceiling obj
Return the least inexact integer greater than or equal to @var{obj}.
@end defun


@defun int?   obj
Return @code{#t} if @var{obj} is an integer, @code{#f} otherwise.

This is @code{#t} if whether @var{obj} is exact or inexact.
@end defun

@defun integer?  obj
Return @code{#t} if @var{obj} is an exact integer, @code{#f} otherwise.
@end defun

@defun odd?   obj
@defunx even?   obj
Test the parity of an exact integer.
@end defun

@defun real?   obj
@defunx rational?   obj
True if @var{obj} is a number with no imaginary part (or imaginary part 0).
@end defun


@defun complex?  obj
True for all numbers.
@end defun

@defun make-rectangular   a b
@defunx make-polar   a m
Two ways to construct complex numbers.
@end defun


@defun real-part   obj
@defunx imag-part   obj
@defunx magnitude   obj
@defunx angle   obj
Access to the components of complex numbers.
@end defun


@node  Ordering Numbers, Basic Math, Kinds of Numbers and Conversions, Numbers
@section Ordering Numbers

@defun zero?   obj
@end defun

@defun =? &rest obj1 obj2 ...
@defunx <? &rest obj1 obj2 ...
@defunx >? &rest obj1 obj2 ...
@defunx <=? &rest obj1 obj2 ...
@defunx >=? &rest obj1 obj2 ...
Return true if the arguments are objects in the given relation.

@example
(<? 1 2 3 4) => #t
(<? 1 3 2 4) => #f
@end example
@end defun

@defun positive?   obj
@defunx negative?   obj
Test the sign of @var{obj}.

These always return @code{#f} for 0.
@end defun

@defun max obj &rest obj1 obj2
@defunx min obj &rest obj1 obj2
Return the numeric maximum (or minimum) of the arguments.
@end defun


@node  Basic Math, Binary Math , Ordering Numbers, Numbers
@section Basic Math

@defun + &rest obj1 obj2 ...
@defunx - &rest obj1 obj2 ...
@defunx * &rest obj1 obj2 ...
@defunx / &rest obj1 obj2 ...
@defunx gcd &rest obj1 obj2 ...
@defunx lcm &rest obj1 obj2 ...
@defunx quotient   a b
@defunx remainder  a b
@defunx modulo   a b
@defunx abs obj
Basic arithmetic on the arguments.
@end defun

@defun log z
@defunx exp z
Return the natural log of @var{z} (@code{e^z}).
@end defun

@defun sqrt z
Return the square root of @var{z}
@end defun


@node  Binary Math , Transcendental Functions, Basic Math, Numbers
@section Binary Math 

@defvr Constant most-positive-fixnum
The immediate integer closest to positive infinity.
@xref{Configuration, , , slib, SLIB}.
@end defvr

@defvr Constant most-negative-fixnum
The immediate integer closest to negative infinity.
@end defvr

@defun logand a b &rest obj1 obj2 ...
@defunx logior a b &rest obj1 obj2 ...
@defunx logxor a b &rest obj1 obj2 ...
@defunx logand a b &rest obj1 obj2 ...
@defunx logior a b &rest obj1 obj2 ...
@defunx logxor a b &rest obj1 obj2 ...
@defunx lognot obj
@defunx logtest a b
@defunx logbit? obj bit-pos
Bitwise operations on exact integers.

@code{logtest} returns @code{#t} if @var{a} and @var{b} have
any bits in common.

@code{logbit?} returns @code{#t} if @var{obj} has a one in @var{bit-pos}.
@end defun

@defun integer-expt a b
Return @code{@var{a}^@var{b}}.  Both must be exact integers.
@end defun

@defun ash a b
Return @code{@var{a} << @var{b}}.  Both must be exact integers.
@end defun

@defun bit-extract n start end
Return the integer formed from bits @var{start}...@var{end}-1.

@example
(bit-extract 7 1 4) => 3
(bit-extract 7 0 3) => 3
bit-extract 7 0 4) => 7
(bit-extract 7 4 32) => 0
@end example
@end defun

@defun logcount n
Return the number of 1 bits in the exact integer @var{n}.
@end defun

@defun integer-length   obj
Return the number of significant bits in the exact integer @var{n}.
@end defun

@node  Transcendental Functions, libc.a Math , Binary Math , Numbers
@section Transcendental Functions

@defun sin x
@defunx cos x
@defunx tan x
Return the sine, cosine, and tangent of @var{x}
@end defun

@defun asin x
@defunx acos x
Return the inverse sine and cosine @var{x}
@end defun

@defun atan x &opt y
Computes @code{(angle (make-rectangular x y))} for real numbers @var{y}
and @var{x}.
@end defun

@defun sinh x
@defunx cosh x
@defunx tanh x
Return the hyperbolic sine, cosine, and tangent of @var{x}
@end defun

@defun asinh x
@defunx acosh x
@defunx atanh x
Return the inverse hyperbolic sine, cosine, and tangent of @var{x}
@end defun

@node libc.a Math ,  , Transcendental Functions, Numbers
@section libc.a Math 

@defun $asinh a
@defunx $acosh a
@defunx $atanh a
@defunx $sqrt a
@defunx $abs a
@defunx $exp a
@defunx $log a
@defunx $sin a
@defunx $cos a
@defunx $tan a
@defunx $asin a
@defunx $acos a
@defunx $atan a
@defunx $sinh a
@defunx $cosh a
@defunx $tanh a
@defunx %expt a b
@defunx %atan2 a b
These functions are implemented by their libc counterparts.

Real-only versions of these popular functions.  The argument @var{a}
must be a real number.  It is an error if the value which should be
returned by a call to these procedures is @emph{not} real.

@end defun


@node  Cons Pairs and Lists, Vectors, Numbers, Top
@chapter Cons Pairs and Lists

A @emph{cons pair} is a generic two element structure.  It has two
`fields' or `slots which are called the "car" and the "cdr".

The slots of a cons pair can hold references to any object (even the
pair itself).


@defun pair?   obj
Return @code{#t} if @var{obj} is a cons pair, and @code{#f} otherwise.
@end defun

@defun null?   obj
Return @code{#t} only if @var{obj} is @code{#f} (aka @code{()}),
@code{#f} otherwise.

In Guile, the "reference to no object", @code{()} or @code{nil}
is the same value as "false", @code{#f}.
@end defun

@defun cons a d
Create a new cons pair, initializing the car to @var{a}, the cdr to @var{d}.
@end defun

@defun copy-tree obj
Recursively copy a tree of cons-pairs.

If @var{obj} is not a cons pair, this is simply the identity function.
If @var{obj} is a cons pair, then @var{copy-tree} returns:

@example
(cons (copy-tree (car obj)) (copy-tree (cdr obj)))
@end example

@var{copy-tree} will not terminate on circular structures of cons pairs
and will fill up memory.
@end defun



@menu
* Basic Accessors and Mutators::  
* Lists::                       
* Lists As Collections::        
* Lists as Association Mappings::  
@end menu

@node  Basic Accessors and Mutators, Lists, Cons Pairs and Lists, Cons Pairs and Lists
@section Basic Accessors and Mutators

@defun car obj
@defunx cdr obj
Return the car (cdr) slot of @var{obj}, which must be a cons pair.
@end defun

@defun set-car! obj new-val
@defunx set-cdr! obj new-val
Modify the car (cdr) slot of @var{obj}, which must be a cons pair.

@var{new-val} is returned.
@end defun


@defun caar obj
@defunx cdar obj
@defunx cadr obj
@defunx cddr obj
@defunx caaar obj
@defunx cdaar obj
@defunx cadar obj
@defunx cddar obj
@defunx caadr obj
@defunx cdadr obj
@defunx caddr obj
@defunx cdddr obj
@defunx caaaar obj
@defunx cdaaar obj
@defunx cadaar obj
@defunx cddaar obj
@defunx caadar obj
@defunx cdadar obj
@defunx caddar obj
@defunx cdddar obj
@defunx caaadr obj
@defunx cdaadr obj
@defunx cadadr obj
@defunx cddadr obj
@defunx caaddr obj
@defunx cdaddr obj
@defunx cadddr obj
@defunx cddddr obj
These functions are all compositions of @code{car} and @code{cdr}.

For example, @code{(cadr x)} is the same as @code{(car (cdr x))}.
@end defun

@node  Lists, Lists As Collections, Basic Accessors and Mutators, Cons Pairs and Lists
@section Lists

A @dfn{list} is considered to be any chain of cons-pairs, the cdr of each pair
pointing to the next pair in the chain, and the cdr of the last pair
containing @code{()} (aka @code{#f}).

A list is written as a left-parenthesis, followed by a white-space
separated enumeration of the car slots of the cells in the list,
followed by a right-parenthesis.

@example
;; Note that lists typed-in have to be quoted or else
;; they will be interpreted as an expression and
;; evaluated:
;
'(a b c) => (a b c)     ; a three element list
@end example

An @dfn{improper list} is similar, except that the cdr slot of the last
pair is filled with some object other than @code{#f}.  Dotted-pair
notation is used to write an improper list:

@example
'(a b . c) => (a b . c)     ; a two element improper list
			    ; with the symbol c in the last cdr
			    ; slot.
@end example



@defun list?   obj
Return @code{#t} if @var{obj} is a list, @code{#f} otherwise.
@end defun

@defun list &rest obj1 obj2 ...
Return a new list of all of the arguments.
@end defun

@defun list-length   obj
@defunx length   obj
Return the number of cons-pairs that make up the list @var{obj}.
@end defun

@defun append &rest obj1 obj2 ...
@defunx append!  &rest obj1 obj2 ...
Construct a list by appending the argument lists.

@code{append} returns a new list, @code{append!} works
by modifying its arguments.

In both cases, the last argument need not be a list -- it
can be any type and will become the tail of the returned
list.

@example
;; append creates a new list:
;;
(define x '(a b c))
(define z '(1 2 3))
(define y (append z x))

y => (1 2 3 a b c)

(set-car! z 99)
z => (99 2 3)
y => (1 2 3 a b c)


;; append! modifies its arguments:
;;
(define x '(a b c))
(define z '(1 2 3))
(define y (append! z x))

y => (1 2 3 a b c)

(set-car! z 99)
z => (99 2 3)
y => (99 2 3 a b c)


;; But the last argument is special in either
;; case:
;;
(define x '(a b c))
(define y (append '(1 2 3) x))

y => (1 2 3 a b c)

(set-car! (cdr x) 99)

y => (1 2 3 a 99 c)
@end example
@end defun

@defun reverse   obj
@defunx reverse!   obj
Return a new list like @var{obj}, but in the opposite order.
@code{reverse!} works by re-arraning the pairs in OBJ while @code{reverse} 
constructs an entirely new list.

@var{obj} must be a proper list.
@end defun

@defun list-copy obj
Copy the argument as a list and return the copy.

The argument may be an improper list.  In that case, the copy and the
original share the final @code{CDR}:

@example
(define tail-elt (vector 'a))
(define a `(x y z . ,tail-elt))
(define b (list-copy a))
(equal? a b) => #t
(eq? a b) => #f
(eq? tail-elt (cdr (last-pair a)) (cdr (last-pair b))) => #t
@end example

@end defun

@defun list-ref obj n
@defunx list-set! obj n val
Return (perhaps modifying) the nth car slot of (possibly improper) list @var{obj}.
@end defun

@defun list-tail obj n
@defunx list-cdr-ref obj n
Return the contents the nth cdr in the (possibly improper) list @var{obj}.
@end defun

@defun list-cdr-set! obj n val
Modify the nth cdr in the (possibly improper) list @var{obj}.

@var{val} is returned.
@end defun

@defun last-pair obj
Return the last pair in the (possibly improper) list @var{obj}.
@end defun

@node  Lists As Collections, Lists as Association Mappings, Lists, Cons Pairs and Lists
@section Lists As Collections

These functions operate on lists as collections (ordered or unordered).

@defun map function obj  &rest obj1 obj2 ...
Construct a new list by applying @var{function} to the list arguments, elementwise.

For example:

@example
(map - '(1 2 3)) => (-1 -2 -3)

(map + '(1 2 3)
       '(10 10 11))
 => (11 12 14)
@end example

The list arguments to map need not be proper lists, but if they improper,
the contents of the last cdr are ignored.

The order in which map is applied to its arguments is unspecified
but definate.
@end defun

@defun for-each function obj  &rest obj1 obj2 ...
Apply function to the list arguments, elementwise, for side effects.

@code{for-each} is similar to @code{map}, but there are two differences.
First, @code{for-each} is guaranteed to process the elements in the 
order they occur in the argument lists.   Second, @code{for-each} does
not return a useful value -- the results of apply @code{function} are
ignored.
@end defun

@defun memq obj l
@defunx memv obj l
@defunx member obj l
@defunx sloppy-memq obj l
@defunx sloppy-memv obj l
@defunx sloppy-member obj l
Return the first pair in the proper list @code{l} whose car is @var{obj}.

@code{memq} compares @var{obj} to cars using @code{eq?}

@code{memv} compares @var{obj} to cars using @code{eqv?}

@code{member} compares @var{obj} to cars using @code{equal?}

The @code{sloppy-} varieties simply return @code{#f} if the reach
the end of @code{l} and @code{l} is an improper list.  Under the
same condition, the non-@code{sloppy-} varieties signal an error.
@end defun

@defun delq obj l
@defunx delv obj l
@defunx delete obj l
@defunx delq! obj l
@defunx delv! obj l
@defunx delete! obj l
Remove elements matching @var{obj} from the list @code{l}.  The
@code{delq}, @code{delv}, and @code{delete} functions use the
@code{eq?}, @code{eqv?}, and @code{equal?} predicates respectively to
determine which elements of @var{l} match @var{obj}.

The functions whose names end in @code{!} modify @var{l} destructively;
the functions lacking a @code{!} return a (possibly) modified copy of
@var{l}.

If @code{l} is not a proper list, the functions behave as normal on the
initial chain of pairs, and preserve the tail of the final pair.

When using the destructive operators, it is usually not correct to
simply write:
@example
(delq! elt my-list)
@end example
because @code{delq!} may remove pairs from the beginning of the list,
but cannot update @code{my-list} to point to the new head, since
function arguments in Scheme are passed by value.  To avoid this
situation, write the following instead:
@example
(set! my-list (delq! elt my-list))
@end example

@end defun

@node  Lists as Association Mappings,  , Lists As Collections, Cons Pairs and Lists
@section Lists as Association Mappings

Lists of the form:

@example
((k1 . v1) (k2 . v2) (k3 . v3) ...)
@end example

are considered "association lists".  They represent a mapping from the
value @code{k1 k2 k3...} to the values @code{v1 v2 v3...}.

In an association, @code{(k1 . v1)} is called the "value cell" for
@code{k1}.   @code{v1} is called the "binding" of @code{k1}.  @code{k1} is
a "key" and @code{v1} a "value".

An association list may contain more than one binding for a particular
key, but generally, only the first occuring binding matters.

@defun assq k alist
@defunx assv k alist
@defunx assoc k alist
Search @var{alist} for @var{k} and return the first applicable value cell.

If @var{k} has no binding in @var{alist}, @code{#f} is returned.

@code{assq} compares keys using @code{eq?}

@code{assv} compares keys using @code{eqv?}

@code{assoc} compares keys using @code{equal?}
@end defun


@defun acons k v alist
Prepend a binding of @var{v} for @code{k} to @var{alist} and return the new list.

@example
(acons 'george 'drums 
	'((paul . bass)
	  (john . guitar)
	  (john . piano)
	  (george . gc)))
=> ((george . drums)
    (paul . bass)
    (john . guitar)
    (john . piano)
    (george . gc))
@end example

@end defun

To make it easier and faster to use associate lists, additional
convenience functions are provided for alists; see @xref{Dictionaries in
General}.

@node  Vectors, Symbols, Cons Pairs and Lists, Top
@chapter Vectors

A vector is an array of objects, addressed by integers, in which
elements can be referenced or set in a single operation.

Vectors are written this way:

@example
#(a b c)	; a three element vector
@end example


@defun vector?   obj
Return @code{#t} if @var{obj} is a vector, @code{#f} otherwise.
@end defun

@defun make-vector size &opt fill
Return a new vector of @var{size} elements.

If @var{fill} is specified, the elements are initialized
to that value.  Otherwise, they are initialized to @code{#f}.
@end defun

@defun vector &rest obj1 obj2 ...
Return a new vector containing the arguments, in order.

The vector returned has as many elements as there are arguments.
@end defun

@defun list->vector obj
@defunx vector->list obj
Convert between lists and vectors.
@end defun


@defun vector-length obj
@defunx length obj
Return the number of elements in the vector @var{obj}.
@end defun


@defun vector-ref obj n
@defunx vector-set! obj n val
Return (possibly setting) the @var{n}th element of @var{obj}.
@end defun


@defun vector-fill! obj fill
Set all elements of the vector @var{obj}.
@end defun

@defun vector-move-left!   vec start end vec2 start2
@defunx vector-move-right!  vec start end vec2 start2
Copy objects from @var{vec} to @var{vec2}.

The suffixes @code{-left} and @code{-right} refer to the order in which
objects are copied which is significant of @code{vec} and @code{vec2}
are the same object.
@end defun

@node  Symbols, Keywords, Vectors, Top
@chapter Symbols

Symbols in Guile are read-only strings with some extra properties in
addition.

In addition to being string-like, symbols are distinguished by having a
@dfn{function slot} and @dfn{property slot} -- storage for arbitrary
values much like the @code{CAR} and @code{CDR} slots of a cons pair.

Normally symbols are named using strings of the characters a-z, A-Z,
0-9, and punctuation drawn from "-_!@@$%^~&*=+|:/?><,.".

@example
'abc => abc
'2much => 2much
'set! => set!
@end example

A symbol name must not begin with the character @code{:} (unless the
@code{#@{@}#} syntax describe below is used).   If you write what
appears to be a symbol name but begins with a @code{:}, you'll get
a keyword, not a symbol; see @xref{Keywords}.

@example
(symbol? 'this-is-a-symbol)	=> #t
(symbol? ':this-is-not)		=> #f
@end example


Except in obscure cases, the same name always names the same
symbol:

@example
(eq? 'abc 'abc) => #t
@end example


Symbols are usually read in a case @emph{sensitive} manner:

@example
(eq? 'ABC 'abc) => #f
@end example


Arbitrary symbol names can be written using "#@{" and "@}#" with
backslash to escape characters:

@example
#@{this is one really unusual symbol name.  
It is multiple lines long and even contains the sequence \@}#.@}#

=> #@{this\ is\ one\ really\ unusual\ symbol\ name.\ \ \
It\ is\ multiple\ lines\ long\ and\ even\ contains\ the\ sequence\ \@}\#.@}#
@end example


@defun symbol? obj
Return @code{#t} if @var{obj} is a symbol, false otherwise.
@end defun

@defun symbol->string symbol
@defunx string->symbol string
Convert between strings and symbols.
@end defun

@defun symbol-hash obj
Return an integer hash value based on the name of the symbol @var{obj}.

The hash value is guaranteed to have at least 16 useful bits.
@end defun

[For information about internationalizatio and symbol names, see
@xref{The String Representation Type, The String Representation Type,
The String Representation Type, ./intspec.info}.]

@menu
* F-slots and P-slots::         
* Obarrays::                    
@end menu

@node  F-slots and P-slots, Obarrays, Symbols, Symbols
@section F-slots and P-slots

Symbols have two slots that can contain references to arbitrary
objects.  These are called the f-slot and p-slot (function-slot
and property-slot).

@defun symbol-fref obj
@defunx symbol-pref obj
@defunx symbol-fset! obj val
@defunx symbol-pset! obj val
Set or reference the f or p slot of symbol @var{obj}.
@end defun

@node  Obarrays,  , F-slots and P-slots, Symbols
@section Obarrays

Earlier it was asserted: "Except in obscure cases, the same name always
names the same symbol".  This section explains how exceptions can come
about.

An @dfn{obarray} is an ordinary Scheme vector, used in a particular way.
It represents two mapping: a mapping of strings to symbols, and a
mapping of symbols to arbitrary values.

To initialize an obarray, create a vector of any non-0 size, filled with
the empty list.  The obarray is stored as hash table whose keys are
symbols, compared on the basis of string equality.

Although the structure of an obarray is a simple hash table, operations
on obarrays are not done using hash table primitives.  The
obarray-specific operations are, unlike what you could easily write in
scheme using hash table operations, atomic.  Two calls to
string->obarray-symbol will [allegedly] always yield the same result
even if one call interrupts the other (barring explicit mutations to the
obarray, of course).

@defun string->obarray-symbol  obarray name &opt soft
Return the @var{symbol} bound to the string@var{name} in @var{obarray}.

@var{obarray} may be @code{#t}, in which case the symbol is interned in
the system's built-in symbol table (like when using
@code{string->symbol}).

@var{obarray} may be @code{#f}, in which case the symbol is created,
but not associated with @emph{any} obarray.  In this case, the returned
symbol is guaranteed to be a new object.

@var{soft}, if specified and not @code{#f}, means that a symbol should
be returned only if it already exists in the specified obarray.  (In the
case of creating an uninterned symbol, the paramater @code{soft} is
ignored.)
@end defun

@defun unintern-symbol obarray symbol
Remove @var{symbol} from @var{obarray}.

Thereafter, @code{string->obarray-symbol} will no longer return @var{symbol}
for @code{obarray} unless @var{symbol} is first re-interned.
@end defun

@defun intern-symbol obarray symbol
Add @var{symbol} to @var{obarray}.  If @var{symbol} is already present,
this has no effect.

After this addition, @var{symbol} is the symbol binding of its name.
That is, even if another symbol of the same name was previously interned
in @var{obarray}, @var{symbol} becomes the binding of that name after
intern-symbol.  (This does not mean that the previous symbol is removed
from the @var{obarray}).
@end defun


@defun symbol-interned? obarray symbol
Return @code{#t} if @var{symbol} is in @var{obarray}.
@end defun

@defun symbol-bound? obarray symbol
@defunx symbol-binding obarray symbol
@defunx symbol-set! obarray symbol value
A @var{symbol} in an @var{obarray} may be bound arbitrarily.  The
binding may be changed.  When first interned, a symbol is unbound.
@end defun


@node Keywords, Arbiters, Symbols, Top
@chapter Keywords

A @dfn{keyword} is a self-evaluating symbol-like object with a 
convenient read syntax.   Keyword names are written just like
symbol names except that whereas a symbol name may not be written
starting with ":", keyword names @emph{must} begin with ":".

@example
        (keyword? :keyword) => #t
@end example

@defun keyword? obj
Return @code{#t} if @var{obj} is a keyword, @code{#f} otherwise.
@end defun 

@defun symbol->keyword symbol
Construct a keyword from a symbol.

@example
        (symbol->keyword 'fnord) => :fnord
@end example
@end defun


@defun keyword->symbol symbol
Construct a symbol from a keyword.

@example
        (symbol->keyword :fnord) => fnord
@end example
@end defun


In the above functions there is a one-to-one mapping between symbol
names and keywords.  Because there are such things as uninterned symbols
and obarrays, two @emph{symbols} can have the same name, yet not be
equal (@pxref{Obarrays}).  With keywords, there is only one universal
namespace -- if two keywords have the same name, they are equal in the
sense of @code{eq?}:

@example
;; Two symbols can have different names:
;;
(eq? (string->obarray-symbol #f "foo") 
     (string->obarray-symbol #f "foo"))
=> #f

;; but not two keywords.
;;
(eq? (symbol->keyword (string->obarray-symbol #f "foo"))
     (symbol->keyword (string->obarray-symbol #f "foo")))
=> #t
@end example


Many other systems write keyword-like values with a dash, following the
conventions of unix command line arguments.  It has proven convenient to
have procedures for mapping that style of "keyword" neatly into Guile
keywords:

@defun make-keyword-from-dashed-symbol symbol
A low-level way to construct a keyword from a symbol,
convenient when dealing with Tcl or unix.
The first character of the symbol's name must be '-'.  

@example
        (make-keyword-from-dashed-symbol '-command) => :command
@end example
@end defun 

@defun keyword-dash-symbol keyword
Return the dashed symbol that corresponds to a keyword.

@example
        (keyword-dash-symbol :text) => -text
@end example
@end defun 

@node  Arbiters, Procedures, Keywords, Top
@chapter Arbiters

@defun make-arbiter name

Returns an object of type arbiter and name @var{name}.  Its state is
initially unlocked.
@end defun

@defun try-arbiter arbiter

Returns @code{#t} and locks @var{arbiter} if @var{arbiter} was unlocked.
Otherwise, returns @code{#f}.
@end defun

@defun release-arbiter arbiter

Returns @code{#t} and unlocks @var{arbiter} if @var{arbiter} was locked.
Otherwise, returns @code{#f}.
@end defun



@node  Procedures, Ports, Arbiters, Top
@chapter Procedures

Procedures are those objects which the evaluator knows how to apply to
arguments.  Built-in functions are procedures as are any functions
defined by programs.

It should be obvious but perhaps bears repeating that procedure is
distinct from the name it is given in any particular context.  Thus the
symbol @code{'+} and the primitive procedure bound to the variable
called @code{+} are distinct objects.

@defun procedure? obj
Return @code{#t} if @var{obj} is a procedure, @code{#f} otherwise.
@end defun

Procedures have a binding slot which you can use arbitrarily.  Many
parts of the system will presume that this slot will contain a (possible
empty) assoc list, keyed by symbols (`procedure properties').  If your
procedure will be manipulated by a part of the system which is
documented as using property lists, you should follow the convention,
and use a unique prefix for all property names that you define.
Procedures which do not escape to such parts of the system can hve any
value at all in their binding slot.

@defun procedure-properties procedure
@defunx set-procedure-properties! procedure value
Return or set the value held in a procedures binding slow.
@end defun

@defun procedure-property proc key
@defunx procedure-assoc proc key
@defunx procedure-putprop! proc key value
Retrieve or get the binding of a particular procedure property.

These functions assume that the binding slot of the procedure holds an
assoc list.

@code{procedure-property} returns the binding of the property while
@code{procedure-assoc} returns the key-value pair that holds the binding.
@end defun

[It is a minor bug that the interface to procedure properties doesn't
include functions conforming to the standard interface for dictionaries;
see @xref{Dictionaries in General}.]


@node  Ports, Equality, Procedures, Top
@chapter Ports

[This documentation is accurate, but I expect that the details of ports
are going to change over the next few months.   In particular, Guile now
uses Tcl Channels as its preferred I/O mechanism.   The interfaces to ports
and channels are going to be merged.]

Ports are objects, such as open files, from which characters can be read
or written in sequence.   A read on an input port may yield, instead of a
character, an eof-object, indicating that no characters are available.

Ports are distinguished by whether they are for reading, writing, or both.

@defun port? obj
@defunx input-port? obj
@defunx output-port? obj
Return @code{#t} if @var{obj} is a port (input port, or output port), @code{#f} otherwise.
@end defun

@defun port-mode port
Return a string describing the mode of @var{port}, such as "r" or "w".
@end defun

@defun close-port port
@defunx close-input-port port
@defunx close-output-port port
@defunx close-io-port port
Close @var{port}.

If @code{close-input-port} is used on an i/o port, it becomes an output port.
If @code{close-output-port} is used on an i/o port, it becomes an input port.
@end defun

@defun force-output &opt port
Flush buffered output from all ports or from @var{port}, if specified.
@end defun


[For information about internationalizatio and ports, see @xref{Extended
Character I/O, Extended Character I/O, Extended Character I/O,
./intspec.info}.]


@menu
* Character I/O::               
* Structured I/O::              
* I/O Redirection::             
* Soft Ports::                  
* String Ports::                
* File Ports::                  
* Low-level File Port Operations::  
@end menu

@node  Character I/O, Structured I/O, Ports, Ports
@section Character I/O

@defun read-char &opt port
@defunx peek-char &opt port
Read one character or eof-object from @var{port} or @code{current-input-port}.

@code{read-char} advances the port while @code{peek-char} does not.
@end defun

@defun write-char char &opt port
Write @var{char} to @var{port} or to @code{current-input-port}.
@end defun

@defun newline &opt port
Write the character @code{#\nl} to @var{port} or to @code{current-input-port}.
@end defun

@defun char-ready? @var{port}
Return @code{#t} if a character be read from @var{port} without delay, @code{#f} otherwise.
@end defun

@defun eof-object? obj
Return @code{#t} if a character be read from @var{port} without delay, @code{#f} otherwise.
@end defun

@node  Structured I/O, I/O Redirection, Character I/O, Ports
@section Structured I/O

@defun write obj &opt port
@defunx display obj &opt port
Write a printed representation of @code{obj} on @var{port} or @code{current-input-port}.

For all objects with a read syntax, @code{write} prints using that syntax.

@code{display} is similar to write, except that strings are printed without
quotes, characters are printed without @code{#\} and so forth.
@end defun

@defun read &opt port case-i?
Read an object from @var{port} or @code{current-input-port}.

If @var{case-i?} is specified and not @code{#f}, symbols are read
in a case insensitive manner.  Otherwise, case matters in symbol
names.
@end defun

@node  I/O Redirection, Soft Ports, Structured I/O, Ports
@section I/O Redirection

@defun current-input-port
@defunx current-output-port
@defunx current-error-port
These each return the named port.
@end defun

@defun set-current-input-port port
@defunx set-current-output-port port
@defunx set-current-error-port port
These each establish the named port.
@end defun

@defun with-input-from-port port thunk
@defunx with-output-to-port port thunk
@defunx with-error-to-port port thunk
Evaluate @code{thunk} with the named port set to @var{port}.

The binding of input, output or error port to @var{port} is valid
within the dynamic scope of the call to @code{with-*-to/from-port}
but when leaving that scope, the binding outside of the call
to @code{with-*-to/from-port} is restored.
@end defun

@node Soft Ports, String Ports, I/O Redirection, Ports
@section Soft Ports

A @dfn{soft-port} is a port based on a vector of procedures capable of
accepting or delivering characters.  It allows emulation of I/O ports.

@defun make-soft-port vector modes
Returns a port capable of receiving or delivering characters as
specified by the @var{modes} string (@pxref{Ports, port-mode}).
@var{vector} must be a vector of length 6.  Its components are as
follows:

@enumerate 0
@item
procedure accepting one character for output
@item
procedure accepting a string for output
@item
thunk for flushing output
@item
thunk for getting one character
@item
thunk for closing port (not by garbage collection)
@end enumerate

For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need be
procedures.  Thunks 2 and 4 can instead be @code{#f} if there is no useful
operation for them to perform.

If thunk 3 returns @code{#f} or an @code{eof-object} (@pxref{Input,
eof-object?, ,r4rs, Revised(4) Scheme}) it indicates that the port has
reached end-of-file.  For example:

@example
(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@@" stdout)))
           "rw"))

(write p p) @result{} #<input-output-soft#\space45d10#\>
@end example
@end defun

[The set of functions needed to define a soft port could be improved
upon.  For example, relying on single-character i/o neatly fits these
ports into the standard R4RS i/o functions, but compromises a lot on
potential performance when using soft ports.]


@node  String Ports, File Ports, Soft Ports, Ports
@section String Ports

@defun call-with-output-string proc
@defunx call-with-input-string string proc
Call @var{proc} with one argument, a @code{port}.

If the @code{port} is an output string, writes to the string accumulate
in a string which is returned from @code{call-with-input-string}.

If the @code{port} is an input string, reads from the port
come from @var{string} and the value of @var{proc} is returned form
@code{call-with-input-string}.
@end defun

@defun with-input-from-string string thunk
@defunx with-output-to-string thunk
@defunx with-error-to-string thunk
Evaluate @var{thunk} with standard ports set to string ports.

@code{with-output-to-string} and @code{with-error-to-string} return
the string containing the corresponding output of thunk.

@code{with-input-from-string} returns the value of @var{thunk}.
@end defun

@node File Ports, Low-level File Port Operations, String Ports, Ports
@section File Ports

@defun open-file str mode
@defunx open-input-file str
@defunx open-output-file str
@defunx open-io-file str
Open a file, returning a @var{port}
@end defun

@defvar OPEN_READ
@defvarx OPEN_WRITE
@defvarx OPEN_BOTH
These are values that can be passed for the @code{mode} argument to @code{open-file}.
@end defvar

[[Mode strings should be explained in detail (maybe cleaned up, too)]]


@defun call-with-input-file str proc
@defunx call-with-output-file str proc
Call @var{proc} with one argument, a port which is the file named by @var{str}.

Both functions close the port after @var{proc} returns.

Both return the value of @var{proc}
@end defun

@defun with-input-from-file file thunk
@defunx with-output-to-file file thunk
@defunx with-error-to-file file thunk
Evaluate @var{thunk} in the scope of the proscribed i/o redirection.
@end defun


@node Low-level File Port Operations,  , File Ports, Ports
@section Low-level File Port Operations

@defun port-revealed port
@defunx set-port-revealed! port n
Return (or set) the reveal count of @var{port}

Every port has an integer value, the @dfn{reveal count} of the port,
It is a reference count.  If the count is not 0 when a port is
reclaimed by the garbage collector, then that port will not be 
automatically closed.
@end defun



@node  Equality, Hash Values, Ports, Top
@chapter Equality

There are three built-in ways to compare objects for equality in Guile.
These are:

@defun eq? &rest obj1 obj2 ...
Return @code{#t} if it is known that the arguments can not be distinguished.

This is the fastest form of equality to check for, and is often
sufficient, but it exposes some implementation specific details.
For example:

@example
(eq? 1 1)  => #t
(eq? 1.0 1.0) => #f
@end example
@end defun

@defun eqv? &rest obj1 obj2 ...
Return @code{#t} if it is known that only @code{eq?} can distinguish the arguments.

@example
(eq? 1.0 1.0) => #f
(eqv? 1.0 1.0) => #t
@end example
@end defun


@code{eq?} and @code{eqv?} have the property that if they say objects
A and B are equal, then mutations to A are also mutations to B.  The
final equality predicate does not share that property:

@defun equal? &rest obj1 obj2 ...
Return @code{#t} if it is known that the arguments are equal, modulo future mutations.

@example
(eq? "abc" "abc") => #f
(eqv? "abc" "abc") => #f
(equal? "abc" "abc") => #t

(eq? '(a b c) '(a b c)) => #f
(eqv? '(a b c) '(a b c)) => #f
(equal? '(a b c) '(a b c)) => #t
@end example
@end defun

@node  Hash Values, Tag Values, Equality, Top
@chapter Hash Values

The system has built-in rules for computing hash values:

@defun hash obj n
@defunx hashv obj n
@defunx hashq obj n
Compute a hash value for @var{obj} in the range 0..@var{n}-1.

@code{hash} returns the same value for any two objects that are @code{equal?}.

@code{hashv} returns the same value for any two objects that are @code{eqv?}

@code{hashq} returns the same value for any two objects that are @code{eq?}
@end defun

@node  Tag Values, Dictionaries in General, Hash Values, Top
@chapter Tag Values

Values in Guile Scheme are partitioned into disjoint subsets called
@dfn{tag groups}.  Every object has an associated @dfn{tag number}.  All
the members of a tag group share the same tag number.  No two tag groups
share the same tag number.  The tag numbers describe one, fairly natural
way to divide Scheme objects up into types.

@defun tag obj
Return the tag number of @var{obj}.
@end defun

[The set of tag numbers will be documented later, as it becomes more stable.]

@node  Dictionaries in General, Weak References, Tag Values, Top
@chapter Dictionaries in General

A @dfn{dictionary} is defined to be any data structure that binds keys
to values.  A wide variety of implementations and semantics are possible
for dictionaries.  Some examples are association lists, keyword-argument lists,
hash tables, weak hash tables, and so on.

Guile Scheme does not contain a universal "dictionary type" of which all
actual dictionaries are instances and it does not contain a set of
generic dictionary procedures that can operate on any dictionary,
regardless of its actual type.  Instead, Guile defines some common
minimal calling conventions that apply to all dictionaries.  There
are three basic dictionary operators:

@deffn Convention <dictionary-type>-ref dictionary key
Return the value bound to @var{key} in @var{dictionary}.
Return @var{#f} if @var{key} has no binding.
@end deffn


@deffn Convention <dictionary-type>-set! dictionary key value
Set the value bound to @var{key} in @var{dictionary}.

This may construct a new head for the dictionary.  If your dictionary
is bound to @var{x}, be sure to use:

@example
(set! x (<dictionary-type>-set! x key value))

;;; NOT:  (<dictionary-type>-set! x key value)
@end example
@end deffn


@deffn Convention <dictionary-type>-remove! dictionary key
Set the value (if any) bound to @var{key} in @var{dictionary}.

This may construct a new head for the dictionary.  If your dictionary
is bound to @var{x}, be sure to use:

@example
(set! x (<dictionary-type>-remove! x key value))

;;; NOT:  (<dictionary-type>-remove! x key value)
@end example
@end deffn

Here is how to use these conventions.   Suppose that your code involves
a dictionary-style data structure.   Initially you choose to use association 
lists.  At the top of the file put:

@example
(define (make-widget-dictionary)   '())
(define widget-dictionary-ref assq-ref)
(define widget-dictionary-set! assq-set!)
(define widget-dictionary-remove! assq-remove!)
@end example

Later, you can change to hash tables by changing just those four lines:

@example
(define (make-widget-dictionary)   (make-hash-table 73))
(define widget-dictionary-ref hashq-ref)
(define widget-dictionary-set! hashq-set!)
(define widget-dictionary-remove! hashq-remove!)
@end example

Another aspect of the dictionary calling convention is that for each
type of dictionary data structure, three dictionary types are generally
provided: one each for the possibilities of comparing keys using
@code{eq?}, @code{eqv?}, and @code{equal?}.  We try to make it so that
@code{eq?} and @code{eqv?} dictionary procedures are named with
abbreviations using "q" and "v", while the @code{equal?} version uses no
suffix character.  This convention gives the cleanest looking names to
"equal?" based procedures: @code{hash-ref}, @code{assoc-ref}.

Finally, some dictionary types can be extended beyond @code{eq?},
@code{eqv?} and @code{equal?} to be based on an arbitrary equivalence
relation.   When this is the case, a generalized form of the dictionary
operators may be provided using the suffix "x" (as in @code{hashx-ref}).
Compared to normal dictionary operators, the "x" forms take extra arguments
of a dictionary-type-specific nature (see below).

@defun assq-ref alist key
@defunx assq-set! alist key value
@defunx assq-remove! alist key value
@defunx assv-ref alist key
@defunx assv-set! alist key value
@defunx assv-remove! alist key value
@defunx assoc-ref alist key
@defunx assoc-set! alist key value
@defunx assoc-remove! alist key value
@defunx sloppy-assq-ref alist key
@defunx sloppy-assq-set! alist key value
@defunx sloppy-assq-remove! alist key value
@defunx sloppy-assv-ref alist key
@defunx sloppy-assv-set! alist key value
@defunx sloppy-assv-remove! alist key value
@defunx sloppy-assoc-ref alist key
@defunx sloppy-assoc-set! alist key value
@defunx sloppy-assoc-remove! alist key value
@defunx hashq-ref alist key
@defunx hashq-set! alist key value
@defunx hashq-remove! alist key value
@defunx hashv-ref alist key
@defunx hashv-set! alist key value
@defunx hashv-remove! alist key value
@defunx hash-ref alist key
@defunx hash-set! alist key value
@defunx hash-remove! alist key value

Standard-style dictionary functions for association lists and hash tables.

The @code{sloppy-} varieties are robust even if the alist
contains elements that are not key-value pairs or if the alist
is an improper list.   In those same conditions, the non-sloppy
varieties signal an error.

Don't forget -- mutations may construct a new head for an alist so:

@example
;;; don't say:
(assq-set! some-alist 'some-key some-value)

;;; when you mean:

(set! some-alist (assq-set! some-alist 'some-key some-value))
@end example
@end defun

For fine control over resource allocation, you can mix and match the
hash table dictionary operators with the various kinds of weak hash
table defined in the next chapter.

@defun hashx-ref hash-fn assoc-fn table key ?default?
@defunx hashx-set! hash-fn assoc-fn table key value
@defunx hashx-remove! hash-fn assoc-fn delete-fn table key
Perform the basic dictionary operations on hash tables.

@var{hash-fn} is the function to use to compute an integer hash value
for a key.

@var{assoc-fn} is a function with the same calling convention as @code{assoc}
but using a comparison function suitable for use with @code{hash-fn}.

@var{delete-fn} is a function with the same calling conventions as
@code{delq!}  but with an appropriate semantics for deleting the values
returned by @var{assoc-fn}.
@end defun

@node  Weak References, Evaluation, Dictionaries in General, Top
@chapter Weak References

Normally, if object A references object B, then object B is guaranteed
to exist for as long as A does.   @dfn{weak references} are the exception
to that rule.

An object A may weakly reference an object B, in which case B might
cease to exist before A does.   The rule is that, when all the references to
an object are weak references, the system is free to destroy the object
and remove the references at any time.

There are several types in Guile that hold weak references to other
objects.  These types are all vector-like objects -- they answer
@code{#t} if you ask @code{vector?}.

A @dfn{weak-vector} is like a vector, except that the elements of the
vector are weakly referenced.  When a reference is removed from a weak
vector, that element is replaced by @code{#f}.  

[The convention of replacing values by @code{#f} means that weak vectors
can't be used to represent collections of arbitrary objects since there
would be no way to tell whether @code{#f} is really a member of the
collection or an artifact of garbage collection.  This shortcoming might
be addressed in the future by creating a distinct value, say
@code{#collected}, to replace references to weakly held objects.

In fact, Mike Djurfeldt's original implementation of weak vectors had
such a value and I removed it for some reason.   Hrmm.]

A @dfn{weak-key-hash-table} is like a vector, except that if any
elements of the vector are assoc lists, then the @emph{keys}
(@code{CAR}s of key-value cells) of those lists are weakly referenced.
When a key is removed from such an assoc list because the object it
refers to has been destroyed, the entire key-value cell for that key is
removed from the assoc list. [Probably this should be called a
weak-key-hash-table -- the names of the procedures defined below may
change accordingly.]

A @dfn{weak-value-hash-table} is like a vector, except that if any
elements of the vector are assoc lists, then the @emph{values}
(@code{CDR}s of key-value cells) of those lists are weakly referenced.
When a value is removed from such an assoc list because the object it
refers to has been destroyed, the entire key-value cell for that value
is removed from the assoc list.

A @dfn{doubly-weak-hash-table} is like a vector, except that if any
elements of the vector are assoc lists, then both the @emph{keys} and
@emph{values} (@code{CAR}s and @code{CDR}s of key-value cells) of those
lists are weakly referenced.  When a key or value is removed from such
an assoc list because the object it refers to has been destroyed, the
entire key-value cell for that value is removed from the assoc list.

@defun weak-vector? obj
@defunx weak-key-hash-table? obj
@defunx weak-value-hash-table? obj
@defunx doubly-weak-hash-table? obj
Return @code{#t} if @var{obj} is a weak vector (weak hash table), @code{#f} otherwise.
@end defun

@defun weak-vector &rest obj1 obj2 ...
@defunx weak-key-hash-table &rest obj1 obj2 ...
@defunx weak-value-hash-table &rest obj1 obj2 ...
@defunx doubly-weak-table &rest obj1 obj2 ...
Create a new weak vector (hash table) containing the arguments.
@end defun

@defun make-weak-vector n &opt fill
@defunx make-weak-key-hash-table n &opt fill
@defunx make-weak-value-hash-table n &opt fill
@defunx make-doubly-weak-hash-table n &opt fill
Create a new weak vector (hash table) of size @var{n}.

If @var{fill} is specified, all elements are initialized to that
value.
@end defun

The hash-table weak vectors are especially useful in combination with the hash table
operators of the previous chapter.

@node  Evaluation, Exception Handling with Catch and Throw, Weak References, Top
@chapter Evaluation

@dfn{Source forms} are list structures which obey the
rules of Guile Scheme syntax.

@dfn{Evaluation} is the operation by which source forms are reduced to a
process, a series of calls to primitive functions.

Evaluation has the job of resolving variable references, interpreting
special forms, and carrying out function calls.   This section
describes the interface to those capabilities.

An introduction to Scheme or the current "Revised Report on Scheme" are
good places to learn about evaluation in more detail.  This overview is
intended just as an informal reference.


@menu
* Managing Top Level Variables::  
* Evaluation and Function Application::  
* Quotation::                   
* Promises::                    
* Flow of Control::             
* Anonymous Procedures and Local Environments::  
@end menu


@node  Managing Top Level Variables, Evaluation and Function Application, Evaluation, Evaluation
@section Managing Top Level Variables

@deffn Syntax defined? name
Evaluate @code{#t} if @var{name} has a top-level definition, @code{#f} otherwise.
@end deffn


@deffn Syntax define name expression
@deffnx Syntax define (name . formals) exp1 exp2 ...
@deffnx Syntax define ((name . formals1) . formals2) exp1 exp2 ...
Create a top-level binding for @var{name} to the value of
@var{expression}.

The second form of define:
@example
(define (name arg1 arg2 ...)  exp1 exp2 ...)
@end example

is equivalent to:

@example
(define name (lambda (arg1 arg2 ...) exp1 exp2...))
@end example
@noindent
Thus, as with @code{lambda} itself, the first @var{exp1} in the
definition's body may be a documentation string; see @ref{Anonymous
Procedures and Local Environments} for a full description of this.

The form

@example
(define ((name arg1 ...) arg2 ...)  exp1 exp2 ...)
@end example

means:

@example
(define (name arg1...) (lambda (arg2 ...) exp1 exp2...))
@end example

The nesting can go on arbitrarily:

@example
(define ((((name arg1...) arg2...) arg3...) arg4...) exp1 exp2 ...)

;; is like:

(define (name arg1...)
   (lambda (arg2...)
      (lambda (arg3...)
         (lambda (arg4 ...)
	    exp1
	    exp2
	    ...))))
@end example

@end deffn

@code{defined?} and @code{define} can be combined to achieve the effect
of conditional definition.  For example, the default initialization
code for Guile contains this fragment:

@example
(if (defined? array?)
    (begin
      (define uniform-vector? array?)
      ....))
@end example


@deffn Syntax set! name expression
Modify already-bound @var{name} to be bound to the value of @var{expression}.
@end deffn



@node  Evaluation and Function Application, Quotation, Managing Top Level Variables, Evaluation
@section Evaluation and Function Application

These functions take a source form and return its value:

@defun eval src
@defunx eval2 src env-fn
Return the value of evaluator @var{src}.

The second for, @code{eval2} take a parameter @var{env-fn}.
That parameter is explained elsewhere (@pxref{eval2; User Defined Top Levels}).
@end defun

In contrast to @code{eval}, this function takes a procedure
argument and a list of arguments to which that procedure should
be applied:

@defun apply proc args
Return the value of @var{proc} applied to the elements of the list @var{args}.
@end defun

@node  Quotation, Promises, Evaluation and Function Application, Evaluation
@section Quotation

@deffn Syntax quote expression
Evaluates to @var{expression} without evaluating it.
@end deffn

@deffn Syntax quasiquote template
Quasiquote is a convenient short-hand for writing expressions that
compose the functions and syntax @code{list}, @code{vector}, @code{cons}, and
@code{quote}.

Put another way, it is a convenient way to write expressions denoting
"almost constant" values.

@var{template} should be a list (possibly improper but non-circular) or
vector.  The template is recursively copied with two exceptions.

If an element has the form @code{(unquote <exp>)}, it is replaced by
the result of evaluating <exp>.

If the final element of a proper list has the form
@code{(unquote-splicing <exp>)}, then the value of evaluating
<exp> becomes the tail of the list.

@example
(let ((x 5))
  `(1 (+ 2 3) ,(+ 4 x)))

=> (1 (+ 2 3) 9)

(let ((x 5))
  `(1 (+ 2 3) #(,(+ 4 x) a b)))

=> (1 (+ 2 3) #(9 a b))


(let ((naughts '(bowman tichy)))
  `(kelvin ,@ naughts))

=> (kelvin bowman tichy)
@end example

Quasiquotes nest, so:

@example
;; Note that the inner quasiquote prevents
;; the outer quasiquote from evaluating one
;; level of unquotes:
;;

`(1 2 `(3 ,(+ 4 ,(+ 1 5))))
=>
(1 2 (quasiquote (3 (unquote (+ 4 6)))))
@end example



@end deffn

@node  Promises, Flow of Control, Quotation, Evaluation
@section Promises

Promises are expressions whose evaluation is postponed until
the result it will yield is needed.  The result of a promise
may be requested more than once, but the expression is evaluated
only once:

@deffn Syntax delay expression
Return a @var{promise} whose value comes from @var{expression}.

@var{expression} is not initially evaluated.
@end deffn

@defun force promise
Return the value of the expression of @var{promise}.

The first time the value of a promise is forced, the promises experssion
is evaluated.
@end defun

@example
(define a-promise (let loop ((x 0))  (delay (cons x (loop (+ x 1))))))

(force a-promise) => (0 . #<promise...>)
(force (cdr (force a-promise))) => (1 . #<promise...>)
(force (cdr (force (cdr (force a-promise))))) => (2 . #<promise...>)
@end example



@node  Flow of Control, Anonymous Procedures and Local Environments, Promises, Evaluation
@section Flow of Control

@deffn Syntax begin exp1 exp2 exp3
Evaluate @var{exp1}, @var{exp2}... in sequence, returning the value of the last.
@end deffn

@deffn Syntax and exp1 exp2
Evaluate @var{exp1}, @var{exp2}... in sequence, stopping if one returns @code{#f}.

Return the value of the last evaluated expression.
@end deffn

@deffn Syntax or
Evaluate @var{exp1}, @var{exp2}... in sequence, stopping if one returns @code{#t}.

Return the value of the last evaluated expression.
@end deffn

@deffn Syntax if pred-exp exp1 &opt exp2
If @var{pred-exp} evaluates to a non-@code{#f} value, evaluate and return @var{exp1}.
Otherwise, if @var{exp2} is specified, evaluate it and return that value.
Otherwise the value is unspecified.

Note that an @code{if} expression only evaluates one of @var{exp1} and @code{exp2}.
@end deffn

@deffn Syntax cond &rest (pred-exp1 exp1a exp1b...) (pred-exp2 exp2a exp2b...) ...
Evaluate predicate expressions in order until one returns non-@code{#f}.
Then evaluate the corresponding expressions @code{expna expnb ...} and return 
the value of the last such expression.

Note that a @code{cond} expression only evaluates one of @var{exp1}, @code{exp2}...

A predicate expression @code{else} is equivalent to one which is
@code{#t}.

As a special case, a clause may have the form:

@example
(pred-exp => exp-proc)
@end example

In that case, if @var{pred-exp} evaluates to a non-@code{#f} value,
@var{exp-proc} must evaluate to a one argument procedure -- that
procedure is called with the value of @var{pred-exp} and its value
becomes the value of the @code{cond}.
@end deffn

@deffn Syntax case select-exp ((val1 val2 ...) exp1a exp1b ...) ((valn valn+1 ...) exp2a exp2b ...)
Evaluate @var{select-exp} and then evaluate the expressions in the matching
clause of the @code{case} statement, returning the value of the last such 
expression.

Note that a @code{case} expression only evaluates one of @var{exp1}, @code{exp2}...

The values @var{val1} @var{val2} ... are not evaluated.  The result
of evaluating @var{select-exp} is compared to these using @code{eqv?}
(pxref Equality).
@end deffn



@defun call-with-current-continuation proc
Apply @var{proc} to a procedure which gives its argument to the current continuation.

When the continuation procedure created by this function is called with
one argument, V, it causes the call to
@code{call-with-current-continuation} to immediately return V.

A continuation procedure may be called any number of times and so
@var{call-with-current-continuation} may return more than once.
@end defun



@node Anonymous Procedures and Local Environments,  , Flow of Control, Evaluation
@section Anonymous Procedures and Local Environments

@deffn Syntax lambda formals [docstring] body @dots{}
Create a new anonymous function from @var{formals} and @var{body}.
@var{formals} is a list of the function's formal parameters; applying
the function causes the @var{body} expressions to be evaluated in order.
The value of the last @var{body} expression is the value returned from
the function.

The @var{docstring} is a string describing the function.  If it is more
than one line long, the first line should be a complete summary of the
function's purpose.  See @code{procedure-documentation}, described below.

@example
;; Applying an anonymous function to two arguments:
( (lambda (a b) (+ a b))  1 2)
@result{} 3
@end example

@end deffn

@defun procedure-documentation proc
Return the documentation string for @var{proc}.

@example
(define incr (lambda (n) "Add one to n." (+ n 1)))
(procedure-documentation incr)
@result{} "Add one to n."
@end example
@end defun

@deffn Syntax let ((v1 val1) (v2 val2) ...) exp1 exp2...
@deffnx Syntax let* ((v1 val1) (v2 val2) ...) exp1 exp2...
@deffnx Syntax letrec ((v1 val1) (v2 val2) ...) exp1 exp2...
Evaluate @var{exp1} @var{exp2} ... in the context of bindings for @var{v1} @var{v2}...

Return the value of the last expression evaluated.

These create bindings for @var{v1}... that are local to the expression.
Similarly named variables in a containing @code{let}, @code{lambda}, or from
the top-level are shadowed.

@var{val1} @var{val2} etc. provide initial values for the new bindings.

In a @code{let}, each of the value expressions (@var{val1} etc) are evaluated
in the scope enclosing the let.

In a @code{let*}, each of the value expressions are evaluated
in the scope enclosing the let augmented with the earlier occuring
bindings in the @code{let*}.   Thus, @var{val2} is evaluated in the
scope of @var{v1}, @var{val3} in the scope of @var{v1} and @var{v2} etc.

In a @code{letrec}, each of the value expressions is evaluated in the scope
of all of the variables @var{v1} @var{v2} etc. after first initializing
those variables to the special value @code{#undefined}.   It is an error
if any expression in a program produces the value @code{#undefined}.

It is unspecified the order in which the evaluations of @var{val1} etc.
are intermingled with giving @var{v1} etc. the values form those
evaluations.
@end deffn

@deffn Syntax set! var-name value var-name value var-name value ...
Modify the value of the variable named by @var{var-name}.

That variable is the innermost binding created by @code{let, let*,
letrec} @code{or lambda}, or a top-level binding if none of those
are defined.

It is an error to @code{set!} a variable with no top-level and no
local binding.

Any number of variable/value pairs may be specified.  Assignments are
carried out from left to right.
@end deffn

@deffn Syntax let name ((v1 x1) (v2 x2) ...) exp1 exp2 ...
Equivalent to:
@example
(letrec ((name (lambda (v1 v2 ...) exp1 exp2 ...)))
   (name x1 x2 ...))
@end example
@end deffn

@deffn Syntax do ((v1 x1 i1) (v2 x2 i2)...) (test a1 a2...) b1 b2...
Equivalent to:
@example
;; Assuming that @var{loop} is not used in any
;; of the expressions @var{x1} @var{x2} @var{i1} @var{test} @var{b1}...
;; and that it is distinct from @var{v1} @var{v2} etc...
;;
(letrec ((loop (lambda (v1 v2 ...) 
		 (if test
		     (begin a1 a2 ...)
		     (begin b1
			    b2
			    ...
			    (loop i1 i2 ...))))))
   (loop x1 x2 ...))
@end example
@end deffn


@node  Exception Handling with Catch and Throw, Dynamic Wind, Evaluation, Top
@chapter Exception Handling with Catch and Throw


These are the low level entry points to exceptions.  Individual
subsystems may define their own uses for exceptions.

@defun catch key thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} may be a symbol.  In that case, @var{thunk} takes no
arguments.  If @var{thunk} returns normally, that is the return value of
@code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} against throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.

Key may also be the value @code{#f}.  In that case, @var{thunk} takes
one argument which will be passed a @dfn{jump buffer object}.  A jump
buffer object may be used as the key argument to @code{throw} to throw
to a specific @code{catch} without an intervening search for a symbolic
key.
@end defun

@defun throw key &rest args ...
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

If the key is a symbol it will match catches of the same
symbol or of #t.  If no catch matches, the @code{throw-default-handler}
property of the key is checked.  If it is bound to a procedure,
that procedure is called:

@example
(handler key args ...)
@end example

That procedure is called the @dfn{default handler}.

If there is no handler at all, or if the default handler returns to its
caller, an error is signaled.

It is traditional in Scheme to implement exception systems using
@code{call-with-current-continuation}, but his has not been done, for
performance reasons.  The implementation of
@code{call-with-current-continuation} is a stack copying implementation.
This allows it to interact well with ordinary C code.  Unfortunately, a
stack-copying implementation can be slow -- creating a new continuation
involves a block copy of the stack.

Instead of using @code{call-with-current-continuation}, the exception
primitives are implemented as built-ins that take advantage of the
@emph{upward only} nature of exceptions.
@end defun

@node  Dynamic Wind, First-class Variables, Exception Handling with Catch and Throw, Top
@chapter Dynamic Wind

@defun dynamic-wind in-guard thunk out-guard
All three arguments must be 0-argument procedures.

@var{in-guard} is called, then @var{thunk}, then @var{out-guard}.

If, any time during the execution of @var{thunk}, the continuation
of the @code{dynamic-wind} expression is escaped non-locally, @var{out-guard}
is called.   If the continuation of the dynamic-wind is re-entered,
@var{in-guard} is called.   Thus @var{in-guard} and @var{out-guard} may
be called any number of times.

@example
(define x 'normal-binding)
=> x

(define a-cont  (call-with-current-continuation 
		  (lambda (escape)
		     (let ((old-x x))
		       (dynamic-wind
			  ;; in-guard:
			  ;;
			  (lambda () (set! x 'special-binding))

			  ;; thunk
			  ;;
		 	  (lambda () (display x) (newline)
				     (call-with-current-continuation escape)
				     (display x) (newline)
				     x)

			  ;; out-guard:
			  ;;
			  (lambda () (set! x old-x)))))))

;; Prints: 
special-binding
;; Evaluates to:
=> a-cont

x
=> normal-binding

(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
=> a-cont  ;; the value of the (define a-cont...)

x
=> normal-binding

a-cont
=> special-binding
@end example

@end defun



@node First-class Variables, eval2; User Defined Top Levels, Dynamic Wind, Top
@chapter First-class Variables

All top level bindings are stored in locations called @dfn{variables}.
Variables are first class objects.

@defun variable? obj
Return @code{#t} if @var{obj} is a variable;  @code{#f} otherwise.
@end defun

@defun make-variable init
@defunx make-variable init name-hint
Return a new variable, bound to @var{init}.

The optional @var{name-hint} is a symbolic name for the variable.  It
will be used in some error messages relating to the variable.
@end defun

@defun variable-ref variable
Return the current binding of @var{variable}.

It is an error to call @code{variable-ref} on a variable which is
unbound.
@end defun

@defun variable-set! variable value
Modify the binding of @var{variable}.
@end defun

@defun builtin-variable name
Return the built-in variable for named @var{name}.  @var{name} must be a
symbol.

Even symbols with no top level bindings have built-in variables.
There is an unbounded supply of undefined variables.
@end defun

@defun variable-bound? var
Return @code{#t} if @var{var} is a bound variable; @code{#f} otherwise.
@end defun

@defun make-undefined-variable
@defunx make-undefined-variable name-hint
Return a new variable, initially unbound.

The optional @var{name-hint} a symbolic name for the variable.  It will
be used in some error messages relating to the variable.
@end defun

@node eval2; User Defined Top Levels, First-class Modules, First-class Variables, Top
@chapter eval2; User Defined Top Levels

Low level support is provided for multiple top levels.  

@defun eval2 form env-fn
Evaluate @var{form} in the top level environment described by
@var{env-fn}.

@var{env-fn} is called this way:
@example
(env-fn name defining?)
@end example

It should return a variable object for the symbol @var{name}.  Returning
@code{#f} indicates that @var{name} has no binding.

The boolean @var{defining?} is @code{#t}, then the lookup is for a
@code{define} form or the equivalent -- a new variable may be created if
none already exists.

If @code{#f}, then the request should not create a new binding.
@end defun


@defun repl prompt &optional env-fn
Run a read-eval-print loop on the current input, output and error ports.

@var{prompt} is what to print before reading each expression.

If @var{env-fn} is specified, it is passed as the second argument
to @code{eval2} by the repl.
@end defun

@node  First-class Modules, Recursive Namespaces, eval2; User Defined Top Levels, Top
@chapter First-class Modules

Module objects are anonymous, first-class objects representing
top-level namespaces.  They are used, for example, to implement the
simple module system described in following chapters.

@subsection Warning

@cartouche
The interface to modules described in this chapter is slightly bogus.
The lazy binder will eventually be a general purpose interface
providing:

@example
'find name		;; Return a variable for name or #f.
			;; If #f is returned, this indicates the variable
			;; is undefined.
			;;

'define! name		;; Return a variable for name or #f.
			;; If #f is returned, this indicates the variable
			;; should be created and stored in the module
			;; obarray in the usual way.
			;;

'for-each procedure	;; implement module-for-each for this module

etc.
@end example

Additionally, three new types of weak vectors may be provided:
weak-key-obarrays, weak-value-obarrays, and doubly-weak-obarrays.
Corresponding to these and to the existing weak hash tables will be
variations on the basic module data structure.
@end cartouche

The modules interface comes in two parts: the module data structure
itself and the interface between modules and @code{eval}.

@menu
* Module Data Structures::      
* Modules and Evaluation::      
@end menu

@node  Module Data Structures, Modules and Evaluation, First-class Modules, First-class Modules
@section Module Data Structures

A module object is fundamentally a mapping from symbols to arbitrary
objects, usually variables.

The mapping consists of module-local bindings, plus local-bindings
inherited from the use-list of the module.   A module can be associated
with a procedure called the @dfn{lazy-binding-proc} the function of which
is to supply module-local bindings on-demand.


@defun module? obj
Return @code{#t} if obj is a module, false otherwise.
@end defun

@defun make-module size use-list lazy-binding-proc
Create a new module.

@var{size} is the size of the hash table to allocate.

@var{use-list} is the initial list of modules from which
to inherit bindings.

@var{lazy-binding-proc}, which if not @code{#f} is called:

@example
(lazy-binding-proc module symbol defining?)
@end example

is used to instantiate module-local variables on-demand.

It should return a variable object or @code{#f} for names 
that are not locally defined, even on demand.

@var{defining?}, if not @code{#f}, indicates that the given name is
being defined as by a top level @code{define}.  In such a case,
if the lazy binder returns @code{#f}, a new variable will be allocated
by the system.
@end defun

@defun module-locally-bound? module symbol
Return @code{#t} if @var{symbol} is bound locally in @var{module}.
@end defun

@defun module-bound? module symbol
Return @code{#t} if @var{symbol} is bound locally or inherited in @var{module}.
@end defun

@defun module-symbol-locally-interned? module symbol
Return @code{#t} if @var{symbol} is interned locally in @var{module}
(@pxref{Obarrays}).
@end defun

@defun module-symbol-interned? module symbol
Return @code{#t} if @var{symbol} is interned or inherited in @var{module}
(@pxref{Obarrays}).
@end defun

@defun module-local-variable module symbol
Return the variable locally bound in @var{module} to @var{symbol} (or @code{#f}).
@end defun

@defun module-variable module symbol
Return the variable bound or inherited in @var{module} to @var{symbol} (or @code{#f}).
@end defun

@defun module-symbol-binding module symbol &opt value
Return the value of the named variable in @var{module}.

If there is no such variable, the behavior depends on @var{value}.
If @var{value} is specified, it is returned.  Otherwise, an error
is signaled.
@end defun

@defun module-make-local-var! module symbol
Ensure that @var{symbol} is locally bound in @var{module}.
@end defun

@defun module-add! module symbol variable
Bind @var{symbol} to @var{variable} locally in @var{module}.
@end defun

@defun module-remove! module symbol
Remove binding of  @var{symbol} in @var{module}.
@end defun

@defun module-for-each proc module
Call @var{proc} for each binding in @var{module} with arguments @code{symbol variable}.
@end defun

@defun make-scm-module
Create a module whose lazy-binder copies bindings from the builtin module.
@end defun

@defun make-root-module
Create a module whose lazy-binder copies bindings to and from the builtin module.
@end defun

@defun module-obarray m
@defunx module-obarray-set! m v
Return (or set) the obarray of @var{m}.
@end defun

@defun module-uses m
@defunx module-uses-set! m v
Return (or set) the use-list of @var{m}.
@end defun

@defun module-binder m
@defunx module-binder-set! m v
Return (or set) the binder of @var{m}.
@end defun

@defun module-name m
@defunx module-name-set! m v
Return (or set) the name used when @code{write} or @code{display} is passed @var{m}
@end defun

@defun module-ref module name &opt default
Returns the value of a variable in @var{module}, bound to @var{name}.

If there is no such variable and the optional third argument
@var{default} is present, it is returned; otherwise an error is
signaled.
@end defun


@node  Modules and Evaluation,  , Module Data Structures, First-class Modules
@section Modules and Evaluation

The function @code{eval2} allows a program to define the top-level 
environment of code as it evaluated.   Naturally, this relates
to modules.

Each module has an associated @dfn{eval closure}, suitable for passing
as the second argument to eval2:

@defun module-eval-closure m
@defunx module-eval-closure-set! m v
Return (or set) the eval closure of @var{m}.

The default eval closure is:

@example
(lambda (symbol define?)
  (if define?
    (module-make-local-var! this-module symbol)
    (module-variable this-module symbol)))
@end example
@end defun


One module and one eval closure are designated as the system defaults.
Both can be set or checked with this interface:

@defun current-module
@defunx set-current-module module
Return (or set) the current module.

@code{set-current-module} also sets the system eval closure.
@end defun

@node  Recursive Namespaces, Declaring Modules, First-class Modules, Top
@chapter Recursive Namespaces

A hierarchical namespace emerges if we consider some module to be
root, and variables bound to modules as nested namespaces.

A handful of routines manage variable names in hierarchical namespace.
Each variable name is a list of elements, looked up in successively nested
modules.

@example
(nested-ref root-module '(foo bar baz))
=> <value of baz as bound in bar as bound in foo as bound in the root>
@end example

There are:

@defun nested-ref a-root name
@defunx nested-set! a-root name val
@defunx nested-define! a-root name val
@defunx nested-remove! a-root name
Standard dictionary operations for modules, taken as recursive namespaces.
See @xref{Dictionaries in General}.
@end defun

@code{(current-module)} is a natural choice for a root module so for
convenience there are also:

@defun local-ref name
@defunx local-set! name val
@defunx local-define! name val
@defunx local-remove! name
Recursive namespace dictionary operators that implicitly work on @code{current-module}.
@end defun

There is a special syntax that is convenient when writing the names of variables
in nested namespaces.

A token beginning "#/" followed by a symbol is short-hand for a list of
symbols whose names are found by treating the "#/" as a slash-separated list
of names:

@example
#/foo/bar/baz	==	(foo bar baz)
@end example

The transformation is made by the reader so:

@example
guile> '#/foo/bar/baz
(foo bar baz)
@end example


This syntax is handy and familar in expressions such as:

@example
(local-ref '#/app/modules/utils/string-fun)
(local-set! '#/app/modules/utils/string-fun (make-module 73))
@end example

The variable @code{app} is bound to a module is used as the root
of many conventionally named objects in Guile.  For example, modules
created by the auto-loader are bound in @code{#/app/modules}.


@node  Declaring Modules, Auto-Loading Modules, Recursive Namespaces, Top
@chapter Declaring Modules

Programmer's can arrange to load Scheme source files into private
namespaces and to selectively export definitions from those namespaces
into other top-levels.

In the simplest case, this is done by putting a call to the macro
@code{define-module} at the top of the file.

@deffn Syntax define-module module-id kw option ....
Set the current module.  None of the arguments to define-module are evaluated.

If the requested module does not yet exist, it is created.

If @code{define-module} occurs in a source file being loaded, then
the scope of this operation is for the remainder of the file or
until the next @code{define-module}.

@var{module-id} is a list of symbols, interpreted as a name
in a recursive namespace maintained by the auto-loader.
For example, if you say:

@example
(define-module #/utils/strings)
@end example

the auto-loader will create the new module and assign it the name
(relative to the current module when define-module is invoked):

@example
#/app/modules/utils/strings
@end example


The module name passed to define-module can optionally be followed by
keywords and keyword value pairs.   The currently supported keyword is:

@itemize @bullet{}
@item @code{:use-module module-id}

This indicates that the public definitions (see below) of the named
module should be made visible in the current module.  Assignment to the
imported public variables is visible both in the current module and in
the module from which the variables are imported.   If an imported id
is bound using @code{define}, that definition shadows the imported one,
and creates a new variable, local to the current module.

@code{:use-module} can be repeated any number of times.  Each used module
is added to the end of the use list, so the first occuring @code{:use-module}
has highest precendence.
@var{module-id} is a list of symbols.
@end itemize
@end deffn


@defun process-define-module module-name . kw-args
Process arguments like @code{define-module}, but return the new module.
The new module is not made the current module.

@code{process-define-module} is a normal procedure: all arguments are
evaluated.


@end defun

Most modules locally contain a binding for the name
@code{%module-public-interface}.  By convention, that variable is bound
to another module.  Variables in a module which are intended to be
shared with other modules are put into the public interface of the
module.

When the @code{:use-module} keyword is passed to @code{define-module},
it works this way.  We have the "new module" -- the module being built
by @code{define-module}, and the "used module", the module named by the
argument to @code{:use-module}.  To process a @code{:use-module}
request, @code{define-module} first asks the auto-loader to produce the
used module.  Then it looks up the binding of
@code{%module-public-interface} in the used module.  Finally, it adds
the module bound to @code{%module-public-interface} to the @emph{end} of
the use-list of the new module.


@deffn Syntax define-public defined-thing definition
@code{define-public} works just like @code{define}, except that the definition
is also exported from the current module.  A definition is exported by sharing
the variable with the module bound to @code{%module-public-interface}.
@end deffn


@node  Auto-Loading Modules, Using Emacs and Guile, Declaring Modules, Top
@chapter Auto-Loading Modules

When a module is referenced using @code{define-module} or
@code{process-define-module}, the module name is @dfn{resolved}.
"Resolved" means that if the module doesn't already exist, 
the auto-loader is asked to create it.

A module name is resolved this way:

@dfn{Auto-loader algorithm}:  to load a module named @code{N}

@enumerate 
@item If @code{(local-ref (append '#/app/modules N))} is not @code{#f},
then return that value.  Otherwise, the module must be loaded or created.

@item If @code{N} is a list of length greater than 1, then it is a @dfn{sub-module}.
The parent module name is formed by dropping the last element of
@code{N}, call this @code{N2}.  This step is: if @code{N} is the name of
a sub-module, then recursively apply the auto-loader algorithm to
@code{N2}.

@item Try to load a source file for @code{N}.   First, a relative file-name
is formed from @code{N} as described above (e.g. @code{#/widgets/simple}
=> @code{"widgets/simple"}).  Second, the auto-loader tries loading a
series of file names, stopping at the first file found to exist (and not
be a directory).  The names are:

@itemize @bullet{}
@item  <N>
@item  <N>.scm
@item  <N>/%module.scm
@end itemize

Each of these file-names is expanded along the list of file-names bound
to @code{%load-path}.

@item Hopefully by now the module has been created by one of the source files automatically
loaded.  If not, the variable @code{%auto-loader-developer-mode} is
checked.  If it is bound to a non-@code{#f} value, then an empty is
module is automatically created and a warning issued.  If
@code{%auto-loader-developer-mode} is @code{#f}, then an error is
signaled.
@end enumerate

By convention, programmers should try to maintain a one-to-one
correspondance between source files and modules.  @code{define-module}
should be used at most once per file, usually at the top of the source
file.  Support is planned (for example, in Emacs Scheme mode) for
features that rely on this convention.


@node  Using Emacs and Guile, Records, Auto-Loading Modules, Top
@chapter Emacs and Guile

The recommended way to organize large collections of Guile Scheme code

modules can be grouped in a subdirectory.   Choose module names that
reflect the subdirectory structure of the source that defines them.
For example, for the source files:

@example
project/utils/string-fun.scm
project/utils/runq.scm
project/widgets/simple.scm
project/widgets/app.scm
@end example

Use the module names:

@example
#/utils/string-fun
#/utils/runq
#/widgets/simple
#/widgets/app
@end example

Installed versions of the source files should keep the same subdirectory structure:

@example
some-dir-on-%load-path/utils/string-fun.scm
some-dir-on-%load-path/utils/runq.scm
some-dir-on-%load-path/widgets/simple.scm
some-dir-on-%load-path/widgets/app.scm
@end example


If you are a developer working on the project,
create a file like this:

Contents of @file{project/=ws.scm:}

@example
(define-module #/work-space
  :use-module #/utils/app
  :use-module #/utils/simple
  :use-module #/utils/runq
  :use-module #/utils/string-fun)
@end example

and add this to your .emacs file:

@example
(defun modular-scheme-send-definition ()
  "Send the first then the current definition to the inferior Scheme process."
  (interactive)
  (save-excursion
    (end-of-defun)
    (let ((pos (point)))
      (goto-char (point-min))
      (end-of-defun)
      (if (not (= pos (point)))
	  (progn
	   (beginning-of-defun)
	   (if (looking-at "(define-module")
	       (scheme-send-definition))))))
  (scheme-send-definition)))

(define-key scheme-mode-map "\M-\C-x" 'modular-scheme-send-definition)
@end example

@code{modular-scheme-send-definition} works like the traditional
emacs command @code{scheme-send-definition}, except that before
sending the current definition, emacs first sends the @code{define-module}
expression, if any can be found, from the top of the same file.
This has the effect of setting the current module correctly before sending
the current definition.

You can start things off by running @code{M-x run-scheme}, visiting
@file{=ws.scm}, and using @code{modular-scheme-send-definition} on an
expression in @file{=ws.scm}.  This will send the @code{define-module}
expression shown above causing the auto-loader to load the source files
@file{app.scm}, @file{simple.scm}, @file{runq.scm}, and
@file{string-fun.scm}.   

For this to work properly, the module names you use must reflect the
sub-directory structure of the source files, and the source files
must be found on the @code{%load-path} of your Guile process.  @file{.} is
on @code{%load-path} by default and so usually it should work simply
to run the scheme process in the root directory of your source.

[fill in reference: "Modular Programming In Scheme" ....]


@node Records, Structures, Using Emacs and Guile, Top
@chapter Records

A @dfn{record type} is a first class object representing a user-defined
data type.  A @dfn{record} is an instance of a record type.

@defun record? obj
Returns @code{#t} if @var{obj} is a record of any type and @code{#f}
otherwise.

Note that @code{record?} may be true of any Scheme value; there is no
promise that records are disjoint with other Scheme types.
@end defun

@defun make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.  It is
unspecified how record-type descriptors are represented.@refill
@end defun

@defun record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.@refill
@end defun

@defun record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.@refill
@end defun

@defun record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.@refill
@end defun

@defun record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created the given record.@refill
@end defun

@defun record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end defun


@node  Structures, Arrays, Records, Top
@chapter Structures

A @dfn{structure type} is a first class user-defined data type.  A
@dfn{structure} is an instance of a structure type.  A structure type is
itself a structure.

Structures are less abstract and more general than traditional records.
In fact, in Guile Scheme, records are implemented using structures.

@menu
* Structure Concepts::          The structure of Structures
* Structure Layout::            Defining the layout of structure types
* Structure Basics::            make-, -ref and -set! procedures for structs
* Vtables::                     Accessing type-specific data
@end menu

@node  Structure Concepts, Structure Layout, Structures, Structures
@section Structure Concepts

A structure object consists of a handle, structure data, and a vtable.
The handle is a Scheme value which points to both the vtable and the
structure's data.  Structure data is a dynamically allocated region of
memory, private to the structure, divided up into typed fields.  A
vtable is another structure used to hold type-specific data.  Multiple
structures can share a common vtable.

Three concepts are key to understanding structures.  

@itemize @bullet{}
@item @dfn{layout specifications}

Layout specifications determine how memory allocated to structures is
divided up into fields.  Programmers must write a layout specification
whenever a new type of structure is defined.

@item @dfn{structural accessors}

Structure access is by field number.   There is only one set of
accessors common to all structure objects.

@item @dfn{vtables}

Vtables, themselves structures, are first class representations of
disjoint sub-types of structures in general.   In most cases, when a 
new structure is created, programmers must specifiy a vtable for the
new structure.   Each vtable has a field describing the layout of its
instances.   Vtables can have additional, user-defined fields as well.
@end itemize



@node  Structure Layout, Structure Basics, Structure Concepts, Structures
@section Structure Layout

When a structure is created, a region of memory is allocated to hold its
state.  The @dfn{layout} of the structure's type determines how that
memory is divided into fields.

Each field has a specified type.  There are only three types allowed, each
corresponding to a one letter code.  The allowed types are: 

@itemize @bullet{}
@item 'u' -- unprotected

The field holds binary data that is not GC protected.

@item 'p' -- protected

The field holds a Scheme value and is GC protected.

@item 's' -- self

The field holds a Scheme value and is GC protected.  When a structure is
created with this type of field, the field is initialized to refer to
the structure's own handle.  This kind of field is mainly useful when
mixing Scheme and C code in which the C code may need to compute a
structure's handle given only the address of its malloced data.
@end itemize


Each field also has an associated access protection.   There are only
three kinds of protection, each corresponding to a one letter code.
The allowed protections are:

@itemize @bullet{}
@item 'w' -- writable

The field can be read and written.

@item 'r' -- readable

The field can be read, but not written.

@item 'o' -- opaque

The field can be neither read nor written.   This kind
of protection is for fields useful only to built-in routines.
@end itemize

A layout specification is described by stringing together pairs
of letters: one to specify a field type and one to specify a field
protection.    For example, a traditional cons pair type object could
be described as:

@example
; cons pairs have two writable fields of Scheme data
"pwpw"
@end example

A pair object in which the first field is held constant could be:

@example
"prpw"
@end example

Binary fields, (fields of type "u"), hold one @emph{word} each.  The
size of a word is a machine dependent value defined to be equal to the
value of the C expression: @code{sizeof (long)}.

The last field of a structure layout may specify a tail array.
A tail array is indicated by capitalizing the field's protection 
code ('W', 'R' or 'O').   A tail-array field is replaced by 
a read-only binary data field containing an array size.   The array
size is determined at the time the structure is created.  It is followed
by a corresponding number of fields of the type specified for the
tail array.   For example, a conventional Scheme vector can be
described as:

@example
; A vector is an arbitrary number of writable fields holding Scheme
; values:
"pW"
@end example

In the above example, field 0 contains the size of the vector and 
fields beginning at 1 contain the vector elements.

A kind of tagged vector (a constant tag followed by conventioal
vector elements) might be:

@example
"prpW"
@end example


Structure layouts are represented by specially interned symbols whose
name is a string of type and protection codes.  To create a new
structure layout, use this procedure:

@defun make-struct-layout fields
Return a new structure layout object.

@var{fields} must be a read-only string made up of pairs of characters
strung together.  The first character of each pair describes a field
type, the second a field protection.  Allowed types are 'p' for
GC-protected Scheme data, 'u' for unprotected binary data, and 's' for
fields that should point to the structure itself.    Allowed protections
are 'w' for mutable fields, 'r' for read-only fields, and 'o' for opaque 
fields.  The last field protection specification may be capitalized to
indicate that the field is a tail-array.
@end defun



@node Structure Basics, Vtables, Structure Layout, Structures
@section Structure Basics

This section describes the basic procedures for creating and accessing
structures.

@defun make-struct type tail-elts . inits
Create a new structure.

@var{type} must be a vtable structure (@xref{Vtables}).

@var{tail-elts} must be a non-negative integer.  If the layout
specification indicated by @var{type} includes a tail-array,
this is the number of elements allocated to that array.

The @var{inits} are optional arguments describing how successive fields
of the structure should be initialized.  Only fields with protection 'r'
or 'w' can be initialized -- fields of protection 's' are automatically
initialized to point to the new structure itself;  fields of protection 'o'
can not be initialized by Scheme programs.
@end defun

@defun struct? obj
Return #t iff @var{obj} is a structure object.
@end defun


@defun struct-ref struct n
@defunx struct-set! struct n value
Access (or modify) the @var{n}th field of @var{struct}.

If the field is of type 'p', then it can be set to an arbitrary value.

If the field is of type 'u', then it can only be set to a non-negative
integer value small enough to fit in one machine word.
@end defun



@node  Vtables,  , Structure Basics, Structures
@section Vtables

Vtables are structures that are used to represent structure types.
Each vtable contains a layout specification in field 0 -- instances
of the type are laid out according to that specification.  Vtables
contain additional fields which are used only internally to libguile.
The variable @code{struct-vtable-offset} is bound to a field number.
Vtable fields at that position or greater are user definable.

@defun struct-vtable struct
Return the vtable structure that describes the type of @var{struct}.
@end defun

@defun struct-vtable? obj
Return #t iff obj is a vtable structure.
@end defun

If you have a vtable structure, @code{V}, you can create an instance of
the type it describes by using @code{(make-struct V ...)}.  But where
does @code{V} itself come from?  One possibility is that @code{V} is an
instance of a user-defined vtable type, @code{V'}, so that @code{V} is
created by using @code{(make-struct V' ...)}.  Another possibility is
that @code{V} is an instance of the type it itself describes.  Vtable
structures of the second sort are created by this procedure:

@defun make-vtable-vtable new-fields tail-size . inits
Return a new, self-describing vtable structure.

@var{new-fields} is a layout specification describing fields
of the resulting structure beginning at the position bound to
@code{struct-vtable-offset}.

@var{tail-size} specifies the size of the tail-array (if any) of
this vtable.

@var{inits} initializes the fields of the vtable.  Minimally, one
initializer must be provided: the layout specification for instances
of the type this vtable will describe.

@example
;;; loading ,a...
(define x
  (make-vtable-vtable (make-struct-layout (quote pw))
                      0
                      'foo))

(struct? x)
=> #t
(struct-vtable? x)
=> #t
(eq? x (struct-vtable x))
=> #t
(struct-ref x struct-vtable-offset)
=> foo
(struct-ref x 0)
=> pruosrpw


(define y
  (make-struct x
               0
               (make-struct-layout (quote pwpwpw))
               'bar))

(struct? y)
=> #t
(struct-vtable? y)
=> #t
(eq? x y)
=> ()
(eq? x (struct-vtable y))
=> #t
(struct-ref y 0)
=> pwpwpw
(struct-ref y struct-vtable-offset)
=> bar


(define z (make-struct y 0 'a 'b 'c))

(struct? z)
=> #t
(struct-vtable? z)
=> ()
(eq? y (struct-vtable z))
=> #t
(map (lambda (n) (struct-ref z n)) '(0 1 2))
=> (a b c)
@end example

@end defun


@node Arrays, Object Properties, Structures, Top
@chapter Arrays

@menu
* Conventional Arrays::         
* Array Mapping::               
* Uniform Array::               
* Bit Vectors::                 
@end menu

@node Conventional Arrays, Array Mapping, Arrays, Arrays
@section Conventional Arrays

@dfn{Arrays} read and write as a @code{#} followed by the @dfn{rank}
(number of dimensions) followed by what appear as lists (of lists) of
elements.  The lists must be nested to the depth of the rank.  For each
depth, all lists must be the same length.
@example
(make-array 'ho 3 3) @result{}
#2((ho ho ho) (ho ho ho) (ho ho ho))
@end example

Unshared conventional (not uniform) 0-based arrays of rank 1 (dimension)
are equivalent to (and can't be distinguished from) vectors.
@example
(make-array 'ho 3) @result{} (ho ho ho)
@end example

When constructing an array, @var{bound} is either an inclusive range of
indices expressed as a two element list, or an upper bound expressed
as a single integer.  So
@example
(make-array 'foo 3 3) @equiv{} (make-array 'foo '(0 2) '(0 2))
@end example

@defun array? obj
Returns @code{#t} if the @var{obj} is an array, and @code{#f} if not.
@end defun

@defun make-array initial-value bound1 bound2 @dots{}
Creates and returns an array that has as many dimensions as there are
@var{bound}s and fills it with @var{initial-value}.
@end defun

@defun array-ref array index1 index2 @dots{}
Returns the element at the @code{(index1, index2)} element in @var{array}.
@end defun

@defun array-in-bounds? array index1 index2 @dots{}
Returns @code{#t} if its arguments would be acceptable to array-ref.
@end defun

@defun array-set! array new-value index1 index2 @dots{}
Sets the element at the @code{(index1, index2)} element in @var{array} to
@var{new-value}.  The value returned by array-set! is unspecified.
@end defun

@defun make-shared-array array mapper bound1 bound2 @dots{}
@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:
@example
(define fred (make-array #f 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3) @result{} foo
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
(array-ref freds-center 0 0) @result{} foo
@end example
@end defun

@defun transpose-array array dim0 dim1 @dots{}
Returns an array sharing contents with @var{array}, but with dimensions
arranged in a different order.  There must be one @var{dim} argument for
each dimension of @var{array}.  @var{dim0}, @var{dim1}, @dots{} should
be integers between 0 and the rank of the array to be returned.  Each
integer in that range must appear at least once in the argument list.

The values of @var{dim0}, @var{dim1}, @dots{} correspond to dimensions
in the array to be returned, their positions in the argument list to
dimensions of @var{array}.  Several @var{dim}s may have the same value,
in which case the returned array will have smaller rank than
@var{array}.

examples:
@example
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end example
@end defun

@defun enclose-array array dim0 dim1 @dots{}
@var{dim0}, @var{dim1} @dots{} should be nonnegative integers less than
the rank of @var{array}.  @var{enclose-array} returns an array
resembling an array of shared arrays.  The dimensions of each shared
array are the same as the @var{dim}th dimensions of the original array,
the dimensions of the outer array are the same as those of the original
array that did not match a @var{dim}.

An enclosed array is not a general Scheme array.  Its elements may not
be set using @code{array-set!}.  Two references to the same element of
an enclosed array will be @code{equal?} but will not in general be
@code{eq?}.  The value returned by @var{array-prototype} when given an
enclosed array is unspecified.

examples:
@example
(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) @result{}
   #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) @result{}
   #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>
@end example
@end defun

@defun array-shape array
Returns a list of inclusive bounds of integers.
@example
(array-shape (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) (0 4))
@end example
@end defun

@defun array-dimensions array
@code{Array-dimensions} is similar to @code{array-shape} but replaces
elements with a @code{0} minimum with one greater than the maximum. So:
@example
(array-dimensions (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) 5)
@end example
@end defun

@defun array-rank obj
Returns the number of dimensions of @var{obj}.  If @var{obj} is not an
array, @code{0} is returned.
@end defun

@defun array->list array
Returns a list consisting of all the elements, in order, of @var{array}.
@end defun

@defun array-copy! source destination
Copies every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must have
the same rank as @var{source}, and be at least as large in each
dimension.  The order is unspecified.
@end defun

@defun serial-array-copy! source destination
Same as @code{array-copy!} but guaranteed to copy in row-major order.
@end defun

@defun array-fill! array fill
Stores @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end defun

@defun array-equal? array0 array1 @dots{}
Returns @code{#t} iff all arguments are arrays with the same shape, the
same type, and have corresponding elements which are either
@code{equal?}  or @code{array-equal?}.  This function differs from
@code{equal?} in that a one dimensional shared array may be
@var{array-equal?} but not @var{equal?} to a vector or uniform vector.
@end defun

@defun array-contents array
@defunx array-contents array strict
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @var{make-array} and
@var{make-uniform-array} may be unrolled, some arrays made by
@var{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end defun

@node Array Mapping, Uniform Array, Conventional Arrays, Arrays
@section Array Mapping

@defun array-map! array0 proc array1 @dots{}
@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.
@end defun

@defun serial-array-map! array0 proc array1 @dots{}
Same as @var{array-map!}, but guaranteed to apply @var{proc} in
row-major order.
@end defun

@defun array-for-each proc array0 @dots{}
@var{proc} is applied to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.
@end defun

@defun array-index-map! array proc
applies @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.

One can implement @var{array-indexes} as
@example
(define (array-indexes array)
    (let ((ra (apply make-array #f (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end example
Another example:
@example
(define (apl:index-generator n)
    (let ((v (make-uniform-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end example
@end defun

@node Uniform Array, Bit Vectors, Array Mapping, Arrays
@section Uniform Array

@noindent
@dfn{Uniform Arrays} and vectors are arrays whose elements are all of
the same type.  Uniform vectors occupy less storage than conventional
vectors.  Uniform Array procedures also work on vectors,
uniform-vectors, bit-vectors, and strings.

@noindent
@var{prototype} arguments in the following procedures are interpreted
according to the table:

@example
prototype       type                            printing character

#t              boolean (bit-vector)                    b
#\a             char (string)                           a
integer >0      unsigned integer                        u
integer <0      signed integer                          e
1.0             float (single precision)                s
1/3             double (double precision float)         i
+i              complex (double precision)              c
()              conventional vector
@end example

@noindent
Unshared uniform character 0-based arrays of rank 1 (dimension)
are equivalent to (and can't be distinguished from) strings.
@example
(make-uniform-array #\a 3) @result{} "$q2"
@end example

@noindent
Unshared uniform boolean 0-based arrays of rank 1 (dimension) are
equivalent to (and can't be distinguished from) @ref{Bit Vectors,
bit-vectors}.
@example
(make-uniform-array #t 3) @result{} #*000
@equiv{}
#b(#f #f #f) @result{} #*000
@equiv{}
#1b(#f #f #f) @result{} #*000
@end example

@noindent
Other uniform vectors are written in a form similar to that of vectors,
except that a single character from the above table is put between
@code{#} and @code{(}.  For example, @code{'#e(3 5 9)} returns a uniform
vector of signed integers.

@defun array? obj prototype
Returns @code{#t} if the @var{obj} is an array of type corresponding to
@var{prototype}, and @code{#f} if not.
@end defun

@defun make-uniform-array prototype bound1 bound2 @dots{}
Creates and returns a uniform array of type corresponding to
@var{prototype} that has as many dimensions as there are @var{bound}s
and fills it with @var{prototype}.
@end defun

@defun array-prototype array
Returns an object that would produce an array of the same type as
@var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end defun

@defun list->uniform-array rank prot lst
@defunx list->uniform-vector prot lst
Returns a uniform array of the type indicated by prototype @var{prot}
with elements the same as those of @var{lst}.  Elements must be of the
appropriate type, no coercions are done.
@end defun

@defun uniform-vector-fill! uve fill
Stores @var{fill} in every element of @var{uve}.  The value returned is
unspecified.
@end defun

@defun uniform-vector-length uve
Returns the number of elements in @var{uve}.
@end defun

@defun dimensions->uniform-array dims prototype fill
@defunx dimensions->uniform-array dims prototype
@defunx make-uniform-vector length prototype fill
@defunx make-uniform-vector length prototype
Creates and returns a uniform array or vector of type corresponding to
@var{prototype} with dimensions @var{dims} or length @var{length}.  If
the @var{fill} argument is supplied, the returned array is filled with
this value.
@end defun

@defun uniform-array-read! ura
@defunx uniform-array-read! ura port
@defunx uniform-vector-read! uve
@defunx uniform-vector-read! uve port
Attempts to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port}.  If an end of file is encountered during
uniform-array-read! the objects up to that point only are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end defun

@defun uniform-array-write ura
@defunx uniform-array-write ura port
@defunx uniform-vector-write uve
@defunx uniform-vector-write uve port
Writes all elements of @var{ura} as binary objects to @var{port}. The
number of objects actually written is returned. @var{port} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end defun

@node Bit Vectors,  , Uniform Array, Arrays
@section Bit Vectors

@noindent
Bit vectors can be written and read as a sequence of @code{0}s and
@code{1}s prefixed by @code{#*}.

@example
#b(#f #f #f #t #f #t #f) @result{} #*0001010
@end example

@noindent
Some of these operations will eventually be generalized to other
uniform-arrays.

@defun bit-count bool bv
Returns the number occurrences of @var{bool} in @var{bv}.
@end defun

@defun bit-position bool bv k
Returns the minimum index of an occurrence of @var{bool} in @var{bv}
which is at least @var{k}.  If no @var{bool} occurs within the specified
range @code{#f} is returned.
@end defun

@defun bit-invert! bv
Modifies @var{bv} by replacing each element with its negation.
@end defun

@defun bit-set*! bv uve bool
If uve is a bit-vector @var{bv} and uve must be of the same length.  If
@var{bool} is @code{#t}, uve is OR'ed into @var{bv}; If @var{bool} is @code{#f}, the
inversion of uve is AND'ed into @var{bv}.

If uve is a unsigned integer vector all the elements of uve must be
between 0 and the @code{LENGTH} of @var{bv}.  The bits of @var{bv}
corresponding to the indexes in uve are set to @var{bool}.

The return value is unspecified.
@end defun

@defun bit-count* bv uve bool
Returns
@example
(bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
@end example
@var{bv} is not modified.
@end defun



@node  Object Properties, Low-Level Syntax Extensions, Arrays, Top
@chapter Object Properties

The system maintains an assoc list of properties associated with every
object in the system.   A property list is protected by the object it is
for;  if that object is garbage collected, then the property list may
be as well.

@defun object-properties obj
@defunx set-object-properties obj alist
Return (perhaps setting) the properties of @var{obj}.
@end defun

@defun object-property obj key
@defunx set-object-property obj key val
Return (perhaps setting) a specific property of @var{obj}.
@end defun

[Interface bug:  there should be a second level of interface in which
the user provides a "property table" that is possibly private.]

@node  Low-Level Syntax Extensions, Time, Object Properties, Top
@chapter Low-Level Syntax Extensions

Normally when you define a function, arguments passed to that function
are evaluated and the function itself has no access to the lexical
environment of the caller.

Three low-level hooks provide a way to define functions that violate
these rules, taking arguments unevaluated, and gaining access to the
lexical environment of the caller.

To use any of these syntactic extension mechanisms you must define
a procedure of two arguments, an expression and an environment:

An @dfn{environment} is a list of @dfn{environment frames}.  There are 2
types of environment frames:

@table @code
@item ((lambda (variable1 @dots{}) @dots{}) value1 @dots{})
@itemx (let ((variable1 value1) (variable2 value2) @dots{}) @dots{})
@itemx (letrec ((variable1 value1)  @dots{}) @dots{})
result in a single enviroment frame:
@example
((variable1 @dots{}) value1 @dots{})
@end example

@item (let ((variable1 value1)) @dots{})
@itemx (let* ((variable1 value1) @dots{}) @dots{})
result in an environment frame for each variable:
@example
(variable1 . value1) (variable2 .  value2) @dots{}
@end example
@end table

[Warning: the interface to run-time local environments is subject to
change.  A more abstract interface should be provided.  

Low-level macros thwart non-trivial compilation.]

@defun procedure->syntax proc
Convert @var{proc} into "syntax".  

@var{proc} should take an expression and an environment.  

When the syntax object is applied, the expression containing it and the
active environment are passed to @var{proc}.  The value returned from
@var{proc} becomes the value of the expression.
@end defun

@defun procedure->macro proc
Convert @var{proc} into a "macro".

@var{proc} should take an expression and an environment.  

When the macro object is applied, the expression containing it and the
active environment are passed to @var{proc}.  The value returned from
@var{proc} is evaluated in the callers lexical environment and to
produce the value of the expression.
@end defun


@defun procedure->memoizing-macro proc
Convert @var{proc} into a "memoizing macro".

@var{proc} should take an expression and an environment.  

@var{proc} should take an expression and an environment.  

When the macro object is applied, the expression containing it and the
active environment are passed to @var{proc}.  

The first time that occurs, the value returned from @var{proc} replaces
the source-expression that called the macro.

That time and thereafter the expansion is evaluated normally.
@end defun


@node  Time, GC, Low-Level Syntax Extensions, Top
@chapter Time

@defvr Constant internal-time-units-per-second

Is the integer number of internal time units in a second.
@end defvr

@defun get-internal-run-time
Returns the integer run time in internal time units from an unspecified
starting time.  The difference of two calls to
@code{get-internal-run-time} divided by
@code{internal-time-units-per-second} will give elapsed run time in
seconds.
@end defun

@defun get-internal-real-time
Returns the integer time in internal time units from an unspecified
starting time.  The difference of two calls to
@code{get-internal-real-time} divided by
@code{interal-time-units-per-second} will give elapsed real time in
seconds.
@end defun

@defun current-time
Returns the time since 00:00:00 GMT, January 1, 1970, measured in
seconds.  @xref{Time, current-time, , slib, SLIB}.  @code{current-time} is
used in @ref{Time, , , slib, SLIB}.
@end defun



@node  GC, Dynamic Roots, Time, Top
@chapter GC

@defun gc
Scans all of SCM objects and reclaims for further use those that are
no longer accessible.
@end defun

@defun gc-stats
Returns an association list of statistics about Guile's current use of storage.  
@end defun

@defun object-address obj
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end defun


@node Dynamic Roots, System Exceptions, GC, Top
@chapter Dynamic Roots

A @dfn{dynamic root} is a root frame of Scheme evaluation.
The top-level repl, for example, is an instance of a dynamic root.

Each dynamic root has its own chain of dynamic-wind information.  Each
has its own set of continuations, jump-buffers, and pending CATCH
statements which are inaccessible from the dynamic scope of any
other dynamic root.

In a thread-based system, each thread has its own dynamic root.  Therefore,
continuations created by one thread may not be invoked by another.

Even in a single-threaded system, it is sometimes useful to create a new
dynamic root.  For example, if you want to apply a procedure, but to
not allow that procedure to capture the current continuation, calling
the procedure under a new dynamic root will do the job.

@defun call-with-dynamic-root thunk handler
Evaluate @var{(thunk)} in a new dynamic context, returning its value.

If an error occurs during evaluation, apply @var{handler} to the
arguments to the throw, just as @code{throw} would.  If this happens,
@var{handler} is called outside the scope of the new root -- it is
called in the same dynamic context in which
@code{call-with-dynamic-root} was evaluated.

If @var{thunk} captures a continuation, the continuation is rooted at
the call to @var{thunk}.  In particular, the call to
@code{call-with-dynamic-root} is not captured.  Therefore,
@code{call-with-dynamic-root} always returns at most one time.

Before calling @var{thunk}, the dynamic-wind chain is un-wound back to
the root and a new chain started for @var{thunk}.  Therefore, this call
may not do what you expect:

@example
;; Almost certainly a bug:
(call-with-output-to-port
 some-port

 (lambda ()
   (call-with-dynamic-root
    (lambda ()
      (display 'fnord)
      (newline))
    (lambda (errcode) errcode))))
@end example

The problem is, on what port will @samp{fnord\n} be displayed?  You
might expect that because of the @code{call-with-input-from-port} that
it will be displayed on the port bound to @code{some-port}.  But it
probably won't -- before evaluating the thunk, dynamic winds are
unwound, including those created by @code{call-with-input-from-port}.
So, the standard output port will have been re-set to its default value
before @code{display} is evaluated.

(This function was added to Guile mostly to help calls to functions in C
libraries that can not tolerate non-local exits or calls that return
multiple times.  If such functions call back to the interpreter, it should
be under a new dynamic root.)
@end defun


@defun dynamic-root
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.
They are currently represented as numbers, but your code should
in no way depend on this.
@end defun

@defun quit &opt exit_val
@defunx restart
@defunx abort
Throw back to the error handler of the current dynamic root.

These call the error handler with the values bound to @code{repl-quit},
@code{repl-abort} and @code{repl-restart}, respectively.

If integer @var{exit_val} is specified and if Guile is being used
stand-alone and if quit is called from the initial dynamic-root,
@var{exit_val} becomes the exit status of the Guile process and the
process exits.
@end defun

@defvr Constant repl-quit
@defvrx Constant repl-abort
@defvrx Constant repl-restart
Possible values passed to the error proc of a dynamic root.
@end defvr



@node System Exceptions, Libc procedures, Dynamic Roots, Top
@chapter System Exceptions

These two expressions are equivalent:

@example
(error arg ...)
       
(throw 'error arg ...)
@end example

The following are the names of excpetions that may be thrown by the
interpreter itself.

@example
ARGn		"Wrong type argument"
ARG1		"Wrong type argument in position 1"
ARG2		"Wrong type argument in position 2"
ARG3		"Wrong type argument in position 3"
ARG4	        "Wrong type argument in position 4"
ARG5		"Wrong type argument in position 5"
WNA		"Wrong number of arguments"
OVFLOW		"Numerical overflow"
OUTOFRANGE	"Argument out of range"
NALLOC		"Could not allocate"
HUP_SIGNAL	"hang-up"
INT_SIGNAL	"user interrupt"
FPE_SIGNAL	"arithmetic error"
BUS_SIGNAL	"bus error"
SEGV_SIGNAL	"segmentation violation"
ALRM_SIGNAL	"alarm"

read-sharp-error
@end example

@node  Libc procedures, Procedure and Macro Index, System Exceptions, Top
@chapter Libc procedures

[This section is under construction.]

@defun software-type, 0, 0, 0
@end defun

@defun getenv, 1, 0, 0
@end defun

@defun system, 1, 0, 0
@end defun

@defun tmpnam
@defunx %delete-file file-name
@end defun

@node Procedure and Macro Index, Variable Index, Libc procedures, Top
@unnumbered Procedure and Macro Index

This is an alphabetical list of all the procedures and macros in SCM.

@printindex fn

@node Variable Index,  , Procedure and Macro Index, Top
@unnumbered Variable Index

This is an alphabetical list of all the global variables in SCM.

@printindex vr


@contents
@bye

