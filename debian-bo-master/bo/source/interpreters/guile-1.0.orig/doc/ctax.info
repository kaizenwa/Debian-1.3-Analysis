This is Info file ctax.info, produced by Makeinfo version 1.67 from the
input file ctax.texi.

INFO-DIR-SECTION Guile -- GNU extension language
START-INFO-DIR-ENTRY
* ctax: (ctax).                                 C-like syntax for Guile.
END-INFO-DIR-ENTRY


File: ctax.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

  This file documents Ctax, a flexible, C-like notation for writing
programs.

* Menu:

* Copying::
* Introduction - A Standard Block-structured and Algebraic Syntax::
* The Lexical Syntax of Ctax::
* The Grammar of Ctax::
* Ctax Syntax Trees::
* Translating Ctax to Scheme::
* Ctax Operators::
* A Ctax Example::


File: ctax.info,  Node: Copying,  Next: Introduction - A Standard Block-structured and Algebraic Syntax,  Prev: Top,  Up: Top

Copying
*******

                          Copyright (C) 1995

                    Free Software Foundation, Inc.

                675 Mass Ave, Cambridge, MA 02139, USA

Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

                              NO WARRANTY

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


File: ctax.info,  Node: Introduction - A Standard Block-structured and Algebraic Syntax,  Next: The Grammar of Ctax,  Prev: Copying,  Up: Top

Introduction - A Standard Block-structured and Algebraic Syntax
***************************************************************

     :use-module #/ctax/reader
     :use-module #/ctax/translator

  Ctax is a C-like, block-structured, algebraic notation for writing
computer programs.

  Ctax is defined by a reader that parses Ctax syntax and returns syntax
trees made up of Scheme lists.

  Ctax should not be confused with a programming language.  A
programming language would be defined not only by a reader, but also by
an evaluator that showed how to interpret the expressions parsed by the
reader.  Instead, Ctax is just a surface syntax in a programming
library - interpretation is up to the application.

  Nevertheless, there is at least one particularly natural
interpretation for Ctax expressions.  That interpretation is defined by
the Ctax translator.  The Ctax translator maps Ctax syntax trees to
Scheme syntax trees.  Mostly, this translation is a matter of mapping
C-style flow-of-control and scoping operators to Scheme-style
flow-of-control and scoping operators.  Additionally, Ctax expressions
are (trivially) translated.

  Ctax inherits all of C's expression operators.  The translator
translates these to calls to user-definable procedures and more than one
possible set of definitions is included in the ctax module.


File: ctax.info,  Node: The Grammar of Ctax,  Next: Ctax Syntax Trees,  Prev: Introduction - A Standard Block-structured and Algebraic Syntax,  Up: Top

The Grammar of Ctax
*******************

  This chapter describes the grammar of Ctax twice.  First informally,
and then as a grammar.

* Menu:

* What Ctax is Like::
* What Ctax is Really Like::


File: ctax.info,  Node: What Ctax is Like,  Next: What Ctax is Really Like,  Prev: The Grammar of Ctax,  Up: The Grammar of Ctax

What Ctax is Like
=================

  From the broadest perspective, Ctax syntax is described by the
"equation":

     Ctax =
       (C syntax)
     - CPP
     - (type declarations)
     + (Scheme constants)
     + (extended identifiers)
     + (C++ comments)
     + (The $ operator)
     + (Top-level statements);

* Menu:

* Identifiers::
* Constants::
* Expressions::
* Statements::
* Declarations::
* Commands::


File: ctax.info,  Node: Identifiers,  Next: Constants,  Prev: What Ctax is Like,  Up: What Ctax is Like

Identifiers
-----------

  The set of ctax identifiers is the same as the set of C identifiers.

     x
     y
     foo_bar

  In addition, the full range of Scheme identifiers is available in Ctax
though identifiers which are not also C identifiers must be quoted with
an initial backslash:

     \list-ref(x);
     x = \list-ref;

  Be careful to use enough whitespace when using Scheme-style
identifiers in expressions.   For example:

     \some-number+1

  names the variable `some-number+1', while

     \some-number + 1

  adds `some-number' to 1.  Like Scheme, symbols are terminated by
whitespace and by the characters `(' and `)'.  Unlike Scheme,
extended-syntax symbols in Ctax are terminated by comma (`,') as well.

  Using C-style identifiers, whitespace is not so significant:

     x+1

  is an addition expression, adding 1 to `x'.

  Identifiers always refer to variables from the lexical environment.


File: ctax.info,  Node: Constants,  Next: Expressions,  Prev: Identifiers,  Up: What Ctax is Like

Constants
---------

  Ctax supports ordinary numeric and string constants:

     10
     1000000000000000000
     "hello world\n"

  character constants, using C syntax:

     'a'
     '\n'
     '\001'

  quoted symbols:

     'a
     'list-ref

  and quoted Scheme lists:

     '(a b (c d) (long-identifier foo) ...)

  There is a slight lexical ambiguity because a character constant like:

     'a'

  could be read as a quoted symbol, `a', followed by a single quote.
The disambiguating rule is that if it looks like a character constant,
it is.


File: ctax.info,  Node: Expressions,  Next: Statements,  Prev: Constants,  Up: What Ctax is Like

Expressions
-----------

  Ctax expressions resemble C expressions.  There are function calls:

     cos (x)

  algebraic expresions:

     cos (x) * 2
     a ? b : c

  assignment expressions:

     a = 3
     a++
     ++a
     a += 10

  and comma expressions:

     a += 10, b += 4

  Ctax supports lambda expressions:

     lambda (a, b) { return a * b; }

  In the middle of Ctax, you can embed an expression written in s-exp
Scheme by using the `#' operator:

     x * #(some-scheme-expression ...)

  In Scheme, keywords are passed just like normal arguments, but by
convention, we think of them as sometimes being associated with the
parameter that follows.  For example, (in Scheme):

     (make-frob 'acme-style :color 'red :noise 'feep)

  The keyword `:color' is modified by the parameter `'red' and the
keyword `:noise' is modified by `'feep'.  In Ctax, keyword arguments
like those need not be followed by a comma in an argument list:

     make-frob ('acme-style, :color 'red, :noise 'feep)

  Ctax has one operator that C lacks: "dollar" (`$').  Dollar is a
prefix operator similar to `!' or `++'.  It is intended for use in Ctax
applications where there is some centrally significant, application
specific, unary mapping such as indexes to fields in awk, or indexes to
program arguments in shell scripts.

     puts ($(argc - 1));


File: ctax.info,  Node: Statements,  Next: Declarations,  Prev: Expressions,  Up: What Ctax is Like

Statements
----------

  Statements resemble C, too.  There are `for', `do' and `while' loops
supporting `break' and `continue'.  There are conditionals using `if'
and `if ... else'.  There are compound statements in which local
variables can be defined.  There is a `return' statement.  I have not
yet, but plan to support labeled loops and `break' and `continue' that
take label arguments.  I also plan to add `letrec', `let*', `let' and
`labeled let' blocks.

     public
     foo(r)
     {
       auto x;
       x = #(a b r c d);
       return some-fn (:bar, 1, :baz, :foo r,
                       '(dflj sdljf (sldkjf sdflkj)));
     }

  Var-args functions can be defined using this syntax:

     public foo(first, ... rest) { ... }

  or

     public foo (... vargs) {...}


File: ctax.info,  Node: Declarations,  Next: Commands,  Prev: Statements,  Up: What Ctax is Like

Declarations
------------

  When declaring functions or variables, types need not be specified,
though eventually support will be added so that they may optionally be
specified.

  Top level definitions must be declared either `static' or `public'.
`static' definitions use the Scheme primitive `define', `public' use
`define-public'.

  Local variables are declared using the keyword `auto' as in:

     lambda (y) { auto x; x = y * y;  return cons (x, y); }

  A top-level assignment statement (outside of any function definiton)
acts like a static declaration.  Thus:

     x = 69;

  is equivalent to:

     static x = 69;


File: ctax.info,  Node: Commands,  Prev: Declarations,  Up: What Ctax is Like

Commands
--------

  The ctax reader reads a complete "command" each time it is called.  A
command is either a function definition or variable declaration, or a
statement which is evaluated at global scope.


File: ctax.info,  Node: What Ctax is Really Like,  Prev: What Ctax is Like,  Up: The Grammar of Ctax

What Ctax is Really Like
========================

  This section presents the Ctax notation as a formal lexical language
and grammar.  The specifications printed here were derived from the
source code by (trivial) Scheme procedures that pretty-printed the data
structures that drive lexing and parsing.

  Unfortunately, tools for automatically deriving the manual from the
source code are lacking and so the results have to be maintained by
hand.  If the manual seems to be out of date on some point, consult the
source code.

* Menu:

* The Lexical Syntax of Ctax::
* Ctax Grammar::


File: ctax.info,  Node: The Lexical Syntax of Ctax,  Next: Ctax Grammar,  Prev: What Ctax is Really Like,  Up: What Ctax is Really Like

The Lexical Syntax of Ctax
--------------------------


     ;; C++ style comments:
     ;;
     //[^\n]*                                        ignored
     
     ;; Whitespace is ignored:
     ;;
     [ \t\n]\+                                       ignored
     
     ;; Identifiers normally follow C syntax:
     ;;
     [a-zA-Z_][a-zA-Z0-9_]*                          <identifier>
     
     ;; except when preceeded by a backslash:
     ;;
     \\[a-z?!<>=0-9_-][a-z:?!<>=0-9_-]*              <identifier>
     
     ;; Ctax has keywords, which C does not.   Keywords have the
     ;; syntax of extended (Scheme-like) identifiers, but begin
     ;; with a colon:
     ;;
     :[a-z?:!<>=0-9_-]\+                             <keyword>
     
     ;; Numbers
     ;;
     [0-9]\+\.\?[0-9]*                               <constant>
     
     ;; String constants:
     ;;
     \("\([^"\\]\|\\.\)*"\)                          <constant>
     
     ;; There are octal character constants:
     ;;
     '\\0[0-7]?[0-7]?[0-7]?'                         <constant>  :shortest
     
     ;; Backslash-code character constants:
     ;;
     '\\n'                                           <constant> :shortest
     '\\t'                                           <constant> :shortest
     '\\r'                                           <constant> :shortest
     
     ;; Character constants with an irrelevant backslash:
     ;;
     '\\.'                                           <constant> :shortest
     
     ;; Normal character constants
     ;;
     '.'                                             <constant> :shortest
     
     ;; If something begins with a single quote but doesn't look like a character
     ;; constant, it might be a quoted Scheme symbol name, or a quoted Scheme list.
     ;;
     '[a-z?!<>=0-9_-][a-z:?!<>=0-9_-]*               <constant>
     
     ;; The lex spec only shows the opening paren of a quoted list but
     ;; if that much is read, the lexer reads the entire list.
     ;;
     '(                                              <constant>
     
     
     ;; Scheme backquote expressions can also be embedded in Ctax.
     ;; The spec only shows the backquote, but if that much is read,
     ;; the lexer reads the entire backquote expression.
     ;;
     `                                               <constant>
     
     ;; A pound-sign can be followed by an arbitrary Scheme expression.
     ;; It is read using the Scheme procedure "read".   In a Ctax
     ;; program, this kind of literal can be embedded in the middle
     ;; of an expression.
     ;;
     #                                               <literal>
     
     ;; With the exception of a few new keywrods, the rest of the grammar
     is unremarkable:
     
     {                                              <lbrace>
     }                                              <rbrace>
     ;                                               <semi>
     \.\.\.                                          <...>
     lambda                                          <lambda>
     public                                          <public>
     static                                          <static>
     auto                                            <auto>
     if                                              <if>
     else                                            <else>
     for                                             <for>
     while                                           <while>
     return                                          <return>
     do                                              <do>
     break                                           <break>
     continue                                        <continue>
     ,                                               <comma>
     =                                               <=>
     \*=                                             <assignment>
     /=                                              <assignment>
     %=                                              <assignment>
     +=                                              <assignment>
     -=                                              <assignment>
     >>=                                             <assignment>
     <<=                                             <assignment>
     &=                                              <assignment>
     \^=                                             <assignment>
     |=                                              <assignment>
     \?                                              <?>
     :                                               <colon>
     ||                                              <flowor>
     &&                                              <flowand>
     |                                               <logor>
     &                                               <logand>
     \^                                              <logxor>
     ==                                              <==>
     !=                                              <!=>
     >=                                              <>=>
     <=                                              <<=>
     <                                               <<>
     >                                               <>>
     <<                                              <<<>
     >>                                              <>>>
     +                                               <+>
     -                                               <->
     \*                                              <*>
     /                                               </>
     %                                               <%>
     --                                              <-->
     ++                                              <++>
     ~                                               <lognot>
     !                                               <!>
     \[                                              <lbracket>
     \]                                              <rbracket>
     (                                               <lparen>
     )                                               <rparen>
     ->                                              <arrow>
     ->*                                             <arrow*>
     .                                               <dot>
     .*                                              <dot*>


File: ctax.info,  Node: Ctax Grammar,  Prev: The Lexical Syntax of Ctax,  Up: What Ctax is Really Like

Ctax Grammar
------------

     $cmd$ -> <static> <identifier> <lparen> $arg-list$ <rparen> $block$
            | <public> <identifier> <lparen> $arg-list$ <rparen> $block$
            | <public> <identifier> <=> $exp$ <semi>
            | <static> <identifier> <=> $exp$ <semi>
            | <public> <identifier> <semi>
            | <static> <identifier> <semi>
            | $statement$
     
     $arg-list$ -> <...> <identifier>
                 | $id-list$ <comma> <...> <identifier>
                 | $id-list$
                 |
     
     $id-list$ -> $id-list$ <comma> <identifier>
                | <identifier>
     
     $block$ -> <lbrace> $declarations$ $statement-list$ <rbrace>
     
     $declarations$ -> $declarations$ $declaration$
                     |
     
     $declaration$ -> <auto> <identifier> <semi>
                    | <auto> <identifier> <=> $exp$ <semi>
     
     $statement-list$ -> $statement-list$ $statement$
                       |
     
     $statement$ -> <if> <lparen> $exp$ <rparen> $statement$
                  | <if> <lparen> $exp$ <rparen> $statement$ <else> $statement$
                  | <while> <lparen> $exp$ <rparen> $statement$
                  | <do> $statement$ <lparen> $exp$ <rparen> <semi>
                  | <for> <lparen> $exp$ <semi> $exp$ <semi> $exp$ <rparen> $statement$
                  | <return> $exp$ <semi>
                  | <break> <semi>
                  | <continue> <semi>
                  | <semi>
                  | $exp$ <semi>
                  | <lbrace> $declarations$ $statement-list$ <rbrace>
     
     $exp$ -> $assignment-exp$
            | $exp$ <comma> $assignment-exp$
     
     $assignment-exp$ -> $conditional-exp$
                       | $unary-exp$ <assignment> $assignment-exp$
                       | $unary-exp$ <=> $assignment-exp$
     
     $conditional-exp$ -> $flow-or-exp$
                        | $flow-or-exp$ <?> $exp$ <colon> $conditional-exp$
     
     $flow-or-exp$ -> $flow-and-exp$
                    | $flow-or-exp$ <flowor> $flow-and-exp$
     
     $flow-and-exp$ -> $logor-exp$
                     | $flow-and-exp$ <flowand> $logor-exp$
     
     $logor-exp$ -> $logxor-exp$
                  | $logor-exp$ <logor> $logxor-exp$
     
     $logxor-exp$ -> $logand-exp$
                   | $logxor-exp$ <logxor> $logand-exp$
     
     $logand-exp$ -> $equality-exp$
                   | $logand-exp$ <logand> $equality-exp$
     
     $equality-exp$ -> $relational-exp$
                     | $equality-exp$ <==> $relational-exp$
                     | $equality-exp$ <!=> $relational-exp$
     
     $relational-exp$ -> $shift-exp$
                       | $relational-exp$ <<> $shift-exp$
                       | $relational-exp$ <>> $shift-exp$
                       | $relational-exp$ <<=> $shift-exp$
                       | $relational-exp$ <>=> $shift-exp$
     
     $shift-exp$ -> $additive-exp$
                  | $shift-exp$ <<<> $additive-exp$
                  | $shift-exp$ <>>> $additive-exp$
     
     $additive-exp$ -> $multiplicative-exp$
                     | $additive-exp$ <+> $multiplicative-exp$
                     | $additive-exp$ <-> $multiplicative-exp$
     
     $multiplicative-exp$ -> $cm-exp$
                           | $multiplicative-exp$ <*> $cm-exp$
                           | $multiplicative-exp$ </> $cm-exp$
                           | $multiplicative-exp$ <%> $cm-exp$
     
     $cm-exp$ -> $unary-exp$
               | $cm-exp$ <arrow*> $unary-exp$
               | $cm-exp$ <dot*> $unary-exp$
     
     $unary-exp$ -> $postfix-exp$
                  | <dollar> $unary-exp$
                  | <++> $unary-exp$
                  | <--> $unary-exp$
                  | <-> $unary-exp$
                  | <!> $unary-exp$
                  | <lognot> $unary-exp$
     
     $postfix-exp$ -> $primary-exp$
                    | $postfix-exp$ <lbracket> $exp$ <rbracket>
                    | $postfix-exp$ <lparen> $opt-exp-list$ <rparen>
                    | $postfix-exp$ <++>
                    | $postfix-exp$ <-->
     
     $exp-list$ -> $assignment-exp$
                 | <keyword>
                 | <keyword> $assignment-exp$
                 | $exp-list$ <comma> $assignment-exp$
                 | $exp-list$ <comma> <keyword>
                 | $exp-list$ <comma> <keyword> $assignment-exp$
     
     $opt-exp-list$ -> $exp-list$
                     |
     
     $primary-exp$ -> <identifier>
                    | <number>
                    | <constant>
                    | <lparen> $exp$ <rparen>
                    | <literal>
                    | <keyword>
                    | <quasi-constant>
                    | <lambda> <lparen> $arg-list$ <rparen> <lbrace> $declarations$ $statement-list$ <rbrace>


File: ctax.info,  Node: Ctax Syntax Trees,  Next: Translating Ctax to Scheme,  Prev: The Grammar of Ctax,  Up: Top

Ctax Syntax Trees
*****************

  The best way to see what syntax trees are returned for particular
constructs in the Ctax grammar is to read the parser code (it is quite
simple).  See the file `ctax/grammar.scm' in the distribution that
includes this manual.


File: ctax.info,  Node: Translating Ctax to Scheme,  Next: Ctax Operators,  Prev: Ctax Syntax Trees,  Up: Top

Translating Ctax to Scheme
**************************

  The basic interface for translating Ctax to Scheme consists of one
procedure and one macro:

 - Function: translate-ctax-statement STMT
 - Macro: ctax-statement STMT
     Convert a Ctax syntax tree to executable Scheme code.

     The procedure `translate-ctax-statement' returns the translated
     Scheme expressions.

     The macro, `ctax-statement', is a trivial wrapper for
     `translate-ctax-statement'.  The macro allows Ctax syntax trees to
     be passed to Scheme `eval' because the compiler makes translations
     like:

          public
          addem (a, b, c)
          {
             return a + b + c;
          }
          
          =>
          
          (define-public addem (ctax-statment (ctax-lambda (a b c) () ((ctax-+ a b c)))))

     and

          addem (1, 2, 3);
          
          =>
          
          (ctax-statment (ctax-apply addem (1 2 3)))


File: ctax.info,  Node: Ctax Operators,  Next: A Ctax Example,  Prev: Translating Ctax to Scheme,  Up: Top

Ctax Operators
**************

  Users are given the opportunity to redefine any operator in the Ctax
language.  Every operator corresponds to a conventionally named Scheme
procedure that can be redefined in the usual way.

  For example, the translation of:

     a + b * c

  is

     (ctax-+ a (ctax-* b c))

  `ctax-+' and `ctax-*' can be defined however you like.

  Some implementations of the Ctax operators are provided in this
distribution.

* Menu:

* C ops::
* hashtables::
* Scheme ops::


File: ctax.info,  Node: C ops,  Next: hashtables,  Prev: Ctax Operators,  Up: Ctax Operators

C ops
=====

     :use-module #/ctax/c-ops

  The `c-ops' module defines the Ctax operators to be similar to those
of the C programming language.

  Arithmetic operators, such as `ctax-+' and `ctax-/' are implemented
by the corresponding Scheme function (such as `+' or `/').

  Array subscripting (`ctax-array-ref' and `ctax-array-set!') is
defined to work on both vectors and strings.

  `ctax-test' which is implicitly applied to all conditional
expressions (as in `if (exp) ...') reduces all values to `#t' except
for `#f' and `0', which are reduced to `#f'.


File: ctax.info,  Node: hashtables,  Next: Scheme ops,  Prev: C ops,  Up: Ctax Operators

hashtables
==========

     :use-module #/ctax/hashtabs

  The `hashtabs' module doesn't define all ctax-operators, only
`ctax-array-ref' and `ctax-array-set!'.   These operators are defined
to work both on vectors and associative mappings as defined by the
module `#/ice-9/mapping'


File: ctax.info,  Node: Scheme ops,  Prev: hashtables,  Up: Ctax Operators

Scheme ops
==========

     :use-module #/ctax/scm-ops

  The `c-ops' module defines the Ctax operators to be similar to those
of Scheme.

  Arithmetic operators, such as `ctax-+' and `ctax-/' are implemented
by the corresponding Scheme function (such as `+' or `/').

  Array subscripting (`ctax-array-ref' and `ctax-array-set!') is
defined to work on vectors only.

  `ctax-test' which is implicitly applied to all conditional
expressions (as in `if (exp) ...') reduces all values to `#t' except
for `#f'.   Unlike the `c-ops' version of `ctax-test', this version
reduces `0' to `#t'.


File: ctax.info,  Node: A Ctax Example,  Prev: Ctax Operators,  Up: Top

A Ctax Example
**************

     \define-module (#(example),
     		:use-module #(ice-9 mapping),
     		:use-module #(ctax macros),
     		:use-module #(ctax hashtabs),
     		:use-module #(ctax cops));
     
     static table = hash_table ();
     static table2 = hash_table (:hash-proc hashq);
     
     public
     register (key, value)
     {
       table[key] = value;
       table2[key] = value;
       return value;
     }
     
     
     public
     check (key)
     {
       return table[key];
     }
     
     public
     check2 (key)
     {
       return table2[key];
     }
     
     
     x = '(a b . c);
     
     register (x, "hello world");
     
     write (check (x));
     newline ();
     write (check2 (x));
     newline ();
     write (check ('(a b . c)));
     newline ();
     write (check2 ('(a b . c)));
     newline ();



Tag Table:
Node: Top258
Node: Copying646
Node: Introduction - A Standard Block-structured and Algebraic Syntax2497
Node: The Grammar of Ctax3985
Node: What Ctax is Like4337
Node: Identifiers4887
Node: Constants5915
Node: Expressions6568
Node: Statements8017
Node: Declarations8902
Node: Commands9631
Node: What Ctax is Really Like9920
Node: The Lexical Syntax of Ctax10611
Node: Ctax Grammar17173
Node: Ctax Syntax Trees22100
Node: Translating Ctax to Scheme22484
Node: Ctax Operators23540
Node: C ops24151
Node: hashtables24811
Node: Scheme ops25187
Node: A Ctax Example25853

End Tag Table
