@node Introduction - what is Guile
@chapter Introduction - what is Guile
@cindex Guile
@cindex GNU extension language

@dfn{Guile} (which can stand for @emph{GNU Ubiquitous Intelligent
Language Extension}) is the GNU extension language.  It started out as
an embeddable Scheme interpreter, and has rapidly evolved into a
kitchen-sink package including an embeddable Scheme interpreter, several
graphics options, other languages that can be used along with Scheme
(for now just @emph{ctax} and @emph{Tcl}), and hooks for much more.



@menu
* What are scripting and extension languages::  
* History of Guile and its motivations::  
* How to characterize Guile::   
* Roadmap for the User Manual::
@end menu

@node What are scripting and extension languages
@section What are scripting and extension languages
@cindex scripting languages
@cindex extension languages

A @dfn{scripting language} is a programming language which serves as
glue between other system programs.  In the UNIX world, the traditional
scripting language is the @emph{Bourne shell}, which allows many UNIX
commands to be executed in sequence, or in a pipeline.  Traditional UNIX
commands are cleverly written to work well when put together in a
script.

Other examples of UNIX scripting languages are AWK, Perl, Scsh (the
Scheme Shell: a Scheme interpreter enhanced to do good scripting),
Python, Tcl, Java @dots{}
@cindex scripting languages - examples

UNIX programmers noticed, more than 25 years ago, that scripting
languages can do serious work, so the Bourne shell was written to have
variables, operators and control structures, just like a full-featured
programming language.
@cindex Bourne shell

What scripting languages have, that traditional programming languages do
not, is the ability to easilly run an external program (or a pipeline of
external programs) and use the returned values and output from that
program in useful ways.

@c Unfortunately, scripting languages have typically been not been designed
@c for writing large programs.  Recently, with SCSH and Guile, a good
@c programming language (Scheme) has been enhanced to work well for
@c scripting.

An @dfn{extension language} is a programming language interpreter
offered by an applications program, so that users can write macros or
even full-fledged programs to extend the original application.
Extension languages have a C interface (it is usually C, but it could be
any other compiled language), and can be given access to the C data
structures.  Likewise, there are C routines to access the extension
language data structures.

Extension languages abound in the software world, even though the name
@emph{extension language} is seldom used.  Examples are:
@cindex extension languages - examples

@itemize @bullet
@item
Emacs Lisp, the language used to program and customize GNU Emacs.
@cindex Emacs Lisp

@item
Tcl, John Ousterhout's general-purpose scripting and extension language.
@cindex Tcl

@item
The Lotus 1-2-3 macro language (any spreadsheet macro language,
really).  I mention this one first because it is a classic, even though
it is seldom used any more.
@cindex Lotus 1-2-3

@item
Other spreadsheet and database macro languages.

@item
The Dominion empire-style game's @emph{exec} files.
@cindex Dominion

@item
Any syntax for a ".*rc" file you might have used.  Almost all programs
end up parsing some kind of startup or configuration file.  The syntax
for those can get pretty involved, thus justifying calling them
"extension languages".  The @emph{fvwm} window manager, for example,
parses a rather elaborate @file{.fvwmrc} file.

@item
Brent Benson's libscheme.a, an embeddable Scheme interpreter.
@cindex Benson, Brent
@cindex libscheme

@item
Guile, the GNU extension language, which is the subject of this manual.

@end itemize

One lesson we can learn from looking at classical large software
applications is that "writers of large programs" always end up throwing
in some kind of parser for configurations or scripting.

Of the examples listed above, Emacs Lisp, Tcl, Libscheme and Guile have
an important property: they are not added as an afterthought for a
specific application.  They are general-purpose languages which a user
can learn (even in college courses) and then use to customize the
application program.

This is a new and (in my opinion) very exciting direction in
large-program software engineering: program designers can link to the
Guile or Tcl library from the very beginning, and tell their users "You
want to customize this program?  Just use Scheme (or Tcl, or whatever
language), which you already know!"
@cindex large programs



@node History of Guile and its motivations
@section History of Guile and its motivations

A few separate threads of events lead to the development of Guile.

In the fall of 1994 Richard Stallman, director of the GNU project,
posted an article with the subject "Why you should not use Tcl", in
which he argued that Tcl is inadequate as an extension language.  This
generated a flurry of flames (available in the hypermail archive
(@url{http://www.utdallas.edu/acc/glv/Tcl/war/}) @strong{The Tcl War}).
@cindex Stallman, Richard
@cindex GNU project
@cindex Tcl

The result was that Stallman then proposed his design for the GNU
Extension Language, first called GEL and then renamed Guile.  The
discussion triggered by that article is also available
@url{http://www.utdallas.edu/acc/glv/Tcl/war2/} in a hypermail archive.

One interesting feature of this GNU Extension Language plan was that
users should have a @emph{choice} of languages to use in extending their
program.  The basic language would be a slightly modified Scheme, and
translators would be written to convert other languages (like Tcl,
Python, Perl, C-like languages @dots{}) into Scheme.

Tom Lord started working on this project immediately, taking Aubrey
Jaffer's small and portable implementation of Scheme, SCM, and making it
into an embeddable interpreter: callable from C and allowing new Scheme
procedures to be written in C.
@cindex Lord, Tom
@cindex Jaffer, Aubrey

In the spring of 1995, the guile-ii snapshot was released.  This made it
possible to start writing code in C and Scheme using the guile
facilities.

The guile-iii snapshot was released the summer of 1995, and it had fixed
enough problems so that the access to Scheme data structures from C was
almost complete.

After this Cygnus Support added many features to Guile and finished
implementing others, so that Guile acquired tread support, a regular
expression matcher, a Tk interface, an interface to the SGI OpenGL
graphics system, an @emph{applet} formalism, and some other packages.
This was all in the Cygnus Guile r0.3 and r0.4 releases.
@cindex Cygnus Support

Meanwhile Tom Lord left the project having produced a divergent version
Guile: 1.0b2.  The Free Software Foundation hired Jim Blandy to
coordinate Guile development.  At the time of writing (October 1996) a
Guile 1.0 relesae is approaching, and many of the Cygnus packages are
being re-integrated into Guile.
@cindex Blandy, Jim
@cindex Free Software Foundation



@node How to characterize Guile
@section How to characterize Guile

I have already mentioned that Guile has become a kitchen sink package;
here you can see how Guile freely takes new commands and constructs from
the portable Scheme library @emph{slib}, the @emph{Tk} widget set, a
posix library (useful for UNIX systems programming), the regular
expression library @emph{rx}, and many more @dots{}
@cindex slib
@cindex Tk
@cindex POSIX
@c @cindex OpenGL
@cindex rx

So Guile has many more primitive procedures available to it than those
specified in @ref{Standard Procedures, Revised(4) Report on the
Algorithmic Language Scheme, , r4rs, Revised(4) Report on the
Algorithmic Language Scheme}.  On top of that, Guile will interpret
almost all standard Scheme programs.  The only incompatible difference
between the basic Guile language and R4RS Scheme is that Guile is case
sensitive, whereas R4RS is case insensitive.  We hope that few people
have written Scheme programs that depend on case.
@cindex case sensitivity
@cindex Revised(4) Report on the Algorithmic Language Scheme
@cindex report on Scheme
@cindex Scheme language - report
@cindex Scheme language - definition

Here is a possible view of the @emph{sum of the parts} in Guile:
@cindex extensions to standard Scheme
@cindex extensions to R4RS
@cindex Scheme extensions
@example
guile   =       standard Scheme (R4RS)
        PLUS    extensions to R4RS offered by SCM
        PLUS    some extra primitives offered by Guile (catch/throw)
        PLUS    portable Scheme library (SLIB)
        PLUS    embeddable Scheme interpreter library (libguile)
        PLUS    Tk toolkit
        PLUS    threads
        PLUS    Posix library
@c         PLUS    OpenGL library (mesa)
@c         PLUS    OpenGL toolkit (glut)
        PLUS    Regular expression library (rx)
@c         PLUS    Applet formalism
        PLUS    Tcl library
@end example

@node Roadmap for the User Manual
@section Roadmap for the User Manual

My intention in this User Manual is to give you all you need to know to
do simple and advanced programming with Guile.  I will assume that you
(the Guile programmer using this manual) know how to program in C and
Scheme.

Some sections -- @ref{Regular expression support} and @ref{The Guile
interface to Posix} -- will make further assumptions about your
background; in the two sections just mentioned it will be assumed that
you are familiar with regular expressions and UNIX system programming.


