@c \input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename guile_user.info
@settitle Guile User Manual
@c %**end of header



@node More on the Guile interface to Tk, Some other features of Guile, Guile in a library - using libguile.a, Top
@chapter More on the Guile interface to Tk
@cindex Tk

A couple of the examples in the quick tour made use of the Tk toolkit.
Here I will say more about how Guile interfaces to Tk.  We will also
give you a recipe for reading Tk documentation, which is written
assuming the Tcl interface, and writing scheme code with it.

In this chapter I do not give any sort of introduction to Tk in general.
There are books on Tk, but maybe the best way to learn the Tk widgets is
to go through the @code{wtour} tour of widgets that is distributed with
Tk.  It is more pedagogical than the main book @cite{Tcl and the Tk
Toolkit}.


@menu
* What you need to use Tk::     
* Creating a widget::           
* Scheme callbacks::            
* Sending a command to a widget::  
@end menu

@node What you need to use Tk, Creating a widget, More on the Guile interface to Tk, More on the Guile interface to Tk
@section What you need to use Tk

The Guile program is usually compiled with the Tk interface, so to use
Tk you only need to include this preamble in your scheme code:
@cindex Tk - step by step

@cartouche
@smalllisp
(require 'Gwish)
(use-library tcl)
(use-interface tcl)
(use-interface tclhack)
@end smalllisp
@end cartouche

and then conclude the main program with:

@cartouche
@smalllisp
(tk-main-loop)
(quit)
@end smalllisp
@end cartouche

Note: the preamble is kind of ugly, and it will probably change.



@node Creating a widget, Scheme callbacks, What you need to use Tk, More on the Guile interface to Tk
@section Creating a widget
@cindex Tk - creating widgets
@cindex creating widgets
@cindex creating Tk widgets
@cindex widgets - creation

Here are some (out of context) examples of the syntax for creating Tk
widgets:

@smalllisp
(button '.quit :text "quit" :command (tcl-lambda () (quit-callback)))
(text '.a :yscrollcommand ".b set")
(scrollbar '.b :command ".a yview")
(frame '.button-bar :relief 'raised :bd 2)
(canvas '.ca :width 200 :height 300)
(label '.lab :text "this is a label")
@end smalllisp

What can we deduce from these examples of widget creation?

@enumerate
@item
There are new primitive scheme procedures for each type of widget;
invoking this procedure creates the widget.

@item
The widget name is always followed by a quoted variable name.  The
variable name is the standard Tk widget hierarchical name with the
@emph{dot} separator.

@item
Options that modify the appearance or behaviour of the widget are given
with a @emph{colon}, such as @code{:text}, @code{:command},
@code{:width} @dots{}

@end enumerate


@node Scheme callbacks, Sending a command to a widget, Creating a widget, More on the Guile interface to Tk
@section Scheme callbacks
@cindex widget callbacks
@cindex scheme callbacks
@cindex callbacks - Tk
@cindex Tk widget callbacks

A @dfn{widget callback} (or simply @dfn{callback}) is a procedure that
gets invoked when something happens in a widget, for example if the
mouse is clicked on a button or scrollbar.

When you first create a Tk widget, you can specify that a procedure
should become the callback, usually with the @code{:command} option
in the widget creation, although a widget could allow several callbacks,
and those could be set by other options such as @code{:yscrollcommand}.

If a command is to @strong{invoke a scheme procedure}, it is done with
the @code{tcl-lambda} primitive.  This is similar to a simple scheme
@code{lambda} expression, but it straightens out the calling convention
between Tcl and scheme.
@cindex tcl-lambda
@cindex lambda - tcl-lambda

The @code{tcl-lambda} expression also makes sure that the anonymous
procedure created will not be garbage-collected away while a callback is
not being executed.

@c [??? must check on this; it's just a vague memory from the mailing list]

Notice that @code{tcl-lambda} is not a clean implementation, and Guile
will probably be fixed eventually so that you can just use
@code{lambda}.

But not all callbacks invoke scheme procedures.  In the creation
examples just given, the widget created by
@smalllisp
(scrollbar '.b :command ".a yview")
@end smalllisp
passes a message to the text widget @code{.a}.  This message passing is
done with the string @code{".a yview"}, which just maps directly to the
equivalent Tcl code.
@cindex message passing - Tk
@cindex Tk message passing

@c [??? I don't know if this will always be this way]


@node Sending a command to a widget,  , Scheme callbacks, More on the Guile interface to Tk
@section Sending a command to a widget
@cindex configuring widgets
@cindex widget configuration

Once a widget has been created and its callbacks (if any) have been
registered, that widget becomes a new scheme primitive procedure.  This
procedure can be used to give further instructions to a widget.

One example of this is to add or change configuration options to a
widget after it has been created.  Try this self-contained program to
see an example of the @code{config} command being sent to a widget.  It
also shows examples of putting several buttons together in a frame, and
illustrates the @code{destroy} command that kills off a Tk widget.

You can find this example in @file{examples/tk/two-button.scm}.
@findex config

@smalllisp
#!/packages/bin/guile -qb
; -*-scheme-*-

;; a two-button example that does some funky stuff

(require 'Gwish)
(use-library tcl)
(use-interface tcl)
(use-interface tclhack)

;; create a frame widget to house the buttons
(frame '.button-bar :relief 'raised :bd 2)
(pack '.button-bar)

;; create the quit button: its callback destroys the top level widget
(button '.button-bar.quit :text "quit" :command
  (tcl-lambda ()
    (begin
      (display "quitting now\n")
      (destroy "."))))

;; create the "change text" button: its callback changes the text
;; of the "quit" button, and destroys itself.
(button '.button-bar.change-text :text "change text" :command
  (tcl-lambda ()
    (begin
      (.button-bar.quit 'config :text "hey, it just changed")
      (destroy ".button-bar.change-text"))))

(pack '.button-bar.quit '.button-bar.change-text :side 'left)

(tk-main-loop)
(quit)
@end smalllisp
