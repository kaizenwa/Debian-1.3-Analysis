@node How to start up Guile - a quick tour
@chapter How to start up Guile - a quick tour
@cindex anonymous procedure
@cindex widget callback
@cindex callback
@c @cindex lambda expressions


@menu
* Invoking Guile::              
* Guile as a basic Scheme interpreter::  
@end menu

@node Invoking Guile
@section Invoking Guile
@cindex options
@cindex command line options
@cindex invocation
@cindex invoking Guile
@cindex invoking ggl
@cindex synopsis

@noindent

Here is the synopsis for @code{guile}:

@smallexample
guile  [-h, --help] [-v, --version] [-s SCRIPT] [-e, --emacs]
@end smallexample

Upon startup Guile checks to see if you have a file called @file{.guile}
in your home directory, and if you do it loads that file.

@table @code

@item -h
@itemx --help
Prints out a synopsis for invoking @code{guile}.

@item -v
@itemx --version
Prints out the version of Guile you are executing.

@item -s SCRIPT
Load the file named SCRIPT, then exit.

@item -v
@itemx --version
Prints out the version of Guile you are executing.

@c @item --
@c specifies that there are no more options on the command line.

@end table


@node Guile as a basic Scheme interpreter
@section Guile as a basic Scheme interpreter

You could start by running the actual @code{guile} program.  In a most
basic sense, @code{guile} is a souped-up version of Aubrey Jaffer's
Scheme interpreter @emph{SCM}.

If the binary directory into which you installed guile is in your path,
you should be able to just type @code{guile}.  Here is an example
session:

@smallexample
<shell-prompt> guile
guile> (+ 20 35)
55
guile> (define (recursive-factorial n)
         (if (= n 0)
             1
            (* n (recursive-factorial (- n 1)))))
guile> (recursive-factorial 5)
120
guile> (recursive-factorial 500)
1220136825991110068701238785423046926253574342803192842192413588
3858453731538819976054964475022032818630136164771482035841633787
2207817720048078520515932928547790757193933060377296085908627042
9174547882424912726344305670173270769461062802310452644218878789
4657547771498634943677810376442740338273653974713864778784954384
8959553753799042324106127132698432774571554630997720278101456108
1188373709531016356324432987029563896628911658974769572087926928
8712817800702651745077684107196243903943225364226052349458501299
1857150124870696156814162535905669342381300885624924689156412677
5654481886506593847951775360894005745238940335798476363944905313
0623237490664450488246650759467358620746379251842004593696929810
2226397195259719094521782333175693458150855233282076282002340262
6907898342451712006207714640979456116127629145951237229913340169
5523638509428855920187274337951730145863575708283557801587354327
6888868012039988238470215146760544540766353598417443048012893831
3896881639487469658817504506926365338175055478128640000000000000
0000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000
guile> (quit)
<shell-prompt>
@end smallexample

In this last example we did some simple arithmetic @code{(+ 20 35)} and
got the answer @code{55}.  Then we coded the classic (and rather
wasteful) factorial algorithm, and got a glimpse of Scheme's nice
@emph{bignumbers} by asking for the factorial of 1000.  Then we quit
with @code{(quit)}.
@cindex bignumbers

