@c \input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile-i18n.info
@settitle Internationalization Features in Guile
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@node Internationalization Features in Guile, Where to find more Guile/scheme resources, Some other features of Guile, Top
@appendix Internationalization Features in Guile

This chapter has been written by Takumi Doi at CST, March 29 1996.  It
is included here verbatim.
@cindex Doi, Takumi

Among significant improvements made to Guile in this release, this
appendix describes the @dfn{internationalization features} that allow
Guile manipulate and render characters from various international
character sets including Latin, Japanese Kanji, Chinese Hanji, Korean
Hangul, et al.

@appendixsec Building Guile with Internationalization Features

To include internationalization feature in Guile, you should
specify the option @code{--enable-i18n} when you @code{configure} Guile,
such as:

@example
% ./configure --enable-i18n --prefix=`pwd`/=inst
@end example

In the current release, the modules affected by this option are only
libguile, gls, and gtcltk. In addition, Tcl/Tk that comes with this
release incorporates support solely for Japanese EUC patches.  This also
means the rest of plugin libraries are yet to be internationalized.
@ifset debug
Those who want to contribute the tasks should contact Whats H. Name
<His-Mail-Address>.
@end ifset

@appendixsec Character and String representations

In Guile, each character is identified by a unique internal character
code, a 24 bit integer. The function @code{char->integer} can be used 
to retrieve the internal character code of a character.

On the other hand, strings are represented as sequences of 8 bit-byte
elements, where characters with character codes beyond 255 are split
into adjacent bytes to form a @dfn{multibyte string}.

This design decision of using multibyte strings is motivated by one of
major goals of Guile; to provide an east-to-integrate underlying
implementation for GNU Emacs. Authors also believe that this design
allows a single string data type and compact string representation that
can easily support evolving international standards with larger
character sets.


@appendixsec External Character Encodings

While Guile has its own internal character representation, the new 
internationalization features enable users to easily handle characters 
from wide variety of existing coded character sets.

By @dfn{external character encoding} the author means any character
encoding method other than the Guile Scheme internal encoding, whose
coded characters have to be converted when reading from text streams and
writing to external devices for saving or rendering.

In Guile Scheme, such conversion is controled by optional arguments
to several I/O procedures, in addition to a couple of global variable 
values to be used as the default conversion method. 

Following self-evaluating symbols designate available character
encodings for file I/O as well as process I/O:

@itemize @bullet
@item @code{*sjis*} -- Microsoft Kanji code, or Shift-JIS
@item @code{*iso-2022-jp*}, aka @code{*junet*} -- encoding used in Japan 
to transfer emails and netnews 
@item @code{*iso-2022-int-1*} -- "ISO-2022-INT-1" [So what's this?!]
@item @code{*old-jis*} -- Obsolete JIS encoding  
@item @code{*ctext*}, aka @code{*iso-8859-1*} -- Compound Text encoding
@item @code{*euc-japan*} -- Japanese version of Extended Unix Code
@item @code{*euc-korea*}, aka @code{*euc-kr*} -- Korean version of Extended 
Unix Code
@item @code{*iso-2022-kr*}, aka @code{*korean-mail*} -- encoding used in Korea 
to transfer emails and netnews 
@item @code{*iso-2022-ss2-8*} -- ISO-2022 encoding using SS2 for 96-charset 
in 8-bit code
@item @code{*iso-2022-ss2-7*} -- ISO-2022 coding system using SS2 for 
96-charset in 7-bit code
@item @code{*iso-2022-lock*} -- ISO-2022 coding system using Locking-Shift 
for 96-charset
@item @code{*big5*}, aka @code{*big5-eten*} -- BIG5, a Chinese encoding.
@item @code{*internal*} -- Mule's representation in buffers.
@item @code{*utf-8*} -- ISO10646 UCS2 (known as Unicode) character set 
represented in UTF-8 encoding scheme.
@item @code{*noconv*} -- for "NO CONVersion"
@item @code{*autoconv*} -- for "AUTOmatic CONVersion"
@end itemize

These symbols can be specified as @var{encoding} parameter for
procedures described later in this document. 

For precise meaning of these values, see also online Info manuals
included in Mule, the Multilingual Emacs. As of this writing,
Guile supports as many external coded character sets as the Mule 
version 2.3, in addition to Unicode. 


@appendixsec New Guile Scheme variables

@defvar input-coding-system
@defvarx output-coding-system

These variables are used by the function @code{open-file} and its buddies
to determine default external encoding to associate with opened ports.
The value @code{#f} means no conversion takes place on I/O, which is
the default.

@end defvar

@defvar process-coding-system

Used by functions to determine the character encoding understood by
the operating system environment.
The value of this variable affects the behavior of each of follwing
functions: 

@itemize @bullet
@item @var{str} argument to @code{open-file}, @code{open-input-file},
@code{open-output-file}, @code{open-io-file}, @code{call-with-input-file},
@code{call-with-output-file}.

@item @var{cmd} argument to @code{system}.

@item @var{nam} argument to @code{getenv}.
@end itemize

The initial value is @code{#f}, meaning that no conversion takes place.
@end defvar


@appendixsec Changes to existing Guile Scheme commands

Although not apparent changes, each of string operations now treats a
string as a sequence of characters, not a byte chunk.  Namely,
@var{index} value is assumed to be the character position instead of
byte position, the length of a string is the number of characters in the
string, not the number of bytes, and so on. This is also the case with
the uniform vector operations on multibyte strings.

Users who need to operate on byte sequences are encouraged to use
byte-vector extensions instead. 

Follwing procedures are now extended to form the internationalization
features in Guile:

@defun open-file str mode &optional encoding
@defunx open-input-file str &optional encoding
@defunx open-output-file str &optional encoding
@defunx open-io-file str &optional encoding
These functions open a file specified by @var{str}, 
and return a port associated with the file. 
@var{str} must be a string or a symbol that names the file to open.

The @var{mode} argument to @code{open-file} specifies the direction[s]
to which I/O operations are allowed via the returned port. It can be
one of following values:

@itemize @bullet
@item @code{OPEN_READ}, for input
@item @code{OPEN_WRITE}, for output
@item @code{OPEN_BOTH}, for input and output
@end itemize

The optional argument @var{encoding} can be a symbol that names 
an external character encoding. 
If specified, further I/O operations via opened port will convert 
the file contents between the specified character encoding and the 
Guile Scheme internal character encoding. 
If @var{encoding} is omitted, the encoding of the file is determined
by the current value of @code{input-coding-system} (for input) and
@code{output-coding-system} (for output).

The functions @code{open-input-file}, @code{open-output-file} and
@code{open-io-file} are similiar to @code{open}, except for opening
a file for read-only, write-only, and read-write, respectively. 
@end defun

@defun call-with-input-file str proc &optional encoding
@defunx call-with-output-file str proc &optional encoding
Call @var{proc} with one argument, a port which is the file named by
@var{str}.

Both functions close the port after @var{proc} returns.

Both return the value of @var{proc}.

The optional argument @var{encoding} specifies the external character
encoding used in the file @var{str}. Default behavior is determined by
the current values of @code{input-coding-system} and
@code{output-coding-system}, respectively.

@end defun

@defun load name &optional encoding
Loads the Scheme source file named by @var{name} in core.  if
@var{encoding} is specified, the file @var{name} is assumed to have
contents encoded in @var{encoding}. Otherwise, the current value of
@code{input-coding-system} is used.
@end defun


@appendixsec New Guile Scheme commands

@defun port-coding port
@defunx set-port-coding! port encoding &optional modes 

The function @code{port-coding} retrieves the character encoding used by
@var{port}.
@var{port} must be an open port object, otherwise an error is signaled.
It returns a symbol that names the character encoding currently used by
@var{port}. Refer previous sections for external character encoding symbols
that are available in this release. 

The function @code{set-port-coding!} sets the character encoding
attribute of @var{port} to @var{encoding}.

@end defun

Following procedures are not immediately relevant to
internationalization, however added in the hope they will effectively
compliment the uses of raw byte data (such as binary image data and
network packet data) that might normally have been implemented using 
strings:

@defun uniform-vector->string uve encoding
@defunx string->uniform-vector str encoding
Coerces between byte-vector and string. 
In Guile, a @dfn{byte-vector} is a uniform-vector whose prototype is
@code{#\nul}.

If specified, code conversion between @var{encoding} and Guile internal
encoding is performed. Otherwise, no conversion takes place.


For @code{uniform-vector->string}, programmers must make sure if each
vector element has a valid value to form a string element.
@end defun

@defun concatenate &rest args
@defunx concatenate! &rest args
Similiar to @code{string-append}, but works on any uniform vectors.
each of @var{args} must be uniform-vector with same element type.
@code{concatenate} returns a newly created vector, where
@code{concatenate!} modifies the original vector.
@end defun

@defun subvector vec start end
Returns a uniform-vector formed from elements of the uniform-vector 
@var{vec}, beginning from index @var{start} (inclusive) and ending 
with index @var{end} (exclusive).

Note in this release, returned vector is a shared-vector to 
the original vector. This implementation is subject to change in
future releases.
@end defun

@appendixsec New libguile procedures

@ifset debug
[Constructs in this section needs cleanup, hopefully together with the
rest of GSCM API. As well, formatting is not appropreate for C
definitions...]
@end ifset

@defun gscm_foreign_str src len encoding
@defunx gscm_foreign_str0 src encoding
Used for converting a string from the encoding in "foreign" (anywhere 
outside GSCM) code to Guile Scheme internal encoding. 

Similiar to @code{gscm_str} and @code{gscm_str0} respectively, except
for accepting encoding argument. @var{encoding} must be of type SCM and
a valid Scheme symbol representing an character encoding.  
This means you may have to @code{scm_intern} the encoding name in your
code. This subject to change.

@end defun 

@defun gscm_2_foreign_str str_out len_out obj_in encoding
Used for converting SCM string contents to "foreign" string encoded in
@var{encoding}.

Similiar to @code{gscm_2_string}. but accepts encoding
argument. @var{encoding} must be of type SCM and a valid Scheme symbol
representing an character encoding.  This means you may have to
@code{scm_intern} the encoding name in your code (this is subject to
change).

@var{str_out} must be an address to @code{unsigned char *} storage, 
but not neccessarily be an allocated memory.

@end defun 
