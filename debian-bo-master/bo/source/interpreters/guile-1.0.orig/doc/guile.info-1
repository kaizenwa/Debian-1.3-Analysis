This is Info file guile.info, produced by Makeinfo version 1.67 from
the input file guile.texi.


File: guile.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)



  This is the reference manual for Guile Scheme.

* Menu:

* Copying::
* Acknowledgements::
* Booleans::
* Characters::
* Strings::
* Read Only Strings::
* Shared Substrings::
* Numbers::
* Cons Pairs and Lists::
* Vectors::
* Symbols::
* Keywords::
* Arbiters::
* Procedures::
* Ports::
* Equality::
* Hash Values::
* Tag Values::
* Dictionaries in General::
* Weak References::
* Evaluation::
* Exception Handling with Catch and Throw::
* Dynamic Wind::
* First-class Variables::
* eval2; User Defined Top Levels::
* First-class Modules::
* Recursive Namespaces::
* Declaring Modules::
* Auto-Loading Modules::
* Using Emacs and Guile::
* Records::
* Structures::
* Arrays::
* Object Properties::
* Low-Level Syntax Extensions::
* Time::
* GC::
* Dynamic Roots::
* System Exceptions::
* Libc procedures::
* Procedure and Macro Index::
* Variable Index::


File: guile.info,  Node: Copying,  Next: Acknowledgements,  Prev: Top,  Up: Top

Copying
*******

           Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995

                    Free Software Foundation, Inc.

                675 Mass Ave, Cambridge, MA 02139, USA

Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

                              NO WARRANTY

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


File: guile.info,  Node: Acknowledgements,  Next: Booleans,  Prev: Copying,  Up: Top

Acknowledgements
****************

Guile is derived from SCM, by Aubrey Jaffer and others.  Most of this
section derives from the SCM manual.

* Menu:

* Guile History::
* SCM Authors::
* Bibliography::


File: guile.info,  Node: Guile History,  Next: SCM Authors,  Prev: Acknowledgements,  Up: Acknowledgements

Guile History
=============

  Here is a very, very brief history of this interpreter.  I hope that
people involved in its past will contribute more to this document.

  SIOD:

  George Carrette wrote SIOD, the earliest version.  Although most of
this code as been rewritten or replaced over time, the garbage
collector from SIOD is still an important part of Guile.

  SIOD is still actively developed and freely available (search for
"siod").  It has a very small footprint.

  SCM:

  Aubrey Jaffer seriously tuned performance and added features.  He
designed many hairy parts of the tag system and evaluator.  He added and
facilitated the addition of many new run-time primitives and assembled
slib, a useful library of Scheme code.

  Guile:

  Guile is a GNU volunteer project, initiated by Richard Stallman. The
project has evolved SCM into a library, added some features to make the
interpreter more flexible, and added some new types and extension
packages.  The goal is to make a small, portable, powerfully scalable
extension langauge library.

  The name Guile was first suggested in a Usenet discussion by Lee
Thomas.


File: guile.info,  Node: SCM Authors,  Next: Bibliography,  Prev: Guile History,  Up: Acknowledgements

Authors
=======

Aubrey Jaffer (jaffer@ai.mit.edu)
     Most of SCM.

Radey Shouman
     Arrays. `gsubr's, compiled closures, and records.

Jerry D. Hedden
     Real and Complex functions.  Fast mixed type arithmetics.

Hugh Secker-Walker
     Syntax checking and memoization of special forms by evaluator.
     Storage allocation strategy and parameters.

George Carrette
     "Siod", written by George Carrette, was the starting point for SCM.
     The major innovations taken from Siod are the evaluator's use of
     the C-stack and being able to garbage collect off the C-stack.

  [Mention Mikael Djurfeldt, Gary Houston, Mark Galassi, Tom Lord,
Anthony Green.]

There are many other contributors to SCM.  They are acknowledged in the
file `ChangeLog', a log of changes that have been made to scm.  [This
file is called `libguile/ChangeLog.scm' in Guile distributions]


File: guile.info,  Node: Bibliography,  Prev: SCM Authors,  Up: Acknowledgements

Bibliography
============

[IEEE]
     `IEEE Standard 1178-1990.  IEEE Standard for the Scheme
     Programming Language.'  IEEE, New York, 1991.

[Simply]
     Brian Harvey and Matthew Wright.  `Simply Scheme: Introducing
     Computer Science' MIT Press, 1994 ISBN 0-262-08226-8

[SICP]
     Harold Abelson and Gerald Jay Sussman with Julie Sussman.
     `Structure and Interpretation of Computer Programs.' MIT Press,
     Cambridge, 1985.

[R4RS]
     William Clinger and Jonathan Rees, Editors.  Revised(4) Report on
     the Algorithmic Language Scheme.  In `ACM Lisp Pointers IV'
     (July-September 1991).

[SLIB]
     Todd R. Eigenschink, Dave Love, and Aubrey Jaffer.

[JACAL]
     Aubrey Jaffer.

`scm.texi'
`scm.info'
     Documentation of `scm' extensions (beyond Scheme standards).
     Documentation on the internal representation and how to extend or
     include `scm' in other programs.


File: guile.info,  Node: Booleans,  Next: Characters,  Prev: Acknowledgements,  Up: Top

Booleans
********

  There are two values which are called booleans, written:

     `#t' 	;; used to represent "true"
     `#f'	;; used to represent "false"

  Only one value in the system, `#f' represents "false".  All other
values, including `#t', are interpreted as "true".

 - Function: boolean? OBJ
     Return `#t' only if OBJ is either `#f' or `#t'.

     Otherwise, return `#f'

 - Function: not A
 - Function: null? OBJ
     Return `#t' only if OBJ is `#f', `#f' otherwise.

     In Guile, the "reference to no object", `()' or `nil' is the same
     value as "false", `#f'.

  Boolean values are also important to some special forms such as `if',
`cond', and `and'; see *Note Flow of Control::.


File: guile.info,  Node: Characters,  Next: Strings,  Prev: Booleans,  Up: Top

Characters
**********

  Individual character constants are written:

     #\<character-name>

  For example, upper-case "A" is written:

     #\A

  lower-case:

     #\a

  Characters can be written in terms of their ASCII representation by
using octal numbers:

     #\101
      => #\A

  Some special characters are given mnemonic names:

     #\space
     #\newline
     #\nl
     #\tab
     #\backspace
     #\return
     #\page
     #\null
     #\del

  Other special character names include:

     nul soh stx etx eot enq ack bel bs ht vt np cr so
     si dle dc1 dc2 dc3 dc4 nak syn etb can em sub esc
     fs gs rs us

 - Function: char? OBJ
     Return `#t' if OBJ is a character, `#f' otherwise.

 - Function: char=? &rest OBJS
 - Function: char<? &rest OBJS
 - Function: char<=? &rest OBJS
 - Function: char>? &rest OBJS
 - Function: char>=? &rest OBJS
 - Function: char-ci=? &rest OBJS
 - Function: char-ci<? &rest OBJS
 - Function: char-ci<=? &rest OBJS
 - Function: char-ci>? &rest OBJS
 - Function: char-ci>=? &rest OBJS
     Return `#t' if the OBJS are in the indicated relation.

     The "-ci" forms compare characters without regard to case.

 - Function: char-alphabetic? OBJ
 - Function: char-numeric? OBJ
 - Function: char-whitespace? OBJ
 - Function: char-upper-case? OBJ
 - Function: char-lower-case? OBJ
     Return `#t' if OBJ is a character of the indicated type `#f'
     otherwise.

 - Function: char->integer OBJ
 - Function: integer->char OBJ
     Convert between characters and integers.

     All characters have an integer representation, but not all
     integers have a character representation.  Only the 16 low-order
     bits of a character number are significant.

     Guile allows characters in the range 0...2^16, but only values in
     the range 0...127 are portable.  Values outside of that range
     depend on the character set encoding in use with Guile.

 - Function: char-upcase OBJ
 - Function: char-downcase OBJ
     Convert between upper and lower case.

     If OBJ is not alphabetic, this function returns its argument.

  [Internationalization note: extended characters (outside of the range
0..255) are permitted, but classification and case conversion functions
currently operate meaningfully only on the range 0..127.  see *Note
Character Set Encodings: (./intspec.info)Character Set Encodings.]


File: guile.info,  Node: Strings,  Next: Read Only Strings,  Prev: Characters,  Up: Top

Strings
*******

  Strings are sequences of characters.   Strings are written using
double-quotes:

     "Strings are used for many purposes in Emacs"

  Strings can include newlines:

     "Strings are used for many purposes in Emacs, as can be
     expected in a text editor;..."

  Strings can include special "escape sequences" that represent
individual characters:

     "as can be\nexpected in a text editor;..."

  Supported escape seqences include:

     Escape sequence:			Character:
     
     \0					#\null
     \f					#\ack
     \n					#\newline
     \r					#\return
     \t					#\tab
     \a					#\bel
     \v					#\vt

 - Function: string? OBJ
     Return `#t' if OBJ is a string, #F otherwise.

  Several string functions address substrings of a string.  This is
always done with a starting and ending position.  All characters from
`[start...end-1]' are included in the substring.  If `end<=start', the
substring is empty.  String positions begin with 0.

  These functions treat symbols as read-only strings.  If a function
defined in this section does not modify a string argument, then a symbol
can be passed for that argument.  The symbol name is used as the string,
in that case.

* Menu:

* Making Strings::
* Examining Strings::
* Ordering Strings::
* Internationalization Notes::


File: guile.info,  Node: Making Strings,  Next: Examining Strings,  Prev: Strings,  Up: Strings

Making Strings
==============

 - Function: make-string LENGTH &opt FILL
     Return a new string of size LENGTH.

     If FILL is specified, it should be a character.  The string is
     initially LENGTH copies of that character.

     There is no default FILL; if no value is specified, the initial
     contents of a string are unspecified.

 - Function: string &rest CHARS
     The arguments, all characters, are concatenated to form a new
     string.

 - Function: substring STR FROM TO
     The addressed substring of STR is copied to form a new string.

 - Function: string-append &rest OBJS
     The arguments, all strings or symbols, are concatenated to form a
     new string.

 - Function: string-copy STR
     The argument, a string or symbol, is copied to a new string.

 - Function: string->list STR
     A list is returned that contains all the characters of STR, in
     order.

 - Function: list->string CHARS
     CHARS is a list of characters which are concatenated to form a
     string.


File: guile.info,  Node: Examining Strings,  Next: Ordering Strings,  Prev: Making Strings,  Up: Strings

Examining Strings
=================

 - Function: string-length OBJ
 - Function: length OBJ
     The number of characters in OBJ, a string or symbol, is returned.

 - Function: string-ref OBJ INDEX
     The INDEX character of OBJ, a string or symbol, is returned.

 - Function: string-set! OBJ INDEX VALUE
     The INDEX character of OBJ, a string, is set to VALUE.

 - Function: string-null? OBJ
     Return `#t' if OBJ is a 0 length string or symbol, `#f' otherwise.

 - Function: string-index STR CHAR
 - Function: string-rindex STR CHAR
     Return the position of the first instance of CHAR in STR.

     STR may be a string or symbol.   #F is returned if the character
     is not found.

     INDEX searches from the start of the string, RINDEX from the end.

 - Function: string-fill! STR CHAR
 - Function: substring-fill! STR START END CHAR
     Set some or all of the characters of the string STR to CHAR.

 - Function: substring-move-left! STR START END STR2 START2
 - Function: substring-move-right! STR START END STR2 START2
     Copy characters from STR to STR2.

     The suffixes `-left' and `-right' refer to the order in which
     characters are copied which is significant of `str' and `str2' are
     the same object.


File: guile.info,  Node: Ordering Strings,  Next: Internationalization Notes,  Prev: Examining Strings,  Up: Strings

Ordering Strings
================

 - Function: string=?, &rest OBJS
 - Function: string-ci=?, &rest OBJS
 - Function: string<?, &rest OBJS
 - Function: string<=?, &rest OBJS
 - Function: string>?, &rest OBJS
 - Function: string>=?, &rest OBJS
 - Function: string-ci<?, &rest OBJS
 - Function: string-ci<=?, &rest OBJS
 - Function: string-ci>?, &rest OBJS
 - Function: string-ci>=?, &rest OBJS
     Test for a particular relation among string arguments.

     The ordering of strings is lexigraphical, based on the ordering of
     characters.


File: guile.info,  Node: Internationalization Notes,  Prev: Ordering Strings,  Up: Strings

Internationalization Notes
==========================

  Internationalization support for strings is underway though not yet
done, see *Note The String Representation Type: (./intspec.info)The
String Representation Type.


File: guile.info,  Node: Read Only Strings,  Next: Shared Substrings,  Prev: Strings,  Up: Top

Read Only Strings
*****************

  Type-checking in Guile primitives distinguishes between mutable
strings and read only strings.  Mutable strings answer `#t' to
`string?'  while read only strings may or may not.   All kinds of
strings, whether or not they are mutable return #t to this:

 - Function: read-only-string? OBJ
     Return true of OBJ can be read as a string,

     This illustrates the difference between `string?' and
     `read-only-string?':

          (string? "a string") => #t
          (string? 'a-symbol") => #f
          
          (read-only-string? "a string") => #t
          (read-only-string? 'a-symbol") => #t

  "Read only" refers to how the string will be used, not how the string
is permitted to be used.  In particular, all strings are "read only
strings" even if they are mutable, because a function that only reads
from a string can certainly operate on even a mutable string.

  Symbols are an example of read only strings.  Many string functions,
such as `string-append' are happy to operate on symbols.  Many
functions that expect a string argument, such as `open-file', will
accept a symbol as well.

  Another of example of a read-only string is a "shared substring".
Shared substrings are defined in the next chapter.


File: guile.info,  Node: Shared Substrings,  Next: Numbers,  Prev: Read Only Strings,  Up: Top

Shared Substrings
*****************

  Whenever you extract a substring using `substring', a new string is
allocated and substring data is copied from the old string to the new
string.

  Sometimes, in order avoid the expense of copying, programmers will
write programs that pass around triples:  a string, a starting position
within the string, and an ending position.  This convention is awkward,
especially because many useful string primitives operate only on full
strings, not a string with substring indexes.

  Guile Scheme offers another way: shared substrings.  A shared
substring is a read-only string built from an older string, and
substring indexes into that older string.  A shared substring is not a
copy of the older string, but shares the older strings data directly.
Compared to copying substrings, shared substrings are cheap to allocate.

 - Function: make-shared-substring SOURCE-STRING START-POS ?END-POS?
     Return a shared substring of SOURCE-STRING, from START-POS to
     END-POS or the end of the source string

          	(define some-string "the quick brown fox")
          	(define x (make-shared-substring some-string 4 9))
          	x => "quick"
          
          	(string-set! some-string 7 #\r)
          	x => "quirk"
          
          	(string? some-string) => #t
          	(string? x)
          	(read-only-string? some-string) => #t
          	(read-only-string? x) => #t
          
          	(define y (make-shared-substring x 2))
          	y => "irk"

  String operators which mutate their arguments do not work on shared
substrings but most other string operators do work.  For example, if you
want to compare the substring [FROM ... TO - 1] of string A to the
string B, you can use the relatively inexpensive idiom:

     (string=? (make-shared-substring A FROM TO) B)


File: guile.info,  Node: Numbers,  Next: Cons Pairs and Lists,  Prev: Shared Substrings,  Up: Top

Numbers
*******

  Numbers are a distinct type in Guile Scheme.

 - Function: number? OBJ
     Return `#t' if OBJ is a number, `#f' otherwise.

 - Function: number->string NUMBER &opt RADIX
 - Function: string->number STRING &opt RADIX
     Convert between numbers and strings.

     The syntax of a number for `string->number', which is also the
     syntax of how numbers are written in programs, is illustrated by
     these examples:

          (eq? 10 +10) => #t
          
          (eq? -10 (- 0 10)) => #t
          
          (eq? 10 10.0) => #f
          (eq? 10 #e10) => #t   ;; exact 10
          (eq? 10.0 #i10) => #t ;; inexact 10 (floating point 10.0)
          
          (eq? #b1010 10) => #t ;; binary
          (eq? #xa 10) => #t    ;; hex
          (eq? #o12 10) => #t   ;; ocatal
          (eq? #d12 10) => #t   ;; decimal
          
          +i		      ;; sqrt of -1
          10+4i		      ;; a complex number (currently read as inexact)
          1/4		      ;; a fraction (currently read as inexact)


* Menu:

* Kinds of Numbers and Conversions::
* Ordering Numbers::
* Basic Math::
* Binary Math ::
* Transcendental Functions::
* libc.a Math ::


File: guile.info,  Node: Kinds of Numbers and Conversions,  Next: Ordering Numbers,  Prev: Numbers,  Up: Numbers

Kinds of Numbers and Conversions
================================

 - Function: exact? OBJ
     Return `#t' if OBJ is an exact number, `#f' otherwise.

 - Function: inexact? OBJ
     Return `#t' if OBJ is an inexact number, `#f' otherwise.

 - Function: inexact->exact OBJ
     Return the exact number closest to OBJ.

     Odd multiple of .5 round in the positive direction.

 - Function: exact->inexact OBJ
     Return the inexact number closest to OBJ.

 - Function: round OBJ
     Round OBJ to the nearest inexact integer.

     Odd multiple of .5 round in the positive direction.

 - Function: floor OBJ
     Return the greatest inexact integer less than or equal to OBJ.

 - Function: ceiling OBJ
     Return the least inexact integer greater than or equal to OBJ.

 - Function: int? OBJ
     Return `#t' if OBJ is an integer, `#f' otherwise.

     This is `#t' if whether OBJ is exact or inexact.

 - Function: integer? OBJ
     Return `#t' if OBJ is an exact integer, `#f' otherwise.

 - Function: odd? OBJ
 - Function: even? OBJ
     Test the parity of an exact integer.

 - Function: real? OBJ
 - Function: rational? OBJ
     True if OBJ is a number with no imaginary part (or imaginary part
     0).

 - Function: complex? OBJ
     True for all numbers.

 - Function: make-rectangular A B
 - Function: make-polar A M
     Two ways to construct complex numbers.

 - Function: real-part OBJ
 - Function: imag-part OBJ
 - Function: magnitude OBJ
 - Function: angle OBJ
     Access to the components of complex numbers.


File: guile.info,  Node: Ordering Numbers,  Next: Basic Math,  Prev: Kinds of Numbers and Conversions,  Up: Numbers

Ordering Numbers
================

 - Function: zero? OBJ

 - Function: =? &rest OBJ1 OBJ2 ...
 - Function: <? &rest OBJ1 OBJ2 ...
 - Function: >? &rest OBJ1 OBJ2 ...
 - Function: <=? &rest OBJ1 OBJ2 ...
 - Function: >=? &rest OBJ1 OBJ2 ...
     Return true if the arguments are objects in the given relation.

          (<? 1 2 3 4) => #t
          (<? 1 3 2 4) => #f

 - Function: positive? OBJ
 - Function: negative? OBJ
     Test the sign of OBJ.

     These always return `#f' for 0.

 - Function: max OBJ &rest OBJ1 OBJ2
 - Function: min OBJ &rest OBJ1 OBJ2
     Return the numeric maximum (or minimum) of the arguments.


File: guile.info,  Node: Basic Math,  Next: Binary Math,  Prev: Ordering Numbers,  Up: Numbers

Basic Math
==========

 - Function: + &rest OBJ1 OBJ2 ...
 - Function: - &rest OBJ1 OBJ2 ...
 - Function: * &rest OBJ1 OBJ2 ...
 - Function: / &rest OBJ1 OBJ2 ...
 - Function: gcd &rest OBJ1 OBJ2 ...
 - Function: lcm &rest OBJ1 OBJ2 ...
 - Function: quotient A B
 - Function: remainder A B
 - Function: modulo A B
 - Function: abs OBJ
     Basic arithmetic on the arguments.

 - Function: log Z
 - Function: exp Z
     Return the natural log of Z (`e^z').

 - Function: sqrt Z
     Return the square root of Z


File: guile.info,  Node: Binary Math,  Next: Transcendental Functions,  Prev: Basic Math,  Up: Numbers

Binary Math
===========

 - Constant: most-positive-fixnum
     The immediate integer closest to positive infinity.  *Note
     Configuration: (slib)Configuration.

 - Constant: most-negative-fixnum
     The immediate integer closest to negative infinity.

 - Function: logand A B &rest OBJ1 OBJ2 ...
 - Function: logior A B &rest OBJ1 OBJ2 ...
 - Function: logxor A B &rest OBJ1 OBJ2 ...
 - Function: logand A B &rest OBJ1 OBJ2 ...
 - Function: logior A B &rest OBJ1 OBJ2 ...
 - Function: logxor A B &rest OBJ1 OBJ2 ...
 - Function: lognot OBJ
 - Function: logtest A B
 - Function: logbit? OBJ BIT-POS
     Bitwise operations on exact integers.

     `logtest' returns `#t' if A and B have any bits in common.

     `logbit?' returns `#t' if OBJ has a one in BIT-POS.

 - Function: integer-expt A B
     Return `A^B'.  Both must be exact integers.

 - Function: ash A B
     Return `A << B'.  Both must be exact integers.

 - Function: bit-extract N START END
     Return the integer formed from bits START...END-1.

          (bit-extract 7 1 4) => 3
          (bit-extract 7 0 3) => 3
          bit-extract 7 0 4) => 7
          (bit-extract 7 4 32) => 0

 - Function: logcount N
     Return the number of 1 bits in the exact integer N.

 - Function: integer-length OBJ
     Return the number of significant bits in the exact integer N.


File: guile.info,  Node: Transcendental Functions,  Next: libc.a Math,  Prev: Binary Math,  Up: Numbers

Transcendental Functions
========================

 - Function: sin X
 - Function: cos X
 - Function: tan X
     Return the sine, cosine, and tangent of X

 - Function: asin X
 - Function: acos X
     Return the inverse sine and cosine X

 - Function: atan X &opt Y
     Computes `(angle (make-rectangular x y))' for real numbers Y and X.

 - Function: sinh X
 - Function: cosh X
 - Function: tanh X
     Return the hyperbolic sine, cosine, and tangent of X

 - Function: asinh X
 - Function: acosh X
 - Function: atanh X
     Return the inverse hyperbolic sine, cosine, and tangent of X


File: guile.info,  Node: libc.a Math,  Prev: Transcendental Functions,  Up: Numbers

libc.a Math
===========

 - Function: $asinh A
 - Function: $acosh A
 - Function: $atanh A
 - Function: $sqrt A
 - Function: $abs A
 - Function: $exp A
 - Function: $log A
 - Function: $sin A
 - Function: $cos A
 - Function: $tan A
 - Function: $asin A
 - Function: $acos A
 - Function: $atan A
 - Function: $sinh A
 - Function: $cosh A
 - Function: $tanh A
 - Function: %expt A B
 - Function: %atan2 A B
     These functions are implemented by their libc counterparts.

     Real-only versions of these popular functions.  The argument A
     must be a real number.  It is an error if the value which should be
     returned by a call to these procedures is *not* real.



File: guile.info,  Node: Cons Pairs and Lists,  Next: Vectors,  Prev: Numbers,  Up: Top

Cons Pairs and Lists
********************

  A *cons pair* is a generic two element structure.  It has two
`fields' or `slots which are called the "car" and the "cdr".

  The slots of a cons pair can hold references to any object (even the
pair itself).

 - Function: pair? OBJ
     Return `#t' if OBJ is a cons pair, and `#f' otherwise.

 - Function: null? OBJ
     Return `#t' only if OBJ is `#f' (aka `()'), `#f' otherwise.

     In Guile, the "reference to no object", `()' or `nil' is the same
     value as "false", `#f'.

 - Function: cons A D
     Create a new cons pair, initializing the car to A, the cdr to D.

 - Function: copy-tree OBJ
     Recursively copy a tree of cons-pairs.

     If OBJ is not a cons pair, this is simply the identity function.
     If OBJ is a cons pair, then COPY-TREE returns:

          (cons (copy-tree (car obj)) (copy-tree (cdr obj)))

     COPY-TREE will not terminate on circular structures of cons pairs
     and will fill up memory.

* Menu:

* Basic Accessors and Mutators::
* Lists::
* Lists As Collections::
* Lists as Association Mappings::


File: guile.info,  Node: Basic Accessors and Mutators,  Next: Lists,  Prev: Cons Pairs and Lists,  Up: Cons Pairs and Lists

Basic Accessors and Mutators
============================

 - Function: car OBJ
 - Function: cdr OBJ
     Return the car (cdr) slot of OBJ, which must be a cons pair.

 - Function: set-car! OBJ NEW-VAL
 - Function: set-cdr! OBJ NEW-VAL
     Modify the car (cdr) slot of OBJ, which must be a cons pair.

     NEW-VAL is returned.

 - Function: caar OBJ
 - Function: cdar OBJ
 - Function: cadr OBJ
 - Function: cddr OBJ
 - Function: caaar OBJ
 - Function: cdaar OBJ
 - Function: cadar OBJ
 - Function: cddar OBJ
 - Function: caadr OBJ
 - Function: cdadr OBJ
 - Function: caddr OBJ
 - Function: cdddr OBJ
 - Function: caaaar OBJ
 - Function: cdaaar OBJ
 - Function: cadaar OBJ
 - Function: cddaar OBJ
 - Function: caadar OBJ
 - Function: cdadar OBJ
 - Function: caddar OBJ
 - Function: cdddar OBJ
 - Function: caaadr OBJ
 - Function: cdaadr OBJ
 - Function: cadadr OBJ
 - Function: cddadr OBJ
 - Function: caaddr OBJ
 - Function: cdaddr OBJ
 - Function: cadddr OBJ
 - Function: cddddr OBJ
     These functions are all compositions of `car' and `cdr'.

     For example, `(cadr x)' is the same as `(car (cdr x))'.


File: guile.info,  Node: Lists,  Next: Lists As Collections,  Prev: Basic Accessors and Mutators,  Up: Cons Pairs and Lists

Lists
=====

  A "list" is considered to be any chain of cons-pairs, the cdr of each
pair pointing to the next pair in the chain, and the cdr of the last
pair containing `()' (aka `#f').

  A list is written as a left-parenthesis, followed by a white-space
separated enumeration of the car slots of the cells in the list,
followed by a right-parenthesis.

     ;; Note that lists typed-in have to be quoted or else
     ;; they will be interpreted as an expression and
     ;; evaluated:
     ;
     '(a b c) => (a b c)     ; a three element list

  An "improper list" is similar, except that the cdr slot of the last
pair is filled with some object other than `#f'.  Dotted-pair notation
is used to write an improper list:

     '(a b . c) => (a b . c)     ; a two element improper list
     			    ; with the symbol c in the last cdr
     			    ; slot.

 - Function: list? OBJ
     Return `#t' if OBJ is a list, `#f' otherwise.

 - Function: list &rest OBJ1 OBJ2 ...
     Return a new list of all of the arguments.

 - Function: list-length OBJ
 - Function: length OBJ
     Return the number of cons-pairs that make up the list OBJ.

 - Function: append &rest OBJ1 OBJ2 ...
 - Function: append! &rest OBJ1 OBJ2 ...
     Construct a list by appending the argument lists.

     `append' returns a new list, `append!' works by modifying its
     arguments.

     In both cases, the last argument need not be a list - it can be
     any type and will become the tail of the returned list.

          ;; append creates a new list:
          ;;
          (define x '(a b c))
          (define z '(1 2 3))
          (define y (append z x))
          
          y => (1 2 3 a b c)
          
          (set-car! z 99)
          z => (99 2 3)
          y => (1 2 3 a b c)
          
          
          ;; append! modifies its arguments:
          ;;
          (define x '(a b c))
          (define z '(1 2 3))
          (define y (append! z x))
          
          y => (1 2 3 a b c)
          
          (set-car! z 99)
          z => (99 2 3)
          y => (99 2 3 a b c)
          
          
          ;; But the last argument is special in either
          ;; case:
          ;;
          (define x '(a b c))
          (define y (append '(1 2 3) x))
          
          y => (1 2 3 a b c)
          
          (set-car! (cdr x) 99)
          
          y => (1 2 3 a 99 c)

 - Function: reverse OBJ
 - Function: reverse! OBJ
     Return a new list like OBJ, but in the opposite order.  `reverse!'
     works by re-arraning the pairs in OBJ while `reverse' constructs
     an entirely new list.

     OBJ must be a proper list.

 - Function: list-copy OBJ
     Copy the argument as a list and return the copy.

     The argument may be an improper list.  In that case, the copy and
     the original share the final `CDR':

          (define tail-elt (vector 'a))
          (define a `(x y z . ,tail-elt))
          (define b (list-copy a))
          (equal? a b) => #t
          (eq? a b) => #f
          (eq? tail-elt (cdr (last-pair a)) (cdr (last-pair b))) => #t


 - Function: list-ref OBJ N
 - Function: list-set! OBJ N VAL
     Return (perhaps modifying) the nth car slot of (possibly improper)
     list OBJ.

 - Function: list-tail OBJ N
 - Function: list-cdr-ref OBJ N
     Return the contents the nth cdr in the (possibly improper) list
     OBJ.

 - Function: list-cdr-set! OBJ N VAL
     Modify the nth cdr in the (possibly improper) list OBJ.

     VAL is returned.

 - Function: last-pair OBJ
     Return the last pair in the (possibly improper) list OBJ.


File: guile.info,  Node: Lists As Collections,  Next: Lists as Association Mappings,  Prev: Lists,  Up: Cons Pairs and Lists

Lists As Collections
====================

  These functions operate on lists as collections (ordered or
unordered).

 - Function: map FUNCTION OBJ &rest OBJ1 OBJ2 ...
     Construct a new list by applying FUNCTION to the list arguments,
     elementwise.

     For example:

          (map - '(1 2 3)) => (-1 -2 -3)
          
          (map + '(1 2 3)
                 '(10 10 11))
           => (11 12 14)

     The list arguments to map need not be proper lists, but if they
     improper, the contents of the last cdr are ignored.

     The order in which map is applied to its arguments is unspecified
     but definate.

 - Function: for-each FUNCTION OBJ &rest OBJ1 OBJ2 ...
     Apply function to the list arguments, elementwise, for side
     effects.

     `for-each' is similar to `map', but there are two differences.
     First, `for-each' is guaranteed to process the elements in the
     order they occur in the argument lists.   Second, `for-each' does
     not return a useful value - the results of apply `function' are
     ignored.

 - Function: memq OBJ L
 - Function: memv OBJ L
 - Function: member OBJ L
 - Function: sloppy-memq OBJ L
 - Function: sloppy-memv OBJ L
 - Function: sloppy-member OBJ L
     Return the first pair in the proper list `l' whose car is OBJ.

     `memq' compares OBJ to cars using `eq?'

     `memv' compares OBJ to cars using `eqv?'

     `member' compares OBJ to cars using `equal?'

     The `sloppy-' varieties simply return `#f' if the reach the end of
     `l' and `l' is an improper list.  Under the same condition, the
     non-`sloppy-' varieties signal an error.

 - Function: delq OBJ L
 - Function: delv OBJ L
 - Function: delete OBJ L
 - Function: delq! OBJ L
 - Function: delv! OBJ L
 - Function: delete! OBJ L
     Remove elements matching OBJ from the list `l'.  The `delq',
     `delv', and `delete' functions use the `eq?', `eqv?', and `equal?'
     predicates respectively to determine which elements of L match OBJ.

     The functions whose names end in `!' modify L destructively; the
     functions lacking a `!' return a (possibly) modified copy of L.

     If `l' is not a proper list, the functions behave as normal on the
     initial chain of pairs, and preserve the tail of the final pair.

     When using the destructive operators, it is usually not correct to
     simply write:
          (delq! elt my-list)
     because `delq!' may remove pairs from the beginning of the list,
     but cannot update `my-list' to point to the new head, since
     function arguments in Scheme are passed by value.  To avoid this
     situation, write the following instead:
          (set! my-list (delq! elt my-list))



File: guile.info,  Node: Lists as Association Mappings,  Prev: Lists As Collections,  Up: Cons Pairs and Lists

Lists as Association Mappings
=============================

  Lists of the form:

     ((k1 . v1) (k2 . v2) (k3 . v3) ...)

  are considered "association lists".  They represent a mapping from the
value `k1 k2 k3...' to the values `v1 v2 v3...'.

  In an association, `(k1 . v1)' is called the "value cell" for `k1'.
`v1' is called the "binding" of `k1'.  `k1' is a "key" and `v1' a
"value".

  An association list may contain more than one binding for a particular
key, but generally, only the first occuring binding matters.

 - Function: assq K ALIST
 - Function: assv K ALIST
 - Function: assoc K ALIST
     Search ALIST for K and return the first applicable value cell.

     If K has no binding in ALIST, `#f' is returned.

     `assq' compares keys using `eq?'

     `assv' compares keys using `eqv?'

     `assoc' compares keys using `equal?'

 - Function: acons K V ALIST
     Prepend a binding of V for `k' to ALIST and return the new list.

          (acons 'george 'drums
          	'((paul . bass)
          	  (john . guitar)
          	  (john . piano)
          	  (george . gc)))
          => ((george . drums)
              (paul . bass)
              (john . guitar)
              (john . piano)
              (george . gc))


  To make it easier and faster to use associate lists, additional
convenience functions are provided for alists; see *Note Dictionaries
in General::.


File: guile.info,  Node: Vectors,  Next: Symbols,  Prev: Cons Pairs and Lists,  Up: Top

Vectors
*******

  A vector is an array of objects, addressed by integers, in which
elements can be referenced or set in a single operation.

  Vectors are written this way:

     #(a b c)	; a three element vector

 - Function: vector? OBJ
     Return `#t' if OBJ is a vector, `#f' otherwise.

 - Function: make-vector SIZE &opt FILL
     Return a new vector of SIZE elements.

     If FILL is specified, the elements are initialized to that value.
     Otherwise, they are initialized to `#f'.

 - Function: vector &rest OBJ1 OBJ2 ...
     Return a new vector containing the arguments, in order.

     The vector returned has as many elements as there are arguments.

 - Function: list->vector OBJ
 - Function: vector->list OBJ
     Convert between lists and vectors.

 - Function: vector-length OBJ
 - Function: length OBJ
     Return the number of elements in the vector OBJ.

 - Function: vector-ref OBJ N
 - Function: vector-set! OBJ N VAL
     Return (possibly setting) the Nth element of OBJ.

 - Function: vector-fill! OBJ FILL
     Set all elements of the vector OBJ.

 - Function: vector-move-left! VEC START END VEC2 START2
 - Function: vector-move-right! VEC START END VEC2 START2
     Copy objects from VEC to VEC2.

     The suffixes `-left' and `-right' refer to the order in which
     objects are copied which is significant of `vec' and `vec2' are
     the same object.


File: guile.info,  Node: Symbols,  Next: Keywords,  Prev: Vectors,  Up: Top

Symbols
*******

  Symbols in Guile are read-only strings with some extra properties in
addition.

  In addition to being string-like, symbols are distinguished by having
a "function slot" and "property slot" - storage for arbitrary values
much like the `CAR' and `CDR' slots of a cons pair.

  Normally symbols are named using strings of the characters a-z, A-Z,
0-9, and punctuation drawn from "-_!@$%^~&*=+|:/?><,.".

     'abc => abc
     '2much => 2much
     'set! => set!

  A symbol name must not begin with the character `:' (unless the
`#{}#' syntax describe below is used).   If you write what appears to
be a symbol name but begins with a `:', you'll get a keyword, not a
symbol; see *Note Keywords::.

     (symbol? 'this-is-a-symbol)	=> #t
     (symbol? ':this-is-not)		=> #f

  Except in obscure cases, the same name always names the same symbol:

     (eq? 'abc 'abc) => #t

  Symbols are usually read in a case *sensitive* manner:

     (eq? 'ABC 'abc) => #f

  Arbitrary symbol names can be written using "#{" and "}#" with
backslash to escape characters:

     #{this is one really unusual symbol name.
     It is multiple lines long and even contains the sequence \}#.}#
     
     => #{this\ is\ one\ really\ unusual\ symbol\ name.\ \ \
     It\ is\ multiple\ lines\ long\ and\ even\ contains\ the\ sequence\ \}\#.}#

 - Function: symbol? OBJ
     Return `#t' if OBJ is a symbol, false otherwise.

 - Function: symbol->string SYMBOL
 - Function: string->symbol STRING
     Convert between strings and symbols.

 - Function: symbol-hash OBJ
     Return an integer hash value based on the name of the symbol OBJ.

     The hash value is guaranteed to have at least 16 useful bits.

  [For information about internationalizatio and symbol names, see
*Note The String Representation Type: (./intspec.info)The String
Representation Type.]

* Menu:

* F-slots and P-slots::
* Obarrays::


File: guile.info,  Node: F-slots and P-slots,  Next: Obarrays,  Prev: Symbols,  Up: Symbols

F-slots and P-slots
===================

  Symbols have two slots that can contain references to arbitrary
objects.  These are called the f-slot and p-slot (function-slot and
property-slot).

 - Function: symbol-fref OBJ
 - Function: symbol-pref OBJ
 - Function: symbol-fset! OBJ VAL
 - Function: symbol-pset! OBJ VAL
     Set or reference the f or p slot of symbol OBJ.


File: guile.info,  Node: Obarrays,  Prev: F-slots and P-slots,  Up: Symbols

Obarrays
========

  Earlier it was asserted: "Except in obscure cases, the same name
always names the same symbol".  This section explains how exceptions
can come about.

  An "obarray" is an ordinary Scheme vector, used in a particular way.
It represents two mapping: a mapping of strings to symbols, and a
mapping of symbols to arbitrary values.

  To initialize an obarray, create a vector of any non-0 size, filled
with the empty list.  The obarray is stored as hash table whose keys are
symbols, compared on the basis of string equality.

  Although the structure of an obarray is a simple hash table,
operations on obarrays are not done using hash table primitives.  The
obarray-specific operations are, unlike what you could easily write in
scheme using hash table operations, atomic.  Two calls to
string->obarray-symbol will [allegedly] always yield the same result
even if one call interrupts the other (barring explicit mutations to the
obarray, of course).

 - Function: string->obarray-symbol OBARRAY NAME &opt SOFT
     Return the SYMBOL bound to the stringNAME in OBARRAY.

     OBARRAY may be `#t', in which case the symbol is interned in the
     system's built-in symbol table (like when using `string->symbol').

     OBARRAY may be `#f', in which case the symbol is created, but not
     associated with *any* obarray.  In this case, the returned symbol
     is guaranteed to be a new object.

     SOFT, if specified and not `#f', means that a symbol should be
     returned only if it already exists in the specified obarray.  (In
     the case of creating an uninterned symbol, the paramater `soft' is
     ignored.)

 - Function: unintern-symbol OBARRAY SYMBOL
     Remove SYMBOL from OBARRAY.

     Thereafter, `string->obarray-symbol' will no longer return SYMBOL
     for `obarray' unless SYMBOL is first re-interned.

 - Function: intern-symbol OBARRAY SYMBOL
     Add SYMBOL to OBARRAY.  If SYMBOL is already present, this has no
     effect.

     After this addition, SYMBOL is the symbol binding of its name.
     That is, even if another symbol of the same name was previously
     interned in OBARRAY, SYMBOL becomes the binding of that name after
     intern-symbol.  (This does not mean that the previous symbol is
     removed from the OBARRAY).

 - Function: symbol-interned? OBARRAY SYMBOL
     Return `#t' if SYMBOL is in OBARRAY.

 - Function: symbol-bound? OBARRAY SYMBOL
 - Function: symbol-binding OBARRAY SYMBOL
 - Function: symbol-set! OBARRAY SYMBOL VALUE
     A SYMBOL in an OBARRAY may be bound arbitrarily.  The binding may
     be changed.  When first interned, a symbol is unbound.


File: guile.info,  Node: Keywords,  Next: Arbiters,  Prev: Symbols,  Up: Top

Keywords
********

  A "keyword" is a self-evaluating symbol-like object with a convenient
read syntax.   Keyword names are written just like symbol names except
that whereas a symbol name may not be written starting with ":",
keyword names *must* begin with ":".

             (keyword? :keyword) => #t

 - Function: keyword? OBJ
     Return `#t' if OBJ is a keyword, `#f' otherwise.

 - Function: symbol->keyword SYMBOL
     Construct a keyword from a symbol.

                  (symbol->keyword 'fnord) => :fnord

 - Function: keyword->symbol SYMBOL
     Construct a symbol from a keyword.

                  (symbol->keyword :fnord) => fnord

  In the above functions there is a one-to-one mapping between symbol
names and keywords.  Because there are such things as uninterned symbols
and obarrays, two *symbols* can have the same name, yet not be equal
(*note Obarrays::.).  With keywords, there is only one universal
namespace - if two keywords have the same name, they are equal in the
sense of `eq?':

     ;; Two symbols can have different names:
     ;;
     (eq? (string->obarray-symbol #f "foo")
          (string->obarray-symbol #f "foo"))
     => #f
     
     ;; but not two keywords.
     ;;
     (eq? (symbol->keyword (string->obarray-symbol #f "foo"))
          (symbol->keyword (string->obarray-symbol #f "foo")))
     => #t

  Many other systems write keyword-like values with a dash, following
the conventions of unix command line arguments.  It has proven
convenient to have procedures for mapping that style of "keyword"
neatly into Guile keywords:

 - Function: make-keyword-from-dashed-symbol SYMBOL
     A low-level way to construct a keyword from a symbol, convenient
     when dealing with Tcl or unix.  The first character of the
     symbol's name must be '-'.

                  (make-keyword-from-dashed-symbol '-command) => :command

 - Function: keyword-dash-symbol KEYWORD
     Return the dashed symbol that corresponds to a keyword.

                  (keyword-dash-symbol :text) => -text


File: guile.info,  Node: Arbiters,  Next: Procedures,  Prev: Keywords,  Up: Top

Arbiters
********

 - Function: make-arbiter NAME
     Returns an object of type arbiter and name NAME.  Its state is
     initially unlocked.

 - Function: try-arbiter ARBITER
     Returns `#t' and locks ARBITER if ARBITER was unlocked.
     Otherwise, returns `#f'.

 - Function: release-arbiter ARBITER
     Returns `#t' and unlocks ARBITER if ARBITER was locked.
     Otherwise, returns `#f'.


File: guile.info,  Node: Procedures,  Next: Ports,  Prev: Arbiters,  Up: Top

Procedures
**********

  Procedures are those objects which the evaluator knows how to apply to
arguments.  Built-in functions are procedures as are any functions
defined by programs.

  It should be obvious but perhaps bears repeating that procedure is
distinct from the name it is given in any particular context.  Thus the
symbol `'+' and the primitive procedure bound to the variable called
`+' are distinct objects.

 - Function: procedure? OBJ
     Return `#t' if OBJ is a procedure, `#f' otherwise.

  Procedures have a binding slot which you can use arbitrarily.  Many
parts of the system will presume that this slot will contain a (possible
empty) assoc list, keyed by symbols (`procedure properties').  If your
procedure will be manipulated by a part of the system which is
documented as using property lists, you should follow the convention,
and use a unique prefix for all property names that you define.
Procedures which do not escape to such parts of the system can hve any
value at all in their binding slot.

 - Function: procedure-properties PROCEDURE
 - Function: set-procedure-properties! PROCEDURE VALUE
     Return or set the value held in a procedures binding slow.

 - Function: procedure-property PROC KEY
 - Function: procedure-assoc PROC KEY
 - Function: procedure-putprop! PROC KEY VALUE
     Retrieve or get the binding of a particular procedure property.

     These functions assume that the binding slot of the procedure
     holds an assoc list.

     `procedure-property' returns the binding of the property while
     `procedure-assoc' returns the key-value pair that holds the
     binding.

  [It is a minor bug that the interface to procedure properties doesn't
include functions conforming to the standard interface for dictionaries;
see *Note Dictionaries in General::.]


File: guile.info,  Node: Ports,  Next: Equality,  Prev: Procedures,  Up: Top

Ports
*****

  [This documentation is accurate, but I expect that the details of
ports are going to change over the next few months.   In particular,
Guile now uses Tcl Channels as its preferred I/O mechanism.   The
interfaces to ports and channels are going to be merged.]

  Ports are objects, such as open files, from which characters can be
read or written in sequence.   A read on an input port may yield,
instead of a character, an eof-object, indicating that no characters
are available.

  Ports are distinguished by whether they are for reading, writing, or
both.

 - Function: port? OBJ
 - Function: input-port? OBJ
 - Function: output-port? OBJ
     Return `#t' if OBJ is a port (input port, or output port), `#f'
     otherwise.

 - Function: port-mode PORT
     Return a string describing the mode of PORT, such as "r" or "w".

 - Function: close-port PORT
 - Function: close-input-port PORT
 - Function: close-output-port PORT
 - Function: close-io-port PORT
     Close PORT.

     If `close-input-port' is used on an i/o port, it becomes an output
     port.  If `close-output-port' is used on an i/o port, it becomes
     an input port.

 - Function: force-output &opt PORT
     Flush buffered output from all ports or from PORT, if specified.

  [For information about internationalizatio and ports, see *Note
Extended Character I/O: (./intspec.info)Extended Character I/O.]

* Menu:

* Character I/O::
* Structured I/O::
* I/O Redirection::
* Soft Ports::
* String Ports::
* File Ports::
* Low-level File Port Operations::


File: guile.info,  Node: Character I/O,  Next: Structured I/O,  Prev: Ports,  Up: Ports

Character I/O
=============

 - Function: read-char &opt PORT
 - Function: peek-char &opt PORT
     Read one character or eof-object from PORT or `current-input-port'.

     `read-char' advances the port while `peek-char' does not.

 - Function: write-char CHAR &opt PORT
     Write CHAR to PORT or to `current-input-port'.

 - Function: newline &opt PORT
     Write the character `#\nl' to PORT or to `current-input-port'.

 - Function: char-ready? PORT
     Return `#t' if a character be read from PORT without delay, `#f'
     otherwise.

 - Function: eof-object? OBJ
     Return `#t' if a character be read from PORT without delay, `#f'
     otherwise.


File: guile.info,  Node: Structured I/O,  Next: I/O Redirection,  Prev: Character I/O,  Up: Ports

Structured I/O
==============

 - Function: write OBJ &opt PORT
 - Function: display OBJ &opt PORT
     Write a printed representation of `obj' on PORT or
     `current-input-port'.

     For all objects with a read syntax, `write' prints using that
     syntax.

     `display' is similar to write, except that strings are printed
     without quotes, characters are printed without `#\' and so forth.

 - Function: read &opt PORT CASE-I?
     Read an object from PORT or `current-input-port'.

     If CASE-I? is specified and not `#f', symbols are read in a case
     insensitive manner.  Otherwise, case matters in symbol names.

