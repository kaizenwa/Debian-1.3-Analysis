\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename gtcltk.info
@settitle Using Tk and Tcl with Guile
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Using Tk and Tcl with Guile
@author by Tom Lord

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@node Top, Copying, (dir), (dir)

@ifinfo

This file documents how to use Tk and Tcl with Guile.

@end ifinfo

@menu
* Copying::                     
* Tcl Facilities::              
* Tk Facilities::               
* Gwish::                       
@end menu

@node Copying, Tcl Facilities, Top, Top
@chapter Copying

@center Copyright (C) 1995
@center Free Software Foundation, Inc.
@center 675 Mass Ave, Cambridge, MA 02139, USA

@noindent
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

@center NO WARRANTY

@noindent
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@noindent
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


@node Tcl Facilities, Tk Facilities, Copying, Top
@chapter Tcl Facilities

If you have Tcl extension modules written in C, these can be accessed
from Guile programs.  If you have an application that uses the Tcl
interpreter, you can use Guile to define new modules for it -- modules
that can be loaded without having to re-compile.

Documented here are the low-level facilities linking Tcl to Guile.  In
the future, a friendlier Scheme interface will be provided in preference
to these entry points.

@defun tcl-create-interp
Return a new Tcl interpreter object.

An interpreter object is a namespace of functions and variables managed
by modules that use the Tcl calling conventions.
@end defun 

@defun tcl-global-eval interpreter string
Evaluate a string according to Tcl's evaluation rules.

@var{interpreter} must be an object returned by @code{tcl-create-interp}.

The return value is an integer/string pair.  The integer is the Tcl
status code, the string is the Tcl result.

This is not the way to call a Tcl command.  See the functions @code{tcl-command}
and @code{tcl-apply-command}.  Using those functions is faster.

N.B.: by default, most built-in Tcl commands are absent in Guile.
Consequently, most Tcl programs will not run.  However, facilities
exist so that you can link all of libtcl with Guile programs -- in which
case all the usual built-in commands will be present.  [add reference!]
@end defun

@defun tcl-get-int interpreter string
@defunx tcl-get-double interpreter string
@defunx tcl-get-boolean interpreter string
Convert strings to Scheme types according to the conventions of Tcl.
@end defun

@defun tcl-split-list interpreter string
Split a Tcl-style "list" (a string following Tcl's list syntax) into a list.
@end defun

@defun tcl-merge interpreter list
Combine a list of strings into a string following Tcl's list syntax.
@end defun

@defun tcl-create-command interpreter name procedure
Define a new Tcl command which is recognized by the Tcl evaluator.

@var{interpreter} must be an object returned by @code{tcl-create-command}.

@var{name} must be a string which is a valid Tcl identifier.

@var{procedure} may be any Scheme procedure object.

When the Tcl evaluator invokes the new command, @var{procedure} is
called with as many arguments as were passed to the Tcl command.
The arguments are all passed as strings.

The return value of @var{procedure} is used as the Tcl result.  The
return value of @var{procedure} determines the Tcl return value
according to these rules:

@example
if PROCEDURE returns:      the Tcl result is:   and Tcl status is:
__________________________________________________________________

string (e.g. "foo")           that string ("foo")       TCL_OK

integer (e.g. 1)              the empty string          the int
                                                            (1)

an int/string pair            the string                the int 
(e.g. (1 . "bogus frob"))        ("bogus frob")             (1)
@end example
@end defun

@defun tcl-delete-command interpreter name
Remove the named command from a Tcl interpreter.
@end defun

@defun tcl-trace-var2 interpreter name index flags procedure
@defunx tcl-untrace-var2 interpreter name index flags procedure
Add a callback to a Tcl variable.

@var{name} is the name of the variable.

@var{index} is the subscript of the variable, or @code{#f} for a scalar.

After @code{tcl-trace-var2}, modifications to the named variable or 
array position cause procedure to be called with four arguments:
a tcl interpreter, the variable being modified, an index into the 
named variable (possible the empty string), and an integer of flags.
@end defun


@defun tcl-set-var2 interpreter name index value flags
@defunx tcl-get-var2 interpreter name index flags
Set or return the current value of a Tcl variable.
@end defun

Symbolic names for Tcl flags are provided in the source file Gtcl.scm
and are the same as their C counterparts.  The procedure @code{flags}
is used to combine flags.  For example:

        (flags TCL_TRACE_READS TCL_TRACE_WRITES TCL_TRACE_UNSETS)


Tcl commands can be invoked from Scheme directly, without having to 
use the Tcl evaluator:

@defun tcl-command interpreter name
Return an object representing the named command (or #f if none is defined).
@end defun

@defun tcl-apply-command command args
Apply Tcl command @var{command} to the list of strings @var{args}.

@var{command} should be an object returned by @code{tcl-command}.

@var{args} should be a list of arguments.

The return value is an integer/string pair.  The integer is a Tcl return
code, the string the Tcl result.

The arguments can be of several types but must ultimately be converted
to strings because of the way Tcl and Tk work internally.  Types are
converted this way:

@example
  ;;----------------------------------------
  ;; Argument             Converted argument
  ;;----------------------------------------
    123                     "123"
    123.34                  "123.34"
    "a-string"              "a-string"
    'a-symbol               "a-symbol"
    :keyword                "-keyword"
    #t                      "1"
    #f                      "0"
    (lambda (...) ...)      "*__guile#234"
@end example

The automatic conversion of a procedure works this way.  First, a new
Tcl name is generated for the procedure and a Tcl command with that name
is defined.  When evaluated, the Tcl command calls the Scheme procedure.
Second, if the procedure has a property defined called
'tcl-calling-convention, and if that is bound to a string, then that
string is appended to the name with an intervening space.  For example,
if a procedure's properties bind 'tcl-calling-convention to "%x %y",
then the name is appended and winds up like "__guile#234 %x %y".
Finally, an asterix is prepended to the name (e.g. "*__guile#234 %x %y").

In the GNU modified version of Tcl/Tk, an asterix prepended to a command
name has special meaning if the name is passed as a "-command" or
similar configuration parameter to a widget, or if passed as the command
argument to a "bind" operation.  In that case, the command is renamed to
a canonical name that is unique to the widget or binding sequence
(overwriting any previous definition).  If the widget or binding
sequence is later deleted, so is the canonicalized command.  This is an
extremely twisted way to trick Tcl into managing anonymous Scheme
procedures with acceptable semantics (e.g., without core leaks and
without requiring Scheme programmers to invent liveness for anonymous
procedures they'd otherwise drop).
@end defun

@node Tk Facilities, Gwish, Tcl Facilities, Top
@chapter Tk Facilities

So that Tk widgets can be used form Scheme, Guile provides the following
functions:

@defun tk-init-main-window interpreter display name class
Initialize a Tcl interpreter as a Tk main window.

@var{display}, @var{name}, and @var{class} must all be strings.
@end defun

@defun tk-do-one-event flags
Process one window system event.

Symbolic definitions for @var{flags} are provided in Gtk.scm and have
the same name as their C counterparts.
@end defun

@defun tk-main-loop
Process window events until no windows remain.
@end defun 

@node Gwish,  , Tk Facilities, Top
@chapter Gwish

Gwish is a Wish-like application of Guile, based on STk by Erick
Gallesio.

@subsection Running Gwish

@subsection Mapping Tcl/Tk Constructs onto Gwish

In Gwish, there is a single Tcl/Tk interpreter which is an implicit
default.  Commands defined in that interpreter are automaticly defined
as Scheme commands as well (unless a Scheme-specific binding overwrites
them).  This means that you can write Scheme code that closely matches
the corresponding Tcl code.  For example:

@example
(button '.b)
(.b 'configure :text "hello world" :command (tcl-lambda () (beep)))
@end example

Arguments passed to a procedure implemented by a Tcl command must be
converted to a string for the sake of Tcl's calling conventions and data
representations.  This table illustrates how argument types are converted:

@example
  ;;----------------------------------------
  ;; Argument             Converted argument
  ;;----------------------------------------
    123                     "123"
    123.34                  "123.34"
    "a-string"              "a-string"
    'a-symbol               "a-symbol"
    :keyword                "-keyword"
    #t                      "1"
    #f                      "0"
    (lambda (...) ...)      "*__guile#234"
@end example

Most of these conversions are simple and obvious but the conversion of
procedure objects is subtle and non-obvious.  It is not necessary to
understand the details, though they are documented elsewhere.  It is
necessary to know that procedure arguments `do the right thing' when
they are passed as command parameters to widget configuration commands,
and as event bindings.  You might ask: what is the right thing?

A procedure passed as either an event binding or widget command is protected
by the binding or widget involved.  Effectively, the widget or binding
keeps a reference to the procedure object.  For this reason, it is possible
to use an anonymous Scheme procedure as an event binding or widget command.
For example:

@example
(let ((n 0))
   (.b configure :command (lambda ()
                             (write n)
                             (newline)
                             (set! n + 1)
                             "")))

;; Incidently, note that the command procedure returns an empty string.
;; All procedures called by Tcl have to return a proper Tcl result.
;; Return values are explained further in the next subsection.
;;
@end example

When a command or binding is overwritten and that command or binding is
to a Scheme procedure, the reference to the procedure is dropped.  The
procedure is also dropped if the binding or widget is deleted.  For this
reason, there are no core leaks associated with passing anonymous
procedures as these kinds of arguments.

At this time, it isn't generally useful to pass Scheme procedures to Tcl
commands other than as an argument to a binding command or widget
configuration command.

The details of how procedures are translated are described in the
documentation for `tcl-apply-command'.  @xref{Tcl Facilities}.



@subsection Defining Tcl Command in Scheme

Gwish provides a convenient syntax for defining new Tcl commands.

@deffn Syntax proc name formals . body
Define a new Tcl command and Scheme procedure simultaneously.

@example
;; A two argument string-append callable as a Tcl command.
;;
(proc string-smash (s1 s2)  (string-append s1 s2))
@end example

Proc expands to a @code{tcl-lambda} form, which is explained below.
The example above is equivalent to:

@example
(begin
  (define string-smash (tcl-lambda (s1 s2) (string-append s1 s2)))
  (tcl-create-command the-interpreter 'string-smash string-smash))
@end example

@end deffn

@deffn Syntax tcl-lambda (?calling-convention? ?.? formals) . body
Similar to lambda, but imposes Tcl-specific calling conventions.
Type declarations are supported.  This is best explained via examples.

A simple use of @code{tcl-lambda}:

@example
;; By default, when called from Tcl, all of the arguments 
;; to a tcl-lambda are strings.
;;
(tcl-lambda (a b) (string-append a b))
@end example

The return value of a tcl-lambda has special signficance when the
function is invoked by Tcl.  

An integer return value is converted to a string.  A string or symbol is
used used directly as a Tcl result.  A cons pair with an integer car and
string cdr is a Tcl status/message combination.

Type declarations can be used to specify that parameters passed as
strings should be coerced to some other type.  For example:

@example
(define tcl-plus 
   (tcl-lambda ((number a) (number b))
      (+ a b)))

(tcl-plus "23" 19)  => 42
@end example


Tcl-lambda is very useful for using anonymous Scheme functions
as Tk event bindings.  For this purpose, you can can specify a
Tk "calling convention" by writing a string in the first of
the argument specification.  For example:

@example
(.c 'bind 'node "<Button-2>"
    (tcl-lambda ("%x %y" (number x) (number y))
      (set! cur-x x)
      (set! cur-y y)
      #t))                    ; Tcl-compatible return value.
@end example

In that example, @code{"%x %y"} is the calling convention.  The full command
that Tcl calls when invoking the binding will be similar to:

@example
__binding#0x123123 %x %y
@end example

and therefore the Scheme procedure will be passed (in this case) the x and
y position of the mouse.
@end deffn 

@subsection An Example: Ousterhout's Graph Editor

This program implements the toy graph editor from the Tcl/Tk <fixme>.

@example
@c include Ggraph.scm
@end example

@bye
