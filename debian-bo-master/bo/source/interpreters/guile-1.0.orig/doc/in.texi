\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename in.info
@settitle Ice 9
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header


@dircategory Guile -- GNU extension language
@direntry
* in: (in).                                     Ice-9.
@end direntry

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage Ice 9
@title Ice 9
@author by Tom Lord

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995, 1996 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@node Top, Copying, (dir), (dir)

@ifinfo

This file documents Ice 9, an operating system for Guile Scheme.

@end ifinfo

@menu
* Copying::                     
* About This Manual::           
* What is Ice 9?::              
* Calling Convention Preliminaries::  
* Coroutines Using Runqs::      
* Named Resources::             
* Channels::                    
* Tcl Commands::                
* Booting Ice 9::               
* Tk Programming::              
* The Gnotscope Window System::  
* Famous Runqs::                
@end menu

@node Copying, About This Manual, Top, Top
@chapter Copying

@center Copyright (C) 1995, 1996
@center Free Software Foundation, Inc.
@center 675 Mass Ave, Cambridge, MA 02139, USA

@noindent
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

@center NO WARRANTY

@noindent
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@noindent
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

@node  About This Manual, What is Ice 9?, Copying, Top
@chapter About This Manual

This manual describes a work-in-progress, but one that I think has
reached a point where it is reasonable (and arguably important) to begin
applying it to real-world problems.  You have to be pretty brave and
reasonably expert at Scheme to use Ice 9 at this point.  If you embark
on that course, expect to encounter difficulties -- and please use those
difficulties to help refine the design direction of Ice 9!

What stands to be gained by using Ice 9?  In spite of its being a
work-in-progress, I think Ice 9 is already a powerful tool with a clean,
flexible, extensible design.  I know that Ice 9 resembles the Scheme
programming environment @emph{I've} wished(!) for for a long time --
perhaps @emph{you} will like it too.

This manual is itself a work-in-progress.  Large sections of it are, as
you will see, simply blank.  This deficiency is somewhat made-up-for by
the comments in the code -- I've tried to make those pretty thorough and
eventually they'll be edited and reformated to complete this manual.

I've lightly proof-read the manual, but haven't had time to carefully
review it.   Expect typos, errors, and confusing passeages.

Expect spelling errors.  At this time there doesn't seem to be a freely
available on-line dictionary and so automatic spell-checking is an
impossibility for me.

Ice-9 was developed on a machine running Linux 1.2.2 (really, I'll get
around to upgrading one of these days).  Only free software is used on
this machine.  When I stop to think about it, that fact amazes and
delights me.

When I first became interested in programs with embedded lisp dialects,
it was because of GNU Emacs, the customizable, self-documenting editor.
At the time, not much free software was available and the idea of free
software was foreign to many people.  I learned about lisp, editors,
user interfaces, and free software all in the same breath; it changed my
life and informed my choices about what skills to develop and what goals
to strive for.

It is startling and exciting to look around now, roughly a decade later,
and see free software thriving so well that I can get by running nothing
else on the machine I use.  It is inspiring to observe so many people
agree that in areas where it competes with proprietary solutions, free
software is often the highest quality choice.

It has been a real struggle and a constant challenge to be able to
continue learning and working long enough to reach this point, where I
can finally contribute back in the way I long hoped I could.  I'm not
mentioning this simply to valorize myself -- although I admit to feeling
good about having stuck to it.  I'm mentioning it to thank certain
helpers I've had along the way who insisted on doing their good deeds in
a way that permitted no other form of ackowldgement than this. 

Thanks to T. and M. for the kind of help that without which -- nothing.

Finally, don't let all these "thanks" create the wrong impression.  This
is the beginning, not the end.  With Ice 9, I'm finally ready to get
started.

@node  What is Ice 9?, Calling Convention Preliminaries, About This Manual, Top
@chapter What is Ice 9?

Ice 9 is the operating system for Guile Scheme.

The operating system's job is to manage resources shared by multiple
Guile Scheme programs that might be loaded into a Guile instance.  It
should provide file system access, network access, scheduling
primitives, support for terminal and GUI programming, and other
libraries of commonly needed functionality.

The implementation of Ice 9 was greatly simplified by the direction
taken by the Tcl/Tk team.  They've done an outstanding job providing
extremely portable C libraries for file system access, network access,
scheduling primitives, and GUI programming.  The goal of Ice 9 is
largely just to present their work with a Scheme-friendly interface.

So just what is a Scheme-friendly interface to those capabilities?  Of
course, the answer can only be a matter of experience or opinion.  The
former is largely lacking at this point in time.  In forming opinions, I
tried to steal only the very best ideas: programming techniques from
SICP, operating system concepts from Plan 9 and the GNU hurd, GUI
techniques from lisp machine environments and so forth.  I've tried to
build it all up from very simple data structures and algorithms, because
I think this leads to a system that is small, comprehensible,
extensible, and parsimonious.

But enough philosophizing, here's the manual.  Enjoy!


@node  Calling Convention Preliminaries, Coroutines Using Runqs, What is Ice 9?, Top
@chapter Calling Convention Preliminaries

Key parts of Ice 9 are coded in Guile Scheme.

Ice 9 makes heavy use of a few calling conventions that are layered on
top of ordinary Scheme procedure calls.  Some parts of Ice 9, for
example, use a message-passing style of object oriented programming.
Some parts of Ice 9 make heavy use of option arguments (flags that may
or may not occur in an argument list) and optional keyword arguments
(arguments that may or may not be present and that, if present, are
preceded by keyword that indicates their presense).  This chapter
documents the calling conventions that come up most often in Ice 9.

The terminology in this chapter, "message", "object", "getters and
setters" and so forth is used throughout the manual.  Be careful to
note: I use terms like "message" and "object" as names for
@emph{ordinary Scheme objects} like argument lists and procedures.
These names emphasize how I am using the Scheme objects, but they do not
imply that we're using an "Object System" in which objects, messages,
and method invocations are disjoint in kind from ordinary Scheme data
and procedure calls.

@menu
* Message Passing::             
* GET and SET messages::        
* Keyword Arguments::           
* Distributed Message Passing::  
@end menu


@node  Message Passing, GET and SET messages, Calling Convention Preliminaries, Calling Convention Preliminaries
@section Message Passing

In a number of places in Ice 9 a message-passing style of object
oriented programming is adopted.  In this style, objects are represented
by Scheme procedures and sending a message means calling a procedure.
All messages consist of a symbol in the first argument position,
followed by 0 or more message-specific arguments.  The symbol in the
first argument position is a @dfn{message selector}:

@example
(some-object 'set :x-pos 12 :y-pos 32)
(some-other-object 'print)
@end example

Implementing a new object is easy.  Use something like:

@example
(define (make-some-kind-of-object . constructor-arguments)
   ... initialize the object's state ...

   ... bind methods to local names, e.g. "set-handler"

   ;; Return a dispatcher procedure for the new object:
   ;;
   (lambda (msg . args)
     (case msg
       ((get)		(apply get-handler args))
       ((set)		(apply set-handler args))
       ...
       (else		(apply throw 'not-understood msg args)))))
@end example

When a message is received that isn't handled, throw a
@code{not-understood} error passing the message and its arguments to
throw.  [This convention is new and not yet implemented everywhere.]

One way to define new kinds of objects is in terms of older kinds of
objects using the technique of delegation.  In that case, don't handle
unrecognized messages by throwing an error, but by passing them along to
a delegate object.

For example:

@example
(define (make-some-kind-of-object delegate-object . constructor-arguments)
   ... initialize and bind methods ...

   ;; Return a dispatcher procedure for the new object:
   ;;
   (lambda (msg . args)
     (case msg
       ((get)		(apply get-handler args))
       ((set)		(apply set-handler args))
       ...

	;; Unhandled message are sent to the delegate.
	;;
       (else		(apply delegate-object msg args)))))
@end example


@node  GET and SET messages, Keyword Arguments, Message Passing, Calling Convention Preliminaries
@section @code{get} and @code{set} messages

Many objects understand @code{get} and @code{set} messages.  These
messages are part of a sub-convention of message passing in general.
The subconvention provides a generic interface to variable-like
attributes of objects.

Each object variable is assigned a keyword for use with @code{get} and @code{set}.
Messages are sent like:


@example
(object 'get :x-pos :y-pos) => (1 1)
(object 'get :x-pos) => (1)
(object 'get :x-pos :x-pos :x-pos) => (1 1 1)

(object 'set :x-pos 1 :y-pos 1)
@end example

Generally, @code{get} messages return a list of values but there is an exception.
With no arguments, a get message returns a list of keywords and values:

@example
(object 'get) => (:x-pos 1 :y-pos 1)
@end example


The bi-modal convention for @code{get} may seem odd at first, but here
are two compelling idioms it supports:

@example

;; This takes advantage of the convention for no-argument get messages:
;;
(define saved-state (object 'get))
(apply object 'set saved-state)

;; This takes advantage of the convention for get with arguments.
;; Note that (apply-args A B) == (apply B A)
;;
(apply-args (object 'get :x-pos :y-pos)
	    (lambda (x y) 
		 ...))
@end example

For unrecognized keywords passed to @code{get} or @code{set}, objects
should throw @code{unrecognized-field} passing the remaining
keyword-value list (if a setter) or the remaining keyword list (if a
getter), including the errant keyword at the head of that list. [This is
a new convention, No objects in the current release do this.]

There are some macros to help implement getters and setters.

@deffn Syntax with-getter-and-setter @var{<vars>} proc
@var{<vars>} is an unevaluated list of names that are bound in the
caller.  @var{proc} is a procedure.  When this form is evaluated,
@var{proc} is called this way: 

@example
(proc getter setter)
@end example

@code{getter} and @code{setter} are procedures used to access or modify
@var{<vars>}.  They take arguments of the sort that follow a @code{get}
or @code{set} message selector.

Here is an example:


@example
;; make-point returns an object which is a point on the plane
;; and a color assigned to that point.  The object understands
;; get and set messages and a message, "draw", whose definition
;; isn't shown.  All three attributes of the object, x and y position
;; and color, can be queried or changed using get and set.
;;
(define (make-point x-pos y-pos)
  (let ((color 'green))
    (with-getter-and-setter (x-pos y-pos color)
       (lambda ((get set) msg . args)
	  (case msg
	     ((get)	(apply get args))
	     ((set)	(apply set args))
	     ((draw)    ....)
	     (else	(apply throw 'not-understood msg args)))))))
@end example

@end deffn


@deffn Syntax with-delegating-getter-and-setter <vars> get-delegate set-delegate proc
This creates new getters and setters that delegate to old ones.

@var{<vars>} is an unevaluated list of names that are bound in the caller.
  
@var{get-delegate} is a procedure used by the new getter to extend the
set of gettable variables beyond just @var{<vars>}.  The arguments to
@var{get-delegate} follow the same convention as the arguments to a
@code{get} message.

@var{set-delegate} is procedure used by the new setter to extend the set of
settable variables beyond just @var{<vars>}.  The arguments to
@var{set-delegate} follow the same convention as the arguments to a
@code{set} message.

@var{proc} is a procedure that is called

@example
(proc getter setter)
@end example

The @var{getter} and @var{setter} process the named @var{<vars>} and use
@var{get-delegate} and @var{set-delegate} to handle unrecognized keywords.
@end deffn


@deffn Syntax with-configuration-getter-and-setter <vars-etc> proc
Create a getter and setter that can trigger arbitrary computation.

@var{<vars-etc>} is a partially unevaluated list of variable specifiers,
explained below.

@var{proc} is a procedure called, as usual:

@example
(proc getter setter)
@end example

Each element of the @var{<vars-etc>} list is of the form:

@example
(<var> getter-hook setter-hook)
@end example

Both hook elements are evaluated; the variable name is not.
Either hook may be @code{#f} or procedure.

A getter hook is a thunk that returns a value for the corresponding
variable.  If @code{#f} is specified as the getter hook, then the
lexical binding of @code{<var>} is returned from get messages querying
this variable.  If a thunk is specified as the getter hook, then asking
the getter about this variable will cause that thunk to be called and
its return value will be returned as the variable value.

A setter hook is a procedure of one argument that accepts a new value
for the corresponding variable.  If omitted, the binding of @var{<var>}
is simply set using @var{set!}.
@end deffn

@deffn Syntax let-configuration-getter-and-setter <vars-etc> proc
This procedure is like @code{with-configuration-getter-and-setter} (q.v.)
except that each element of @var{<vars-etc>} is:

@example
(<var> initial-value getter-hook setter-hook)
@end example

Unlike @code{with-configuration-getter-and-setter},
@code{let-configuration-getter-and-setter} introduces bindings for the
variables named in <vars-etc>.  It is short-hand for:

@example
(let ((<var1> initial-value-1)
      (<var2> initial-value-2)
       ...)
  (with-configuration-getter-and-setter ((<var1> v1-get v1-set) ...) proc))
@end example
@end deffn



@node  Keyword Arguments, Distributed Message Passing, GET and SET messages, Calling Convention Preliminaries
@section Keyword Arguments

Guile Scheme has a type of self-evaluating object called a keyword.
The syntax of keywords is the same as that of symbols except that
a keyword must begin with a colon character (":").  (Correspondingly,
Guile Scheme symbol names normally do not begin with a colon.)

In Ice 9, I almost always adhere to the convention that keywords are
used in argument lists to specify options and to tag optional arguments
when the number and meaning of the options and optional arguments is
potentially variable.  If that sounds confusing, just think about
@code{get} and @code{set} messages -- they are examples of this
convention:

@example
;; Keywords used to specify options:
;;
(some-obj 'get :x :y :z)


;; keywords used to tag optional arguments
;;
(some-obj 'set :x 1 :z 10)
(some-obj 'set :y 13)
@end example

Another example is the way messages are sent to many Tk widget commands:

@example
(some-canvas 'create 'oval 10 10 20 20 :fill red)
@end example

Here is an example of where some of the keywords are used to specify
options that don't require arguments and others are used to tag optional
arguments:

@example
(make-gadget :persistant
             :exported
             :fill-factor 10)
@end example

In that last example, there is the potential for ambiguity.  Are
@code{:persistant} and @code{:exported} two separate options with no
arguments, or one option (@code{:persistant}) with an argument
(@code{:exported})?

To avoid such ambiguities, I use a coding convention:

@cartouche
As a rule of thumb, never use keywords except as tags for optional
arguments or option specifiers.  In particular, keywords should never be
passed as keyword arguments.
@end cartouche

To help programmers write procedures that accept keyword arguments, the
following is provided:

@defun kw-arg-ref a-list a-key
Return @code{(and (memq @var{a-key} @var{a-list}) (cdr (memq @var{a-key} @var{a-list})))}.

Here is an example showing one way @code{kw-arg-ref} can be used:

@example
(define (example-fun req-a req-b . optional-arguments)
  (let ((fill-factor (or (kw-arg-ref optional-arguments :fill-factor)
                          default-fill-factor))
        (chill-factor (or (kw-arg-ref optional-arguments :chill-factor)
                          'garage-acid-jazz))
        (persistant? (not (not (memq :persistant optional-arguments))))
        (exported? (not (not (memq :exported optional-arguments)))))
    ...do stuff...))

@end example

@end defun

@node  Distributed Message Passing,  , Keyword Arguments, Calling Convention Preliminaries
@section Distributed Message Passing

A subset of the values encountered in Scheme programming have the
property that they can be read and written, yielding @code{equal?}
values.  In some cases, writing and reading a value yields an @code{eq?}
or @code{eqv?}.

The calling conventions used in Guile are based on symbols and keywords
-- objects which can be read and written yield @code{eq?} results.
@emph{If you use these calling conventions, and are careful in choosing
the types of other arguments and return values}, then you can send
messages over network connections, store them in files, and otherwise
transmit them or receive them from outside of your process.

Of course, it isn't practical to require that @emph{every} message in
the system be distributable in this way -- but it is something to keep
in mind as you write design new interfaces.  If you think you might
someday want to call the new interfaces remotely, choose the argument
and return types accordingly.


@node  Coroutines Using Runqs, Named Resources, Calling Convention Preliminaries, Top
@chapter Coroutines Using Runqs

Ice 9 uses Scheme closures to represent flyweight coroutines.  I use
thunks (nullary procedures) and lists of thunks to represent
@dfn{strips}, schedulable units of computation.  One strip runs at a
time and execution of the strips of many coroutines may be interleaved.

By convention, the return value of a strip-thunk must either be another
strip or the value @code{#f}.  Returning the value @code{#f} from a
strip signals the termination of the coroutine that the strip is a part
of.  Returning a strip from a strip signals that a coroutine is being
suspended and that calling the returned strip resumes the coroutine.

There are two ways to suspend a coroutine -- one is to return a single
thunk, which is the serial continuation of the coroutine; the other is
to return a list of thunks, in which case the coroutine forks into
multiple continuations.

A @dfn{runq} is a procedure that manages a queue of strips.  Called with
no arguments, a runq processes one strip from the queue.  Called with
arguments, the arguments form a control message for the queue.  The
first argument of a control message is a symbol which is the message
selector; see @xref{Message Passing}.

A strip is processed this way: 

@itemize @bullet{}
@item If the strip is a thunk, the thunk is
called -- if it returns a strip, that strip is added back to the queue.
@item To process a strip which is a list of thunks, the CAR of that list is
called.  After a call to that CAR, there are 0, 1, or 2 strips --
perhaps one returned by the thunk, and perhaps the CDR of the original
strip if that CDR is not nil.  The runq puts whichever of these strips
exist back on the queue.  
@end itemize

The exact order in which strips are put back on the queue determines the
scheduling semantics of a particular queue -- it's a parameter and
different kinds of queues do this different ways.  Another scheduling
parameter is the number of strips processed per nullary call to a runq.

When a runq is called with no arguments, it process strips from its
queue.  How many strips are processed is up to the runq itself.
After processing, if the queue is not empty, the runq procedure returns
@emph{itself}.  If the queue is empty, the runq returns @code{#f}.
This convention is important: it means that a runq procedure is itself
a coroutine (consisting of strip that sometimes iterates).

In addition to being a useful thunk, runq procedures also accept control
messages.  The standard runq control messages are:

@example
'add! strip0 strip1...		;; to enqueue one or more strips
'enqueue! strip0 strip1...	;; to enqueue one or more strips
'push! strip0 ...		;; add strips to the front of the queue
'empty?				;; true if it is
'length				;; how many strips in the queue?
'kill!				;; empty the queue
else				;; throw 'not-understood
@end example

@defun make-void-runq
Make a runq that discards all messages except "length", for which
it returns 0.
@end defun


@defun make-fair-runq
Returns a runq procedure.
Called with no arguments, the procedure processes one strip from the queue.
Called with arguments, it uses runq-control.

In a fair runq, if a strip returns a new strip X, X is added
to the end of the queue, meaning it will be the last to execute
of all the remaining procedures.
@end defun


@defun make-exclusive-runq
Returns a runq procedure.
Called with no arguments, the procedure processes one strip from the queue.
Called with arguments, it uses runq-control.

In an exclusive runq, if a strip W returns a new strip X, X is added
to the front of the queue, meaning it will be the next to execute
of all the remaining procedures.

An exception to this occurs if W was the CAR of a list of strips.
In that case, after the return value of W is pushed onto the front
of the queue, the CDR of the list of strips is pushed in front
of that (if the CDR is not nil).   This way, the rest of the thunks
in the list that contained W have priority over the return value of W.
@end defun


@defun make-subordinate-runq-to superior basic-inferior
Returns a runq proxy for the runq basic-inferior.

The proxy forwards all calls to the @var{basic-inferior}.
After each control message to the inferior runq, the proxy
examines the length of the queue.   On a transition from 0
to 1, the proxy adds a coroutine to the superior runq.  On a 
transition from 1 to 0, that coroutine is removed.
Each time a strip of the coroutine is called, @code{N} strips
are processed on the @var{basic-inferior} where @code{N}
is the length of the @var{basic-inferior} before any
strips have been processed.

[Endless scheduling variations are possible on this basic idea.]
@end defun


@defun fork-strips . strips
Return a strip that starts several strips in 
parallel.   If this strip is enqueued on a fair
runq, strips of the parallel subtasks will run
round-robin style.
@end defun

		
@defun strip-sequence . strips
Returns a new strip which is the concatenation of the argument strips.
Each coroutine in the concatenation runs to completion and then triggers
the beginning of the next.
@end defun


@defun fair-strip-subtask . strips
Returns a new strip which is the synchronos, fair,
parallel execution of the argument strips.

Each argument is a coroutine and strips of these coroutines are
multiplexed by the single coroutine returned by
@code{fair-strip-subtask}.
@end defun


You might be wondering what it is that calls a runq to process strips --
that is, how does Ice 9 itself schedule coroutines.  The coroutine
facility, documented in this section, is completely independent of the
scheduling conventions of Ice 9.  The specific runq objects maintained
by Ice 9 are, accordingly, documented elsewhere; see @xref{Famous
Runqs}.

@node  Named Resources, Channels, Coroutines Using Runqs, Top
@chapter Named Resources

Ice-9 maintains a hierarchical namespace reminiscent of a unix
file-system or the URL namespace.

At any one time, the root of this namespace is the current module.
Names in the root are the top-level variable names and, of course,
names in the root are bound to the values of the variables.

If a variable is bound to a module, then that module is a
@dfn{subdirectory}.  Subdirectories may be nested arbitrarily,
therefore, names in the hierarchical namespace are conveniently
represented as lists of symbols.  For example, 

@example
'(app frames system-monitor)
@end example

is a name for the variable called @code{system-monitor} as bound
in a module stored in the variable called @code{frames} in another
module, which is itself stored in a variable called @code{app} in
the top-level module.

Programs can extend the namespace by creating new modules and binding
variables in ordinary ways (see the Guile reference manual to learn more
about modules and variables).  Programs can create virtual modules
(modules in which some of the bindings are create on-demand by a
"lazy-binder" procedure) in order to create directories with special
semantics.

A convenient syntax is provided for writing lists of symbols: the
@code{#/} syntax.  This syntax is useful for emphasizing that a list of
symbols is being used as a name in the hierarchical name-space.  Don't
be confused: this syntax still denotes an ordinary list of symbols:

@example
#/a/list/of/symbols == (a list of symbols)

;; So for example, you can do weird things.  Here is an unlikely
;; way to apply the procedure "list" to three math primitives:
;;
#/list/+/-/* 
=> (#<primitive-procedure +> #<primitive-procedure -> #<primitive-procedure *>)

;; Normally, #/ lists are explicitly quoted:
;;
'#/a/typical/hierarchicy/name
=> '(a typical hierarchicy name)
@end example

The current module is the root of the named-resource hierarchy.  One
element names refer to top-level bindings.  For example, the name
@code{#/list} refers to the same binding as the variable name
@code{list}.  The only zero-element name, @code{#/} a.k.a. @code{()},
is a name for the current module.

By convention, the @code{(current-module)} should always have a binding
for a variable named @code{app}.  That binding should be to a module.
@code{#/app} is the "system directory" in which Ice 9 itself defines
names.  Other branches of the hierarchy (siblings of @code{app}) are
available for programs to use as they see fit.  A default @code{app}
directory is constructed at start-up time and installed in the "the root
module" from which it is inherited by most interactive top levels.  It
is probably a mistake for programs to try to create a private
@code{#/app}.  (Incidently, don't confuse "the root module", which is
what I call the top-level that contains all of Guile Scheme's built-in
functions and variables with the root of the resource namespace.  Sometimes
they are the one in the same, but not always).

The following examples may help to make the structure of the namespace a
little clearer and to introduce the basic procedures for accessing the
namespace.  The Guile reference manual can provide more details about
modules and variables and some of the procedures illustrated here.


@example
;;; A hypothetical Guile session.   
;;;

guile> (current-module)			; current-module is also the "root".
#<module the-root-module 20e550>

;; local-ref looks up a node in the hierarchical namespace and returns
;; that node.  For a "directory", that means returning the module that
;; represents the directory:
;;

guile> (local-ref '#/)			; look up the root
#<module the-root-module 20e550>

guile> (local-ref '#/+)			; look up a non-directory
#<primitive-procedure +>

;; Always true:
guile> (eq? (current-module) (local-ref '#/))
#t


;; ls is a procedure that returns a list of directory contents.
;; Naturally, the root directory, doubling as an interactive top level,
;; has many bindings:
;;
guile> (ls '#/)
(cons car cdr caar cadr + - * / [..many names omitted..] )


;; Modules bound to variables serve as subdirectories:
;;
guile> app
#<module 20f548>

guile> (local-ref '#/app)
#<module 20f548>

;; App is a "system directory" containing, (among other things)
;; a directory of all source modules that have been loaded.
;;
guile> (ls '#/app)
(display-cmds frames modules)

;; The special directory "modules" is the root of the namespace
;; of modules.   One module of interest is the module that defines
;; ls, namely #/utils/tree:
;;
guile> (ls '#/app/modules)
(guile utils)

guile> (ls '#/app/modules/utils)
(tree)

;; Take a look at what is defined in the module #/utils/tree:
;;
guile> (ls '#/app/modules/utils/tree)
(defined? eval-load zero? [....] nthcdr)	;; a huge top-level

;; Oops, I really only want to know what is *locally* defined
;; in the tree module -- excluding the definitions inherited
;; from the root module.   So, use "lls" -- local ls
;; to discover that the tree module only provides a few new
;; definitions:
;;

guile> (lls '#/app/modules/utils/tree)
(definitions-in ls recursive-local-define 
 local-definitions-in %module-public-interface lls)


;; Source modules use "define" and "define-public".  "define-public"
;; copies bindings into a designated public interface.   I
;; can use "ls" to see what definitions are exported by #/utils/tree:
;;
guile> (ls '#/app/modules/utils/tree/%module-public-interface)
(definitions-in ls recursive-local-define local-definitions-in lls)

@end example

@defun ls . various-names
This procedure is inspired by the unix command @code{ls}.

With just one argument, interpret that argument as the name of a subdirectory
of the current module and return a list of names defined there.

With more than one argument, still compute subdirectory lists, but
return a list:

@example
((<subdir-name> . <names-defined-there>)
 (<subdir-name> . <names-defined-there>)
 ...)
@end example
@end defun


Here is a further example of using @code{ls}:

To see what windows currently exist on the screen,

@example
guile> (ls '#/app/frames)
(load-avg clock inspector<0> inspector)
@end example

Subtrees of @code{#/app/modules} are often library modules or
interactive top levels.  As such, they may contain hundreds of
definitions including bindings for all of the built-in functions.  Other
parts of the name-space are sparser and more disciplined.  For example,
each frame is a directory with a few standard entries:

@example
guile> (ls '#/app/frames/inspector)
(ctl panels)
@end example

In the case of this example, @code{ctl} is bound to an object
that processes messages for the frame over-all while @code{panels}
is a subdirectory (i.e., panels is bound to a module) whose
contents are interfaces for the individually addressable sub-windows
of the frame:

@example
guile> (ls '#/app/frames/inspector/panels)
(panel88 panel79 panel70 panel62)

guile> (ls '#/app/frames/inspector/panels/panel79)
(ctl focus)

;;; etc.
@end example

As a trivial example of using these names, a user
might want to change the background color of a particular
panel:

@example
((local-ref '#/app/frames/inspector/panels/panel79/ctl)
  'set :background 'black)
@end example


@defun lls . various-names
@code{lls} is similar to @code{ls} except that while 
@code{ls} searches both a module and its use-list for bindings,
@code{lls} searches only for bindings local to the module -- it
ignores the use-list.
@end defun

You can add to the namespace by creating new modules (subdirectories)
and binding them within the existing namespace.  For example:

@example
;; Make a directory of doc-strings for spreadsheet functions:
;;
(local-set! '#/app/doc/spreadsheet-functions (make-module 13))
@end example

The technique just illustrated works to extend the namespace one-level
at a time, but sometimes it is convenient to define a new name several
levels past the current leaf nodes of the tree, filling in the missing
intermediate subdirectories with small bland modules.   This
can be done using:

@defun recursive-local-define name value
Bind @var{name} to @var{value} in the recursive namespace, automatically
generating subdirectories to hold @var{name} if they do not already exist.
@end defun

The virtual module facility of modules (see the Guile reference manual)
provides a mechanism for creating "magic" subtrees within the namespace.
"magic" subtrees contain bindings that are computed on-demand.  [The
current lazy binding mechanism will soon be extended to allow
customization of other module primitives as well.  For example, magic
modules will be able to specially define the behavior of map-module and
therefore the output of @code{ls}.]

It was said earlier that names in the hierarchical namespace are usually
lists of symbols.  Sometimes they are not; @code{local-define},
@code{local-set!}, and @code{local-ref} accept names made up of
arbitrary values.  Names which are not symbols are compared using
@code{equal?}.  For example:


@example
(define basic-name 'example)
(define backup-number 3)

;; Store a numbered backup.  Instead of using an extension like .~3~, I
;; construct the names for backups using "cons"
;;
(local-define (append '#/app/gadgets/backups  (cons basic-name backup-number))
	      previous-version)

;; Resulting in a namespace in which some of the names are not simply symbols:
;;
(ls '#/app/gadgets/backups)
=> (ctl README (example . 0) (example . 1) (example . 2) (example . 3))
@end example

@cartouche
By convention, make sure that all names you use can be printed using
@code{write} and read using @code{read} (yielding @code{eq?} objects for
symbolic names and @code{equal?} objects otherwise).
@end cartouche

Our namespace data structure can be summed up this way:

@itemize @bullet{}
@item Modules are a dictionary mapping names to variables.   By binding
variables within a module to other modules, a tree structure is created.
That tree of dictionaries is the namespace for all named resources in
Ice 9.

@item Programmers can customize modules to supply local bindings on-demand
or by inheritence from other modules.

@item The namespace is accessed by procedures like
@code{local-ref}, @code{local-set!}, @code{ls}, and @code{lls}.
@end itemize


@node  Channels, Tcl Commands, Named Resources, Top
@chapter Channels, Handlers, and Timers

Ice 9 uses the portable buffered I/O layer of Tcl to provide a substrate
underlying Scheme ports.

At this time, documentation for the Scheme channel functions is not ready,
but they  are easy to figure out by looking at:

@itemize @bullet{}
@item @file{tcl7.5/doc/OpenFileChnl.3} 
-- A Tcl man page concerning file channels.

@item @file{tcl7.5/doc/OpenTcp.3} 
-- A Tcl man page concerning network connection channels.

@item @file{libguile/guile-tcl.c}
-- Source code implementing Scheme wrappers for the libtcl functions.
@end itemize

Because the documentation is incomplete, and you'll need to do a little
work to understand the channels layer, perhaps I can offer some
incentive: this is great stuff!  The channel I/O layer provides a
platform independent (Macintosh, unix and Windows) interface to files
and network connections.  It is simple to use and quite general.

Some work remains to be done to thoroughly unify ports and channels.
For now, you can create a port wrapper for a Tcl channel using
this function:

@defun %make-channel-port channel mode
Return a port that corresponds to the indicated channel.

The port is create for reading or writing according to @var{mode} which
should be @code{"r"}, @code{"w"}, or @code{"rw"}.
@end defun

@node Tcl Commands, Booting Ice 9, Channels, Top
@chapter Tcl Commands

This section of the documentation is not finished yet.

It will explain how built-in functions defined as Tcl commands can be
called from Scheme.

It will explain how new Tcl commands can be defined in Scheme.

In lieu of documentation, try the comments in the code or some examples.
Check out @file{ice-9/system.scm} and @file{ice-9/tcl-builtins.scm}.


@node  Booting Ice 9, Tk Programming, Tcl Commands, Top
@chapter Booting Ice 9

This section of the documentation is not finished yet.

In lieu of documentation, check out the Tcl script @file{guile/gls.in}.
(Note that before it is installed, that file is processed by the
configure script and turned into @code{gls}.  It is installed as
@file{gls1.0} or whatever the current version number is.)  That script
boots Guile in a minimal way -- still needed are boot scripts which 
handle command line arguments.


@node  Tk Programming, The Gnotscope Window System, Booting Ice 9, Top
@chapter Tk Programming

This section of the documentation is not finished yet, but the
corresponding source is heavily commented and the manual will eventually
be just a reformatting of those comments.  Check out
@file{ice-9/win.scm}.

Here are a few highlights of what will eventually be documented:

@itemize @bullet{}

@item Tcl/Tk programs run normally.

This section is about how to do Tk programming from Scheme -- it is a
bit different from Tk programming in Tcl.  Ice-9 can also run Tcl/Tk
programs.   The new conventions for widget programming in Scheme have
no effect on Tcl/Tk -- Tcl programs should run without modification 
under Ice-9.

@item  Nice Scheme wrappers are provided for a few Tk widget types.

A few widget types are picked and those are imported to Scheme.  The
rest are not used.  For example, I use text and canvas widgets, but not
list widgets because they can be implemented using either texts or
canvases.

@item Event bindings are changed

Scheme programs don't use the Tcl command "bind".   Instead, Scheme
programs use keymaps (defined in @file{win.scm}).   Some nice things
about keymaps are:

@itemize -
@item You can have more than one keymap and switch between them quickly.
I.e., your interface can have different "modes" of interpretation for
input events.

@item Keymaps are a simple Scheme data structure.  You can write new
functions that examine keymaps (e.g. for on-line help) without having
to dive into the Tk C code.

@item Keymaps support prefix keys.   I.e., keymaps allow you to bind
actions to multi-key input sequences.

@item Keymaps are easily extensible.   The keymap data structure is
basically a dictionary (a module, actually).  It is easy to store new
bindings in keymap dictionaries which don't effect input-event handling,
but which can be reflected on by other subsystems (e.g. on-line help).
@end itemize

Another difference with event bindings is the way arguments are supplied
to interactively called procedures.  In Tcl, arguments are supplied by
doing a string substitution (e.g., replacing "%x %y" with mouse coordinates
in the text of the code bound to a mouse event).   In Scheme, arguments
are passed in the usual way as ordinary parameters.   In Scheme, programmers
use declarations (similar to the Emacs declaration @code{interactive}) to
say how arguments should be passed.
@end itemize


The rest of this chapter is empty except for an outline to be filled in later.

@menu
* Tk Dependencies::             
* Initializing Tk::             
* Window Paths and Procedures::  
* Widget Constructors::         
* Window System Events::        
* Three Kinds of Events::       
* Keymaps::                     
* call-with-keymapping::        
* interact loops::              
* interactive functions::       
* Reading input events::        
@end menu

@node  Tk Dependencies, Initializing Tk, Tk Programming, Tk Programming
@section Tk Dependencies

@node  Initializing Tk, Window Paths and Procedures, Tk Dependencies, Tk Programming
@section Initializing Tk

@node  Window Paths and Procedures, Widget Constructors, Initializing Tk, Tk Programming
@section Window Paths and Procedures

send_widget_message

@node  Widget Constructors, Window System Events, Window Paths and Procedures, Tk Programming
@section Widget Constructors
in general and specificly

@node  Window System Events, Three Kinds of Events, Widget Constructors, Tk Programming
@section Window System Events
in general
locatives

@node  Three Kinds of Events, Keymaps, Window System Events, Tk Programming
@section Three Kinds of Events

@menu
* System Events::               
* Input Events::                
* Ignored Events::              
@end menu

@node  System Events, Input Events, Three Kinds of Events, Three Kinds of Events
@subsection System Events

@node  Input Events, Ignored Events, System Events, Three Kinds of Events
@subsection Input Events


@node  Ignored Events,  , Input Events, Three Kinds of Events
@subsection Ignored Events


@node  Keymaps, call-with-keymapping, Three Kinds of Events, Tk Programming
@section Keymaps

@node  call-with-keymapping, interact loops, Keymaps, Tk Programming
@section call-with-keymapping


@node  interact loops, interactive functions, call-with-keymapping, Tk Programming
@section interact loops
background interact loops


@node  interactive functions, Reading input events, interact loops, Tk Programming
@section interactive functions

@node  Reading input events,  , interactive functions, Tk Programming
@section Reading input events


@node  The Gnotscope Window System, Famous Runqs, Tk Programming, Top
@chapter The Gnotscope Window System

This section of the documentation is not finished yet.

The gnotscope window system is a windowing library, layered on top of
Tk, designed to simplify GUI programming, and eventually to make it
easier to write GUIs that run remotely (in a different thread, process
or machine) from the underlying application.

Gnotscope provides generic management for top-level windows and a
geometry manager that subdivides those windows into resizable panels.
Gnotscope windows are mapped into the namespace under @code{#/app/frames}.

Right now, gnotscope supports very basic text and canvas panels.  It
needs to be extended by writing editting modes for those panels, a
port-based interface to gnotscope overall, and a gnotscope server to
allow gnotscope to be driven remotely.


@node  Famous Runqs,  , The Gnotscope Window System, Top
@chapter Famous Runqs

This section of the documentation is not finished yet, but the code is
reasonably commented.  Look for @code{idleq} and @code{blinkq} in
@file{ice-9/win.scm}.

As more experience is gained building applications, it seems likely to
me that more runqs will be added.

@bye
