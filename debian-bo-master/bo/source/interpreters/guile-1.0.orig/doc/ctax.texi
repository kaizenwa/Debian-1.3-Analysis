\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename ctax.info
@settitle Ctax Language Implementation Tools
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header

@dircategory Guile -- GNU extension language
@direntry
* ctax: (ctax).                                 C-like syntax for Guile.
@end direntry

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title Ctax Language Implementation Tools
@author by Tom Lord

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1995 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@node Top, Copying, (dir), (dir)

@ifinfo

This file documents Ctax, a flexible, C-like notation for writing
programs.

@end ifinfo

@menu
* Copying::                     
* Introduction -- A Standard Block-structured and Algebraic Syntax::  
* The Lexical Syntax of Ctax::  
* The Grammar of Ctax::         
* Ctax Syntax Trees::           
* Translating Ctax to Scheme::  
* Ctax Operators::              
* A Ctax Example::              
@end menu

@node Copying, Introduction -- A Standard Block-structured and Algebraic Syntax, Top, Top
@chapter Copying

@center Copyright (C) 1995
@center Free Software Foundation, Inc.
@center 675 Mass Ave, Cambridge, MA 02139, USA

@noindent
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

@center NO WARRANTY

@noindent
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@noindent
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

@node Introduction -- A Standard Block-structured and Algebraic Syntax, The Grammar of Ctax, Copying, Top
@chapter Introduction -- A Standard Block-structured and Algebraic Syntax

@example
:use-module #/ctax/reader
:use-module #/ctax/translator
@end example

Ctax is a C-like, block-structured, algebraic notation for writing
computer programs.

Ctax is defined by a reader that parses Ctax syntax and returns syntax
trees made up of Scheme lists.   

Ctax should not be confused with a programming language.  A programming
language would be defined not only by a reader, but also by an evaluator
that showed how to interpret the expressions parsed by the reader.  Instead,
Ctax is just a surface syntax in a programming library -- interpretation
is up to the application.

Nevertheless, there is at least one particularly natural interpretation
for Ctax expressions.  That interpretation is defined by the Ctax
translator.  The Ctax translator maps Ctax syntax trees to Scheme syntax
trees.  Mostly, this translation is a matter of mapping C-style
flow-of-control and scoping operators to Scheme-style flow-of-control
and scoping operators.  Additionally, Ctax expressions are (trivially)
translated.

Ctax inherits all of C's expression operators.  The translator
translates these to calls to user-definable procedures and more than one
possible set of definitions is included in the ctax module.


@node  The Grammar of Ctax, Ctax Syntax Trees, Introduction -- A Standard Block-structured and Algebraic Syntax, Top
@chapter The Grammar of Ctax

This chapter describes the grammar of Ctax twice.  First informally, and
then as a grammar.

@menu
* What Ctax is Like::           
* What Ctax is Really Like::    
@end menu


@node  What Ctax is Like, What Ctax is Really Like, The Grammar of Ctax, The Grammar of Ctax
@section What Ctax is Like

From the broadest perspective, Ctax syntax is described by the "equation":

@example
Ctax = 
  (C syntax) 
- CPP
- (type declarations)
+ (Scheme constants)
+ (extended identifiers)
+ (C++ comments)
+ (The $ operator)
+ (Top-level statements);
@end example



@menu
* Identifiers::                 
* Constants::                   
* Expressions::                 
* Statements::                  
* Declarations::                
* Commands::                    
@end menu

@node  Identifiers, Constants, What Ctax is Like, What Ctax is Like
@subsection Identifiers

The set of ctax identifiers is the same as the set of C identifiers.

@example
x
y
foo_bar
@end example

In addition, the full range of Scheme identifiers is available in Ctax
though identifiers which are not also C identifiers must be quoted with
an initial backslash:

@example
\list-ref(x);
x = \list-ref;
@end example

Be careful to use enough whitespace when using Scheme-style identifiers 
in expressions.   For example:

@example
\some-number+1
@end example

names the variable @code{some-number+1}, while

@example
\some-number + 1
@end example

adds @code{some-number} to 1.  Like Scheme, symbols are terminated by
whitespace and by the characters @code{(} and @code{)}.  Unlike Scheme,
extended-syntax symbols in Ctax are terminated by comma (@code{,}) as
well.

Using C-style identifiers, whitespace is not so significant:

@example
x+1
@end example

is an addition expression, adding 1 to @code{x}.

Identifiers always refer to variables from the lexical environment.


@node  Constants, Expressions, Identifiers, What Ctax is Like
@subsection Constants

Ctax supports ordinary numeric and string constants:

@example
10
1000000000000000000
"hello world\n"
@end example

character constants, using C syntax:

@example
'a'
'\n'
'\001'
@end example


quoted symbols:

@example
'a
'list-ref
@end example

and quoted Scheme lists:

@example
'(a b (c d) (long-identifier foo) ...)
@end example

There is a slight lexical ambiguity because a character constant like:

@example
'a'
@end example

could be read as a quoted symbol, @code{a}, followed by a single quote.
The disambiguating rule is that if it looks like a character constant,
it is.


@node  Expressions, Statements, Constants, What Ctax is Like
@subsection Expressions

Ctax expressions resemble C expressions.  There are function calls:

@example
cos (x)
@end example

algebraic expresions:

@example
cos (x) * 2
a ? b : c
@end example

assignment expressions:

@example
a = 3
a++
++a
a += 10
@end example

and comma expressions:

@example
a += 10, b += 4
@end example

Ctax supports lambda expressions:

@example
lambda (a, b) @{ return a * b; @}
@end example

In the middle of Ctax, you can embed an expression written in s-exp Scheme
by using the @code{#} operator:

@example
x * #(some-scheme-expression ...)
@end example

In Scheme, keywords are passed just like normal arguments, but by
convention, we think of them as sometimes being associated with the
parameter that follows.  For example, (in Scheme):

@example
(make-frob 'acme-style :color 'red :noise 'feep)
@end example

The keyword @code{:color} is modified by the parameter @code{'red} and
the keyword @code{:noise} is modified by @code{'feep}.  In Ctax, keyword
arguments like those need not be followed by a comma in an argument
list:

@example
make-frob ('acme-style, :color 'red, :noise 'feep)
@end example

Ctax has one operator that C lacks: @dfn{dollar} (@code{$}).  Dollar is
a prefix operator similar to @code{!} or @code{++}.  It is intended for
use in Ctax applications where there is some centrally significant,
application specific, unary mapping such as indexes to fields in awk,
or indexes to program arguments in shell scripts.

@example
puts ($(argc - 1));
@end example

@node  Statements, Declarations, Expressions, What Ctax is Like
@subsection Statements

Statements resemble C, too.  There are @code{for}, @code{do} and
@code{while} loops supporting @code{break} and @code{continue}.  There
are conditionals using @code{if} and @code{if ... else}.  There are
compound statements in which local variables can be defined.  There is a
@code{return} statement.  I have not yet, but plan to support labeled
loops and @code{break} and @code{continue} that take label arguments.  I
also plan to add @code{letrec}, @code{let*}, @code{let} and
@code{labeled let} blocks.

@example
public
foo(r)
@{
  auto x;
  x = #(a b r c d);
  return some-fn (:bar, 1, :baz, :foo r, 
                  '(dflj sdljf (sldkjf sdflkj)));
@}
@end example


Var-args functions can be defined using this syntax:

@example
public foo(first, ... rest) @{ ... @}
@end example

or

@example
public foo (... vargs) @{...@}
@end example


@node  Declarations, Commands, Statements, What Ctax is Like
@subsection Declarations

When declaring functions or variables, types need not be specified,
though eventually support will be added so that they may optionally be
specified.

Top level definitions must be declared either @code{static} or
@code{public}.  @code{static} definitions use the Scheme primitive
@code{define}, @code{public} use @code{define-public}.

Local variables are declared using the keyword @code{auto} as in:

@example
lambda (y) @{ auto x; x = y * y;  return cons (x, y); @}
@end example

A top-level assignment statement (outside of any function definiton)
acts like a static declaration.  Thus:

@example
x = 69;
@end example

is equivalent to:

@example
static x = 69;
@end example


@node  Commands,  , Declarations, What Ctax is Like
@subsection Commands

The ctax reader reads a complete "command" each time it is called.  A
command is either a function definition or variable declaration, or a
statement which is evaluated at global scope.



@node  What Ctax is Really Like,  , What Ctax is Like, The Grammar of Ctax
@section What Ctax is Really Like

This section presents the Ctax notation as a formal lexical language and
grammar.  The specifications printed here were derived from the source
code by (trivial) Scheme procedures that pretty-printed the data
structures that drive lexing and parsing.

Unfortunately, tools for automatically deriving the manual from the
source code are lacking and so the results have to be maintained by
hand.  If the manual seems to be out of date on some point, consult the
source code.

@menu
* The Lexical Syntax of Ctax::  
* Ctax Grammar::                
@end menu

@node  The Lexical Syntax of Ctax, Ctax Grammar, What Ctax is Really Like, What Ctax is Really Like
@subsection The Lexical Syntax of Ctax

@example

;; C++ style comments:
;;
//[^\n]*                                        ignored 

;; Whitespace is ignored:
;;
[ \t\n]\+                                       ignored 

;; Identifiers normally follow C syntax:
;;
[a-zA-Z_][a-zA-Z0-9_]*                          <identifier>

;; except when preceeded by a backslash:
;;
\\[a-z?!<>=0-9_-][a-z:?!<>=0-9_-]*              <identifier>

;; Ctax has keywords, which C does not.   Keywords have the
;; syntax of extended (Scheme-like) identifiers, but begin
;; with a colon:
;;
:[a-z?:!<>=0-9_-]\+                             <keyword>

;; Numbers
;;
[0-9]\+\.\?[0-9]*                               <constant>

;; String constants:
;;
\("\([^"\\]\|\\.\)*"\)                          <constant>

;; There are octal character constants:
;;
'\\0[0-7]?[0-7]?[0-7]?'                         <constant>  :shortest

;; Backslash-code character constants:
;;
'\\n'                                           <constant> :shortest
'\\t'                                           <constant> :shortest
'\\r'                                           <constant> :shortest

;; Character constants with an irrelevant backslash:
;;
'\\.'                                           <constant> :shortest

;; Normal character constants
;;
'.'                                             <constant> :shortest

;; If something begins with a single quote but doesn't look like a character
;; constant, it might be a quoted Scheme symbol name, or a quoted Scheme list.
;;
'[a-z?!<>=0-9_-][a-z:?!<>=0-9_-]*               <constant>

;; The lex spec only shows the opening paren of a quoted list but
;; if that much is read, the lexer reads the entire list.
;;
'(                                              <constant>
                        

;; Scheme backquote expressions can also be embedded in Ctax.
;; The spec only shows the backquote, but if that much is read,
;; the lexer reads the entire backquote expression.
;;
`                                               <constant>

;; A pound-sign can be followed by an arbitrary Scheme expression.
;; It is read using the Scheme procedure "read".   In a Ctax
;; program, this kind of literal can be embedded in the middle
;; of an expression.
;;
#                                               <literal>

;; With the exception of a few new keywrods, the rest of the grammar
is unremarkable:

@{                                              <lbrace> 
@}                                              <rbrace> 
;                                               <semi> 
\.\.\.                                          <...> 
lambda                                          <lambda> 
public                                          <public> 
static                                          <static> 
auto                                            <auto> 
if                                              <if> 
else                                            <else> 
for                                             <for> 
while                                           <while> 
return                                          <return> 
do                                              <do> 
break                                           <break> 
continue                                        <continue> 
,                                               <comma> 
=                                               <=> 
\*=                                             <assignment> 
/=                                              <assignment> 
%=                                              <assignment> 
+=                                              <assignment> 
-=                                              <assignment> 
>>=                                             <assignment> 
<<=                                             <assignment> 
&=                                              <assignment> 
\^=                                             <assignment> 
|=                                              <assignment> 
\?                                              <?> 
:                                               <colon> 
||                                              <flowor> 
&&                                              <flowand> 
|                                               <logor> 
&                                               <logand> 
\^                                              <logxor> 
==                                              <==> 
!=                                              <!=> 
>=                                              <>=> 
<=                                              <<=> 
<                                               <<> 
>                                               <>> 
<<                                              <<<> 
>>                                              <>>> 
+                                               <+> 
-                                               <-> 
\*                                              <*> 
/                                               </> 
%                                               <%> 
--                                              <--> 
++                                              <++> 
~                                               <lognot> 
!                                               <!> 
\[                                              <lbracket> 
\]                                              <rbracket> 
(                                               <lparen> 
)                                               <rparen> 
->                                              <arrow>
->*                                             <arrow*>
.                                               <dot>
.*                                              <dot*>
@end example


@node  Ctax Grammar,  , The Lexical Syntax of Ctax, What Ctax is Really Like
@subsection Ctax Grammar

@example
$cmd$ -> <static> <identifier> <lparen> $arg-list$ <rparen> $block$ 
       | <public> <identifier> <lparen> $arg-list$ <rparen> $block$ 
       | <public> <identifier> <=> $exp$ <semi> 
       | <static> <identifier> <=> $exp$ <semi> 
       | <public> <identifier> <semi> 
       | <static> <identifier> <semi> 
       | $statement$ 

$arg-list$ -> <...> <identifier> 
            | $id-list$ <comma> <...> <identifier> 
            | $id-list$ 
            | 

$id-list$ -> $id-list$ <comma> <identifier> 
           | <identifier> 

$block$ -> <lbrace> $declarations$ $statement-list$ <rbrace> 

$declarations$ -> $declarations$ $declaration$ 
                | 

$declaration$ -> <auto> <identifier> <semi> 
               | <auto> <identifier> <=> $exp$ <semi> 

$statement-list$ -> $statement-list$ $statement$ 
                  | 

$statement$ -> <if> <lparen> $exp$ <rparen> $statement$ 
             | <if> <lparen> $exp$ <rparen> $statement$ <else> $statement$ 
             | <while> <lparen> $exp$ <rparen> $statement$ 
             | <do> $statement$ <lparen> $exp$ <rparen> <semi> 
             | <for> <lparen> $exp$ <semi> $exp$ <semi> $exp$ <rparen> $statement$ 
             | <return> $exp$ <semi> 
             | <break> <semi> 
             | <continue> <semi> 
             | <semi> 
             | $exp$ <semi> 
             | <lbrace> $declarations$ $statement-list$ <rbrace> 

$exp$ -> $assignment-exp$ 
       | $exp$ <comma> $assignment-exp$ 

$assignment-exp$ -> $conditional-exp$ 
                  | $unary-exp$ <assignment> $assignment-exp$ 
                  | $unary-exp$ <=> $assignment-exp$ 

$conditional-exp$ -> $flow-or-exp$ 
                   | $flow-or-exp$ <?> $exp$ <colon> $conditional-exp$ 

$flow-or-exp$ -> $flow-and-exp$ 
               | $flow-or-exp$ <flowor> $flow-and-exp$ 

$flow-and-exp$ -> $logor-exp$ 
                | $flow-and-exp$ <flowand> $logor-exp$ 

$logor-exp$ -> $logxor-exp$ 
             | $logor-exp$ <logor> $logxor-exp$ 

$logxor-exp$ -> $logand-exp$ 
              | $logxor-exp$ <logxor> $logand-exp$ 

$logand-exp$ -> $equality-exp$ 
              | $logand-exp$ <logand> $equality-exp$ 

$equality-exp$ -> $relational-exp$ 
                | $equality-exp$ <==> $relational-exp$ 
                | $equality-exp$ <!=> $relational-exp$ 

$relational-exp$ -> $shift-exp$ 
                  | $relational-exp$ <<> $shift-exp$ 
                  | $relational-exp$ <>> $shift-exp$ 
                  | $relational-exp$ <<=> $shift-exp$ 
                  | $relational-exp$ <>=> $shift-exp$ 

$shift-exp$ -> $additive-exp$ 
             | $shift-exp$ <<<> $additive-exp$ 
             | $shift-exp$ <>>> $additive-exp$ 

$additive-exp$ -> $multiplicative-exp$ 
                | $additive-exp$ <+> $multiplicative-exp$ 
                | $additive-exp$ <-> $multiplicative-exp$ 

$multiplicative-exp$ -> $cm-exp$ 
                      | $multiplicative-exp$ <*> $cm-exp$ 
                      | $multiplicative-exp$ </> $cm-exp$ 
                      | $multiplicative-exp$ <%> $cm-exp$ 

$cm-exp$ -> $unary-exp$
          | $cm-exp$ <arrow*> $unary-exp$
          | $cm-exp$ <dot*> $unary-exp$

$unary-exp$ -> $postfix-exp$ 
             | <dollar> $unary-exp$ 
             | <++> $unary-exp$ 
             | <--> $unary-exp$ 
             | <-> $unary-exp$ 
             | <!> $unary-exp$ 
             | <lognot> $unary-exp$ 

$postfix-exp$ -> $primary-exp$ 
               | $postfix-exp$ <lbracket> $exp$ <rbracket> 
               | $postfix-exp$ <lparen> $opt-exp-list$ <rparen> 
               | $postfix-exp$ <++> 
               | $postfix-exp$ <--> 

$exp-list$ -> $assignment-exp$ 
            | <keyword> 
            | <keyword> $assignment-exp$ 
            | $exp-list$ <comma> $assignment-exp$ 
            | $exp-list$ <comma> <keyword> 
            | $exp-list$ <comma> <keyword> $assignment-exp$ 

$opt-exp-list$ -> $exp-list$ 
                | 

$primary-exp$ -> <identifier> 
               | <number> 
               | <constant> 
               | <lparen> $exp$ <rparen> 
               | <literal> 
               | <keyword> 
               | <quasi-constant> 
               | <lambda> <lparen> $arg-list$ <rparen> <lbrace> $declarations$ $statement-list$ <rbrace> 
@end example

@node  Ctax Syntax Trees, Translating Ctax to Scheme, The Grammar of Ctax, Top
@chapter Ctax Syntax Trees

The best way to see what syntax trees are returned for particular
constructs in the Ctax grammar is to read the parser code (it is quite
simple).  See the file @file{ctax/grammar.scm} in the distribution that
includes this manual.

@node  Translating Ctax to Scheme, Ctax Operators, Ctax Syntax Trees, Top
@chapter Translating Ctax to Scheme

The basic interface for translating Ctax to Scheme consists of
one procedure and one macro:

@deffn Function translate-ctax-statement stmt
@deffnx Macro ctax-statement stmt
Convert a Ctax syntax tree to executable Scheme code.

The procedure @code{translate-ctax-statement} returns the translated
Scheme expressions.   

The macro, @code{ctax-statement}, is a trivial wrapper for
@code{translate-ctax-statement}.  The macro allows Ctax syntax trees to
be passed to Scheme @code{eval} because the compiler makes translations
like:

@example
public 
addem (a, b, c)
@{
   return a + b + c;
@}

=>

(define-public addem (ctax-statment (ctax-lambda (a b c) () ((ctax-+ a b c)))))
@end example

and 

@example
addem (1, 2, 3);

=>

(ctax-statment (ctax-apply addem (1 2 3)))
@end example
@end deffn




@node  Ctax Operators, A Ctax Example, Translating Ctax to Scheme, Top
@chapter Ctax Operators

Users are given the opportunity to redefine any operator in the Ctax
language.  Every operator corresponds to a conventionally named Scheme
procedure that can be redefined in the usual way.

For example, the translation of:

@example
a + b * c
@end example

is 

@example
(ctax-+ a (ctax-* b c))
@end example

@code{ctax-+} and @code{ctax-*} can be defined however you like.

Some implementations of the Ctax operators are provided in this
distribution.

@menu
* C ops::                       
* hashtables::                  
* Scheme ops::                  
@end menu

@node  C ops, hashtables, Ctax Operators, Ctax Operators
@section C ops

@example
:use-module #/ctax/c-ops
@end example

The @file{c-ops} module defines the Ctax operators to be
similar to those of the C programming language.

Arithmetic operators, such as @code{ctax-+} and @code{ctax-/} are
implemented by the corresponding Scheme function (such as @code{+} or
@code{/}).

Array subscripting (@code{ctax-array-ref} and @code{ctax-array-set!})
is defined to work on both vectors and strings.

@code{ctax-test} which is implicitly applied to all conditional
expressions (as in @code{if (exp) ...}) reduces all values to 
@code{#t} except for @code{#f} and @code{0}, which are reduced
to @code{#f}.


@node  hashtables, Scheme ops, C ops, Ctax Operators
@section hashtables

@example
:use-module #/ctax/hashtabs
@end example

The @file{hashtabs} module doesn't define all ctax-operators,
only @code{ctax-array-ref} and @code{ctax-array-set!}.   These
operators are defined to work both on vectors and associative mappings
as defined by the module @code{#/ice-9/mapping}

@node  Scheme ops,  , hashtables, Ctax Operators
@section Scheme ops

@example
:use-module #/ctax/scm-ops
@end example


The @file{c-ops} module defines the Ctax operators to be
similar to those of Scheme.

Arithmetic operators, such as @code{ctax-+} and @code{ctax-/} are
implemented by the corresponding Scheme function (such as @code{+} or
@code{/}).

Array subscripting (@code{ctax-array-ref} and @code{ctax-array-set!})
is defined to work on vectors only.

@code{ctax-test} which is implicitly applied to all conditional
expressions (as in @code{if (exp) ...}) reduces all values to 
@code{#t} except for @code{#f}.   Unlike the @file{c-ops} version
of @code{ctax-test}, this version reduces @code{0} to @code{#t}.


@node  A Ctax Example,  , Ctax Operators, Top
@chapter A Ctax Example

@example
\define-module (#(example),
		:use-module #(ice-9 mapping),
		:use-module #(ctax macros),
		:use-module #(ctax hashtabs),
		:use-module #(ctax cops));

static table = hash_table ();
static table2 = hash_table (:hash-proc hashq);

public
register (key, value)
@{
  table[key] = value;
  table2[key] = value;
  return value;
@}


public
check (key)
@{
  return table[key];
@}

public
check2 (key)
@{
  return table2[key];
@}


x = '(a b . c);

register (x, "hello world");

write (check (x));
newline ();
write (check2 (x));
newline ();
write (check ('(a b . c)));
newline ();
write (check2 ('(a b . c)));
newline ();

@end example

@bye

