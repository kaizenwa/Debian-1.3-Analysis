This is Info file in.info, produced by Makeinfo version 1.67 from the
input file in.texi.

INFO-DIR-SECTION Guile -- GNU extension language
START-INFO-DIR-ENTRY
* in: (in).                                     Ice-9.
END-INFO-DIR-ENTRY


File: in.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

  This file documents Ice 9, an operating system for Guile Scheme.

* Menu:

* Copying::
* About This Manual::
* What is Ice 9?::
* Calling Convention Preliminaries::
* Coroutines Using Runqs::
* Named Resources::
* Channels::
* Tcl Commands::
* Booting Ice 9::
* Tk Programming::
* The Gnotscope Window System::
* Famous Runqs::


File: in.info,  Node: Copying,  Next: About This Manual,  Prev: Top,  Up: Top

Copying
*******

                       Copyright (C) 1995, 1996

                    Free Software Foundation, Inc.

                675 Mass Ave, Cambridge, MA 02139, USA

Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

                              NO WARRANTY

BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


File: in.info,  Node: About This Manual,  Next: What is Ice 9?,  Prev: Copying,  Up: Top

About This Manual
*****************

  This manual describes a work-in-progress, but one that I think has
reached a point where it is reasonable (and arguably important) to begin
applying it to real-world problems.  You have to be pretty brave and
reasonably expert at Scheme to use Ice 9 at this point.  If you embark
on that course, expect to encounter difficulties - and please use those
difficulties to help refine the design direction of Ice 9!

  What stands to be gained by using Ice 9?  In spite of its being a
work-in-progress, I think Ice 9 is already a powerful tool with a clean,
flexible, extensible design.  I know that Ice 9 resembles the Scheme
programming environment *I've* wished(!) for for a long time - perhaps
*you* will like it too.

  This manual is itself a work-in-progress.  Large sections of it are,
as you will see, simply blank.  This deficiency is somewhat made-up-for
by the comments in the code - I've tried to make those pretty thorough
and eventually they'll be edited and reformated to complete this manual.

  I've lightly proof-read the manual, but haven't had time to carefully
review it.   Expect typos, errors, and confusing passeages.

  Expect spelling errors.  At this time there doesn't seem to be a
freely available on-line dictionary and so automatic spell-checking is
an impossibility for me.

  Ice-9 was developed on a machine running Linux 1.2.2 (really, I'll get
around to upgrading one of these days).  Only free software is used on
this machine.  When I stop to think about it, that fact amazes and
delights me.

  When I first became interested in programs with embedded lisp
dialects, it was because of GNU Emacs, the customizable,
self-documenting editor.  At the time, not much free software was
available and the idea of free software was foreign to many people.  I
learned about lisp, editors, user interfaces, and free software all in
the same breath; it changed my life and informed my choices about what
skills to develop and what goals to strive for.

  It is startling and exciting to look around now, roughly a decade
later, and see free software thriving so well that I can get by running
nothing else on the machine I use.  It is inspiring to observe so many
people agree that in areas where it competes with proprietary
solutions, free software is often the highest quality choice.

  It has been a real struggle and a constant challenge to be able to
continue learning and working long enough to reach this point, where I
can finally contribute back in the way I long hoped I could.  I'm not
mentioning this simply to valorize myself - although I admit to feeling
good about having stuck to it.  I'm mentioning it to thank certain
helpers I've had along the way who insisted on doing their good deeds in
a way that permitted no other form of ackowldgement than this.

  Thanks to T. and M. for the kind of help that without which - nothing.

  Finally, don't let all these "thanks" create the wrong impression.
This is the beginning, not the end.  With Ice 9, I'm finally ready to
get started.


File: in.info,  Node: What is Ice 9?,  Next: Calling Convention Preliminaries,  Prev: About This Manual,  Up: Top

What is Ice 9?
**************

  Ice 9 is the operating system for Guile Scheme.

  The operating system's job is to manage resources shared by multiple
Guile Scheme programs that might be loaded into a Guile instance.  It
should provide file system access, network access, scheduling
primitives, support for terminal and GUI programming, and other
libraries of commonly needed functionality.

  The implementation of Ice 9 was greatly simplified by the direction
taken by the Tcl/Tk team.  They've done an outstanding job providing
extremely portable C libraries for file system access, network access,
scheduling primitives, and GUI programming.  The goal of Ice 9 is
largely just to present their work with a Scheme-friendly interface.

  So just what is a Scheme-friendly interface to those capabilities?  Of
course, the answer can only be a matter of experience or opinion.  The
former is largely lacking at this point in time.  In forming opinions, I
tried to steal only the very best ideas: programming techniques from
SICP, operating system concepts from Plan 9 and the GNU hurd, GUI
techniques from lisp machine environments and so forth.  I've tried to
build it all up from very simple data structures and algorithms, because
I think this leads to a system that is small, comprehensible,
extensible, and parsimonious.

  But enough philosophizing, here's the manual.  Enjoy!


File: in.info,  Node: Calling Convention Preliminaries,  Next: Coroutines Using Runqs,  Prev: What is Ice 9?,  Up: Top

Calling Convention Preliminaries
********************************

  Key parts of Ice 9 are coded in Guile Scheme.

  Ice 9 makes heavy use of a few calling conventions that are layered on
top of ordinary Scheme procedure calls.  Some parts of Ice 9, for
example, use a message-passing style of object oriented programming.
Some parts of Ice 9 make heavy use of option arguments (flags that may
or may not occur in an argument list) and optional keyword arguments
(arguments that may or may not be present and that, if present, are
preceded by keyword that indicates their presense).  This chapter
documents the calling conventions that come up most often in Ice 9.

  The terminology in this chapter, "message", "object", "getters and
setters" and so forth is used throughout the manual.  Be careful to
note: I use terms like "message" and "object" as names for *ordinary
Scheme objects* like argument lists and procedures.  These names
emphasize how I am using the Scheme objects, but they do not imply that
we're using an "Object System" in which objects, messages, and method
invocations are disjoint in kind from ordinary Scheme data and
procedure calls.

* Menu:

* Message Passing::
* GET and SET messages::
* Keyword Arguments::
* Distributed Message Passing::


File: in.info,  Node: Message Passing,  Next: GET and SET messages,  Prev: Calling Convention Preliminaries,  Up: Calling Convention Preliminaries

Message Passing
===============

  In a number of places in Ice 9 a message-passing style of object
oriented programming is adopted.  In this style, objects are represented
by Scheme procedures and sending a message means calling a procedure.
All messages consist of a symbol in the first argument position,
followed by 0 or more message-specific arguments.  The symbol in the
first argument position is a "message selector":

     (some-object 'set :x-pos 12 :y-pos 32)
     (some-other-object 'print)

  Implementing a new object is easy.  Use something like:

     (define (make-some-kind-of-object . constructor-arguments)
        ... initialize the object's state ...
     
        ... bind methods to local names, e.g. "set-handler"
     
        ;; Return a dispatcher procedure for the new object:
        ;;
        (lambda (msg . args)
          (case msg
            ((get)		(apply get-handler args))
            ((set)		(apply set-handler args))
            ...
            (else		(apply throw 'not-understood msg args)))))

  When a message is received that isn't handled, throw a
`not-understood' error passing the message and its arguments to throw.
[This convention is new and not yet implemented everywhere.]

  One way to define new kinds of objects is in terms of older kinds of
objects using the technique of delegation.  In that case, don't handle
unrecognized messages by throwing an error, but by passing them along to
a delegate object.

  For example:

     (define (make-some-kind-of-object delegate-object . constructor-arguments)
        ... initialize and bind methods ...
     
        ;; Return a dispatcher procedure for the new object:
        ;;
        (lambda (msg . args)
          (case msg
            ((get)		(apply get-handler args))
            ((set)		(apply set-handler args))
            ...
     
     	;; Unhandled message are sent to the delegate.
     	;;
            (else		(apply delegate-object msg args)))))


File: in.info,  Node: GET and SET messages,  Next: Keyword Arguments,  Prev: Message Passing,  Up: Calling Convention Preliminaries

`get' and `set' messages
========================

  Many objects understand `get' and `set' messages.  These messages are
part of a sub-convention of message passing in general.  The
subconvention provides a generic interface to variable-like attributes
of objects.

  Each object variable is assigned a keyword for use with `get' and
`set'.  Messages are sent like:

     (object 'get :x-pos :y-pos) => (1 1)
     (object 'get :x-pos) => (1)
     (object 'get :x-pos :x-pos :x-pos) => (1 1 1)
     
     (object 'set :x-pos 1 :y-pos 1)

  Generally, `get' messages return a list of values but there is an
exception.  With no arguments, a get message returns a list of keywords
and values:

     (object 'get) => (:x-pos 1 :y-pos 1)

  The bi-modal convention for `get' may seem odd at first, but here are
two compelling idioms it supports:


     ;; This takes advantage of the convention for no-argument get messages:
     ;;
     (define saved-state (object 'get))
     (apply object 'set saved-state)
     
     ;; This takes advantage of the convention for get with arguments.
     ;; Note that (apply-args A B) == (apply B A)
     ;;
     (apply-args (object 'get :x-pos :y-pos)
     	    (lambda (x y)
     		 ...))

  For unrecognized keywords passed to `get' or `set', objects should
throw `unrecognized-field' passing the remaining keyword-value list (if
a setter) or the remaining keyword list (if a getter), including the
errant keyword at the head of that list. [This is a new convention, No
objects in the current release do this.]

  There are some macros to help implement getters and setters.

 - Syntax: with-getter-and-setter <VARS> PROC
     <VARS> is an unevaluated list of names that are bound in the
     caller.  PROC is a procedure.  When this form is evaluated, PROC
     is called this way:

          (proc getter setter)

     `getter' and `setter' are procedures used to access or modify
     <VARS>.  They take arguments of the sort that follow a `get' or
     `set' message selector.

     Here is an example:

          ;; make-point returns an object which is a point on the plane
          ;; and a color assigned to that point.  The object understands
          ;; get and set messages and a message, "draw", whose definition
          ;; isn't shown.  All three attributes of the object, x and y position
          ;; and color, can be queried or changed using get and set.
          ;;
          (define (make-point x-pos y-pos)
            (let ((color 'green))
              (with-getter-and-setter (x-pos y-pos color)
                 (lambda ((get set) msg . args)
          	  (case msg
          	     ((get)	(apply get args))
          	     ((set)	(apply set args))
          	     ((draw)    ....)
          	     (else	(apply throw 'not-understood msg args)))))))


 - Syntax: with-delegating-getter-and-setter <VARS> GET-DELEGATE
          SET-DELEGATE PROC
     This creates new getters and setters that delegate to old ones.

     <VARS> is an unevaluated list of names that are bound in the
     caller.

     GET-DELEGATE is a procedure used by the new getter to extend the
     set of gettable variables beyond just <VARS>.  The arguments to
     GET-DELEGATE follow the same convention as the arguments to a
     `get' message.

     SET-DELEGATE is procedure used by the new setter to extend the set
     of settable variables beyond just <VARS>.  The arguments to
     SET-DELEGATE follow the same convention as the arguments to a
     `set' message.

     PROC is a procedure that is called

          (proc getter setter)

     The GETTER and SETTER process the named <VARS> and use
     GET-DELEGATE and SET-DELEGATE to handle unrecognized keywords.

 - Syntax: with-configuration-getter-and-setter <VARS-ETC> PROC
     Create a getter and setter that can trigger arbitrary computation.

     <VARS-ETC> is a partially unevaluated list of variable specifiers,
     explained below.

     PROC is a procedure called, as usual:

          (proc getter setter)

     Each element of the <VARS-ETC> list is of the form:

          (<var> getter-hook setter-hook)

     Both hook elements are evaluated; the variable name is not.
     Either hook may be `#f' or procedure.

     A getter hook is a thunk that returns a value for the corresponding
     variable.  If `#f' is specified as the getter hook, then the
     lexical binding of `<var>' is returned from get messages querying
     this variable.  If a thunk is specified as the getter hook, then
     asking the getter about this variable will cause that thunk to be
     called and its return value will be returned as the variable value.

     A setter hook is a procedure of one argument that accepts a new
     value for the corresponding variable.  If omitted, the binding of
     <VAR> is simply set using SET!.

 - Syntax: let-configuration-getter-and-setter <VARS-ETC> PROC
     This procedure is like `with-configuration-getter-and-setter'
     (q.v.) except that each element of <VARS-ETC> is:

          (<var> initial-value getter-hook setter-hook)

     Unlike `with-configuration-getter-and-setter',
     `let-configuration-getter-and-setter' introduces bindings for the
     variables named in <vars-etc>.  It is short-hand for:

          (let ((<var1> initial-value-1)
                (<var2> initial-value-2)
                 ...)
            (with-configuration-getter-and-setter ((<var1> v1-get v1-set) ...) proc))


File: in.info,  Node: Keyword Arguments,  Next: Distributed Message Passing,  Prev: GET and SET messages,  Up: Calling Convention Preliminaries

Keyword Arguments
=================

  Guile Scheme has a type of self-evaluating object called a keyword.
The syntax of keywords is the same as that of symbols except that a
keyword must begin with a colon character (":").  (Correspondingly,
Guile Scheme symbol names normally do not begin with a colon.)

  In Ice 9, I almost always adhere to the convention that keywords are
used in argument lists to specify options and to tag optional arguments
when the number and meaning of the options and optional arguments is
potentially variable.  If that sounds confusing, just think about `get'
and `set' messages - they are examples of this convention:

     ;; Keywords used to specify options:
     ;;
     (some-obj 'get :x :y :z)
     
     
     ;; keywords used to tag optional arguments
     ;;
     (some-obj 'set :x 1 :z 10)
     (some-obj 'set :y 13)

  Another example is the way messages are sent to many Tk widget
commands:

     (some-canvas 'create 'oval 10 10 20 20 :fill red)

  Here is an example of where some of the keywords are used to specify
options that don't require arguments and others are used to tag optional
arguments:

     (make-gadget :persistant
                  :exported
                  :fill-factor 10)

  In that last example, there is the potential for ambiguity.  Are
`:persistant' and `:exported' two separate options with no arguments,
or one option (`:persistant') with an argument (`:exported')?

  To avoid such ambiguities, I use a coding convention:

  As a rule of thumb, never use keywords except as tags for optional
arguments or option specifiers.  In particular, keywords should never be
passed as keyword arguments.

  To help programmers write procedures that accept keyword arguments,
the following is provided:

 - Function: kw-arg-ref A-LIST A-KEY
     Return `(and (memq A-KEY A-LIST) (cdr (memq A-KEY A-LIST)))'.

     Here is an example showing one way `kw-arg-ref' can be used:

          (define (example-fun req-a req-b . optional-arguments)
            (let ((fill-factor (or (kw-arg-ref optional-arguments :fill-factor)
                                    default-fill-factor))
                  (chill-factor (or (kw-arg-ref optional-arguments :chill-factor)
                                    'garage-acid-jazz))
                  (persistant? (not (not (memq :persistant optional-arguments))))
                  (exported? (not (not (memq :exported optional-arguments)))))
              ...do stuff...))



File: in.info,  Node: Distributed Message Passing,  Prev: Keyword Arguments,  Up: Calling Convention Preliminaries

Distributed Message Passing
===========================

  A subset of the values encountered in Scheme programming have the
property that they can be read and written, yielding `equal?' values.
In some cases, writing and reading a value yields an `eq?' or `eqv?'.

  The calling conventions used in Guile are based on symbols and
keywords - objects which can be read and written yield `eq?' results.
*If you use these calling conventions, and are careful in choosing the
types of other arguments and return values*, then you can send messages
over network connections, store them in files, and otherwise transmit
them or receive them from outside of your process.

  Of course, it isn't practical to require that *every* message in the
system be distributable in this way - but it is something to keep in
mind as you write design new interfaces.  If you think you might
someday want to call the new interfaces remotely, choose the argument
and return types accordingly.


File: in.info,  Node: Coroutines Using Runqs,  Next: Named Resources,  Prev: Calling Convention Preliminaries,  Up: Top

Coroutines Using Runqs
**********************

  Ice 9 uses Scheme closures to represent flyweight coroutines.  I use
thunks (nullary procedures) and lists of thunks to represent "strips",
schedulable units of computation.  One strip runs at a time and
execution of the strips of many coroutines may be interleaved.

  By convention, the return value of a strip-thunk must either be
another strip or the value `#f'.  Returning the value `#f' from a strip
signals the termination of the coroutine that the strip is a part of.
Returning a strip from a strip signals that a coroutine is being
suspended and that calling the returned strip resumes the coroutine.

  There are two ways to suspend a coroutine - one is to return a single
thunk, which is the serial continuation of the coroutine; the other is
to return a list of thunks, in which case the coroutine forks into
multiple continuations.

  A "runq" is a procedure that manages a queue of strips.  Called with
no arguments, a runq processes one strip from the queue.  Called with
arguments, the arguments form a control message for the queue.  The
first argument of a control message is a symbol which is the message
selector; see *Note Message Passing::.

  A strip is processed this way:

   * If the strip is a thunk, the thunk is called - if it returns a
     strip, that strip is added back to the queue.

   * To process a strip which is a list of thunks, the CAR of that list
     is called.  After a call to that CAR, there are 0, 1, or 2 strips -
     perhaps one returned by the thunk, and perhaps the CDR of the
     original strip if that CDR is not nil.  The runq puts whichever of
     these strips exist back on the queue.

  The exact order in which strips are put back on the queue determines
the scheduling semantics of a particular queue - it's a parameter and
different kinds of queues do this different ways.  Another scheduling
parameter is the number of strips processed per nullary call to a runq.

  When a runq is called with no arguments, it process strips from its
queue.  How many strips are processed is up to the runq itself.  After
processing, if the queue is not empty, the runq procedure returns
*itself*.  If the queue is empty, the runq returns `#f'.  This
convention is important: it means that a runq procedure is itself a
coroutine (consisting of strip that sometimes iterates).

  In addition to being a useful thunk, runq procedures also accept
control messages.  The standard runq control messages are:

     'add! strip0 strip1...		;; to enqueue one or more strips
     'enqueue! strip0 strip1...	;; to enqueue one or more strips
     'push! strip0 ...		;; add strips to the front of the queue
     'empty?				;; true if it is
     'length				;; how many strips in the queue?
     'kill!				;; empty the queue
     else				;; throw 'not-understood

 - Function: make-void-runq
     Make a runq that discards all messages except "length", for which
     it returns 0.

 - Function: make-fair-runq
     Returns a runq procedure.  Called with no arguments, the procedure
     processes one strip from the queue.  Called with arguments, it
     uses runq-control.

     In a fair runq, if a strip returns a new strip X, X is added to
     the end of the queue, meaning it will be the last to execute of
     all the remaining procedures.

 - Function: make-exclusive-runq
     Returns a runq procedure.  Called with no arguments, the procedure
     processes one strip from the queue.  Called with arguments, it
     uses runq-control.

     In an exclusive runq, if a strip W returns a new strip X, X is
     added to the front of the queue, meaning it will be the next to
     execute of all the remaining procedures.

     An exception to this occurs if W was the CAR of a list of strips.
     In that case, after the return value of W is pushed onto the front
     of the queue, the CDR of the list of strips is pushed in front of
     that (if the CDR is not nil).   This way, the rest of the thunks
     in the list that contained W have priority over the return value
     of W.

 - Function: make-subordinate-runq-to SUPERIOR BASIC-INFERIOR
     Returns a runq proxy for the runq basic-inferior.

     The proxy forwards all calls to the BASIC-INFERIOR.  After each
     control message to the inferior runq, the proxy examines the
     length of the queue.   On a transition from 0 to 1, the proxy adds
     a coroutine to the superior runq.  On a transition from 1 to 0,
     that coroutine is removed.  Each time a strip of the coroutine is
     called, `N' strips are processed on the BASIC-INFERIOR where `N'
     is the length of the BASIC-INFERIOR before any strips have been
     processed.

     [Endless scheduling variations are possible on this basic idea.]

 - Function: fork-strips . STRIPS
     Return a strip that starts several strips in parallel.   If this
     strip is enqueued on a fair runq, strips of the parallel subtasks
     will run round-robin style.

 - Function: strip-sequence . STRIPS
     Returns a new strip which is the concatenation of the argument
     strips.  Each coroutine in the concatenation runs to completion
     and then triggers the beginning of the next.

 - Function: fair-strip-subtask . STRIPS
     Returns a new strip which is the synchronos, fair, parallel
     execution of the argument strips.

     Each argument is a coroutine and strips of these coroutines are
     multiplexed by the single coroutine returned by
     `fair-strip-subtask'.

  You might be wondering what it is that calls a runq to process strips
- that is, how does Ice 9 itself schedule coroutines.  The coroutine
facility, documented in this section, is completely independent of the
scheduling conventions of Ice 9.  The specific runq objects maintained
by Ice 9 are, accordingly, documented elsewhere; see *Note Famous
Runqs::.


File: in.info,  Node: Named Resources,  Next: Channels,  Prev: Coroutines Using Runqs,  Up: Top

Named Resources
***************

  Ice-9 maintains a hierarchical namespace reminiscent of a unix
file-system or the URL namespace.

  At any one time, the root of this namespace is the current module.
Names in the root are the top-level variable names and, of course,
names in the root are bound to the values of the variables.

  If a variable is bound to a module, then that module is a
"subdirectory".  Subdirectories may be nested arbitrarily, therefore,
names in the hierarchical namespace are conveniently represented as
lists of symbols.  For example,

     '(app frames system-monitor)

  is a name for the variable called `system-monitor' as bound in a
module stored in the variable called `frames' in another module, which
is itself stored in a variable called `app' in the top-level module.

  Programs can extend the namespace by creating new modules and binding
variables in ordinary ways (see the Guile reference manual to learn more
about modules and variables).  Programs can create virtual modules
(modules in which some of the bindings are create on-demand by a
"lazy-binder" procedure) in order to create directories with special
semantics.

  A convenient syntax is provided for writing lists of symbols: the
`#/' syntax.  This syntax is useful for emphasizing that a list of
symbols is being used as a name in the hierarchical name-space.  Don't
be confused: this syntax still denotes an ordinary list of symbols:

     #/a/list/of/symbols == (a list of symbols)
     
     ;; So for example, you can do weird things.  Here is an unlikely
     ;; way to apply the procedure "list" to three math primitives:
     ;;
     #/list/+/-/*
     => (#<primitive-procedure +> #<primitive-procedure -> #<primitive-procedure *>)
     
     ;; Normally, #/ lists are explicitly quoted:
     ;;
     '#/a/typical/hierarchicy/name
     => '(a typical hierarchicy name)

  The current module is the root of the named-resource hierarchy.  One
element names refer to top-level bindings.  For example, the name
`#/list' refers to the same binding as the variable name `list'.  The
only zero-element name, `#/' a.k.a. `()', is a name for the current
module.

  By convention, the `(current-module)' should always have a binding
for a variable named `app'.  That binding should be to a module.
`#/app' is the "system directory" in which Ice 9 itself defines names.
Other branches of the hierarchy (siblings of `app') are available for
programs to use as they see fit.  A default `app' directory is
constructed at start-up time and installed in the "the root module"
from which it is inherited by most interactive top levels.  It is
probably a mistake for programs to try to create a private `#/app'.
(Incidently, don't confuse "the root module", which is what I call the
top-level that contains all of Guile Scheme's built-in functions and
variables with the root of the resource namespace.  Sometimes they are
the one in the same, but not always).

  The following examples may help to make the structure of the
namespace a little clearer and to introduce the basic procedures for
accessing the namespace.  The Guile reference manual can provide more
details about modules and variables and some of the procedures
illustrated here.

     ;;; A hypothetical Guile session.
     ;;;
     
     guile> (current-module)			; current-module is also the "root".
     #<module the-root-module 20e550>
     
     ;; local-ref looks up a node in the hierarchical namespace and returns
     ;; that node.  For a "directory", that means returning the module that
     ;; represents the directory:
     ;;
     
     guile> (local-ref '#/)			; look up the root
     #<module the-root-module 20e550>
     
     guile> (local-ref '#/+)			; look up a non-directory
     #<primitive-procedure +>
     
     ;; Always true:
     guile> (eq? (current-module) (local-ref '#/))
     #t
     
     
     ;; ls is a procedure that returns a list of directory contents.
     ;; Naturally, the root directory, doubling as an interactive top level,
     ;; has many bindings:
     ;;
     guile> (ls '#/)
     (cons car cdr caar cadr + - * / [..many names omitted..] )
     
     
     ;; Modules bound to variables serve as subdirectories:
     ;;
     guile> app
     #<module 20f548>
     
     guile> (local-ref '#/app)
     #<module 20f548>
     
     ;; App is a "system directory" containing, (among other things)
     ;; a directory of all source modules that have been loaded.
     ;;
     guile> (ls '#/app)
     (display-cmds frames modules)
     
     ;; The special directory "modules" is the root of the namespace
     ;; of modules.   One module of interest is the module that defines
     ;; ls, namely #/utils/tree:
     ;;
     guile> (ls '#/app/modules)
     (guile utils)
     
     guile> (ls '#/app/modules/utils)
     (tree)
     
     ;; Take a look at what is defined in the module #/utils/tree:
     ;;
     guile> (ls '#/app/modules/utils/tree)
     (defined? eval-load zero? [....] nthcdr)	;; a huge top-level
     
     ;; Oops, I really only want to know what is *locally* defined
     ;; in the tree module -- excluding the definitions inherited
     ;; from the root module.   So, use "lls" -- local ls
     ;; to discover that the tree module only provides a few new
     ;; definitions:
     ;;
     
     guile> (lls '#/app/modules/utils/tree)
     (definitions-in ls recursive-local-define
      local-definitions-in %module-public-interface lls)
     
     
     ;; Source modules use "define" and "define-public".  "define-public"
     ;; copies bindings into a designated public interface.   I
     ;; can use "ls" to see what definitions are exported by #/utils/tree:
     ;;
     guile> (ls '#/app/modules/utils/tree/%module-public-interface)
     (definitions-in ls recursive-local-define local-definitions-in lls)

 - Function: ls . VARIOUS-NAMES
     This procedure is inspired by the unix command `ls'.

     With just one argument, interpret that argument as the name of a
     subdirectory of the current module and return a list of names
     defined there.

     With more than one argument, still compute subdirectory lists, but
     return a list:

          ((<subdir-name> . <names-defined-there>)
           (<subdir-name> . <names-defined-there>)
           ...)

  Here is a further example of using `ls':

  To see what windows currently exist on the screen,

     guile> (ls '#/app/frames)
     (load-avg clock inspector<0> inspector)

  Subtrees of `#/app/modules' are often library modules or interactive
top levels.  As such, they may contain hundreds of definitions
including bindings for all of the built-in functions.  Other parts of
the name-space are sparser and more disciplined.  For example, each
frame is a directory with a few standard entries:

     guile> (ls '#/app/frames/inspector)
     (ctl panels)

  In the case of this example, `ctl' is bound to an object that
processes messages for the frame over-all while `panels' is a
subdirectory (i.e., panels is bound to a module) whose contents are
interfaces for the individually addressable sub-windows of the frame:

     guile> (ls '#/app/frames/inspector/panels)
     (panel88 panel79 panel70 panel62)
     
     guile> (ls '#/app/frames/inspector/panels/panel79)
     (ctl focus)
     
     ;;; etc.

  As a trivial example of using these names, a user might want to
change the background color of a particular panel:

     ((local-ref '#/app/frames/inspector/panels/panel79/ctl)
       'set :background 'black)

 - Function: lls . VARIOUS-NAMES
     `lls' is similar to `ls' except that while `ls' searches both a
     module and its use-list for bindings, `lls' searches only for
     bindings local to the module - it ignores the use-list.

  You can add to the namespace by creating new modules (subdirectories)
and binding them within the existing namespace.  For example:

     ;; Make a directory of doc-strings for spreadsheet functions:
     ;;
     (local-set! '#/app/doc/spreadsheet-functions (make-module 13))

  The technique just illustrated works to extend the namespace one-level
at a time, but sometimes it is convenient to define a new name several
levels past the current leaf nodes of the tree, filling in the missing
intermediate subdirectories with small bland modules.   This can be
done using:

 - Function: recursive-local-define NAME VALUE
     Bind NAME to VALUE in the recursive namespace, automatically
     generating subdirectories to hold NAME if they do not already
     exist.

  The virtual module facility of modules (see the Guile reference
manual) provides a mechanism for creating "magic" subtrees within the
namespace.  "magic" subtrees contain bindings that are computed
on-demand.  [The current lazy binding mechanism will soon be extended
to allow customization of other module primitives as well.  For
example, magic modules will be able to specially define the behavior of
map-module and therefore the output of `ls'.]

  It was said earlier that names in the hierarchical namespace are
usually lists of symbols.  Sometimes they are not; `local-define',
`local-set!', and `local-ref' accept names made up of arbitrary values.
Names which are not symbols are compared using `equal?'.  For example:

     (define basic-name 'example)
     (define backup-number 3)
     
     ;; Store a numbered backup.  Instead of using an extension like .~3~, I
     ;; construct the names for backups using "cons"
     ;;
     (local-define (append '#/app/gadgets/backups  (cons basic-name backup-number))
     	      previous-version)
     
     ;; Resulting in a namespace in which some of the names are not simply symbols:
     ;;
     (ls '#/app/gadgets/backups)
     => (ctl README (example . 0) (example . 1) (example . 2) (example . 3))

  By convention, make sure that all names you use can be printed using
`write' and read using `read' (yielding `eq?' objects for symbolic
names and `equal?' objects otherwise).

  Our namespace data structure can be summed up this way:

   * Modules are a dictionary mapping names to variables.   By binding
     variables within a module to other modules, a tree structure is
     created.  That tree of dictionaries is the namespace for all named
     resources in Ice 9.

   * Programmers can customize modules to supply local bindings
     on-demand or by inheritence from other modules.

   * The namespace is accessed by procedures like `local-ref',
     `local-set!', `ls', and `lls'.


File: in.info,  Node: Channels,  Next: Tcl Commands,  Prev: Named Resources,  Up: Top

Channels, Handlers, and Timers
******************************

  Ice 9 uses the portable buffered I/O layer of Tcl to provide a
substrate underlying Scheme ports.

  At this time, documentation for the Scheme channel functions is not
ready, but they  are easy to figure out by looking at:

   * `tcl7.5/doc/OpenFileChnl.3' - A Tcl man page concerning file
     channels.

   * `tcl7.5/doc/OpenTcp.3' - A Tcl man page concerning network
     connection channels.

   * `libguile/guile-tcl.c' - Source code implementing Scheme wrappers
     for the libtcl functions.

  Because the documentation is incomplete, and you'll need to do a
little work to understand the channels layer, perhaps I can offer some
incentive: this is great stuff!  The channel I/O layer provides a
platform independent (Macintosh, unix and Windows) interface to files
and network connections.  It is simple to use and quite general.

  Some work remains to be done to thoroughly unify ports and channels.
For now, you can create a port wrapper for a Tcl channel using this
function:

 - Function: %make-channel-port CHANNEL MODE
     Return a port that corresponds to the indicated channel.

     The port is create for reading or writing according to MODE which
     should be `"r"', `"w"', or `"rw"'.


File: in.info,  Node: Tcl Commands,  Next: Booting Ice 9,  Prev: Channels,  Up: Top

Tcl Commands
************

  This section of the documentation is not finished yet.

  It will explain how built-in functions defined as Tcl commands can be
called from Scheme.

  It will explain how new Tcl commands can be defined in Scheme.

  In lieu of documentation, try the comments in the code or some
examples.  Check out `ice-9/system.scm' and `ice-9/tcl-builtins.scm'.


File: in.info,  Node: Booting Ice 9,  Next: Tk Programming,  Prev: Tcl Commands,  Up: Top

Booting Ice 9
*************

  This section of the documentation is not finished yet.

  In lieu of documentation, check out the Tcl script `guile/gls.in'.
(Note that before it is installed, that file is processed by the
configure script and turned into `gls'.  It is installed as `gls1.0' or
whatever the current version number is.)  That script boots Guile in a
minimal way - still needed are boot scripts which handle command line
arguments.


File: in.info,  Node: Tk Programming,  Next: The Gnotscope Window System,  Prev: Booting Ice 9,  Up: Top

Tk Programming
**************

  This section of the documentation is not finished yet, but the
corresponding source is heavily commented and the manual will eventually
be just a reformatting of those comments.  Check out `ice-9/win.scm'.

  Here are a few highlights of what will eventually be documented:

   * Tcl/Tk programs run normally.

     This section is about how to do Tk programming from Scheme - it is
     a bit different from Tk programming in Tcl.  Ice-9 can also run
     Tcl/Tk programs.   The new conventions for widget programming in
     Scheme have no effect on Tcl/Tk - Tcl programs should run without
     modification under Ice-9.

   * Nice Scheme wrappers are provided for a few Tk widget types.

     A few widget types are picked and those are imported to Scheme.
     The rest are not used.  For example, I use text and canvas
     widgets, but not list widgets because they can be implemented
     using either texts or canvases.

   * Event bindings are changed

     Scheme programs don't use the Tcl command "bind".   Instead, Scheme
     programs use keymaps (defined in `win.scm').   Some nice things
     about keymaps are:

        - You can have more than one keymap and switch between them
          quickly.  I.e., your interface can have different "modes" of
          interpretation for input events.

        - Keymaps are a simple Scheme data structure.  You can write new
          functions that examine keymaps (e.g. for on-line help)
          without having to dive into the Tk C code.

        - Keymaps support prefix keys.   I.e., keymaps allow you to bind
          actions to multi-key input sequences.

        - Keymaps are easily extensible.   The keymap data structure is
          basically a dictionary (a module, actually).  It is easy to
          store new bindings in keymap dictionaries which don't effect
          input-event handling, but which can be reflected on by other
          subsystems (e.g. on-line help).

     Another difference with event bindings is the way arguments are
     supplied to interactively called procedures.  In Tcl, arguments
     are supplied by doing a string substitution (e.g., replacing "%x
     %y" with mouse coordinates in the text of the code bound to a
     mouse event).   In Scheme, arguments are passed in the usual way
     as ordinary parameters.   In Scheme, programmers use declarations
     (similar to the Emacs declaration `interactive') to say how
     arguments should be passed.

  The rest of this chapter is empty except for an outline to be filled
in later.

* Menu:

* Tk Dependencies::
* Initializing Tk::
* Window Paths and Procedures::
* Widget Constructors::
* Window System Events::
* Three Kinds of Events::
* Keymaps::
* call-with-keymapping::
* interact loops::
* interactive functions::
* Reading input events::


File: in.info,  Node: Tk Dependencies,  Next: Initializing Tk,  Prev: Tk Programming,  Up: Tk Programming

Tk Dependencies
===============


File: in.info,  Node: Initializing Tk,  Next: Window Paths and Procedures,  Prev: Tk Dependencies,  Up: Tk Programming

Initializing Tk
===============


File: in.info,  Node: Window Paths and Procedures,  Next: Widget Constructors,  Prev: Initializing Tk,  Up: Tk Programming

Window Paths and Procedures
===========================

  send_widget_message


File: in.info,  Node: Widget Constructors,  Next: Window System Events,  Prev: Window Paths and Procedures,  Up: Tk Programming

Widget Constructors
===================

  in general and specificly


File: in.info,  Node: Window System Events,  Next: Three Kinds of Events,  Prev: Widget Constructors,  Up: Tk Programming

Window System Events
====================

  in general locatives


File: in.info,  Node: Three Kinds of Events,  Next: Keymaps,  Prev: Window System Events,  Up: Tk Programming

Three Kinds of Events
=====================

* Menu:

* System Events::
* Input Events::
* Ignored Events::


File: in.info,  Node: System Events,  Next: Input Events,  Prev: Three Kinds of Events,  Up: Three Kinds of Events

System Events
-------------


File: in.info,  Node: Input Events,  Next: Ignored Events,  Prev: System Events,  Up: Three Kinds of Events

Input Events
------------


File: in.info,  Node: Ignored Events,  Prev: Input Events,  Up: Three Kinds of Events

Ignored Events
--------------


File: in.info,  Node: Keymaps,  Next: call-with-keymapping,  Prev: Three Kinds of Events,  Up: Tk Programming

Keymaps
=======


File: in.info,  Node: call-with-keymapping,  Next: interact loops,  Prev: Keymaps,  Up: Tk Programming

call-with-keymapping
====================


File: in.info,  Node: interact loops,  Next: interactive functions,  Prev: call-with-keymapping,  Up: Tk Programming

interact loops
==============

  background interact loops


File: in.info,  Node: interactive functions,  Next: Reading input events,  Prev: interact loops,  Up: Tk Programming

interactive functions
=====================


File: in.info,  Node: Reading input events,  Prev: interactive functions,  Up: Tk Programming

Reading input events
====================


File: in.info,  Node: The Gnotscope Window System,  Next: Famous Runqs,  Prev: Tk Programming,  Up: Top

The Gnotscope Window System
***************************

  This section of the documentation is not finished yet.

  The gnotscope window system is a windowing library, layered on top of
Tk, designed to simplify GUI programming, and eventually to make it
easier to write GUIs that run remotely (in a different thread, process
or machine) from the underlying application.

  Gnotscope provides generic management for top-level windows and a
geometry manager that subdivides those windows into resizable panels.
Gnotscope windows are mapped into the namespace under `#/app/frames'.

  Right now, gnotscope supports very basic text and canvas panels.  It
needs to be extended by writing editting modes for those panels, a
port-based interface to gnotscope overall, and a gnotscope server to
allow gnotscope to be driven remotely.


File: in.info,  Node: Famous Runqs,  Prev: The Gnotscope Window System,  Up: Top

Famous Runqs
************

  This section of the documentation is not finished yet, but the code is
reasonably commented.  Look for `idleq' and `blinkq' in `ice-9/win.scm'.

  As more experience is gained building applications, it seems likely to
me that more runqs will be added.



Tag Table:
Node: Top236
Node: Copying638
Node: About This Manual2444
Node: What is Ice 9?5601
Node: Calling Convention Preliminaries7104
Node: Message Passing8496
Node: GET and SET messages10608
Node: Keyword Arguments16193
Node: Distributed Message Passing18815
Node: Coroutines Using Runqs19905
Node: Named Resources25891
Node: Channels36462
Node: Tcl Commands37827
Node: Booting Ice 938294
Node: Tk Programming38833
Node: Tk Dependencies41789
Node: Initializing Tk41931
Node: Window Paths and Procedures42086
Node: Widget Constructors42292
Node: Window System Events42493
Node: Three Kinds of Events42685
Node: System Events42907
Node: Input Events43054
Node: Ignored Events43192
Node: Keymaps43312
Node: call-with-keymapping43442
Node: interact loops43591
Node: interactive functions43771
Node: Reading input events43936
Node: The Gnotscope Window System44076
Node: Famous Runqs45011

End Tag Table
