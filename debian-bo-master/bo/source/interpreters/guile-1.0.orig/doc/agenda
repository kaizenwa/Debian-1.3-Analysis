This is a list of crudely formed notes recording things that 
I think are desirable or necessary in future releases of Guile.
Some of these are clearly bugs (labeled BUG), others just ideas
for extensions or cleanups.

To make navigation easier from Emacs, items are separated by 
form-feed characters.


Guile should have an advice facility similar to elisp's.

Several people have suggested exposing procedure bodies and
environments which is a (complementary) good idea.




clean up the way error are signaled

error.c has too much code

the interface to argument type checking should permit the 
error routines to return a value to the caller of the errant
procedure (which is not quite restartable exceptions but has
the desirable property of those).



SCM uses check_config to make sure various parameters are set
sanely.  This is #if 0'ed in Guile -- don't remember why.
Sure, setting parameters is done by autoconf now but checking
them wouldn't hurt.




Support for extended character sets should be finished.

Ice-9 should provide a message database mechanism.



Look over asyncs.  as i recall, interrupts during transitions from
scheme to tcl and back may have race conditions and possibly there
are other snags too.


Speaking of asyncs, Here is a definiate

BUG:

The Scheme async code swoops in and discards the Tcl async handlers
while Scheme is running.   That's fine, but suppose an interrupt
comes in while a Tcl command is running (under Scheme) or while
some libtcl function (like tcl-do-one-event) is running.

In those cases the async gets flagged, but won't actually run until
flow reenters libguile (and crosses a polling point).  That's a bug.
a long-running tcl command or function should be interrupted in the
usual way, and the interrupt should be propogated to Scheme.

A symptom of this is that if you run gls and start up a background 
event loop handler, interrupts at the guile> prompt are delayed until
some X event arrives.

The fix is that Guile asyncs shouldn't simply replace the Tcl asyncs.




libguile/configure.in should not only find the Tcl/Tk sources, it 
should check that they are patched for Guile.


BUG

unhandled errors in file handlers, server connect procedures timer
handlers and the like confuse the C code.   guile-tcl.c should
use scm_catch to prevent this from happening (search for !!!).




Right now it is *mandatory* that you link with Tk, which is obviously
bogus.



Tools:

How about a pseudo pseudo-scientific visualizer?

Pull in drag and drop -- from blit?


I think it would be nicer to extract a Scheme interface to window
properties in Scheme and do D&D for X that way -- but a Tcl-command
interface may turn out more portably.  Hrmm.



Channels and ports:

The libtcl code for channels should support virtual channels -- this
looks like a small change to avoid calling the platform-specific
routines in a few places.

Virtual channels should be reflected into Scheme, of course.

What to do about ports?  The ability to peek one character and
(internally to the interpreter) unget one character is a poor match
for channels.  Other than that they could easily be the same.

The file port code from SCM should be factored out to a separate library
(it should become part of goonix).   That code is just an obstacle to 
porters to non-unix systems.



As much as I dislike menu bars, most people don't and I have to admit
to using them from time to time.    stdwin should have them, based
on the current keymap a la emacs.



stdwin should have toolbars too, also based on the current keymap.



Being a lisp window system, stdwin should have a mouse-help mode in
which moving the mouse updates a display that reports the behavior of
the mouse buttons clicked in various ways, chorded, and with various
modifier keys.



BUG

Modifiers are discarded for mouse events in low level event handling code (win.scm).


BUG

During a long key-sequence (i.e., involving prefix keys), the partially typed
sequence should be echoed back to the user.



BUG

weak-hash-table should be called weak-key-hash-table



BUG

Lazy-binder procedures for modules should be more general.


weak obarrays, similar to weak hash tables, should be provided.



BUG

gls doesn't pass command line arguments to scheme



A port interface to standard text windows is needed.   This involves
writing editting commands and a command-line mode to run on the 
stdwin side of the port.   The editting mode should work for
unstructured command lines as well as for S-exp structured command lines.

A port interface to canvases is also desirable.



An I/O interface for flyweight threads is desirable.



A standard way to start up a new continuation thread is needed.  This
should include nice interfaces to block one continuation thread on i/o
while others run (including per-thread pseudo-"select" a la pthreads).


BUG

The gls script doesn't pass command line arguments to Scheme, which doesn't
look for them either!



try ilustrated build commands 
postcript docs



how about on-line documentation?   

this is planned and implementation is underway.
its a bit complicated to explain here, though.



asyncs aren't documented

init mechanism for plugins


maybe use sed to identify init procedures in libguile and plugins
and to derive "libguile.h"


nm for modules: examine source and report the free variables



defvar?



BUG: 

read-sharp not automatically used by read


BUG
unif.c in scm_uniform_array_read_x assumes stdio file ports
(unif.c generally bogus)



HMM

make read-only-ness orthogonal to substring-ness?
	read-only substrs of read only strings can be 
	made private strings at the systems discretion

	writable substrs make i/o buffers easier to write






In Guile, symbols with strange names have a special readable print
syntax.  Though, it might be regarded as a bug that the symbol gets
displayed as #{...} both during displaying and writing...

/mdj

