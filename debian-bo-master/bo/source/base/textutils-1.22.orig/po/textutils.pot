# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR Free Software Foundation, Inc.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 1997-01-26 20:32-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: ENCODING\n"

#: src/cat.c:81 src/cksum.c:264 src/comm.c:64 src/csplit.c:1557 src/cut.c:193
#: src/expand.c:111 src/fmt.c:281 src/fold.c:80 src/head.c:84 src/join.c:167
#: src/md5sum.c:100 src/nl.c:190 src/od.c:327 src/paste.c:409 src/pr.c:2411
#: src/sort.c:209 src/split.c:97 src/sum.c:59 src/tac.c:129 src/tail.c:154
#: src/tr.c:354 src/unexpand.c:369 src/uniq.c:110 src/wc.c:70
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr ""

#: src/cat.c:85
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr ""

#: src/cat.c:89
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/cat.c:107 src/cksum.c:278 src/comm.c:81 src/csplit.c:1588 src/cut.c:223
#: src/expand.c:131 src/fmt.c:302 src/fold.c:96 src/head.c:108 src/join.c:201
#: src/md5sum.c:126 src/nl.c:232 src/od.c:391 src/paste.c:428 src/pr.c:2469
#: src/sort.c:249 src/split.c:120 src/sum.c:77 src/tac.c:147 src/tail.c:183
#: src/tr.c:416 src/unexpand.c:389 src/uniq.c:137 src/wc.c:88
msgid ""
"\n"
"Report bugs to textutils-bugs@gnu.ai.mit.edu"
msgstr ""

#: src/cat.c:167 src/cat.c:248 src/cat.c:301 src/cat.c:723 src/comm.c:209
#: src/cut.c:772 src/expand.c:399 src/fold.c:242 src/fold.c:329 src/head.c:179
#: src/head.c:207 src/head.c:382 src/join.c:892 src/md5sum.c:617 src/nl.c:632
#: src/od.c:1975 src/paste.c:495 src/pr.c:902 src/sort.c:393 src/tac.c:217
#: src/tac.c:684 src/tail.c:1139 src/tr.c:1703 src/tr.c:1950 src/tr.c:2058
#: src/tr.c:2065 src/unexpand.c:474
msgid "write error"
msgstr ""

#: src/cat.c:289
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr ""

#: src/cat.c:596 src/od.c:1182
msgid "standard output"
msgstr ""

#: src/cat.c:664
#, c-format
msgid "%s: input file is output file"
msgstr ""

#: src/cksum.c:268 src/cut.c:197 src/expand.c:115 src/fold.c:84 src/head.c:88
#: src/nl.c:194 src/paste.c:413 src/pr.c:2415 src/sort.c:213 src/sum.c:63
#: src/tac.c:133 src/tail.c:158 src/unexpand.c:373 src/wc.c:74
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr ""

#: src/cksum.c:272
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
"  --help      display this help and exit\n"
"  --version   output version information and exit\n"
msgstr ""

#: src/comm.c:68
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr ""

#: src/comm.c:72
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines unique to both files\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
msgstr ""

#: src/csplit.c:292 src/csplit.c:316 src/sort.c:286 src/sort.c:311
#: src/tac.c:192 src/tac.c:206
msgid "virtual memory exhausted"
msgstr ""

#: src/csplit.c:355 src/csplit.c:1546 src/sort.c:503 src/tac.c:484
#: src/tr.c:1652 src/tr.c:1749 src/tr.c:1793
msgid "read error"
msgstr ""

#: src/csplit.c:649
msgid "input disappeared"
msgstr ""

#: src/csplit.c:771 src/csplit.c:782
#, c-format
msgid "%s: line number out of range"
msgstr ""

#: src/csplit.c:807
#, c-format
msgid "%s: `%d': line number out of range"
msgstr ""

#: src/csplit.c:810 src/csplit.c:862
#, c-format
msgid " on repetition %d\n"
msgstr ""

#: src/csplit.c:858
#, c-format
msgid "%s: `%s': match not found"
msgstr ""

#: src/csplit.c:919 src/csplit.c:959 src/tac.c:324
msgid "error in regular expression search"
msgstr ""

#: src/csplit.c:1062
#, c-format
msgid "write error for `%s'"
msgstr ""

#: src/csplit.c:1130
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr ""

#: src/csplit.c:1134
#, c-format
msgid "%s: integer expected after `%c'"
msgstr ""

#: src/csplit.c:1154
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr ""

#: src/csplit.c:1165
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr ""

#: src/csplit.c:1192
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr ""

#: src/csplit.c:1211
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr ""

#: src/csplit.c:1245
#, c-format
msgid "%s: invalid pattern"
msgstr ""

#: src/csplit.c:1248
#, c-format
msgid "%s: line number must be greater than zero"
msgstr ""

#: src/csplit.c:1252
#, c-format
msgid "line number `%s' is smaller than preceding line number, %lu"
msgstr ""

#: src/csplit.c:1257
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr ""

#: src/csplit.c:1378
msgid "missing conversion specifier in suffix"
msgstr ""

#: src/csplit.c:1384
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr ""

#: src/csplit.c:1387
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr ""

#: src/csplit.c:1419
msgid "missing %% conversion specification in suffix"
msgstr ""

#: src/csplit.c:1422
msgid "too many %% conversion specifications in suffix"
msgstr ""

#: src/csplit.c:1501
#, c-format
msgid "%s: invalid number"
msgstr ""

#: src/csplit.c:1529
msgid "too few arguments"
msgstr ""

#: src/csplit.c:1561
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr ""

#: src/csplit.c:1565
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
"      --help                 display this help and exit\n"
"      --version              output version information and exit\n"
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""

#: src/cut.c:201
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
"  -f, --fields=LIST       output only these fields\n"
"  -n                      (ignored)\n"
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/cut.c:361 src/cut.c:392 src/cut.c:452
msgid "invalid byte or field list"
msgstr ""

#: src/cut.c:703 src/cut.c:712
msgid "only one type of list may be specified"
msgstr ""

#: src/cut.c:706
msgid "missing list of positions"
msgstr ""

#: src/cut.c:715
msgid "missing list of fields"
msgstr ""

#: src/cut.c:722
msgid "the delimiter must be a single character"
msgstr ""

#: src/cut.c:748
msgid "you must specify a list of bytes, characters, or fields"
msgstr ""

#: src/cut.c:751
msgid "a delimiter may be specified only when operating on fields"
msgstr ""

#: src/cut.c:754
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""

#: src/expand.c:119
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""

#: src/expand.c:172 src/unexpand.c:157
msgid "tab size contains an invalid character"
msgstr ""

#: src/expand.c:190 src/unexpand.c:175
msgid "tab size cannot be 0"
msgstr ""

#: src/expand.c:192 src/unexpand.c:177
msgid "tab sizes must be ascending"
msgstr ""

#: src/fmt.c:285
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr ""

#: src/fmt.c:286
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
"      --help                display this help and exit\n"
"      --version             output version information and exit\n"
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""

#: src/fmt.c:386 src/nl.c:511
#, c-format
msgid "invalid line number increment: `%s'"
msgstr ""

#: src/fold.c:88
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""

#: src/fold.c:301
#, c-format
msgid "invalid number of columns: `%s'"
msgstr ""

#: src/head.c:92
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
"If -VALUE is used as first OPTION, read -c VALUE when one of\n"
"multipliers bkm follows concatenated, else read -n VALUE.\n"
msgstr ""

#: src/head.c:229 src/md5sum.c:296 src/md5sum.c:620 src/od.c:980 src/od.c:1230
#: src/od.c:1303 src/od.c:1972 src/pr.c:900 src/pr.c:1083 src/pr.c:1205
#: src/tac.c:510 src/tac.c:514 src/tail.c:776 src/tail.c:784 src/tr.c:2068
msgid "standard input"
msgstr ""

#: src/head.c:309
#, c-format
msgid "unrecognized option `-%c'"
msgstr ""

#: src/head.c:338
#, c-format
msgid "invalid number `%s'"
msgstr ""

#: src/join.c:171
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr ""

#: src/join.c:175
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"      --help        display this help and exit\n"
"      --version     output version information and exit\n"
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""

#. `0' must be all alone -- no `.FIELD'.
#: src/join.c:670
#, c-format
msgid "invalid field specifier: `%s'"
msgstr ""

#: src/join.c:684 src/join.c:792 src/join.c:828
#, c-format
msgid "invalid field number: `%s'"
msgstr ""

#: src/join.c:697
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr ""

#: src/join.c:812
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr ""

#: src/join.c:821
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr ""

#: src/join.c:853
msgid "too many non-option arguments"
msgstr ""

#: src/join.c:871
msgid "too few non-option arguments"
msgstr ""

#: src/join.c:882
msgid "both files cannot be standard input"
msgstr ""

#: src/md5sum.c:104
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check MD5 checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --binary            read files in binary mode\n"
"  -c, --check             check MD5 sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated MD5 checksum lines\n"
"\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"The sums are computed as described in RFC 1321.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""

#: src/md5sum.c:340
#, c-format
msgid "%s: %lu: improperly formatted MD5 checksum line"
msgstr ""

#: src/md5sum.c:361
#, c-format
msgid "%s: FAILED open or read\n"
msgstr ""

#: src/md5sum.c:383
msgid "FAILED"
msgstr ""

#: src/md5sum.c:383
msgid "OK"
msgstr ""

#: src/md5sum.c:396
#, c-format
msgid "%s: read error"
msgstr ""

#. Warn if no tests are found.
#: src/md5sum.c:409
#, c-format
msgid "%s: no properly formatted MD5 checksum lines found"
msgstr ""

#: src/md5sum.c:422
#, c-format
msgid "WARNING: %d of %d listed %s could not be read\n"
msgstr ""

#: src/md5sum.c:425
msgid "file"
msgstr ""

#: src/md5sum.c:425
msgid "files"
msgstr ""

#: src/md5sum.c:431
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr ""

#: src/md5sum.c:434
msgid "checksum"
msgstr ""

#: src/md5sum.c:434
msgid "checksums"
msgstr ""

#: src/md5sum.c:507
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""

#: src/md5sum.c:515
msgid "the --string and --check options are mutually exclusive"
msgstr ""

#: src/md5sum.c:522
msgid "the --status option is meaningful only when verifying checksums"
msgstr ""

#: src/md5sum.c:529
msgid "the --warn option is meaningful only when verifying checksums"
msgstr ""

#: src/md5sum.c:537
msgid "no files may be specified when using --string"
msgstr ""

#: src/md5sum.c:556
msgid "only one argument may be specified when using --check"
msgstr ""

#: src/nl.c:198
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
"      --help                      display this help and exit\n"
"      --version                   output version information and exit\n"
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""

#: src/nl.c:501
#, c-format
msgid "invalid starting line number: `%s'"
msgstr ""

#: src/nl.c:524
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr ""

#: src/nl.c:538
#, c-format
msgid "invalid line number field width: `%s'"
msgstr ""

#: src/od.c:331
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""

#: src/od.c:336
msgid ""
"Write an unambiguous representation, octal bytes by default, of FILE\n"
"to standard output.  With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n"
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in pre-POSIX form\n"
"      --help                  display this help and exit\n"
"      --version               output version information and exit\n"
"\n"
"Pre-POSIX format specifications may be intermixed, they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""

#: src/od.c:363
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  -s without a\n"
"number implies 3.  -w without a number implies 32.  By default, od\n"
"uses -A o -t d2 -w 16.\n"
msgstr ""

#. The integer at P in S would overflow an unsigned long.
#. A digit string that long is sufficiently odd looking
#. that the following diagnostic is sufficient.
#: src/od.c:723 src/od.c:836
#, c-format
msgid "invalid type string `%s'"
msgstr ""

#: src/od.c:733
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""

#: src/od.c:846
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""

#: src/od.c:907
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr ""

#: src/od.c:1071
msgid "cannot skip past end of combined input"
msgstr ""

#: src/od.c:1371
msgid "old-style offset"
msgstr ""

#: src/od.c:1690
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""

#: src/od.c:1701
msgid "skip argument"
msgstr ""

#: src/od.c:1712
msgid "limit argument"
msgstr ""

#: src/od.c:1716
#, c-format
msgid ""
"specified number of bytes `%s' is larger than the maximum\n"
"representable value of type `long'"
msgstr ""

#: src/od.c:1727
msgid "minimum string length"
msgstr ""

#: src/od.c:1781
msgid "width specification"
msgstr ""

#: src/od.c:1805
msgid "no type may be specified when dumping strings"
msgstr ""

#: src/od.c:1850
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr ""

#: src/od.c:1871
msgid "in compatibility mode the last 2 arguments must be offsets"
msgstr ""

#: src/od.c:1878
msgid "in compatibility mode there may be no more than 3 arguments"
msgstr ""

#: src/od.c:1946
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr ""

#: src/od.c:1962
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr ""

#: src/paste.c:218
msgid "standard input is closed"
msgstr ""

#: src/paste.c:417
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
msgstr ""

#: src/pr.c:627
#, c-format
msgid "invalid range of page numbers: `%s'"
msgstr ""

#: src/pr.c:639
#, c-format
msgid "invalid starting page number: `%s'"
msgstr ""

#: src/pr.c:651
#, c-format
msgid "invalid ending page number: `%s'"
msgstr ""

#: src/pr.c:658
msgid "starting page number is larger than ending page number"
msgstr ""

#: src/pr.c:782
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr ""

#: src/pr.c:806
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr ""

#: src/pr.c:818
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr ""

#: src/pr.c:848
#, c-format
msgid "`-w PAGE_WIDTH' invalid column number: `%s'"
msgstr ""

#: src/pr.c:869
msgid "Cannot specify number of columns when printing in parallel."
msgstr ""

#: src/pr.c:873
msgid "Cannot specify both printing across and printing in parallel."
msgstr ""

#: src/pr.c:926
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr ""

#: src/pr.c:1014
msgid "page width too narrow"
msgstr ""

#: src/pr.c:1418
#, c-format
msgid "%s%*s%s%*sPage"
msgstr ""

#: src/pr.c:2420
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
"  +FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN           produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
"  -a                print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c                use hat notation (^G) and octal backslash notation\n"
"  -d                double space the output\n"
"  -e[CHAR[WIDTH]]   expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f            use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -f or a 5-line header\n"
"                    and trailer without -f)\n"
"  -h HEADER         use a centered HEADER instead of filename in page "
"headers\n"
"                    with long headers left-hand-side truncation may occur\n"
"                    -h \"\" prints a blank line. Don't use -h\"\"\n"
"  -i[CHAR[WIDTH]]   replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -j                merge full lines, turns off -w line truncation, no "
"column\n"
"                    alignment, -s[STRING] sets separators\n"
"  -l PAGE_LENGTH    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, with -f 63)\n"
msgstr ""

#: src/pr.c:2444
msgid ""
"  -m                print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -j\n"
"  -n[SEP[DIGITS]]   number lines, use DIGITS (5) digits, then SEP (TAB)\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER         start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
"  -o MARGIN         offset each line with MARGIN spaces (do not affect -w)\n"
"  -r                inhibit warning when a file cannot be opened\n"
"  -s[STRING]        separate columns by an optional STRING\n"
"                    don't use -s \"STRING\" \n"
"                    without -s: default sep. 'space' used, same as -s\" \"\n"
"                    -s only: no separator used, same as -s\"\" \n"
"  -t                inhibit page headers and trailers\n"
"  -T                inhibit page headers and trailers, eliminate any page\n"
"                    layout by form feeds set in input files\n"
"  -v                use octal backslash notation\n"
"  -w PAGE_WIDTH     set page width to PAGE_WIDTH (72) columns, truncate\n"
"                    lines (see also -j option)\n"
"  --help            display this help and exit\n"
"  --version         output version information and exit\n"
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -f. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""

#: src/sort.c:217
#, c-format
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"  +POS1 [-POS2]    start a key at POS1, end it before POS2\n"
"  -b               ignore leading blanks in sort fields or keys\n"
"  -c               check if given files already sorted, do not sort\n"
"  -d               consider only [a-zA-Z0-9 ] characters in keys\n"
"  -f               fold lower case to upper case characters in keys\n"
"  -g               compare according to general numerical value, imply -b\n"
"  -i               consider only [\\040-\\0176] characters in keys\n"
"  -k POS1[,POS2]   same as +POS1 [-POS2], but all positions counted from 1\n"
"  -m               merge already sorted files, do not sort\n"
"  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n"
"  -n               compare according to string numerical value, imply -b\n"
"  -o FILE          write result on FILE instead of standard output\n"
"  -r               reverse the result of comparisons\n"
"  -s               stabilize sort by disabling last resort comparison\n"
"  -t SEP           use SEParator instead of non- to whitespace transition\n"
"  -T DIRECT        use DIRECT for temporary files, not $TMPDIR or %s\n"
"  -u               with -c, check for strict ordering;\n"
"                   with -m, only output the first of an equal sequence\n"
"  -z               end lines with 0 byte, not newline, for find -print0\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character\n"
"position in the field, both counted from zero.  OPTS is made up of one\n"
"or more of Mbdfinr, this effectively disable global -Mbdfinr settings\n"
"for that key.  If no key given, use the entire line as key.  With no\n"
"FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/sort.c:372
msgid "flushing file"
msgstr ""

#: src/sort.c:381
msgid "error closing file"
msgstr ""

#: src/sort.c:1505
#, c-format
msgid "%s: disorder on %s\n"
msgstr ""

#: src/sort.c:1638
#, c-format
msgid "invalid field specification `%s'"
msgstr ""

#. Provoke with `sort -9'.
#: src/sort.c:1814
msgid ""
"when using the old-style +POS and -POS key specifiers,\n"
"the +POS specifier must come first"
msgstr ""

#: src/sort.c:1850
msgid "option `-k' requires an argument"
msgstr ""

#. Provoke with `sort -k0'
#: src/sort.c:1867
msgid "the starting field number argument to the `-k' option must be positive"
msgstr ""

#. Provoke with `sort -k1.'
#: src/sort.c:1878
msgid "starting field spec has `.' but lacks following character offset"
msgstr ""

#. Provoke with `sort -k1.0'
#: src/sort.c:1887
msgid ""
"starting field character offset argument to the `-k' option\n"
"must be positive"
msgstr ""

#. Provoke with `sort -k1,'
#: src/sort.c:1915
msgid "field specification has `,' but lacks following field spec"
msgstr ""

#. Provoke with `sort -k1,0'
#: src/sort.c:1925
msgid "ending field number argument to the `-k' option must be positive"
msgstr ""

#. Provoke with `sort -k1,1.'
#: src/sort.c:1936
msgid "ending field spec has `.' but lacks following character offset"
msgstr ""

#: src/sort.c:1967
msgid "option `-o' requires an argument"
msgstr ""

#: src/sort.c:1985
msgid "option `-t' requires an argument"
msgstr ""

#: src/sort.c:1996
msgid "option `-T' requires an argument"
msgstr ""

#: src/sort.c:2011
#, c-format
msgid "%s: unrecognized option `-%c'\n"
msgstr ""

#: src/sort.c:2137 src/sort.c:2142
#, c-format
msgid "%s: write error"
msgstr ""

#: src/split.c:101
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr ""

#: src/split.c:105
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
"  -NUMBER                 same as -l NUMBER\n"
"      --verbose           print a diagnostic to standard error just\n"
"\t\t\t    before each output file is opened\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""

#: src/split.c:181
#, c-format
msgid "creating file `%s'\n"
msgstr ""

#: src/split.c:397 src/split.c:413 src/split.c:429 src/split.c:455
msgid "cannot split in more than one way"
msgstr ""

#: src/split.c:404 src/split.c:437
#, c-format
msgid "%s: invalid number of bytes"
msgstr ""

#: src/split.c:420
#, c-format
msgid "%s: invalid number of lines"
msgstr ""

#: src/split.c:492
msgid "invalid number"
msgstr ""

#: src/split.c:507 src/tr.c:1891
msgid "too many arguments"
msgstr ""

#: src/sum.c:67
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/tac.c:137
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
msgstr ""

#: src/tac.c:616
msgid "separator cannot be empty"
msgstr ""

#: src/tail.c:162
msgid ""
"Print last 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -c, --bytes=N            output the last N bytes\n"
"  -f, --follow             output appended data as the file grows\n"
"  -n, --lines=N            output the last N lines, instead of last 10\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -v, --verbose            always output headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
"or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
"the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
"or -c +VALUE.\n"
msgstr ""

#: src/tail.c:615
msgid "file truncated"
msgstr ""

#: src/tail.c:790
msgid "standard input: cannot follow end of non-regular file"
msgstr ""

#: src/tail.c:827
#, c-format
msgid "%s: cannot follow end of non-regular file"
msgstr ""

#: src/tail.c:938
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr ""

#: src/tail.c:968 src/tail.c:1026
#, c-format
msgid "%s: `%s' is so large that it is not representable"
msgstr ""

#: src/tail.c:969 src/tail.c:1028
msgid "number of lines"
msgstr ""

#: src/tail.c:969 src/tail.c:1028
msgid "number of bytes"
msgstr ""

#: src/tail.c:1020
msgid "invalid number of lines"
msgstr ""

#: src/tail.c:1021
msgid "invalid number of bytes"
msgstr ""

#: src/tr.c:358
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr ""

#: src/tr.c:362
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace sequence of characters with one\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
msgstr ""

#: src/tr.c:373
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR1-CHAR2]   same as CHAR1-CHAR2, if both SET1 and SET2 use this\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""

#: src/tr.c:405
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""

#. Any octal number larger than 0377 won't
#. fit in 8 bits.  So we stop when adding the
#. next digit would put us over the limit and
#. give a warning about the ambiguity.  POSIX
#. isn't clear on this, but one person has said
#. that in his interpretation, POSIX says tr
#. can't even give a warning.
#: src/tr.c:577
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""

#: src/tr.c:586
msgid "invalid backslash escape at end of string"
msgstr ""

#: src/tr.c:592
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr ""

#: src/tr.c:745
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr ""

#: src/tr.c:960
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr ""

#: src/tr.c:1066
#, c-format
msgid "invalid character class `%s'"
msgstr ""

#: src/tr.c:1091
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr ""

#: src/tr.c:1563
msgid "the [c*] repeat construct may not appear in string1"
msgstr ""

#: src/tr.c:1573
msgid "only one [c*] repeat construct may appear in string2"
msgstr ""

#: src/tr.c:1581
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr ""

#: src/tr.c:1594
msgid "when not truncating set1, string2 must be non-empty"
msgstr ""

#: src/tr.c:1603
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""

#: src/tr.c:1610
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""

#: src/tr.c:1619
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""

#: src/tr.c:1896
msgid "two strings must be given when translating"
msgstr ""

#: src/tr.c:1899
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr ""

#: src/tr.c:1913
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""

#: src/tr.c:1919
msgid "at least one string must be given when squeezing repeats"
msgstr ""

#: src/tr.c:2005
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr ""

#: src/tr.c:2028
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""

#: src/unexpand.c:377
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""

#: src/uniq.c:114
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""

#: src/uniq.c:118
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -w, --check-chars=N   compare no more than N characters in lines\n"
"  -N                    same as -f N\n"
"  +N                    same as -s N\n"
"      --help            display this help and exit\n"
"      --version         output version information and exit\n"
"\n"
"A field is a run of whitespace, than non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""

#: src/uniq.c:281
#, c-format
msgid "error reading %s"
msgstr ""

#: src/uniq.c:284
#, c-format
msgid "error writing %s"
msgstr ""

#: src/uniq.c:342
#, c-format
msgid "invalid number of fields to skip: `%s'"
msgstr ""

#: src/uniq.c:358
#, c-format
msgid "invalid number of bytes to skip: `%s'"
msgstr ""

#: src/uniq.c:374 src/uniq.c:405
#, c-format
msgid "invalid number of bytes to compare: `%s'"
msgstr ""

#: src/wc.c:78
msgid ""
"Print line, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes, --chars   print the byte counts\n"
"  -l, --lines            print the newline counts\n"
"  -w, --words            print the word counts\n"
"      --help             display this help and exit\n"
"      --version          output version information and exit\n"
msgstr ""

#: src/wc.c:319
msgid "total"
msgstr ""
