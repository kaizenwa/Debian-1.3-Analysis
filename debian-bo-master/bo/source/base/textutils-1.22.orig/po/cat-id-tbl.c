/* Automatically generated by po2tbl.sed from textutils.pot.  */

#if HAVE_CONFIG_H
# include <config.h>
#endif

#include "libgettext.h"

const struct _msg_ent _msg_tbl[] = {
  {"", 1},
  {"Try `%s --help' for more information.\n", 2},
  {"Usage: %s [OPTION] [FILE]...\n", 3},
  {"\
Concatenate FILE(s), or standard input, to standard output.\n\
\n\
  -A, --show-all           equivalent to -vET\n\
  -b, --number-nonblank    number nonblank output lines\n\
  -e                       equivalent to -vE\n\
  -E, --show-ends          display $ at end of each line\n\
  -n, --number             number all output lines\n\
  -s, --squeeze-blank      never more than one single blank line\n\
  -t                       equivalent to -vT\n\
  -T, --show-tabs          display TAB characters as ^I\n\
  -u                       (ignored)\n\
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n\
      --help               display this help and exit\n\
      --version            output version information and exit\n\
\n\
With no FILE, or when FILE is -, read standard input.\n", 4},
  {"\
\n\
Report bugs to textutils-bugs@gnu.ai.mit.edu", 5},
  {"write error", 6},
  {"cannot do ioctl on `%s'", 7},
  {"standard output", 8},
  {"%s: input file is output file", 9},
  {"Usage: %s [OPTION]... [FILE]...\n", 10},
  {"\
Print CRC checksum and byte counts of each FILE.\n\
\n\
  --help      display this help and exit\n\
  --version   output version information and exit\n", 11},
  {"Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n", 12},
  {"\
Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n\
\n\
  -1              suppress lines unique to left file\n\
  -2              suppress lines unique to right file\n\
  -3              suppress lines unique to both files\n\
      --help      display this help and exit\n\
      --version   output version information and exit\n", 13},
  {"virtual memory exhausted", 14},
  {"read error", 15},
  {"input disappeared", 16},
  {"%s: line number out of range", 17},
  {"%s: `%d': line number out of range", 18},
  {" on repetition %d\n", 19},
  {"%s: `%s': match not found", 20},
  {"error in regular expression search", 21},
  {"write error for `%s'", 22},
  {"%s: `+' or `-' expected after delimeter", 23},
  {"%s: integer expected after `%c'", 24},
  {"%s: `}' is required in repeat count", 25},
  {"%s}: integer required between `{' and `}'", 26},
  {"%s: closing delimeter `%c' missing", 27},
  {"%s: invalid regular expression: %s", 28},
  {"%s: invalid pattern", 29},
  {"%s: line number must be greater than zero", 30},
  {"line number `%s' is smaller than preceding line number, %lu", 31},
  {"warning: line number `%s' is the same as preceding line number", 32},
  {"missing conversion specifier in suffix", 33},
  {"invalid conversion specifier in suffix: %c", 34},
  {"invalid conversion specifier in suffix: \\%.3o", 35},
  {"missing %% conversion specification in suffix", 36},
  {"too many %% conversion specifications in suffix", 37},
  {"%s: invalid number", 38},
  {"too few arguments", 39},
  {"Usage: %s [OPTION]... FILE PATTERN...\n", 40},
  {"\
Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n\
and output byte counts of each piece to standard output.\n\
\n\
  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n\
  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n\
  -k, --keep-files           do not remove output files on errors\n\
  -n, --digits=DIGITS        use specified number of digits instead of 2\n\
  -s, --quiet, --silent      do not print counts of output file sizes\n\
  -z, --elide-empty-files    remove empty output files\n\
      --help                 display this help and exit\n\
      --version              output version information and exit\n\
\n\
Read standard input if FILE is -.  Each PATTERN may be:\n\
\n\
  INTEGER            copy up to but not including specified line number\n\
  /REGEXP/[OFFSET]   copy up to but not including a matching line\n\
  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n\
  {INTEGER}          repeat the previous pattern specified number of times\n\
  {*}                repeat the previous pattern as many times as possible\n\
\n\
A line OFFSET is a required `+' or `-' followed by a positive integer.\n", 41},
  {"\
Print selected parts of lines from each FILE to standard output.\n\
\n\
  -b, --bytes=LIST        output only these bytes\n\
  -c, --characters=LIST   output only these characters\n\
  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n\
  -f, --fields=LIST       output only these fields\n\
  -n                      (ignored)\n\
  -s, --only-delimited    do not print lines not containing delimiters\n\
      --help              display this help and exit\n\
      --version           output version information and exit\n\
\n\
Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n\
range, or many ranges separated by commas.  Each range is one of:\n\
\n\
  N     N'th byte, character or field, counted from 1\n\
  N-    from N'th byte, character or field, to end of line\n\
  N-M   from N'th to M'th (included) byte, character or field\n\
  -M    from first to M'th (included) byte, character or field\n\
\n\
With no FILE, or when FILE is -, read standard input.\n", 42},
  {"invalid byte or field list", 43},
  {"only one type of list may be specified", 44},
  {"missing list of positions", 45},
  {"missing list of fields", 46},
  {"the delimiter must be a single character", 47},
  {"you must specify a list of bytes, characters, or fields", 48},
  {"a delimiter may be specified only when operating on fields", 49},
  {"\
suppressing non-delimited lines makes sense\n\
\tonly when operating on fields", 50},
  {"\
Convert tabs in each FILE to spaces, writing to standard output.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -i, --initial       do not convert TABs after non whitespace\n\
  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n\
  -t, --tabs=LIST     use comma separated list of explicit tab positions\n\
      --help          display this help and exit\n\
      --version       output version information and exit\n\
\n\
Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n", 51},
  {"tab size contains an invalid character", 52},
  {"tab size cannot be 0", 53},
  {"tab sizes must be ascending", 54},
  {"Usage: %s [-DIGITS] [OPTION]... [FILE]...\n", 55},
  {"\
Reformat each paragraph in the FILE(s), writing to standard output.\n\
If no FILE or if FILE is `-', read standard input.\n\
\n\
Mandatory arguments to long options are mandatory for short options too.\n\
  -c, --crown-margin        preserve indentation of first two lines\n\
  -p, --prefix=STRING       combine only lines having STRING as prefix\n\
  -s, --split-only          split long lines, but do not refill\n\
  -t, --tagged-paragraph    indentation of first line different from second\n\
  -u, --uniform-spacing     one space between words, two after sentences\n\
  -w, --width=NUMBER        maximum line width (default of 75 columns)\n\
      --help                display this help and exit\n\
      --version             output version information and exit\n\
\n\
In -wNUMBER, the letter `w' may be omitted.\n", 56},
  {"invalid line number increment: `%s'", 57},
  {"\
Wrap input lines in each FILE (standard input by default), writing to\n\
standard output.\n\
\n\
  -b, --bytes         count bytes rather than columns\n\
  -s, --spaces        break at spaces\n\
  -w, --width=WIDTH   use WIDTH columns instead of 80\n", 58},
  {"invalid number of columns: `%s'", 59},
  {"\
Print first 10 lines of each FILE to standard output.\n\
With more than one FILE, precede each with a header giving the file name.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -c, --bytes=SIZE         print first SIZE bytes\n\
  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n\
  -q, --quiet, --silent    never print headers giving file names\n\
  -v, --verbose            always print headers giving file names\n\
      --help               display this help and exit\n\
      --version            output version information and exit\n\
\n\
SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n\
If -VALUE is used as first OPTION, read -c VALUE when one of\n\
multipliers bkm follows concatenated, else read -n VALUE.\n", 60},
  {"standard input", 61},
  {"unrecognized option `-%c'", 62},
  {"invalid number `%s'", 63},
  {"Usage: %s [OPTION]... FILE1 FILE2\n", 64},
  {"\
For each pair of input lines with identical join fields, write a line to\n\
standard output.  The default join field is the first, delimited\n\
by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n\
\n\
  -a SIDE           print unpairable lines coming from file SIDE\n\
  -e EMPTY          replace missing input fields with EMPTY\n\
  -i, --ignore-case ignore differences in case when comparing fields\n\
  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n\
  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n\
  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n\
  -o FORMAT         obey FORMAT while constructing output line\n\
  -t CHAR           use CHAR as input and output field separator\n\
  -v SIDE           like -a SIDE, but suppress joined output lines\n\
  -1 FIELD          join on this FIELD of file 1\n\
  -2 FIELD          join on this FIELD of file 2\n\
      --help        display this help and exit\n\
      --version     output version information and exit\n\
\n\
Unless -t CHAR is given, leading blanks separate fields and are ignored,\n\
else fields are separated by CHAR.  Any FIELD is a field number counted\n\
from 1.  FORMAT is one or more comma or blank separated specifications,\n\
each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n\
the remaining fields from FILE1, the remaining fields from FILE2, all\n\
separated by CHAR.\n", 65},
  {"invalid field specifier: `%s'", 66},
  {"invalid field number: `%s'", 67},
  {"invalid file number in field spec: `%s'", 68},
  {"invalid field number for file 1: `%s'", 69},
  {"invalid field number for file 2: `%s'", 70},
  {"too many non-option arguments", 71},
  {"too few non-option arguments", 72},
  {"both files cannot be standard input", 73},
  {"\
Usage: %s [OPTION] [FILE]...\n\
  or:  %s [OPTION] --check [FILE]\n\
Print or check MD5 checksums.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -b, --binary            read files in binary mode\n\
  -c, --check             check MD5 sums against given list\n\
  -t, --text              read files in text mode (default)\n\
\n\
The following two options are useful only when verifying checksums:\n\
      --status            don't output anything, status code shows success\n\
  -w, --warn              warn about improperly formated MD5 checksum lines\n\
\n\
      --help              display this help and exit\n\
      --version           output version information and exit\n\
\n\
The sums are computed as described in RFC 1321.  When checking, the input\n\
should be a former output of this program.  The default mode is to print\n\
a line with checksum, a character indicating type (`*' for binary, ` ' for\n\
text), and name for each FILE.\n", 74},
  {"%s: %lu: improperly formatted MD5 checksum line", 75},
  {"%s: FAILED open or read\n", 76},
  {"FAILED", 77},
  {"OK", 78},
  {"%s: read error", 79},
  {"%s: no properly formatted MD5 checksum lines found", 80},
  {"WARNING: %d of %d listed %s could not be read\n", 81},
  {"file", 82},
  {"files", 83},
  {"WARNING: %d of %d computed %s did NOT match", 84},
  {"checksum", 85},
  {"checksums", 86},
  {"\
the --binary and --text options are meaningless when verifying checksums", 87},
  {"the --string and --check options are mutually exclusive", 88},
  {"the --status option is meaningful only when verifying checksums", 89},
  {"the --warn option is meaningful only when verifying checksums", 90},
  {"no files may be specified when using --string", 91},
  {"only one argument may be specified when using --check", 92},
  {"\
Write each FILE to standard output, with line numbers added.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n\
  -d, --section-delimiter=CC      use CC for separating logical pages\n\
  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n\
  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n\
  -i, --page-increment=NUMBER     line number increment at each line\n\
  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as \
one\n\
  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n\
  -p, --no-renumber               do not reset line numbers at logical \
pages\n\
  -s, --number-separator=STRING   add STRING after (possible) line number\n\
  -v, --first-page=NUMBER         first line number on each logical page\n\
  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n\
      --help                      display this help and exit\n\
      --version                   output version information and exit\n\
\n\
By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n\
two delimiter characters for separating logical pages, a missing\n\
second character implies :.  Type \\\\ for \\.  STYLE is one of:\n\
\n\
  a         number all lines\n\
  t         number only nonempty lines\n\
  n         number no lines\n\
  pREGEXP   number only lines that contain a match for REGEXP\n\
\n\
FORMAT is one of:\n\
\n\
  ln   left justified, no leading zeros\n\
  rn   right justified, no leading zeros\n\
  rz   right justified, leading zeros\n\
\n", 93},
  {"invalid starting line number: `%s'", 94},
  {"invalid number of blank lines: `%s'", 95},
  {"invalid line number field width: `%s'", 96},
  {"\
Usage: %s [OPTION]... [FILE]...\n\
  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n", 97},
  {"\
Write an unambiguous representation, octal bytes by default, of FILE\n\
to standard output.  With no FILE, or when FILE is -, read standard input.\n\
\n\
  -A, --address-radix=RADIX   decide how file offsets are printed\n\
  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n\
  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n\
  -s, --strings[=BYTES]       output strings of at least BYTES graphic \
chars\n\
  -t, --format=TYPE           select output format or formats\n\
  -v, --output-duplicates     do not use * to mark line suppression\n\
  -w, --width[=BYTES]         output BYTES bytes per output line\n\
      --traditional           accept arguments in pre-POSIX form\n\
      --help                  display this help and exit\n\
      --version               output version information and exit\n\
\n\
Pre-POSIX format specifications may be intermixed, they accumulate:\n\
  -a   same as -t a,  select named characters\n\
  -b   same as -t oC, select octal bytes\n\
  -c   same as -t c,  select ASCII characters or backslash escapes\n\
  -d   same as -t u2, select unsigned decimal shorts\n\
  -f   same as -t fF, select floats\n\
  -h   same as -t x2, select hexadecimal shorts\n\
  -i   same as -t d2, select decimal shorts\n\
  -l   same as -t d4, select decimal longs\n\
  -o   same as -t o2, select octal shorts\n\
  -x   same as -t x2, select hexadecimal shorts\n", 98},
  {"\
\n\
For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n\
is the pseudo-address at first byte printed, incremented when dump is\n\
progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n\
hexadecimal, suffixes maybe . for octal and b multiply by 512.\n\
\n\
TYPE is made up of one or more of these specifications:\n\
\n\
  a          named character\n\
  c          ASCII character or backslash escape\n\
  d[SIZE]    signed decimal, SIZE bytes per integer\n\
  f[SIZE]    floating point, SIZE bytes per integer\n\
  o[SIZE]    octal, SIZE bytes per integer\n\
  u[SIZE]    unsigned decimal, SIZE bytes per integer\n\
  x[SIZE]    hexadecimal, SIZE bytes per integer\n\
\n\
SIZE is a number.  For TYPE in doux, SIZE may also be C for\n\
sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n\
sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n\
for sizeof(double) or L for sizeof(long double).\n\
\n\
RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n\
BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n\
with b suffix, by 1024 with k and by 1048576 with m.  -s without a\n\
number implies 3.  -w without a number implies 32.  By default, od\n\
uses -A o -t d2 -w 16.\n", 99},
  {"invalid type string `%s'", 100},
  {"\
invalid type string `%s';\n\
this system doesn't provide a %lu-byte integral type", 101},
  {"\
invalid type string `%s';\n\
this system doesn't provide a %lu-byte floating point type", 102},
  {"invalid character `%c' in type string `%s'", 103},
  {"cannot skip past end of combined input", 104},
  {"old-style offset", 105},
  {"invalid output address radix `%c'; it must be one character from [doxn]", 106},
  {"skip argument", 107},
  {"limit argument", 108},
  {"\
specified number of bytes `%s' is larger than the maximum\n\
representable value of type `long'", 109},
  {"minimum string length", 110},
  {"width specification", 111},
  {"no type may be specified when dumping strings", 112},
  {"invalid second operand in compatibility mode `%s'", 113},
  {"in compatibility mode the last 2 arguments must be offsets", 114},
  {"in compatibility mode there may be no more than 3 arguments", 115},
  {"warning: invalid width %lu; using %d instead", 116},
  {"%d: fmt=\"%s\" width=%d\n", 117},
  {"standard input is closed", 118},
  {"\
Write lines consisting of the sequentially corresponding lines from\n\
each FILE, separated by TABs, to standard output.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n\
  -s, --serial            paste one file at a time instead of in parallel\n\
      --help              display this help and exit\n\
      --version           output version information and exit\n\
\n", 119},
  {"invalid range of page numbers: `%s'", 120},
  {"invalid starting page number: `%s'", 121},
  {"invalid ending page number: `%s'", 122},
  {"starting page number is larger than ending page number", 123},
  {"`-l PAGE_LENGTH' invalid number of lines: `%s'", 124},
  {"`-N NUMBER' invalid starting line number: `%s'", 125},
  {"`-o MARGIN' invalid line offset: `%s'", 126},
  {"`-w PAGE_WIDTH' invalid column number: `%s'", 127},
  {"Cannot specify number of columns when printing in parallel.", 128},
  {"Cannot specify both printing across and printing in parallel.", 129},
  {"`-%c' extra characters or invalid number in the argument: `%s'", 130},
  {"page width too narrow", 131},
  {"%s%*s%s%*sPage", 132},
  {"\
Paginate or columnate FILE(s) for printing.\n\
\n\
  +FIRST_PAGE[:LAST_PAGE]\n\
                    begin [stop] printing with page FIRST_[LAST_]PAGE\n\
  -COLUMN           produce COLUMN-column output and print columns down,\n\
                    unless -a is used. Balance number of lines in the\n\
                    columns on each page.\n\
  -a                print columns across rather than down, used together\n\
                    with -COLUMN\n\
  -c                use hat notation (^G) and octal backslash notation\n\
  -d                double space the output\n\
  -e[CHAR[WIDTH]]   expand input CHARs (TABs) to tab WIDTH (8)\n\
  -F, -f            use form feeds instead of newlines to separate pages\n\
                    (by a 3-line page header with -f or a 5-line header\n\
                    and trailer without -f)\n\
  -h HEADER         use a centered HEADER instead of filename in page \
headers\n\
                    with long headers left-hand-side truncation may occur\n\
                    -h \"\" prints a blank line. Don't use -h\"\"\n\
  -i[CHAR[WIDTH]]   replace spaces with CHARs (TABs) to tab WIDTH (8)\n\
  -j                merge full lines, turns off -w line truncation, no \
column\n\
                    alignment, -s[STRING] sets separators\n\
  -l PAGE_LENGTH    set the page length to PAGE_LENGTH (66) lines\n\
                    (default number of lines of text 56, with -f 63)\n", 133},
  {"\
  -m                print all files in parallel, one in each column,\n\
                    truncate lines, but join lines of full length with -j\n\
  -n[SEP[DIGITS]]   number lines, use DIGITS (5) digits, then SEP (TAB)\n\
                    default counting starts with 1st line of input file\n\
  -N NUMBER         start counting with NUMBER at 1st line of first\n\
                    page printed (see +FIRST_PAGE)\n\
  -o MARGIN         offset each line with MARGIN spaces (do not affect -w)\n\
  -r                inhibit warning when a file cannot be opened\n\
  -s[STRING]        separate columns by an optional STRING\n\
                    don't use -s \"STRING\" \n\
                    without -s: default sep. 'space' used, same as -s\" \"\n\
                    -s only: no separator used, same as -s\"\" \n\
  -t                inhibit page headers and trailers\n\
  -T                inhibit page headers and trailers, eliminate any page\n\
                    layout by form feeds set in input files\n\
  -v                use octal backslash notation\n\
  -w PAGE_WIDTH     set page width to PAGE_WIDTH (72) columns, truncate\n\
                    lines (see also -j option)\n\
  --help            display this help and exit\n\
  --version         output version information and exit\n\
\n\
-T implied by -l nn when nn <= 10 or <= 3 with -f. With no FILE, or when\n\
FILE is -, read standard input.\n", 134},
  {"\
Write sorted concatenation of all FILE(s) to standard output.\n\
\n\
  +POS1 [-POS2]    start a key at POS1, end it before POS2\n\
  -b               ignore leading blanks in sort fields or keys\n\
  -c               check if given files already sorted, do not sort\n\
  -d               consider only [a-zA-Z0-9 ] characters in keys\n\
  -f               fold lower case to upper case characters in keys\n\
  -g               compare according to general numerical value, imply -b\n\
  -i               consider only [\\040-\\0176] characters in keys\n\
  -k POS1[,POS2]   same as +POS1 [-POS2], but all positions counted from 1\n\
  -m               merge already sorted files, do not sort\n\
  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n\
  -n               compare according to string numerical value, imply -b\n\
  -o FILE          write result on FILE instead of standard output\n\
  -r               reverse the result of comparisons\n\
  -s               stabilize sort by disabling last resort comparison\n\
  -t SEP           use SEParator instead of non- to whitespace transition\n\
  -T DIRECT        use DIRECT for temporary files, not $TMPDIR or %s\n\
  -u               with -c, check for strict ordering;\n\
                   with -m, only output the first of an equal sequence\n\
  -z               end lines with 0 byte, not newline, for find -print0\n\
      --help       display this help and exit\n\
      --version    output version information and exit\n\
\n\
POS is F[.C][OPTS], where F is the field number and C the character\n\
position in the field, both counted from zero.  OPTS is made up of one\n\
or more of Mbdfinr, this effectively disable global -Mbdfinr settings\n\
for that key.  If no key given, use the entire line as key.  With no\n\
FILE, or when FILE is -, read standard input.\n", 135},
  {"flushing file", 136},
  {"error closing file", 137},
  {"%s: disorder on %s\n", 138},
  {"invalid field specification `%s'", 139},
  {"\
when using the old-style +POS and -POS key specifiers,\n\
the +POS specifier must come first", 140},
  {"option `-k' requires an argument", 141},
  {"the starting field number argument to the `-k' option must be positive", 142},
  {"starting field spec has `.' but lacks following character offset", 143},
  {"\
starting field character offset argument to the `-k' option\n\
must be positive", 144},
  {"field specification has `,' but lacks following field spec", 145},
  {"ending field number argument to the `-k' option must be positive", 146},
  {"ending field spec has `.' but lacks following character offset", 147},
  {"option `-o' requires an argument", 148},
  {"option `-t' requires an argument", 149},
  {"option `-T' requires an argument", 150},
  {"%s: unrecognized option `-%c'\n", 151},
  {"%s: write error", 152},
  {"Usage: %s [OPTION] [INPUT [PREFIX]]\n", 153},
  {"\
Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n\
PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n\
\n\
  -b, --bytes=SIZE        put SIZE bytes per output file\n\
  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n\
  -l, --lines=NUMBER      put NUMBER lines per output file\n\
  -NUMBER                 same as -l NUMBER\n\
      --verbose           print a diagnostic to standard error just\n\
\t\t\t    before each output file is opened\n\
      --help              display this help and exit\n\
      --version           output version information and exit\n\
\n\
SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n", 154},
  {"creating file `%s'\n", 155},
  {"cannot split in more than one way", 156},
  {"%s: invalid number of bytes", 157},
  {"%s: invalid number of lines", 158},
  {"invalid number", 159},
  {"too many arguments", 160},
  {"\
Print checksum and block counts for each FILE.\n\
\n\
  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n\
  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n\
      --help      display this help and exit\n\
      --version   output version information and exit\n\
\n\
With no FILE, or when FILE is -, read standard input.\n", 161},
  {"\
Write each FILE to standard output, last line first.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -b, --before             attach the separator before instead of after\n\
  -r, --regex              interpret the separator as a regular expression\n\
  -s, --separator=STRING   use STRING as the separator instead of newline\n\
      --help               display this help and exit\n\
      --version            output version information and exit\n", 162},
  {"separator cannot be empty", 163},
  {"\
Print last 10 lines of each FILE to standard output.\n\
With more than one FILE, precede each with a header giving the file name.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -c, --bytes=N            output the last N bytes\n\
  -f, --follow             output appended data as the file grows\n\
  -n, --lines=N            output the last N lines, instead of last 10\n\
  -q, --quiet, --silent    never output headers giving file names\n\
  -v, --verbose            always output headers giving file names\n\
      --help               display this help and exit\n\
      --version            output version information and exit\n\
\n\
If the first character of N (the number of bytes or lines) is a `+',\n\
print beginning with the Nth item from the start of each file, otherwise,\n\
print the last N items in the file.  N may have a multiplier suffix:\n\
b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n\
or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n\
the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n\
or -c +VALUE.\n", 164},
  {"file truncated", 165},
  {"standard input: cannot follow end of non-regular file", 166},
  {"%s: cannot follow end of non-regular file", 167},
  {"%c: invalid suffix character in obsolescent option", 168},
  {"%s: `%s' is so large that it is not representable", 169},
  {"number of lines", 170},
  {"number of bytes", 171},
  {"invalid number of lines", 172},
  {"invalid number of bytes", 173},
  {"Usage: %s [OPTION]... SET1 [SET2]\n", 174},
  {"\
Translate, squeeze, and/or delete characters from standard input,\n\
writing to standard output.\n\
\n\
  -c, --complement        first complement SET1\n\
  -d, --delete            delete characters in SET1, do not translate\n\
  -s, --squeeze-repeats   replace sequence of characters with one\n\
  -t, --truncate-set1     first truncate SET1 to length of SET2\n\
      --help              display this help and exit\n\
      --version           output version information and exit\n", 175},
  {"\
\n\
SETs are specified as strings of characters.  Most represent themselves.\n\
Interpreted sequences are:\n\
\n\
  \\NNN            character with octal value NNN (1 to 3 octal digits)\n\
  \\\\              backslash\n\
  \\a              audible BEL\n\
  \\b              backspace\n\
  \\f              form feed\n\
  \\n              new line\n\
  \\r              return\n\
  \\t              horizontal tab\n\
  \\v              vertical tab\n\
  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n\
  [CHAR1-CHAR2]   same as CHAR1-CHAR2, if both SET1 and SET2 use this\n\
  [CHAR*]         in SET2, copies of CHAR until length of SET1\n\
  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n\
  [:alnum:]       all letters and digits\n\
  [:alpha:]       all letters\n\
  [:blank:]       all horizontal whitespace\n\
  [:cntrl:]       all control characters\n\
  [:digit:]       all digits\n\
  [:graph:]       all printable characters, not including space\n\
  [:lower:]       all lower case letters\n\
  [:print:]       all printable characters, including space\n\
  [:punct:]       all punctuation characters\n\
  [:space:]       all horizontal or vertical whitespace\n\
  [:upper:]       all upper case letters\n\
  [:xdigit:]      all hexadecimal digits\n\
  [=CHAR=]        all characters which are equivalent to CHAR\n", 176},
  {"\
\n\
Translation occurs if -d is not given and both SET1 and SET2 appear.\n\
-t may be used only when translating.  SET2 is extended to length of\n\
SET1 by repeating its last character as necessary.  Excess characters\n\
of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n\
expand in ascending order; used in SET2 while translating, they may\n\
only be used in pairs to specify case conversion.  -s uses SET1 if not\n\
translating nor deleting; else squeezing uses SET2 and occurs after\n\
translation or deletion.\n", 177},
  {"\
warning: the ambiguous octal escape \\%c%c%c is being\n\
\tinterpreted as the 2-byte sequence \\0%c%c, `%c'", 178},
  {"invalid backslash escape at end of string", 179},
  {"invalid backslash escape `\\%c'", 180},
  {"range-endpoints of `%s-%s' are in reverse collating sequence order", 181},
  {"invalid repeat count `%s' in [c*n] construct", 182},
  {"invalid character class `%s'", 183},
  {"%s: equivalence class operand must be a single character", 184},
  {"the [c*] repeat construct may not appear in string1", 185},
  {"only one [c*] repeat construct may appear in string2", 186},
  {"[=c=] expressions may not appear in string2 when translating", 187},
  {"when not truncating set1, string2 must be non-empty", 188},
  {"\
when translating with complemented character classes,\n\
string2 must map all characters in the domain to one", 189},
  {"\
when translating, the only character classes that may appear in\n\
string2 are `upper' and `lower'", 190},
  {"the [c*] construct may appear in string2 only when translating", 191},
  {"two strings must be given when translating", 192},
  {"two strings must be given when both deleting and squeezing repeats", 193},
  {"only one string may be given when deleting without squeezing repeats", 194},
  {"at least one string must be given when squeezing repeats", 195},
  {"misaligned [:upper:] and/or [:lower:] construct", 196},
  {"\
invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n\
construct in string1 must be aligned with a corresponding construct\n\
([:upper:] or [:lower:], respectively) in string2", 197},
  {"\
Convert spaces in each FILE to tabs, writing to standard output.\n\
With no FILE, or when FILE is -, read standard input.\n\
\n\
  -a, --all           convert all whitespace, instead of initial whitespace\n\
  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n\
  -t, --tabs=LIST     use comma separated list of explicit tab positions\n\
      --help          display this help and exit\n\
      --version       output version information and exit\n\
\n\
Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n", 198},
  {"Usage: %s [OPTION]... [INPUT [OUTPUT]]\n", 199},
  {"\
Discard all but one of successive identical lines from INPUT (or\n\
standard input), writing to OUTPUT (or standard output).\n\
\n\
  -c, --count           prefix lines by the number of occurrences\n\
  -d, --repeated        only print duplicate lines\n\
  -f, --skip-fields=N   avoid comparing the first N fields\n\
  -i, --ignore-case     ignore differences in case when comparing\n\
  -s, --skip-chars=N    avoid comparing the first N characters\n\
  -u, --unique          only print unique lines\n\
  -w, --check-chars=N   compare no more than N characters in lines\n\
  -N                    same as -f N\n\
  +N                    same as -s N\n\
      --help            display this help and exit\n\
      --version         output version information and exit\n\
\n\
A field is a run of whitespace, than non-whitespace characters.\n\
Fields are skipped before chars.\n", 200},
  {"error reading %s", 201},
  {"error writing %s", 202},
  {"invalid number of fields to skip: `%s'", 203},
  {"invalid number of bytes to skip: `%s'", 204},
  {"invalid number of bytes to compare: `%s'", 205},
  {"\
Print line, word, and byte counts for each FILE, and a total line if\n\
more than one FILE is specified.  With no FILE, or when FILE is -,\n\
read standard input.\n\
  -c, --bytes, --chars   print the byte counts\n\
  -l, --lines            print the newline counts\n\
  -w, --words            print the word counts\n\
      --help             display this help and exit\n\
      --version          output version information and exit\n", 206},
  {"total", 207},
};

int _msg_tbl_length = 207;
