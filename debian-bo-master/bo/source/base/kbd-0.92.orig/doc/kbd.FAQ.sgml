<!doctype linuxdoc system>

<article>

<title>The Linux keyboard and console HOWTO
<author>Andries Brouwer, <tt/aeb@cwi.nl/
<date>v2.3, 960413

<abstract>This note contains some information about the Linux keyboard
and console, and the use of non-ASCII characters.
It describes Linux 2.0.
</abstract>

<toc>

<sect>Useful programs<p>

The following packages contain keyboard or console related programs.
<p>
<tt/kbd-0.92.tar.gz/ contains <tt/loadkeys/, <tt/dumpkeys/, <tt/showkey/,
<tt/setmetamode/, <tt/setleds/, <tt/setfont/, <tt/showfont/, <tt/mapscrn/,
<tt/kbd_mode/, <tt/loadunimap/, <tt/chvt/, <tt/resizecons/, <tt/disalloc/,
<tt/getkeycodes/, <tt/setkeycodes/.
<p>
<tt/util-linux-2.5/ contains <tt/setterm/, <tt/kbdrate/.
<p>
<tt/shellutils-1.8/ (or <tt/stty.tar.gz/) contains <tt/stty/.
<p>
<tt/open-1.1.tgz/ contains <tt/open/. (See also <tt/dynamic-vc-1.1.tar.gz/.)

<tt/SVGATextMode-1.0.tar.gz/ contains <tt/SVGATextMode/, a program that
obsoletes <tt/resizecons/.

The X distribution contains <tt/xmodmap/, <tt/xset/, <tt/kbd_mode/.
(See also X386keybd(1).)

<sect>Keyboard generalities<p>

You press a key, and the keyboard controller sends scancodes to the
kernel keyboard driver. Some keyboards can be programmed, but usually
the scancodes corresponding to your keys are fixed.
The kernel keyboard driver just transmits whatever it receives
to the application program when it is in <em>scancode mode</em>,
like when <tt/X/ is running. Otherwise, it parses the stream of scancodes
into keycodes, corresponding to key press or key release events.
(A single key press can generate up to 6 scancodes.)
These keycodes are transmitted to the application program when it is
in <em>keycode mode</em> (as used, for example, by <tt/showkey/).
Otherwise, these keycodes are looked up in the keymap, and the character
or string found there is transmitted to the application, or the action
described there is performed.
(For example, if one presses and releases the <tt/a/ key, then the keyboard
produces scancodes 0x1e and 0x9e, this is converted to keycodes 30 and 158,
and then transmitted as 0141, the ASCII or latin-1 code for 'a';
if one presses and releases <tt/Delete/, then the keyboard produces scancodes
0xe0 0x53 0xe0 0xd3, these are converted to keycodes 111 and 239, and then
transmitted as the 4-symbol sequence ESC <tt/&lsqb 3 ~/, all assuming
a US keyboard and a default keymap. An example of a key combination to which
an action is assigned is Ctrl-Alt-Del.)
<P>
The translation between unusual scancodes and keycodes can be set using the
utility <tt/setkeycodes/ - only very few people will need it.
The translation between keycodes and characters or strings or actions, that is,
the keymap, is set using the utility <tt/loadkeys/.
For details, see getkeycodes(8), setkeycodes(8), dumpkeys(1), loadkeys(1).
<P>
Where it says `transmitted to the application' in the above description,
this really means `transmitted to the terminal driver'. That is, further
processing is just like that of text that comes in over a serial line.
The details of this processing are set by the program <tt/stty/.

<sect>Console generalities<p>

Conversely, when you output something to the console, it first undergoes
the standard tty processing, and then is fed to the console driver.
The console driver emulates a VT100, and parses the input in order to
recognize VT100 escape sequences (for cursor movement, clear screen, etc.).
The characters that are not part of an escape sequence are first converted
into Unicode, using one of four mapping tables if the console was not
in UTF-8 mode to start with, then looked up in the table describing
the correspondence between Unicode values and font positions,
and the obtained 8- or 9-bit font indices are then written to video memory,
where they cause the display of character shapes found in the video card's
character ROM.
One can load one's own fonts into character ROM using
<tt/setfont/, load the corresponding unicode map with <tt/loadunimap/,
and load a user mapping table using <tt/mapscrn/.
More details will be given below.

<sect>Resetting your terminal<p>

There is garbage on the screen, or all your keystrokes are echoed
as line drawing characters. What to do?

Many programs will redraw the screen when ^L is typed. This might
help when there is some modem noise or broadcast message on your screen.
The command <tt/clear/ will clear the screen.

The command <tt/reset/ will reset the console driver. This helps when
the screen is full of funny graphic characters, and also if it is
reduced to the bottom line. If you don't have this command, or if it
does something else, make your own by putting the following two lines
in an executable file <tt/reset/ in your PATH:
<tscreen><verb>
#!/bin/sh
echo -e \\033c
</verb></tscreen>
that is, you want to send the two characters ESC c to the console.
If you loaded some strange font, and want to return to the default,
<tscreen><verb>
% setfont
</verb></tscreen>
will do (provided you stored the default font in the default place).
On old terminals output involving tabs may require a delay, and you
have to say
<tscreen><verb>
% stty tab3
</verb></tscreen>
(see stty(1)). You can change the video mode using <tt/resizecons/ or
<tt/SVGATextMode/.
This usually settles the output side.
On the input side there are many things that might be wrong. If <tt/X/ or
<tt/DOOM/ or some other program using raw mode crashed, your keyboard may
still be in raw (or mediumraw) mode, and it is difficult to give commands.
(See "How to get out of raw mode" below.)

<sect1>Keyboard hardware reset<p>

Things may be wrong on a lower level than Linux knows about.
There are at least two distinct lower levels (keyboard and keyboard controller)
where one can give the command "keyboard disable" to the keyboard hardware.
Keyboards can often be programmed to use one out of three
different sets of scancodes.
<p>
However, I do not know of cases where this turned out to be
a problem.
<p>
Some keyboards have a remapping capability built in.
Stormy Henderson (<tt/stormy@Ghost.Net/) writes:
`If it's your keyboard accidently being reprogrammed, you can
(on a Gateway AnyKey keyboard) press control-alt-suspend_macro
to reset the keys to normal.'

<sect>Delete and Backspace<p>

<sect1>How to tell Unix what character you want to use to delete the last typed character<p>

<tscreen><verb>
% stty erase ^?
</verb></tscreen>
If the character is erased, but in a funny way, then something is
wrong with your tty settings. If <tt/echoprt/ is set, then erased characters
are enclosed between <tt>&bsol;</tt> and <tt>/</tt>.
If <tt/echoe/ is not set, then the erase char is echoed
(which is reasonable when it is a printing character, like &num;).
Most people will want <tt/stty echoe -echoprt/. Saying <tt/stty sane/
will do this and more. Saying <tt/stty -a/ shows your current settings.
How come this is not right by default? It is, if you use the right
<tt/getty/.

Note that many programs (like <tt/bash/, <tt/emacs/ etc.) have their own
keybindings (defined in <tt>~/.inputrc</tt>, <tt>~/.emacs</tt> etc.)
and are unaffected by the setting of the erase character.

The standard Unix tty driver does not recognize a cursor, or keys
(like the arrow keys) to move the current position, and hence does not
have a command `delete current character' either. But for example
you can get <tt/bash/ on the console to recognize the Delete key by putting
<tscreen><verb>
set editing-mode emacs
"\e[3~":delete-char
</verb></tscreen>
into <tt>~/.inputrc</tt>.

<sect2>`Getty used to do the right thing with DEL and BS but is broken now?'<p>

Earlier, the console driver would do BS Space BS
(<tt>&bsol;010&bsol;040&bsol;010</tt>)
when it got a DEL (<tt>&bsol;177</tt>).
Nowadays, DEL's are ignored (as they should be,
since the driver emulates a vt100). Get a better getty, i.e.,
one that does not output DEL.

<sect2>`Login behaves differently at the first and second login attempts?'<p>

At the first attempt, you are talking to <tt/getty/. At the second attempt,
you are talking to <tt/login/, a different program.

<sect1>How to tell Linux what code to generate when a key is pressed<p>

On the console, or, more precisely, when not in (MEDIUM)RAW mode, use
<tscreen><verb>
% loadkeys mykeys.map
</verb></tscreen>
and under X use
<tscreen><verb>
% xmodmap mykeys.xmap
</verb></tscreen>
Note that (since XFree86-2.1) X reads the Linux settings of the keymaps
when initialising the X keymap. Although the two systems are not
100% compatible, this should mean that in many cases the use of
<tt/xmodmap/ has become superfluous.

If, for example, you want your Backspace key to generate BackSpace
(^H), instead of the default Delete, then
<tscreen><verb>
% loadkeys
keycode 14 = BackSpace
%
</verb></tscreen>
will do.

<sect2>`Why doesn't the Backspace key generate BackSpace by default?'<p>

(i) Because the VT100 had a Delete key above the Enter key.
<p>
(ii) Because Linus decided so.

<sect1>How to tell X to interchange Delete and Backspace<p>

<tscreen><verb>
% xmodmap -e "keysym BackSpace = Delete" -e "keysym Delete = BackSpace"
</verb></tscreen>
Or, if you just want the Backspace key to generate a BackSpace:
<tscreen><verb>
% xmodmap -e "keycode 22 = BackSpace"
</verb></tscreen>
Or, if you just want the Delete key to generate a Delete:
<tscreen><verb>
% xmodmap -e "keycode 107 = Delete"
</verb></tscreen>
(but usually this is the default binding already).

<sect1>How to tell emacs what to do when it receives a Delete or Backspace<p>

Put in your <tt/.emacs/ file lines like
<tscreen><verb>
  (global-set-key "\?" 'delete-backward-char)
  (global-set-key "\C-h" 'help-command)
</verb></tscreen>
Of course you can bind other commands to other keys in the same way.

<sect1>How to tell emacs to interchange Delete and Backspace<p>

Put in your <tt/.emacs/ file lines
<tscreen><verb>
  (setq keyboard-translate-table (make-string 128 0))
  (let ((i 0))
  (while (< i 128)
      (aset keyboard-translate-table i i)
      (setq i (1+ i))))
  (aset keyboard-translate-table ?\b ?\^?)
  (aset keyboard-translate-table ?\^? ?\b)
</verb></tscreen>

<sect1>How to tell kermit to interchange Delete and Backspace<p>

Put in your <tt/.kermrc/ file the lines
<tscreen><verb>
  set key \127 \8
  set key \8 \127
</verb></tscreen>

<sect1>How to tell xterm about your favourite tty modes<p>

Normally xterm will inherit the tty modes from its invoker.
Under <tt/xdm/, the default erase and kill characters are <tt/#/ and <tt/@/,
as in good old Unix Version 6.
If you don't like that, you might put something like
<tscreen><verb>
  XTerm*ttymodes: erase ^? kill ^U intr ^C quit ^\ eof ^D susp ^Z start ^Q stop ^S eol ^@
</verb></tscreen>
in <tt>/usr/lib/X11/app-defaults/XTerm</tt> or in
<tt>&dollar;HOME/.Xresources</tt>, assuming that you have a line
<tscreen><verb>
  xrdb $HOME/.Xresources
</verb></tscreen>
in your <tt>&dollar;HOME/.xinitrc</tt>.

<sect1>How to tell xmosaic that the Backspace key generates a DEL<p>

Putting
<tscreen><verb>
  *XmText.translations: #override\n\
         <Key>osfDelete: delete-previous-character()
  *XmTextField.translations: #override\n\
          <Key>osfDelete: delete-previous-character()
</verb></tscreen>
in your <tt>&dollar;HOME/.Xresources</tt> helps.

The netscape FAQ, however, says:
<verb>
	Why doesn't my Backspace key work in text fields? 
	By default, Linux and XFree86 come with the Backspace and Delete keys
	misconfigured. All Motif programs (including, of course, Netscape
	Navigator) will malfunction in the same way.

	The Motif spec says that Backspace is supposed to delete the previous
	character and Delete is supposed to delete the following character.
	Linux and XFree86 come configured with both the Backspace and Delete
	keys generating Delete.

	You can fix this by using any one of the xmodmap, xkeycaps, or
	loadkeys programs to make the key in question generate the BackSpace
	keysym instead of Delete.

	You can also fix it by having a .motifbind file; see the man page
	for VirtualBindings(3).

	Note: Don't use the *XmText.translations or *XmTextField.translations
	resources to attempt to fix this problem. If you do, you will blow
	away Netscape Navigator's other text-field key bindings.
</verb>

<sect1>What about termcap and terminfo?<p>

When people have problems with backspace, they tend to look at their termcap
(or terminfo) entry for the terminal, and indeed, there does exist a kb
(or kbs) capability describing the code generated by the Backspace key.
However, not many programs use it, so unless you are having problems with one
particular program only, probably the fault is elsewhere.
Of course it is a good idea anyway to correct your termcap (terminfo) entry.
See also below under "The TERM variable".

<sect>The console character sets<p>

The kernel first tries to figure out what symbol is meant by any given
user byte, and next where this symbol is located in the current font.

The kernel knows about 5 translations of bytes into console-screen symbols.
In Unicode (UTF-8) mode, the UTF-8 code is just converted directly into
Unicode. The assumption is that almost all symbols one needs are present
in Unicode, and for the cases where this does not hold the codes 0xff**
are reserved for direct font access.
When not in Unicode mode, one of four translation tables is used.
The four tables are: a) Latin1 -&gt; Unicode,  b) VT100 graphics -&gt; Unicode,
c) PC -&gt; Unicode, d) user-defined.

There are two character sets, called G0 and G1, and one of them
is the current character set. (Initially G0.)
Typing ^N causes G1 to become current, ^O causes G0 to become current.

These variables G0 and G1 point at a translation table, and can be changed
by the user. Initially they point at tables a) and b), respectively.
The sequences ESC ( B and ESC ( 0 and ESC ( U and ESC ( K cause G0 to point
at translation table a), b), c) and d), respectively.
The sequences ESC ) B and ESC ) 0 and ESC ) U and ESC ) K cause G1 to point
at translation table a), b), c) and d), respectively.

The sequence ESC c causes a terminal reset, which is what you want if the
screen is all garbled. The oft-advised <tt/echo ^V^O/ will only make G0
current, but there is no guarantee that G0 points at table a).
In some distributions there is a program reset(1) that just does
<tt>echo ^&lsqb;c</tt>.
If your termcap entry for the console is correct (and has an entry
<tt>:rs=&bsol;Ec:</tt>), then also <tt/setterm -reset/ will work.

The user-defined mapping table can be set using mapscrn(8).
The result of the mapping is that if a symbol c is printed, the symbol
<tt>s = map[c]</tt> is sent to the video memory. The bitmap that corresponds to
<tt/s/ is found in the character ROM, and can be changed using setfont(8).

<sect>Console switching<p>

By default, console switching is done using Alt-Fn or Ctrl-Alt-Fn.
Under <tt/X/ (or recent versions of <tt/dosemu/), only Ctrl-Alt-Fn works.

XFree86 1.3 does not know that Alt is down when you switch to the X
window. Thus, you cannot switch immediately to some other VT again
but have to release Alt first.
In the other direction this should work: the kernel always keeps
track of the up/down status of all keys. (As far as possible: on some
keyboards some keys do not emit a scancode when pressed (e.g.: the PFn
keys of a FOCUS 9000) or released (e.g.: the Pause key of many keyboards).)

XFree86 1.3 saves the fonts loaded in the character ROMs when started,
and restores it on a console switch. Thus, the result of <tt/setfont/ on
a VT is wiped out when you go to X and back.
Using <tt/setfont/ under X will lead to funny results.

One can change under program control using the <tt/chvt/ command.

<sect1>Changing the number of Virtual Consoles<p>

This question still comes up from time to time, but the answer is:
you already have enough of them.
Since kernel version 1.1.54, there are between 1 and 63 virtual
consoles. A new one is created as soon as it is opened. It is
removed by the utility <tt/disalloc/ (but it can be removed only when
no processes are associated to it anymore, and no text on it has been
selected by programs like <tt/selection/ or <tt/gpm/).

For older kernels, change the line
<tscreen><verb>
#define NR_CONSOLES     8
</verb></tscreen>
in <tt>include/linux/tty.h</tt> (don't increase this number beyond 63),
and recompile the kernel. You might have to create the devices
with <tt/MAKEDEV/ or <tt/mknod tty/N <tt/c 4/ N where N denotes
the tty number.
If you want the new VCs to run <tt/getty/, add lines in <tt>/etc/inittab</tt>.

When the consoles are allocated dynamically, it is usually easiest
to have only one or two running <tt/getty/. More are opened by
<tt>open -l -s bash</tt>. Unused consoles (without associated processes)
are disallocated using <tt/disalloc/.

If you have <tt/spawn_login/ from <tt/kbd-0.90.tar.gz/ and you put
<tscreen><verb>
	loadkeys << EOF
	alt keycode 103 = Spawn_Console
	EOF
	spawn_login &
</verb></tscreen>
in <tt>/etc/rc.local</tt>, then typing Alt-UpArrow will create a fresh VC
running <tt/login/ (and switch to it). See also <tt>open-1.3.tgz</tt>.

You can only login as "root" on terminals listed in <tt>/etc/securetty</tt>.

<sect>Ctrl-Alt-Del and other special key combinations<p>

<sect1>Ctrl-Alt-Del (Boot)<p>
If you press Ctrl-Alt-Del (or whatever key was assigned the keysym Boot by
loadkeys) then either the machine reboots immediately (without sync), or
<tt/init/ is sent a SIGINT. The former behaviour is the default. The default can
be changed by root, using the system call reboot(), see ctrlaltdel(8).
Some <tt/init/'s change the default. What happens when <tt/init/ gets SIGINT depends
on the version of <tt/init/ used - often it will be determined by the pf entry in
<tt>/etc/inittab</tt> (which means that you can run an arbitrary program
in this case).
In the current kernel Ctrl-AltGr-Del is no longer by default assigned to Boot.

<sect1>Other combinations<p>
<verb>
Name		Default binding
-------------------------------
Show_Memory	Shift-Scrollock
Show_Registers	AltGr-ScrollLock
Show_State	Ctrl-ScrollLock
Console_n	Alt-Fn and Ctrl-Alt-Fn	(1 <= n <= 12)
Console_{n+12}	AltGr-Fn		(1 <= n <= 12)
Incr_Console	Alt-RightArrow
Decr_Console	Alt-LeftArrow
Last_Console	Alt[Gr]-PrintScreen
Scroll_Backward	Shift-PageUp
Scroll_Forward	Shift-PageDown
Caps_On					(CapsLock is a toggle; this key sets)
Compose		Ctrl-.
</verb>

<sect1>X Combinations<p>
<verb>
Ctrl-Alt-Fn	Switch to VT n
Ctrl-Alt-KP+	Next mode
Ctrl-Alt-KP-	Previous mode
Ctrl-Alt-Backspace	Kill X
</verb>
On some motherboards, Ctrl-Alt-KP- and Ctrl-Alt-KP+ will be equivalent to
pressing the Turbo button. That is, both will produce the scancodes
1d 38 4a ca b8 9d and 1d 38 4e ce b8 9d, and both will switch between
Turbo (&gt;= 25MHz) and non-Turbo (8 or 12 MHz).
(Often these key combinations only function this way when enabled
by jumpers on the motherboard.)

Perry F Nguyen (pfnguyen@netcom22.netcom.com) writes:
AMI BIOS has a feature that locks up the keyboard and flashes the LED's
if the Ctrl-Alt-Backspace combination is pressed while a BIOS password
is enabled, until the CMOS/BIOS password is typed in.

<sect1>Dosemu Combinations<p>
<verb>
Ctrl-Alt-Fn	Switch to VT n (from version 0.50; earlier Alt-Fn)
Ctrl-Alt-PgDn	Kill dosemu (when in RAW keyboard mode)
(and many other combinations - see the dosemu documentation)
</verb>

<sect1>Composing symbols<p>

One symbol may be constructed using several keystrokes.
<itemize>
<item>
LeftAlt-press, followed by a decimal number typed on the keypad, followed
by LeftAlt-release, yields the symbol with code given by this number.
(In Unicode mode this same mechanism, but then with 4 hexadecimal digits,
may be used to define a Unicode symbol.)
<item>
A dead diacritic followed by a symbol, yields that symbol adorned with
that diacritic. If the combination is undefined, both keys are taken
separately.
Which keys are dead diacritics is user-settable; none is by default.
Five dead diacritics can be defined (using loadkeys(1)): dead_grave,
dead_acute, dead_circumflex, dead_tilde, dead_diaeresis.
Precisely what this adorning means is also user-settable:
dead-diacritic, symbol is equivalent to Compose + diacritic + symbol.
<item>
Compose followed by two symbols yields a combination symbol. These
combinations are user-settable. Today there are 68 combinations
defined by default; you can see them by saying "dumpkeys | grep compose".
<item>
Then there are `Sticky' modifier keys (since 1.3.33). For example,
one can type ^C as SControl, C and Ctrl-Alt-BackSpace as SControl, SAlt,
BackSpace.
</itemize>

Note that there are at least three such composition mechanisms:
<enum>
<item>
The Linux keyboard driver mechanism, used in conjunction with loadkeys.
<item>
The X mechanism - see X386keybd(1), later XFree86kbd(1).
Under X11R6: edit <tt>/usr/X11R6/lib/X11/locale/iso8859-1/Compose</tt>.
<item>
The emacs mechanism obtained by loading "iso-insert.el".
</enum>
For X the order of the two symbols is arbitrary: both Compose-,-c and
Compose-c-, yield a c-cedilla; for Linux and emacs only the former sequence
works by default. For X the list of compose combinations is fixed. Linux
and emacs are flexible.
The three default lists are somewhat similar, but the details are different.

<sect>Various properties of the console<p>

See loadkeys(1), setleds(1), setmetamode(1) for the codes generated by the
various keys and the setting of leds when not under X. Under X, see xmodmap(1).

See setterm(1), kbdrate(8) for properties such as foreground and background
colors, screen blanking, character repeat rate when not under X.
Under X, see xset(1), also for key click and bell volume.

The file <tt>/etc/termcap</tt> defines the escape sequences used by many programs
addressing the console (or any other terminal). A more modern version is
found in <tt>/usr/lib/terminfo</tt>. (See terminfo(5). Terminfo files are compiled
by the terminfo compiler <tt>/usr/lib/terminfo/tic</tt>, see tic(1).)

(On my machine) <tt>/dev/console</tt> is a symbolic link to <tt>/dev/tty0</tt>,
and the kernel regards <tt>/dev/tty0</tt> as a synonym for the current VT.
XFree86 1.3 changes the owner of <tt>/dev/tty0</tt>, but does not reset this after
finishing. Thus, dumpkeys might fail because someone else owns <tt>/dev/tty0</tt>;
in such a case you might run X first.

<sect>How to get out of raw mode<p>

If some program using K_RAW keyboard mode exits without restoring the keyboard
mode to K_XLATE, then it is difficult to do anything - not even Ctrl-Alt-Del
works. However, it is sometimes possible to avoid hitting the reset button.
(And desirable as well: your users may get angry if you kill their Hack game
by rebooting; you might also damage your file system.)
Easy solutions involve logging in from another terminal or another machine
and doing <tt>kbd_mode -a</tt>.
The procedure below assumes that no X is running, that the display is in
text mode, and that you are at your bash prompt, that you are using a US
keyboard layout, and that your interrupt character is Ctrl-C.

Step 1. Start X.
As follows: press 2 (and don't release), press F12 (and don't release)
and immediately afterwards press = . This starts X.
  (Explanation: if a key press produces keycode K, then the key release
  produces keycode K+128. Probably your shell does not like these high
  characters, so we avoid generating them by not releasing any key.
  However, we have to be quick, otherwise key repeat starts. The digit 2
  produces a Ctrl-C that discards previous junk, the F12 produces an X
  and the = a Return.)
Probably your screen will be grey now, since no <tt/.xinitrc/ was specified.
However, Ctrl-Alt-Fn will work and you can go to another VT.
(Ctrl-Alt-Backspace also works, but that exits X, and gets you back into
the previous state, which is not what you want.)

Step 2. Setup to change the keyboard mode.
(For example, by <tt>sleep 5; kbd_mode -a</tt>.)

Step 3. Leave X again.
Alt-Fx (often Alt-F7) brings you back to X, and then Ctrl-Alt-Backspace
exits X. Within 5 seconds your keyboard will be usable again.

If you want to prepare for the occasion, then make
<tt>&bsol;215A&bsol;301</tt> (3 symbols) an alias for <tt/kbd_mode -a/.
Now just hitting = F7 = (3 symbols) will return you to sanity.

<sect>The TERM variable<p>

Many programs use the <tt/TERM/ variable and the database <tt>/etc/termcap</tt> or
<tt>/usr/lib/terminfo/*</tt> to decide which strings to send for clear screen,
move cursor, etc., and sometimes also to decide which string is sent
by the users backspace key, function keys etc.
This value is first set by the kernel (for the console).
Usually, this variable is re-set by <tt/getty/, using <tt>/etc/ttytype</tt> or
the argument specified in <tt>/etc/inittab</tt>.
Sometimes, it is also set in <tt>/etc/profile</tt>.

Older systems use <tt/TERM=console/ or <tt/TERM=con80x25/. Newer systems (with
ncurses 1.8.6) use the more specific <tt/TERM=linux/ or <tt/TERM=linux-80x25/.
However, old versions of <tt/setterm/ test for <tt/TERM=con*/ and hence fail
to work with <tt/TERM=linux/.

Since kernel version 1.3.2, the kernel default for the console is
<tt/TERM=linux/.

If you have a termcap without entry for linux, add the word linux
to the entry for the console:
<tscreen><verb>
	console|con80x25|linux:\
</verb></tscreen>
and make <tt>/usr/lib/terminfo/l/linux</tt> a copy of or symbolic link to
<tt>/usr/lib/terminfo/c/console</tt>.

<sect1>Terminfo<p>

The terminfo entry for the linux console from ncurses 1.8.6 misses the
entry <tt>kich1=&bsol;E&lsqb;2~</tt>, needed by some programs.
Edit the file and <tt/tic/ it.

<sect>How to make other programs work with non-ASCII chars<p>

In the bad old days this used to be quite a hassle. Every separate
program had to be convinced individually to leave your bits alone.
Not that all is easy now, but recently a lot of gnu utilities have
learned to react to <tt/LC_CTYPE=iso_8859_1/ or <tt/LC_CTYPE=iso-8859-1/.
Try this first, and if it doesn't help look at the hints below.

First of all, the 8-th bit should survive the kernel input processing,
so make sure to have <tt/stty cs8 -istrip -parenb/ set.

A. For <tt/emacs/, put lines
<tscreen><verb>
	(standard-display-european t)
	(set-input-mode nil nil 1)
	(require 'iso-syntax)
</verb></tscreen>
and perhaps also
<tscreen><verb>
	(load-file "iso-insert.el")
	(define-key global-map [?\C-.] 8859-1-map)
</verb></tscreen>
into your <tt>&dollar;HOME/.emacs</tt>.
(The latter line will not work under <tt/xterm/, if you use <tt/emacs -nw/,
but in that case you can put
<tscreen><verb>
	XTerm*VT100.Translations:       #override\n\
        Ctrl <KeyPress> . : string("\0308")
</verb></tscreen>
in your <tt/.Xresources/.)

B. For <tt/less/, put <tt/LESSCHARSET=latin1/ in the environment.
This is also what you need if you see <tt/&bsol;255/ or <tt/&lt;AD&gt;/
in man output: some versions of <tt/less/ will render the soft hyphen
(octal 0255, hex 0xAD) this way when not given permission to output Latin-1.

C. For <tt/ls/, give the option <tt/-N/. (Probably you want to make an alias.)

D. For <tt/bash/ (version 1.13.*), put
<tscreen><verb>
	set meta-flag on
	set convert-meta off
</verb></tscreen>
and, according to the Danish HOWTO,
<tscreen><verb>
	set output-meta on
</verb></tscreen>
into your <tt>&dollar;HOME/.inputrc</tt>.

E. For <tt/tcsh/, use
<tscreen><verb>
	setenv LANG     US_en
	setenv LC_CTYPE iso_8859_1
</verb></tscreen>
If you have nls on your system, then the corresponding routines are used.
Otherwise <tt/tcsh/ will assume iso_8859_1, regardless of the values given to
LANG and LC_CTYPE. See the section NATIVE LANGUAGE SYSTEM in tcsh(1).
(The Danish HOWTO says: <tt>setenv LC_CTYPE ISO-8859-1; stty pass8</tt>)

F. For <tt/flex/, give the option <tt/-8/ if the parser it generates must be
able to handle 8-bit input. (Of course it must.)

G. For <tt/elm/, set <tt/displaycharset/ to <tt/ISO-8859-1/.
(Danish HOWTO: <tt/LANG=C/ and <tt/LC_CTYPE=ISO-8859-1/)

H. For programs using curses (such as <tt/lynx/) David Sibley reports:
The regular curses package uses the high-order bit for reverse video mode
(see flag _STANDOUT defined in <tt>/usr/include/curses.h</tt>).  However,
<tt/ncurses/ seems to be 8-bit clean and does display iso-latin-8859-1
correctly.

I. For programs using <tt/groff/ (such as <tt/man/), make sure to use
<tt/-Tlatin1/ instead of <tt/-Tascii/. Old versions of the program <tt/man/
also use <tt/col/, and the next point also applies.

J. For <tt/col/, make sure 1) that it is fixed so as to do
<tt>setlocale(LC_CTYPE,"");</tt> and 2) to put
<tt>LC_CTYPE=ISO-8859-1</tt> in the environment.

K. For <tt/rlogin/, use option <tt/-8/.

L. For <tt/joe/,
<tt>sunsite.unc.edu:/pub/Linux/apps/editors/joe-1.0.8-linux.tar.gz</tt>
is said to work after editing the configuration file. Someone else said:
<tt/joe/: Put the <tt/-asis/ option in <tt>/isr/lib/joerc</tt> in the first column.

M. For LaTeX: <tt>&bsol;documentstyle&lsqb;isolatin&rsqb;{article}</tt>.
For LaTeX2e: <tt>&bsol;documentclass{article}&bsol;usepackage{isolatin}</tt>
where <tt>isolatin.sty</tt> is available from
<tt>ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit</tt>.

A nice discussion on the topic of ISO-8859-1 and how to manage 8-bit
characters is contained in the file <tt>grasp.insa-lyon.fr:/pub/faq/fr/accents</tt>
(in French). Another fine discussion (in English) can be found in
<tt>ftp.vlsivie.tuwien.ac.at:/pub/8bit/FAQ-ISO-8859-1</tt>, which
is mirrored in
<tt>rtfm.mit.edu:pub/usenet-by-group/comp.answers/character-sets/iso-8859-1-faq</tt>.

If you need to fix a program that behaves badly with 8-bit characters,
one thing to keep in mind is that if you have a signed char type then
characters may be negative, and using them as an array index will fail.
Several programs can be fixed by judiciously adding (unsigned char) casts.

<sect>What precisely does XFree86-2.1 do when it initializes its keymap?<p>

Since version 2.1, XFree86 will initialize its keymap from the Linux keymap,
as far as possible. However, Linux had 16 entries per key (one for each
combination of the Shift, AltGr, Ctrl, Alt modifiers) and presently has
256 entries per key, while X has 4 entries per key (one for each combination
of Shift, Mod), so some information is necessarily lost.

First <tt/X/ reads the <tt/Xconfig/ file, where definitions of the LeftAlt, RightAlt,
RightCtl, ScrollLock keys as Meta, ModeShift, Compose, ModeLock or ScrollLock
might be found - see X386keybd(1), later XFree86kbd(1).

For Mod the LeftAlt key is taken, unless RightCtl was defined as ModeShift or
ModeLock, in which case RightCtl is taken, or RightAlt was so defined, in which
case RightAlt is taken.
This determines how the 4 XFree86 meanings of a key are selected from the 16
Linux meanings.
Note that Linux today does not distinguish by default between the two Ctrl keys
or between the two Shift keys. <tt/X/ does distinguish.

Now the kernel keymap is read and the usually obvious corresponding X
bindings are made. The bindings for the "action keys" Show_Memory, Show_State,
Show_Registers, Last_Console, Console_n, Scroll_Backward, Scroll_Forward,
Caps_On and Boot are ignored, as are the dead diacriticals, and the locks
(except for ShiftLock), and the "ASCII-x" keys.

Next, the definitions in the <tt/Xconfig/ file are used. (Thus, a definition
of Compose in <tt/Xconfig/ will override its value as found in the Linux keymap.)

What happens to the strings associated with the function keys? Nothing,
X does not have such a concept. (But it is possible to define strings
for function keys in <tt/xterm/ - note however that the window manager gets the
keys first.)

I don't know how to convince <tt/xterm/ that it should use the X keymap
when Alt is pressed; it seems just to look at its resource <tt/eightBitInput/,
and depending on whether that is true or false either set the high order bit
of the character, or generate an additional Escape character
(just like setmetamode(1) does for the console).

<sect>Unusual keys and keyboards<p>

The two keys PrintScrn/SysRq and Pause/Break are special in that they
have two keycodes: the former has keycode 84 when Alt is pressed
simultaneously, and keycode 99 otherwise; the latter has keycode
101 when Ctrl is pressed simultaneously, and keycode 119 otherwise.
(Thus, it makes no sense to bind functions to Alt keycode 99 or
Ctrl keycode 119.)

If you have strange keys, that do not generate any code under Linux
(or generate messages like "unrecognized scancode"), and your kernel
is 1.1.63 or later, then you can use setkeycodes(1) to tell the kernel
about them. They won't work under X, however.
Once they have gotten a keycode from <tt/setkeycodes/, they can be assigned
a function by <tt/loadkeys/.

<sect>Examples of use of loadkeys and xmodmap<p>

Switching Caps Lock and Control on the keyboard (assuming you use
keymaps 0-15; check with <tt>dumpkeys | head -1</tt>)
<tscreen><verb>
  % loadkeys
  keymaps 0-15
  keycode 58 = Control
  keycode 29 = Caps_Lock
  %
</verb></tscreen>
Switching them under X only:
<tscreen><verb>
  % xmodmap .xmodmaprc
</verb></tscreen>
where <tt/.xmodmaprc/ contains lines
<tscreen><verb>
  remove Lock = Caps_Lock
  remove Control =  Control_L
  keysym  Control_L  =  Caps_Lock
  keysym  Caps_Lock  = Control_L
  add Lock = Caps_Lock
  add Control = Control_L
</verb></tscreen>
What is this about the key numbering? Backspace is 14 under Linux,
22 under X?  Well, the numbering can best be regarded as arbitrary;
the Linux number of a key can be found using showkey(1), and the
X number using xev(1). Often the X number will be 8 more than the
Linux number.

<sect1>`I can use only one finger to type with'<p>

"Can the Shift, Ctrl and Alt keys be made to behave as toggles?"
Yes, after saying
<tscreen><verb>
% loadkeys
keycode 29 = Control_Lock
keycode 42 = Shift_Lock
keycode 56 = Alt_Lock
%
</verb></tscreen>
the left Control, Shift and Alt keys will act as toggles.
The numbers involved are revealed by showkey
(and usually are 29, 97, 42, 54, 56, 100 for left and right control,
shift and alt, respectively), and the functions are
Control_Lock, Shift_Lock, Alt_Lock, ALtGr_Lock.

What about `sticky' modifier keys?
Well, since their introduction in the kernel (1.3.33) there has not
been a new release of the kbd package yet, so they have to be invoked
using their hexadecimal codes. For example,
<tscreen><verb>
% loadkeys
keymaps 0-15
keycode 54 = 0x0c00
keycode 97 = 0x0c02
keycode 100 = 0x0c03
%
</verb></tscreen>
will make the right Shift, Ctrl, Alt sticky versions of the left ones.

<sect>Changing the video mode<p>

As far as I know there are 6 ways to change resolution:

1. At compile time: change the line
<tscreen><verb>
        SVGA_MODE=      -DSVGA_MODE=NORMAL_VGA
</verb></tscreen>
in <tt>/usr/src/linux/Makefile</tt>.

1A. After compilation: use <tt>rdev -v</tt> - a terrible hack, but it exists.

2. At boot time: put <tt>vga=ask</tt> in the lilo config file, and lilo will
ask you what video mode you want. Once you know, put <tt/vga=/mypreference.

3. At run time:
A. Use the <tt/resizecons/ command. (This is a very primitive wrapper around
the VT_RESIZE ioctl.)
B. Use the <tt/SVGATextMode/ command. (This is a less primitive wrapper around
the VT_RESIZE ioctl.)

4. Not "on the console":
Under <tt/dosemu/, or with svgalib etc. you can change the hardware video mode
without the console driver being aware of it. Sometimes this is useful in
getting <tt/resizecons/ or <tt/SVGATextMode/ set up: use <tt/dosemu/ and some
DOS program to get into the desired videomode, dump (say from another VT) the
contents of all video hardware registers, and use that in the initialization that
<tt/resizecons/ and <tt/SVGATextMode/ require.
In some cases where the video mode has gotten into some unusable state,
starting <tt/dosemu/, relying on the BIOS to set up the video mode, and then
killing <tt/dosemu/ (with <tt/kill -9/), is the easiest way to get into shape again.

<sect1>Instructions for the use of resizecons<p>

Get svgalib and compile the program <tt/restoretextmode/.
Boot up your machine in all possible video modes
(using <tt/vga=ask/ in the lilo config file), and write
the video hardware register contents to files CxR
(C=cols, R=rows), e.g., 80x25, 132x44, etc.
Put these files in <tt>/usr/lib/kbd/videomodes</tt>.
Now <tt>resizecons 132x44</tt> will change videomode for you
(and send SIGWINCH to all processes that need to know
about this, and load another font if necessary).

At present, <tt/resizecons/ only succeeds when there is memory enough
for both the old and the new consoles at the same time.

<sect>Changing the keyboard repeat rate<p>

At startup, the Linux kernel sets the repeat rate to its maximal value.
For most keyboards this is reasonable, but for some it means that you
can hardly touch a key without getting three copies of the corresponding
symbol. Use the program kbdrate(8) to change the repeat rate, or, if
that doesn't help, edit or remove the section
<code>
     ! set the keyboard repeat rate to the max

         mov     ax,#0x0305
         xor     bx,bx           ! clear bx
         int     0x16
</code>
of <tt>/usr/src/linux/&lsqb;arch/i386/&rsqb;boot/setup.S</tt>.

<sect>Screensaving<p>

<tt>setterm -blank</tt> <it/nn/ will tell the console driver to blank the
screen after <it/nn/ minutes of inactivity. (With <it/nn/ = 0, screensaving
is turned off. In some old kernels this first took effect after the next
keyboard interrupt.)

The <tt/s/ option of xset(1) will set the X screensaving parameters:
<tt>xset s off</tt> turns off the screensaver,
<tt>xset s 10</tt> blanks the screen after 10 minutes.

The video hardware powersaving modes can be enabled/disabled
using the <tt/setvesablank/ program given in the starting comment of
<tt>/usr/src/linux/drivers/char/vesa_blank.c</tt>.

<sect>Some properties of the VT100 - application key mode<p>

: Sometimes my curser keys or keypad keys produce strange codes?

When the terminal is in application key mode the cursor keys
produce  Esc O x  and otherwise  Esc &lsqb x  where x is one of A,B,C,D.
Certain programs put the terminal in application key mode;
if you kill them with <tt/kill -9/, or if they crash, then the mode will
not be reset.
<verb>        % echo -e '\033c'  </verb>
resets all properties of the current VC. Just changing the application
key mode is done by
<verb>        % echo -e '\033[?1h' </verb>
(set) and
<verb>        % echo -e '\033[?1l' </verb>
(clear).

<sect>Hardware incompatibility<p>

Several people have noticed that they lose typed characters when
a floppy disk is active. It seems that this might be a problem with
Uni-486WB motherboards.
(Please mail me to confirm &lsqb;yes, I have the same problem&rsqb;, deny
&lsqb;no, nothing wrong with my Uni-486WB&rsqb;, modify &lsqb;My Xyzzy machine
has the same problem&rsqb;.)

tjalling@ei.ele.tue.nl (Tjalling Tjalkens) reports very similar problems
with "a no-brand GMB-486 UNP Vesa motherboard with AMD 486DX2-66 CPU" -
during floppy activity some keystrokes are lost, during floppy tape streamer
(Conner C 250 MQ) activity many keystrokes are lost.

Some people experience sporadic lockups - sometimes associated to
hard disk activity or other I/O.

ulf@rio70.bln.sni.de (Ulf Tietz) wrote:
`I have had the same problems, when I had my motherboard tuned too fast.
So I reset all the timings ( CLK, wait statements etc ) to more 
conventional values, and the problems are gone.'

bhogan@crl.com (Bill Hogan) wrote:
`If you have an AMI BIOS, you might try setting the Gate A20 emulation
parameter to 'chipset' (if you have that option). Whenever I have had
that parameter set to any of the other options on my machine
('fast', 'both', 'disabled') I have had frequent keyboard lockups.'

--------------------------------------------------------------------

Additions and corrections are welcome.
Andries Brouwer - aeb@cwi.nl

</article>

