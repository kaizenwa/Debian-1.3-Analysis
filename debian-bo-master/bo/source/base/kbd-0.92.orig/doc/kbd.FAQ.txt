  The Linux keyboard HOWTO
  Andries Brouwer, aaeebb@@ccwwii..nnll
  v2.2, 960413

  This note contains some information about the Linux keyboard and
  console, and the use of non-ASCII characters.

  11..  UUsseeffuull pprrooggrraammss


  The following packages contain keyboard or console related programs.

  kkbbdd--00..9900..ttaarr..ggzz contains llooaaddkkeeyyss, dduummppkkeeyyss, sshhoowwkkeeyy, sseettmmeettaammooddee,
  sseettlleeddss, sseettffoonntt, sshhoowwffoonntt, mmaappssccrrnn, kkbbdd__mmooddee, cchhvvtt, rreessiizzeeccoonnss,
  ddiissaalllloocc, ggeettkkeeyyccooddeess, sseettkkeeyyccooddeess.

  uuttiill--lliinnuuxx--22..55 contains sseetttteerrmm, kkbbddrraattee.

  sshheelllluuttiillss--11..88 (or ssttttyy..ttaarr..ggzz) contains ssttttyy.

  ooppeenn--11..11..ttggzz contains ooppeenn. (See also ddyynnaammiicc--vvcc--11..11..ttaarr..ggzz.)

  SSVVGGAATTeexxttMMooddee--11..00..ttaarr..ggzz contains SSVVGGAATTeexxttMMooddee, a program that
  obsoletes rreessiizzeeccoonnss.

  The X distribution contains xxmmooddmmaapp, xxsseett, kkbbdd__mmooddee.  (See also
  X386keybd(1).)


  22..  KKeeyybbooaarrdd ggeenneerraalliittiieess


  You press a key, and the keyboard controller sends scancodes to the
  kernel keyboard driver. Some keyboards can be programmed, but usually
  the scancodes corresponding to your keys are fixed.  The kernel
  keyboard driver just transmits whatever it receives to the application
  program when it is in _s_c_a_n_c_o_d_e _m_o_d_e, like when XX is running.
  Otherwise, it parses the stream of scancodes into keycodes,
  corresponding to key press or key release events.  (A single key press
  can generate up to 6 scancodes.)  These keycodes are transmitted to
  the application program when it is in _k_e_y_c_o_d_e _m_o_d_e (as used, for
  example, by sshhoowwkkeeyy).  Otherwise, these keycodesare looked up in the
  keymap, and the character or string found there is transmitted to the
  application, or the action described there is performed.  (For
  example, if one presses and releases the aa key, then the keyboard
  produces scancodes 0x1e and 0x9e, this is converted to keycodes 30 and
  158, and then transmitted as 0141, the ASCII or latin-1 code for 'a';
  if one presses and releases DDeelleettee, then the keyboard produces
  scancodes 0xe0 0x53 0xe0 0xd3, these are converted to keycodes 111 and
  239, and then transmitted as the 4-symbol sequence ESC [[ 33 ~~, all
  assuming a US keyboard and a default keymap. An example of a key
  combination to which an action is assigned is Ctrl-Alt-Del.)

  The translation between unusual scancodes and keycodes can be set
  using the utility sseettkkeeyyccooddeess - only very few people will need it.
  The translation between keycodes and characters or strings or actions,
  that is, the keymap, is set using the utility llooaaddkkeeyyss.  For details,
  see getkeycodes(8), setkeycodes(8), dumpkeys(1), loadkeys(1).

  Where it says `transmitted to the application' in the above
  description, this really means `transmitted to the terminal driver'.
  That is, further processing is just like that of text that comes in
  over a serial line.  The details of this processing are set by the
  program ssttttyy.


  33..  CCoonnssoollee ggeenneerraalliittiieess


  Conversely, when you output something to the console, it first
  undergoes the standard tty processing, and then is fed to the console
  driver.  The console driver emulates a VT100, and parses the input in
  order to recognize VT100 escape sequences (for cursor movement, clear
  screen, etc.).  The characters that are not part of an escape sequence
  are transformed using a mapping table, and the transformed bytes are
  written in video memory, where they cause the display of character
  shapes found in the video card's character ROM. One can load one's own
  fonts into character ROM using sseettffoonntt, and load the user mapping
  table using mmaappssccrrnn.  More details will be given below.


  44..  RReesseettttiinngg yyoouurr tteerrmmiinnaall


  There is garbage on the screen, or all your keystrokes are echoed as
  line drawing characters. What to do?

  Many programs will redraw the screen when ^L is typed. This might help
  when there is some modem noise or broadcast message on your screen.
  The command cclleeaarr will clear the screen.

  The command rreesseett will reset the console driver. This helps when the
  screen is full of funny graphic characters, and also if it is reduced
  to the bottom line. If you don't have this command, or if it does
  something else, make your own by putting the following two lines in an
  executable file rreesseett in your PATH:

       #!/bin/sh
       echo -e \\033c



  that is, you want to send the two characters ESC c to the console.  If
  you loaded some strange font, and want to return to the default,

       % setfont



  will do (provided you stored the default font in the default place).
  On old terminals output involving tabs may require a delay, and you
  have to say

       % stty tab3



  (see stty(1)). You can change the video mode using rreessiizzeeccoonnss or
  SSVVGGAATTeexxttMMooddee.  This usually settles the output side.  On the input
  side there are many things that might be wrong. If XX or DDOOOOMM or some
  other program using raw mode crashed, your keyboard may still be in
  raw (or mediumraw) mode, and it is difficult to give commands.  (See
  "How to get out of raw mode" below.)


  44..11..  KKeeyybbooaarrdd hhaarrddwwaarree rreesseett


  Things may be wrong on a lower level than Linux knows about.  There
  are at least two distinct lower levels (keyboard and keyboard
  controller) where one can give the command "keyboard disable" to the
  keyboard hardware.  Keyboards can often be programmed to use one out
  of three different sets of scancodes.

  However, I do not know of cases where this turned out to be a problem.

  Some keyboards have a remapping capability built in.  Stormy Henderson
  (ssttoorrmmyy@@GGhhoosstt..NNeett) writes: `If it's your keyboard accidently being
  reprogrammed, you can (on a Gateway AnyKey keyboard) press control-
  alt-suspend_macro to reset the keys to normal.'


  55..  DDeelleettee aanndd BBaacckkssppaaccee



  55..11..  HHooww ttoo tteellll UUnniixx wwhhaatt cchhaarraacctteerr yyoouu wwaanntt ttoo uussee ttoo ddeelleettee tthhee
  llaasstt ttyyppeedd cchhaarraacctteerr



       % stty erase ^?



  If the character is erased, but in a funny way, then something is
  wrong with your tty settings. If eecchhoopprrtt is set, then erased
  characters are enclosed between \\ and //.  If eecchhooee is not set, then
  the erase char is echoed (which is reasonable when it is a printing
  character, like #).  Most people will want ssttttyy eecchhooee --eecchhoopprrtt. Saying
  ssttttyy ssaannee will do this and more. Saying ssttttyy --aa shows your current
  settings.  How come this is not right by default? It is, if you use
  the right ggeettttyy.

  Note that many programs (like bbaasshh, eemmaaccss etc.) have their own
  keybindings (defined in ~~//..iinnppuuttrrcc, ~~//..eemmaaccss etc.)  and are unaffected
  by the setting of the erase character.


  55..11..11..  ``GGeettttyy uusseedd ttoo ddoo tthhee rriigghhtt tthhiinngg wwiitthh DDEELL aanndd BBSS bbuutt iiss
  bbrrookkeenn nnooww??''


  Earlier, the console driver would do BS Space BS (\\001100\\004400\\001100) when
  it got a DEL (\\117777).  Nowadays, DEL's are ignored (as they should be,
  since the driver emulates a vt100). Get a better getty, i.e., one that
  does not output DEL.


  55..11..22..  ``LLooggiinn bbeehhaavveess ddiiffffeerreennttllyy aatt tthhee ffiirrsstt aanndd sseeccoonndd llooggiinn
  aatttteemmppttss??''


  At the first attempt, you are talking to ggeettttyy. At the second attempt,
  you are talking to llooggiinn, a different program.


  55..22..  HHooww ttoo tteellll LLiinnuuxx wwhhaatt ccooddee ttoo ggeenneerraattee wwhheenn aa kkeeyy iiss pprreesssseedd


  On the console, or, more precisely, when not in (MEDIUM)RAW mode, use

       % loadkeys mykeys.map



  and under X use

  % xmodmap mykeys.xmap



  Note that (since XFree86-2.1) X reads the Linux settings of the
  keymaps when initialising the X keymap. Although the two systems are
  not 100% compatible, this should mean that in many cases the use of
  xxmmooddmmaapp has become superfluous.

  If, for example, you want your Backspace key to generate BackSpace
  (^H), instead of the default Delete, then

       % loadkeys
       keycode 14 = BackSpace
       %



  will do.


  55..22..11..  ``WWhhyy ddooeessnn''tt tthhee BBaacckkssppaaccee kkeeyy ggeenneerraattee BBaacckkSSppaaccee bbyy ddeeffaauulltt??''


  (i) Because the VT100 had a Delete key above the Enter key.

  (ii) Because Linus decided so.


  55..33..  HHooww ttoo tteellll XX ttoo iinntteerrcchhaannggee DDeelleettee aanndd BBaacckkssppaaccee



       % xmodmap -e "keysym BackSpace = Delete" -e "keysym Delete = BackSpace"



  Or, if you just want the Backspace key to generate a BackSpace:

       % xmodmap -e "keycode 22 = BackSpace"



  Or, if you just want the Delete key to generate a Delete:

       % xmodmap -e "keycode 107 = Delete"



  (but usually this is the default binding already).


  55..44..  HHooww ttoo tteellll eemmaaccss wwhhaatt ttoo ddoo wwhheenn iitt rreecceeiivveess aa DDeelleettee oorr
  BBaacckkssppaaccee


  Put in your ..eemmaaccss file lines like

         (global-set-key "\?" 'delete-backward-char)
         (global-set-key "\C-h" 'help-command)



  Of course you can bind other commands to other keys in the same way.


  55..55..  HHooww ttoo tteellll eemmaaccss ttoo iinntteerrcchhaannggee DDeelleettee aanndd BBaacckkssppaaccee


  Put in your ..eemmaaccss file lines

         (setq keyboard-translate-table (make-string 128 0))
         (let ((i 0))
         (while (< i 128)
             (aset keyboard-translate-table i i)
             (setq i (1+ i))))
         (aset keyboard-translate-table ?\b ?\^?)
         (aset keyboard-translate-table ?\^? ?\b)




  55..66..  HHooww ttoo tteellll kkeerrmmiitt ttoo iinntteerrcchhaannggee DDeelleettee aanndd BBaacckkssppaaccee


  Put in your ..kkeerrmmrrcc file the lines

         set key \127 \8
         set key \8 \127




  55..77..  HHooww ttoo tteellll xxtteerrmm aabboouutt yyoouurr ffaavvoouurriittee ttttyy mmooddeess


  Normally xterm will inherit the tty modes from its invoker.  Under
  xxddmm, the default erase and kill characters are ## and @@, as in good old
  Unix Version 6.  If you don't like that, you might put something like

         XTerm*ttymodes: erase ^? kill ^U intr ^C quit ^\ eof ^D susp ^Z start ^Q stop ^S eol ^@



  in //uussrr//lliibb//XX1111//aapppp--ddeeffaauullttss//XXTTeerrmm or in $$HHOOMMEE//..XXrreessoouurrcceess, assuming
  that you have a line

         xrdb $HOME/.Xresources



  in your $$HHOOMMEE//..xxiinniittrrcc.


  55..88..  HHooww ttoo tteellll xxmmoossaaiicc tthhaatt tthhee BBaacckkssppaaccee kkeeyy ggeenneerraatteess aa DDEELL


  Putting

         *XmText.translations: #override\n\
                <Key>osfDelete: delete-previous-character()
         *XmTextField.translations: #override\n\
                 <Key>osfDelete: delete-previous-character()



  in your $$HHOOMMEE//..XXrreessoouurrcceess helps.

  The netscape FAQ, however, says:



          Why doesn't my Backspace key work in text fields?
          By default, Linux and XFree86 come with the Backspace and Delete keys
          misconfigured. All Motif programs (including, of course, Netscape
          Navigator) will malfunction in the same way.

          The Motif spec says that Backspace is supposed to delete the previous
          character and Delete is supposed to delete the following character.
          Linux and XFree86 come configured with both the Backspace and Delete
          keys generating Delete.

          You can fix this by using any one of the xmodmap, xkeycaps, or
          loadkeys programs to make the key in question generate the BackSpace
          keysym instead of Delete.

          You can also fix it by having a .motifbind file; see the man page
          for VirtualBindings(3).

          Note: Don't use the *XmText.translations or *XmTextField.translations
          resources to attempt to fix this problem. If you do, you will blow
          away Netscape Navigator's other text-field key bindings.



  55..99..  WWhhaatt aabboouutt tteerrmmccaapp aanndd tteerrmmiinnffoo??


  When people have problems with backspace, they tend to look at their
  termcap (or terminfo) entry for the terminal, and indeed, there does
  exist a kb (or kbs) capability describing the code generated by the
  Backspace key.  However, not many programs use it, so unless you are
  having problems with one particular program only, probably the fault
  is elsewhere.  Of course it is a good idea anyway to correct your
  termcap (terminfo) entry.  See also below under "The TERM variable".


  66..  TThhee ccoonnssoollee cchhaarraacctteerr sseettss


  The kernel knows about 4 translations of bytes into console-screen
  symbols.  The four tables are: a) Latin1 -> PC,  b) VT100 graphics ->
  PC, c) PC -> PC, d) user-defined.

  There are two character sets, called G0 and G1, and one of them is the
  current character set. (Initially G0.)  Typing ^N causes G1 to become
  current, ^O causes G0 to become current.

  These variables G0 and G1 point at a translation table, and can be
  changed by the user. Initially they point at tables a) and b),
  respectively.  The sequences ESC ( B and ESC ( 0 and ESC ( U and ESC (
  K cause G0 to point at translation table a), b), c) and d),
  respectively.  The sequences ESC ) B and ESC ) 0 and ESC ) U and ESC )
  K cause G1 to point at translation table a), b), c) and d),
  respectively.

  The sequence ESC c causes a terminal reset, which is what you want if
  the screen is all garbled. The oft-advised eecchhoo ^^VV^^OO will only make G0
  current, but there is no guarantee that G0 points at table a).  In
  some distributions there is a program reset(1) that just does eecchhoo
  ^^[[cc.  If your termcap entry for the console is correct (and has an
  entry ::rrss==\\EEcc::), then also sseetttteerrmm --rreesseett will work.

  The user-defined mapping table can be set using mapscrn(8).  The
  result of the mapping is that if a symbol c is printed, the symbol ss ==
  mmaapp[[cc]] is sent to the video memory. The bitmap that corresponds to ss
  is found in the character ROM, and can be changed using setfont(8).

  77..  CCoonnssoollee sswwiittcchhiinngg


  By default, console switching is done using Alt-Fn or Ctrl-Alt-Fn.
  Under XX (or recent versions of ddoosseemmuu), only Ctrl-Alt-Fn works.

  XFree86 1.3 does not know that Alt is down when you switch to the X
  window. Thus, you cannot switch immediately to some other VT again but
  have to release Alt first.  In the other direction this should work:
  the kernel always keeps track of the up/down status of all keys. (As
  far as possible: on some keyboards some keys do not emit a scancode
  when pressed (e.g.: the PFn keys of a FOCUS 9000) or released (e.g.:
  the Pause key of many keyboards).)

  XFree86 1.3 saves the fonts loaded in the character ROMs when started,
  and restores it on a console switch. Thus, the result of sseettffoonntt on a
  VT is wiped out when you go to X and back.  Using sseettffoonntt under X will
  lead to funny results.

  One can change under program control using the cchhvvtt command.


  77..11..  CChhaannggiinngg tthhee nnuummbbeerr ooff VViirrttuuaall CCoonnssoolleess


  This question still comes up from time to time, but the answer is: you
  already have enough of them.  Since kernel version 1.1.54, there are
  between 1 and 63 virtual consoles. A new one is created as soon as it
  is opened. It is removed by the utility ddiissaalllloocc (but it can be
  removed only when no processes are associated to it anymore, and no
  text on it has been selected by programs like sseelleeccttiioonn or ggppmm).

  For older kernels, change the line

       #define NR_CONSOLES     8



  in iinncclluuddee//lliinnuuxx//ttttyy..hh (don't increase this number beyond 63), and
  recompile the kernel. You might have to create the devices with
  MMAAKKEEDDEEVV or mmkknnoodd ttttyyN cc 44 N where N denotes the tty number.  If you
  want the new VCs to run ggeettttyy, add lines in //eettcc//iinniittttaabb.

  When the consoles are allocated dynamically, it is usually easiest to
  have only one or two running ggeettttyy. More are opened by ooppeenn --ll --ss
  bbaasshh. Unused consoles (without associated processes) are disallocated
  using ddiissaalllloocc.

  If you have ssppaawwnn__llooggiinn from kkbbdd--00..9900..ttaarr..ggzz and you put

               loadkeys << EOF
               alt keycode 103 = Spawn_Console
               EOF
               spawn_login &



  in //eettcc//rrcc..llooccaall, then typing Alt-UpArrow will create a fresh VC
  running llooggiinn (and switch to it). See also ooppeenn--11..33..ttggzz.

  You can only login as "root" on terminals listed in //eettcc//sseeccuurreettttyy.





  88..  CCttrrll--AAlltt--DDeell aanndd ootthheerr ssppeecciiaall kkeeyy ccoommbbiinnaattiioonnss



  88..11..  CCttrrll--AAlltt--DDeell ((BBoooott))

  If you press Ctrl-Alt-Del (or whatever key was assigned the keysym
  Boot by loadkeys) then either the machine reboots immediately (without
  sync), or iinniitt is sent a SIGINT. The former behaviour is the default.
  The default can be changed by root, using the system call reboot(),
  see ctrlaltdel(8).  Some iinniitt's change the default. What happens when
  iinniitt gets SIGINT depends on the version of iinniitt used - often it will
  be determined by the pf entry in //eettcc//iinniittttaabb (which means that you
  can run an arbitrary program in this case).  In the current kernel
  Ctrl-AltGr-Del is no longer by default assigned to Boot.


  88..22..  OOtthheerr ccoommbbiinnaattiioonnss

  Name            Default binding
  -------------------------------
  Show_Memory     Shift-Scrollock
  Show_Registers  AltGr-ScrollLock
  Show_State      Ctrl-ScrollLock
  Console_n       Alt-Fn and Ctrl-Alt-Fn  (1 <= n <= 12)
  Console_{n+12}  AltGr-Fn                (1 <= n <= 12)
  Incr_Console    Alt-RightArrow
  Decr_Console    Alt-LeftArrow
  Last_Console    Alt[Gr]-PrintScreen
  Scroll_Backward Shift-PageUp
  Scroll_Forward  Shift-PageDown
  Caps_On                                 (CapsLock is a toggle; this key sets)
  Compose         Ctrl-.



  88..33..  XX CCoommbbiinnaattiioonnss

  Ctrl-Alt-Fn     Switch to VT n
  Ctrl-Alt-KP+    Next mode
  Ctrl-Alt-KP-    Previous mode
  Ctrl-Alt-Backspace      Kill X

  On some motherboards, Ctrl-Alt-KP- and Ctrl-Alt-KP+ will be equivalent
  to pressing the Turbo button. That is, both will produce the scancodes
  1d 38 4a ca b8 9d and 1d 38 4e ce b8 9d, and both will switch between
  Turbo (>= 25MHz) and non-Turbo (8 or 12 MHz).  (Often these key
  combinations only function this way when enabled by jumpers on the
  motherboard.)

  Perry F Nguyen (pfnguyen@netcom22.netcom.com) writes: AMI BIOS has a
  feature that locks up the keyboard and flashes the LED's if the Ctrl-
  Alt-Backspace combination is pressed while a BIOS password is enabled,
  until the CMOS/BIOS password is typed in.


  88..44..  DDoosseemmuu CCoommbbiinnaattiioonnss

  Ctrl-Alt-Fn     Switch to VT n (from version 0.50; earlier Alt-Fn)
  Ctrl-Alt-PgDn   Kill dosemu (when in RAW keyboard mode)
  (and many other combinations - see the dosemu documentation)





  88..55..  CCoommppoossiinngg ssyymmbboollss


  One symbol may be constructed using several keystrokes.

     LeftAlt-press, followed by a decimal number typed on the keypad,
     followed by LeftAlt-release, yields the symbol with code given by
     this number.  (In Unicode mode this same mechanism, but then with 4
     hexadecimal digits, may be used to define a Unicode symbol.)

     A dead diacritic followed by a symbol, yields that symbol adorned
     with that diacritic. If the combination is undefined, both keys are
     taken separately.  Which keys are dead diacritics is user-settable;
     none is by default.  Five dead diacritics can be defined (using
     loadkeys(1)): dead_grave, dead_acute, dead_circumflex, dead_tilde,
     dead_diaeresis.  Precisely what this adorning means is also user-
     settable: dead-diacritic, symbol is equivalent to Compose +
     diacritic + symbol.

     Compose followed by two symbols yields a combination symbol. These
     combinations are user-settable. Today there are 68 combinations
     defined by default; you can see them by saying "dumpkeys | grep
     compose".

     Then there are `Sticky' modifier keys (since 1.3.33). For example,
     one can type ^C as SControl, C and Ctrl-Alt-BackSpace as SControl,
     SAlt, BackSpace.

  Note that there are at least three such composition mechanisms:

  1. The Linux keyboard driver mechanism, used in conjunction with
     loadkeys.

  2. The X mechanism - see X386keybd(1), later XFree86kbd(1).  Under
     X11R6: edit //uussrr//XX1111RR66//lliibb//XX1111//llooccaallee//iissoo88885599--11//CCoommppoossee.

  3. The emacs mechanism obtained by loading "iso-insert.el".

     For X the order of the two symbols is arbitrary: both Compose-,-c
     and Compose-c-, yield a c-cedilla; for Linux and emacs only the
     former sequence works by default. For X the list of compose
     combinations is fixed. Linux and emacs are flexible.  The three
     default lists are somewhat similar, but the details are different.


  99..  VVaarriioouuss pprrooppeerrttiieess ooff tthhee ccoonnssoollee


  See loadkeys(1), setleds(1), setmetamode(1) for the codes generated by
  the various keys and the setting of leds when not under X. Under X,
  see xmodmap(1).

  See setterm(1), kbdrate(8) for properties such as foreground and
  background colors, screen blanking, character repeat rate when not
  under X.  Under X, see xset(1), also for key click and bell volume.

  The file //eettcc//tteerrmmccaapp defines the escape sequences used by many
  programs addressing the console (or any other terminal). A more modern
  version is found in //uussrr//lliibb//tteerrmmiinnffoo. (See terminfo(5). Terminfo
  files are compiled by the terminfo compiler //uussrr//lliibb//tteerrmmiinnffoo//ttiicc, see
  tic(1).)

  (On my machine) //ddeevv//ccoonnssoollee is a symbolic link to //ddeevv//ttttyy00, and the
  kernel regards //ddeevv//ttttyy00 as a synonym for the current VT.  XFree86 1.3
  changes the owner of //ddeevv//ttttyy00, but does not reset this after
  finishing. Thus, dumpkeys might fail because someone else owns
  //ddeevv//ttttyy00; in such a case you might run X first.


  1100..  HHooww ttoo ggeett oouutt ooff rraaww mmooddee


  If some program using K_RAW keyboard mode exits without restoring the
  keyboard mode to K_XLATE, then it is difficult to do anything - not
  even Ctrl-Alt-Del works. However, it is sometimes possible to avoid
  hitting the reset button.  (And desirable as well: your users may get
  angry if you kill their Hack game by rebooting; you might also damage
  your file system.)  Easy solutions involve logging in from another
  terminal or another machine and doing kkbbdd__mmooddee --aa.  The procedure
  below assumes that no X is running, that the display is in text mode,
  and that you are at your bash prompt, that you are using a US keyboard
  layout, and that your interrupt character is Ctrl-C.

  Step 1. Start X.  As follows: press 2 (and don't release), press F12
  (and don't release) and immediately afterwards press = . This starts
  X.  (Explanation: if a key press produces keycode K, then the key
  release produces keycode K+128. Probably your shell does not like
  these high characters, so we avoid generating them by not releasing
  any key.  However, we have to be quick, otherwise key repeat starts.
  The digit 2 produces a Ctrl-C that discards previous junk, the F12
  produces an X and the = a Return.)  Probably your screen will be grey
  now, since no ..xxiinniittrrcc was specified.  However, Ctrl-Alt-Fn will work
  and you can go to another VT.  (Ctrl-Alt-Backspace also works, but
  that exits X, and gets you back into the previous state, which is not
  what you want.)

  Step 2. Setup to change the keyboard mode.  (For example, by sslleeeepp 55;;
  kkbbdd__mmooddee --aa.)

  Step 3. Leave X again.  Alt-Fx (often Alt-F7) brings you back to X,
  and then Ctrl-Alt-Backspace exits X. Within 5 seconds your keyboard
  will be usable again.

  If you want to prepare for the occasion, then make \\221155AA\\330011 (3
  symbols) an alias for kkbbdd__mmooddee --aa.  Now just hitting = F7 = (3
  symbols) will return you to sanity.


  1111..  TThhee TTEERRMM vvaarriiaabbllee


  Many programs use the TTEERRMM variable and the database //eettcc//tteerrmmccaapp or
  //uussrr//lliibb//tteerrmmiinnffoo//** to decide which strings to send for clear screen,
  move cursor, etc., and sometimes also to decide which string is sent
  by the users backspace key, function keys etc.  This value is first
  set by the kernel (for the console).  Usually, this variable is re-set
  by ggeettttyy, using //eettcc//ttttyyttyyppee or the argument specified in
  //eettcc//iinniittttaabb.  Sometimes, it is also set in //eettcc//pprrooffiillee.

  Older systems use TTEERRMM==ccoonnssoollee or TTEERRMM==ccoonn8800xx2255. Newer systems (with
  ncurses 1.8.6) use the more specific TTEERRMM==lliinnuuxx or TTEERRMM==lliinnuuxx--8800xx2255.
  However, old versions of sseetttteerrmm test for TTEERRMM==ccoonn** and hence fail to
  work with TTEERRMM==lliinnuuxx.

  Since kernel version 1.3.2, the kernel default for the console is
  TTEERRMM==lliinnuuxx.

  If you have a termcap without entry for linux, add the word linux to
  the entry for the console:

               console|con80x25|linux:\

  and make //uussrr//lliibb//tteerrmmiinnffoo//ll//lliinnuuxx a copy of or symbolic link to
  //uussrr//lliibb//tteerrmmiinnffoo//cc//ccoonnssoollee.


  1111..11..  TTeerrmmiinnffoo


  The terminfo entry for the linux console from ncurses 1.8.6 misses the
  entry kkiicchh11==\\EE[[22~~, needed by some programs.  Edit the file and ttiicc it.


  1122..  HHooww ttoo mmaakkee ootthheerr pprrooggrraammss wwoorrkk wwiitthh nnoonn--AASSCCIIII cchhaarrss


  In the bad old days this used to be quite a hassle. Every separate
  program had to be convinced individually to leave your bits alone.
  Not that all is easy now, but recently a lot of gnu utilities have
  learned to react to LLCC__CCTTYYPPEE==iissoo__88885599__11 or LLCC__CCTTYYPPEE==iissoo--88885599--11.  Try
  this first, and if it doesn't help look at the hints below.

  First of all, the 8-th bit should survive the kernel input processing,
  so make sure to have ssttttyy ccss88 --iissttrriipp --ppaarreennbb set.

  A. For eemmaaccss, put lines

               (standard-display-european t)
               (set-input-mode nil nil 1)
               (require 'iso-syntax)



  and perhaps also

               (load-file "iso-insert.el")
               (define-key global-map [?\C-.] 8859-1-map)



  into your $$HHOOMMEE//..eemmaaccss.  (The latter line will not work under xxtteerrmm,
  if you use eemmaaccss --nnww, but in that case you can put

               XTerm*VT100.Translations:       #override\n\
               Ctrl <KeyPress> . : string("\0308")



  in your ..XXrreessoouurrcceess.)

  B. For lleessss, put LLEESSSSCCHHAARRSSEETT==llaattiinn11 in the environment.  This is also
  what you need if you see \\225555 or <<AADD>> in man output: some versions of
  lleessss will render the soft hyphen (octal 0255, hex 0xAD) this way when
  not given permission to output Latin-1.

  C. For llss, give the option --NN. (Probably you want to make an alias.)

  D. For bbaasshh (version 1.13.*), put

               set meta-flag on
               set convert-meta off



  and, according to the Danish HOWTO,

               set output-meta on

  into your $$HHOOMMEE//..iinnppuuttrrcc.

  E. For ttccsshh, use

               setenv LANG     US_en
               setenv LC_CTYPE iso_8859_1



  If you have nls on your system, then the corresponding routines are
  used.  Otherwise ttccsshh will assume iso_8859_1, regardless of the values
  given to LANG and LC_CTYPE. See the section NATIVE LANGUAGE SYSTEM in
  tcsh(1).  (The Danish HOWTO says: sseetteennvv LLCC__CCTTYYPPEE IISSOO--88885599--11;; ssttttyy
  ppaassss88)

  F. For fflleexx, give the option --88 if the parser it generates must be
  able to handle 8-bit input. (Of course it must.)

  G. For eellmm, set ddiissppllaayycchhaarrsseett to IISSOO--88885599--11.  (Danish HOWTO: LLAANNGG==CC
  and LLCC__CCTTYYPPEE==IISSOO--88885599--11)

  H. For programs using curses (such as llyynnxx) David Sibley reports: The
  regular curses package uses the high-order bit for reverse video mode
  (see flag _STANDOUT defined in //uussrr//iinncclluuddee//ccuurrsseess..hh).  However,
  nnccuurrsseess seems to be 8-bit clean and does display iso-latin-8859-1
  correctly.

  I. For programs using ggrrooffff (such as mmaann), make sure to use --TTllaattiinn11
  instead of --TTaasscciiii. Old versions of the program mmaann also use ccooll, and
  the next point also applies.

  J. For ccooll, make sure 1) that it is fixed so as to do
  sseettllooccaallee((LLCC__CCTTYYPPEE,,""""));; and 2) to put LLCC__CCTTYYPPEE==IISSOO--88885599--11 in the
  environment.

  K. For rrllooggiinn, use option --88.

  L. For jjooee,
  ssuunnssiittee..uunncc..eedduu:://ppuubb//LLiinnuuxx//aappppss//eeddiittoorrss//jjooee--11..00..88--lliinnuuxx..ttaarr..ggzz is said
  to work after editing the configuration file. Someone else said: jjooee:
  Put the --aassiiss option in //iissrr//lliibb//jjooeerrcc in the first column.

  M. For LaTeX: \\ddooccuummeennttssttyyllee[[iissoollaattiinn]]{{aarrttiiccllee}}.  For LaTeX2e:
  \\ddooccuummeennttccllaassss{{aarrttiiccllee}}\\uusseeppaacckkaaggee{{iissoollaattiinn}} where iissoollaattiinn..ssttyy is
  available from ffttpp::////ffttpp..vvllssiivviiee..ttuuwwiieenn..aacc..aatt//ppuubb//88bbiitt.

  A nice discussion on the topic of ISO-8859-1 and how to manage 8-bit
  characters is contained in the file ggrraasspp..iinnssaa--
  llyyoonn..ffrr:://ppuubb//ffaaqq//ffrr//aacccceennttss (in French). Another fine discussion (in
  English) can be found in rrttffmm..mmiitt..eedduu::ppuubb//uusseenneett--bbyy--
  ggrroouupp//ccoommpp..aannsswweerrss//cchhaarraacctteerr--sseettss//iissoo--88885599--11--ffaaqq.  And another(?), in
  ffttpp..vvllssiivviiee..ttuuwwiieenn..aacc..aatt:://ppuubb//88bbiitt//FFAAQQ--IISSOO--88885599--11.

  If you need to fix a program that behaves badly with 8-bit characters,
  one thing to keep in mind is that if you have a signed char type then
  characters may be negative, and using them as an array index will
  fail.  Several programs can be fixed by judiciously adding (unsigned
  char) casts.


  1133..  WWhhaatt pprreecciisseellyy ddooeess XXFFrreeee8866--22..11 ddoo wwhheenn iitt iinniittiiaalliizzeess iittss
  kkeeyymmaapp??


  Since version 2.1, XFree86 will initialize its keymap from the Linux
  keymap, as far as possible. However, Linux had 16 entries per key (one
  for each combination of the Shift, AltGr, Ctrl, Alt modifiers) and
  presently has 256 entries per key, while X has 4 entries per key (one
  for each combination of Shift, Mod), so some information is
  necessarily lost.

  First XX reads the XXccoonnffiigg file, where definitions of the LeftAlt,
  RightAlt, RightCtl, ScrollLock keys as Meta, ModeShift, Compose,
  ModeLock or ScrollLock might be found - see X386keybd(1), later
  XFree86kbd(1).

  For Mod the LeftAlt key is taken, unless RightCtl was defined as
  ModeShift or ModeLock, in which case RightCtl is taken, or RightAlt
  was so defined, in which case RightAlt is taken.  This determines how
  the 4 XFree86 meanings of a key are selected from the 16 Linux
  meanings.  Note that Linux today does not distinguish by default
  between the two Ctrl keys or between the two Shift keys. XX does
  distinguish.

  Now the kernel keymap is read and the usually obvious corresponding X
  bindings are made. The bindings for the "action keys" Show_Memory,
  Show_State, Show_Registers, Last_Console, Console_n, Scroll_Backward,
  Scroll_Forward, Caps_On and Boot are ignored, as are the dead
  diacriticals, and the locks (except for ShiftLock), and the "ASCII-x"
  keys.

  Next, the definitions in the XXccoonnffiigg file are used. (Thus, a
  definition of Compose in XXccoonnffiigg will override its value as found in
  the Linux keymap.)

  What happens to the strings associated with the function keys?
  Nothing, X does not have such a concept. (But it is possible to define
  strings for function keys in xxtteerrmm - note however that the window
  manager gets the keys first.)

  I don't know how to convince xxtteerrmm that it should use the X keymap
  when Alt is pressed; it seems just to look at its resource
  eeiigghhttBBiittIInnppuutt, and depending on whether that is true or false either
  set the high order bit of the character, or generate an additional
  Escape character (just like setmetamode(1) does for the console).


  1144..  UUnnuussuuaall kkeeyyss aanndd kkeeyybbooaarrddss


  The two keys PrintScrn/SysRq and Pause/Break are special in that they
  have two keycodes: the former has keycode 84 when Alt is pressed
  simultaneously, and keycode 99 otherwise; the latter has keycode 101
  when Ctrl is pressed simultaneously, and keycode 119 otherwise.
  (Thus, it makes no sense to bind functions to Alt keycode 99 or Ctrl
  keycode 119.)

  If you have strange keys, that do not generate any code under Linux
  (or generate messages like "unrecognized scancode"), and your kernel
  is 1.1.63 or later, then you can use setkeycodes(1) to tell the kernel
  about them. They won't work under X, however.  Once they have gotten a
  keycode from sseettkkeeyyccooddeess, they can be assigned a function by llooaaddkkeeyyss.


  1155..  EExxaammpplleess ooff uussee ooff llooaaddkkeeyyss aanndd xxmmooddmmaapp


  Switching Caps Lock and Control on the keyboard (assuming you use
  keymaps 0-15; check with dduummppkkeeyyss || hheeaadd --11)



    % loadkeys
    keymaps 0-15
    keycode 58 = Control
    keycode 29 = Caps_Lock
    %



  Switching them under X only:

         % xmodmap .xmodmaprc



  where ..xxmmooddmmaapprrcc contains lines

         remove Lock = Caps_Lock
         remove Control =  Control_L
         keysym  Control_L  =  Caps_Lock
         keysym  Caps_Lock  = Control_L
         add Lock = Caps_Lock
         add Control = Control_L



  What is this about the key numbering? Backspace is 14 under Linux, 22
  under X?  Well, the numbering can best be regarded as arbitrary; the
  Linux number of a key can be found using showkey(1), and the X number
  using xev(1). Often the X number will be 8 more than the Linux number.


  1155..11..  ``II ccaann uussee oonnllyy oonnee ffiinnggeerr ttoo ttyyppee wwiitthh''


  "Can the Shift, Ctrl and Alt keys be made to behave as toggles?"  Yes,
  after saying

       % loadkeys
       keycode 29 = Control_Lock
       keycode 42 = Shift_Lock
       keycode 56 = Alt_Lock
       %



  the left Control, Shift and Alt keys will act as toggles.  The numbers
  involved are revealed by showkey (and usually are 29, 97, 42, 54, 56,
  100 for left and right control, shift and alt, respectively), and the
  functions are Control_Lock, Shift_Lock, Alt_Lock, ALtGr_Lock.

  What about `sticky' modifier keys?  Well, since their introduction in
  the kernel (1.3.33) there has not been a new release of the kbd
  package yet, so they have to be invoked using their hexadecimal codes.
  For example,

       % loadkeys
       keymaps 0-15
       keycode 54 = 0x0c00
       keycode 97 = 0x0c02
       keycode 100 = 0x0c03
       %



  will make the right Shift, Ctrl, Alt sticky versions of the left ones.

  1166..  CChhaannggiinngg tthhee vviiddeeoo mmooddee


  As far as I know there are 6 ways to change resolution:

  1. At compile time: change the line

               SVGA_MODE=      -DSVGA_MODE=NORMAL_VGA



  in //uussrr//ssrrcc//lliinnuuxx//MMaakkeeffiillee.

  1A. After compilation: use rrddeevv --vv - a terrible hack, but it exists.

  2. At boot time: put vvggaa==aasskk in the lilo config file, and lilo will
  ask you what video mode you want. Once you know, put vvggaa==mypreference.

  3. At run time: A. Use the rreessiizzeeccoonnss command. (This is a very
  primitive wrapper around the VT_RESIZE ioctl.)  B. Use the
  SSVVGGAATTeexxttMMooddee command. (This is a less primitive wrapper around the
  VT_RESIZE ioctl.)

  4. Not "on the console": Under ddoosseemmuu, or with svgalib etc. you can
  change the hardware video mode without the console driver being aware
  of it. Sometimes this is useful in getting rreessiizzeeccoonnss or SSVVGGAATTeexxttMMooddee
  set up: use ddoosseemmuu and some DOS program to get into the desired
  videomode, dump (say from another VT) the contents of all video
  hardware registers, and use that in the initialization that rreessiizzeeccoonnss
  and SSVVGGAATTeexxttMMooddee require.  In some cases where the video mode has
  gotten into some unusable state, starting ddoosseemmuu, relying on the BIOS
  to set up the video mode, and then killing ddoosseemmuu (with kkiillll --99), is
  the easiest way to get into shape again.


  1166..11..  IInnssttrruuccttiioonnss ffoorr tthhee uussee ooff rreessiizzeeccoonnss


  Get svgalib and compile the program rreessttoorreetteexxttmmooddee.  Boot up your
  machine in all possible video modes (using vvggaa==aasskk in the lilo config
  file), and write the video hardware register contents to files CxR
  (C=cols, R=rows), e.g., 80x25, 132x44, etc.  Put these files in
  //uussrr//lliibb//kkbbdd//vviiddeeoommooddeess.  Now rreessiizzeeccoonnss 113322xx4444 will change videomode
  for you (and send SIGWINCH to all processes that need to know about
  this, and load another font if necessary).

  At present, rreessiizzeeccoonnss only succeeds when there is memory enough for
  both the old and the new consoles at the same time.


  1177..  CChhaannggiinngg tthhee kkeeyybbooaarrdd rreeppeeaatt rraattee


  At startup, the Linux kernel sets the repeat rate to its maximal
  value.  For most keyboards this is reasonable, but for some it means
  that you can hardly touch a key without getting three copies of the
  corresponding symbol. Use the program kbdrate(8) to change the repeat
  rate, or, if that doesn't help, edit or remove the section
  ______________________________________________________________________
       ! set the keyboard repeat rate to the max

           mov     ax,#0x0305
           xor     bx,bx           ! clear bx
           int     0x16
  ______________________________________________________________________

  of //uussrr//ssrrcc//lliinnuuxx//[[aarrcchh//ii338866//]]bboooott//sseettuupp..SS.


  1188..  SSccrreeeennssaavviinngg


  sseetttteerrmm --bbllaannkk _n_n will tell the console driver to blank the screen
  after _n_n minutes of inactivity. (With _n_n = 0, screensaving is turned
  off. In some old kernels this first took effect after the next
  keyboard interrupt.)

  The ss option of xset(1) will set the X screensaving parameters: xxsseett ss
  ooffff turns off the screensaver, xxsseett ss 1100 blanks the screen after 10
  minutes.

  The video hardware powersaving modes can be enabled/disabled using the
  sseettvveessaabbllaannkk program given in the starting comment of
  //uussrr//ssrrcc//lliinnuuxx//ddrriivveerrss//cchhaarr//vveessaa__bbllaannkk..cc.


  1199..  SSoommee pprrooppeerrttiieess ooff tthhee VVTT110000 -- aapppplliiccaattiioonn kkeeyy mmooddee


  : Sometimes my curser keys or keypad keys produce strange codes?

  When the terminal is in application key mode the cursor keys produce
  Esc O x  and otherwise  Esc [ x  where x is one of A,B,C,D.  Certain
  programs put the terminal in application key mode; if you kill them
  with kkiillll --99, or if they crash, then the mode will not be reset.
          % echo -e '\033c'

  resets all properties of the current VC. Just changing the application
  key mode is done by
          % echo -e '\033[?1h'

  (set) and
          % echo -e '\033[?1l'

  (clear).


  2200..  HHaarrddwwaarree iinnccoommppaattiibbiilliittyy


  Several people have noticed that they lose typed characters when a
  floppy disk is active. It seems that this might be a problem with
  Uni-486WB motherboards.  (Please mail me to confirm [yes, I have the
  same problem], deny [no, nothing wrong with my Uni-486WB], modify [My
  Xyzzy machine has the same problem].)

  tjalling@ei.ele.tue.nl (Tjalling Tjalkens) reports very similar
  problems with "a no-brand GMB-486 UNP Vesa motherboard with AMD
  486DX2-66 CPU" - during floppy activity some keystrokes are lost,
  during floppy tape streamer (Conner C 250 MQ) activity many keystrokes
  are lost.

  Some people experience sporadic lockups - sometimes associated to hard
  disk activity or other I/O.

  ulf@rio70.bln.sni.de (Ulf Tietz) wrote: `I have had the same problems,
  when I had my motherboard tuned too fast.  So I reset all the timings
  ( CLK, wait statements etc ) to more conventional values, and the
  problems are gone.'

  bhogan@crl.com (Bill Hogan) wrote: `If you have an AMI BIOS, you might
  try setting the Gate A20 emulation parameter to 'chipset' (if you have
  that option). Whenever I have had that parameter set to any of the
  other options on my machine ('fast', 'both', 'disabled') I have had
  frequent keyboard lockups.'

  --------------------------------------------------------------------

  Additions and corrections are welcome.  Andries Brouwer - aeb@cwi.nl



























































