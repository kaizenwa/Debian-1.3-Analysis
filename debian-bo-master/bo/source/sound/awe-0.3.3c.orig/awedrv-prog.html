<title>AWEDRV PROGRAMMING NOTES</title>
<body>

<center>
<hr>
<h1>AWEDRV PROGRAMMING NOTES</h1><p>
ver.1.05.
<p>
written by<br>
Takashi Iwai
(<a href=mailto:iwai@dragon.mm.t.u-tokyo.ac.jp><i>iwai@dragon.mm.t.u-tokyo.ac.jp</i></a>)
</center>
<p>

<hr>
<p>

<h1>0. Preface</h1>

This document describes the basic methods to access and control the AWE32
sound driver (ver.0.3) by Takashi Iwai.
The AWE32 sound driver provides full capability of Emu8000 chip
in the AWE32/SB32 sound card.
Please refer to AWE32 Developer's Information Package (ADIP)
distributed by CreativeLabs for details about AWE32.
<p>

<h1>1. Preparation of a message buffer</h1>

Most of macros employ a certain write buffer to access to the sound driver.
At beginning, this buffer must be defined.
The method to define, or declare this buffer is prepared in
<code>soundcard.h</code>.
<ol>
<li> Define a buffer for enough sizes (for example 2048 bytes)
<pre>
SEQ_DEFINEBUF(2048);
</pre>

<li> Define the file descriptor for <code>/dev/sequencer</code>.
<pre>
int seqfd;
</pre>

<li> Define <code>seqbuf_dump</code> function.
<pre>
void seqbuf_dump()
{
	if (_seqbufptr)
		if (write(seqfd, _seqbuf, _seqbufptr) == -1) {
			perror("write /dev/sequencer");
			exit(-1);
		}
	_seqbufptr = 0;
}
</pre>
</ol>
<p>

Most of <code>SEQ_*</code> macros write the data packet on this buffer.
The buffer is occaionally flushed when it's almost filled.
To force to send data to the driver, call <code>seqbuf_dump</code>
(or identically <code>SEQ_DUMPBUF</code>) explicitly.
<p>

<hr>
<p>

<h1>2. Opening a sound device</h1>

Then, open the sound driver device <code>/dev/sequencer</code>,
and find out the AWE32 device number from synthesizer devices in it.
Both the file descriptor and the device number must be specified
for accessing to AWE32 driver later.
Also, you should know other information of AWE32 driver, for example,
allowed voices, etc from <code>synth_info</code> structure.

<pre>
struct synth_info card_info;
int device;

void seq_init()
{
	int nrsynths;

	if ((seqfd = open("/dev/sequencer", O_WRONLY, 0)) < 0) {
		perror("open /dev/sequencer");
		exit(-1);
	}

	if (ioctl(seqfd, SNDCTL_SEQ_NRSYNTHS, &nrsynths) == -1) {
		perror("there is no soundcard");
		exit(-1);
	}
	device = -1;
	for (i = 0; i < nrsynths; i++) {
		card_info.device = i;
		if (ioctl(seqfd, SNDCTL_SYNTH_INFO, &card_info) == -1) {
			perror("cannot get info on soundcard");
			exit(-1);
		}
		if (card_info.synth_type == SYNTH_TYPE_SAMPLE
		    && card_info.synth_subtype == SAMPLE_TYPE_AWE32) {
			device = i;
			break;
		}
	}

	if (device < 0) {
		perror("No AWE synth device is found");
		exit(-1);
	}
}
</pre>
<p>

<hr>
<p>

<h1>3. Loading a sample</h1>

The awedrv has different two ways of sample loading.
One uses its own format, and another is the GUS compatible format.
In any cases, the patch data is loaded by <code>SEQ_WRPATCH</code> macro.
<pre>
SEQ_WRPATCH(patch ptr, patchlen);
</pre>
where <code>patch</code> is the pointer to the patch data,
and <code>patchlen</code> is the total length of the patch data.
<p>

<h2>3.1. AWE32 specific patches</h2>

Many of SoundFont files are designed to share the sample data
with different envelopes, or other effect parameters.
Then, awedrv accepts two separate data: the sample data, and
the voice information data.
The former contains the sample offsets and sizes,
loop position, type of sample data, a check sum value for validating,
and the sample data itself.
The latter contains the basic information to play a sample,
for example, root key note, acceptable MIDI key and velocity ranges,
envelopes, LFO's and cutoff parameters, and so on.
All the AWE patch structures are defined in <code>awe_voice.h</code>.
<p>

<h3>3.1.1. AWE Patch Header</h3>

Both types are loaded as a patch data with the same patch header of 16 bytes,
<code>awe_patch_info</code>
<pre>
typedef struct awe_patch_info {
	short key;			/* use AWE_PATCH here */
	short device_no;		/* synthesizer number */
	unsigned short sf_id;		/* file id */
	short sf_version;		/* patch version (not referred) */
	long len;			/* data length (without this header) */
	short type;			/* following data type */
	short reserved;			/* word alignment data */
} awe_patch_info;
</pre>
where <code>key</code> must be <code>AWE_PATCH</code> value,
and <code>device_no</code> is the above device number of AWE driver.
<code>sf_id</code> and <code>sf_version</code> are ignored.
<code>len</code> has the length of the following data
(not including this patch header itself).
<code>type</code> classifies the type of the patch data,
sample data or voice information.
The corresponding patch data follows after this header,
which size is defined by <code>AWE_PATCH_INFO_SIZE</code>.
<p>

<h3>3.1.2. AWE Sample Information</h3>

The sample data has 32 bytes of preceding patch record described below.
<pre>
typedef struct awe_sample_info {
	unsigned short sf_id;		/* file id */
	unsigned short sample;		/* sample id */
	long start, end;		/* start & end offset */
	long loopstart, loopend;	/* loop start & end offset */
	long size;			/* size (0 = ROM) */
	short checksum_flag;		/* use check sum = 1 */
	unsigned short mode_flags;	/* mode flags */
	unsigned long checksum;		/* check sum */
} awe_sample_info;
</pre>
where <code>sf_id</code> is the file id used internally and normally zero,
<code>sample</code> is the sample id of this sample which is referred by
voice information records.
<code>start</code> and <code>end</code> denote the sample start and end
offset positions,
<code>loopstart</code> and <code>loopend</code> denote the loop start
and end positions,
and <code>size</code> has the data length.
The offsets and size are word length if the data is 16bit.
Otherwise for 8bit data, they are defined as byte size.
The zero <code>size</code> parameter means a ROM sample starting
from <code>start</code> offset.
When <code>size</code> has larger than zero, the sample is loaded on
DRAM, and the offsets will be shifted.
<p>

<code>checksum_flag</code> is a flag to test and compare with the given
checksum to the sample data after loading on DRAM.
Occasionally awedrv fails sample loading on DRAM, and lack some data.
The checksum is useful for checking of this failure.
<p>

<code>mode_flags</code> is 16bit flags of the sample data.
<pre>
#define AWE_SAMPLE_8BITS	1	/* wave data is 8bits */
#define AWE_SAMPLE_UNSIGNED	2	/* wave data is unsigned */
#define AWE_SAMPLE_NO_BLANK	4	/* no blank loop is attached */
#define AWE_SAMPLE_SINGLESHOT	8	/* single-shot w/o loop */
#define AWE_SAMPLE_BIDIR_LOOP	16	/* bidirectional looping */
#define AWE_SAMPLE_STEREO_LEFT	32	/* stereo left sound */
#define AWE_SAMPLE_STEREO_RIGHT	64	/* stereo right sound */
#define AWE_SAMPLE_REVERSE_LOOP 128	/* reverse loop */
</pre>
The 8bit or unsigned data is converted inside the awedrv to 16bit signed data.
When <code>AWE_SAMPLE_NO_BLANK</code> is on, 48 words of blank loop is appended
after the sample automatically.
When <code>AWE_SAMPLE_SINGLESHOT</code> is on, the loop points are set on this blank loop.
<code>AWE_SAMPLE_BIDIR_LOOP</code> indicates that the loop is bidirectional
(pingpong), and the samples in this loop is extended as mirror image inside.
<code>AWE_SAMPLE_REVERSE_LOOP</code> means the reverse loop.
The loop sample is duplicated on mirror image inside the driver.
Other <code>STEREO</code> flags show that the voice is a streo sound.
<p>

The driver doesn't care about these stereo flags, but checks only
the key note and velocity range.  If two or more voices are suitable
on the given note and velocity pair, all they should be played simultaneously.
The multiple instruments are featured only in channel playing mode, but
in normal mode, only the first matching voice is played.
<p>

The sample data follows after this header which size is <code>AWE_SAMPLE_INFO_SIZE</code>.
Thus, the <code>len</code> parameter of the first patch header becomes<br>
(<code>AWE_SAMPLE_INFO_SIZE</code>) + <i>data byte size</i>).<br>
If the sample data doesn't contain any blank loop, <code>AWE_SAMPLE_NO_BLANK</code> flag should be set.
Also, if the sample data is a single-shot, <code>AWE_SAMPLE_SINGLESHOT</code> flag should be set.
Otherwise, you must add a blank loop after the sample, and direct the loop pointers on it by yourself.
<p>

After preparing these records above, and sample data,
load this patch data on the driver.
<pre>
SEQ_WRPATCH(patch, sizeof(*patch) + patch->len);
</pre>
<p>

<h3>3.1.3. AWE Voice Information</h3>

The voice information has 4 bytes of preceding data including
<pre>
typedef struct _awe_voice_rec {
	unsigned char bank;		/* midi bank number */
	unsigned char instr;		/* midi preset number */
	short nvoices;			/* number of voices */
	awe_voice_info info[1];		/* voice information follows here */
} awe_voice_rec;
</pre>
where <code>bank</code> and <code>instr</code> specify
the bank and program number of this instrument,
and <code>nvoices</code> denotes the number of voices (samples)
used in this instrument.
If any voices with the same bank and program number exist already,
the new voices are prepended before the list of older voices.
<code>nvoices</code> must be larger than zero.
Thus, <code>len</code> in patch header has the value<br>
(<code>AWE_VOICE_REC_SIZE</code> +
<code>nvoices</code> * <code>AWE_VOICE_INFO_SIZE</code>).<br>
<b>
Note: do NOT use <code>sizeof(awe_voice_rec)</code>
for calculation of the header size.
From ver.0.3.1, the info item is changed to contain one entry (not zero)
to avoid compile errors in some non-ANSI compilers.
Due to this change, <code>sizeof(awe_voice_rec)</code> becomes different
from older version.  Please use the constant <code>AWE_VOICE_REC_SIZE</code>
instead of sizeof macro.
</b>
<p>

After this 4bytes record,
<code>nvoices</code> of 92bytes of voice information
for each sample are appended.
<pre>
typedef struct _awe_voice_info {
	unsigned short sf_id;		/* file id */
	unsigned short sample;		/* sample id */
	long start, end;		/* sample offset correction */
	long loopstart, loopend;	/* loop offset correction */
	short rate_offset;		/* sample rate pitch offset */
	unsigned short mode;		/* sample mode */
	short root;			/* midi root key */
	short tune;			/* pitch tuning (in cents) */
	char low, high;			/* key note range */
	char vellow, velhigh;		/* velocity range */
	char fixkey, fixvel;		/* fixed key and velocity */
	char pan, fixpan;		/* panning, fixed panning */
	short exclusiveClass;		/* exclusive class (0 = none) */
	unsigned char amplitude;	/* sample volume (127 max) */
	unsigned char attenuation;	/* attenuation (0.375dB) */
	short scaleTuning;		/* pitch scale tuning(%), normally 100 */
	awe_voice_parm parm;		/* voice envelope parameters */
	short index;			/* internal index (set by driver) */
} awe_voice_info;
</code>
where <code>sf_id</code> is an internal file id and normally zero,
<code>sample</code> is the referring sample id of this voice.
<code>start</code>, <code>end</code>, <code>loopstart</code>, and
<code>loopend</code> are the offset correction of this voices.
For example, a value of <code>start</code> 30 means that
this voice starts 30 points after the original start points.
<p>

<code>rate_offset</code> holds the pitch offset of this voice
according to its sample rate.
This value is an AWE specific logarithmic rate,
that each 4096 is one octave shift.
For example, a value of -2048 indicates the sample is played 6 semitones flat.
The value can be calculated by the following equation.
<pre>
rate_offset = log(Hz / 44100) / log(2) * 4096
</pre>
<p>

<code>mode</code> is 16bit flags indicating the kind of this voice.
<pre>
#define AWE_MODE_ROMSOUND		0x8000
#define AWE_MODE_STEREO			1
#define AWE_MODE_LOOPING		2
#define AWE_MODE_NORELEASE		4	/* obsolete */
#define AWE_MODE_INIT_PARM		8
</pre>
<code>AWE_MODE_STEREO</code> and <code>AWE_MODE_NORELEASE</code>
are ignored in the current version.
<code>AWE_MODE_INIT_PARM</code> means that <code>parm</code> members
are initialized at loading automatically.
<p>

<code>root</code> and <code>tune</code> contain the root key note
and fine tune of this voice.
The key is supplied by MIDI key value, from 0 to 127,
and fine tune is a cents order.
A positive fine tune value indicates the sound is played at a higher pitch,
and a negative value means a lower pitch.
<p>

<code>low</code> and <code>high</code> define
the key note range of this voice.
If the key is out of this range, the driver skips this voice,
and searches the next voice from voice list.
To accepts all keys, <code>low</code> be 0, and <code>high</code> 127.
<p>

Similarly, <code>vellow</code> and <code>velhigh</code> define
the velocity range of this voice.
As well as in key note range,
the voice is accepted only when the velocity is within this range.
<p>

<code>fixkey</code>, and <code>fixvel</code> indicate
the fixed key and velocity of this voice.
If the value is not -1, the key or velocity is fixed on this value.
<p>

<code>pan</code> has a panning position of the "dry" sound,
from 0(left) to 127(right), or -1 for not specified.
<code>fixpan</code> also contains the fixed panning position.
If valid <code>fixpan</code> is given, the panning position is fixed
to that value.
<p>

<code>exclusiveClass</code> is the exclusive class of this voice.
If the value is zero, no exclusive system activates.
Otherwise, the voices with the sample exclusive class are turned off
before playing a new voice with this class.
This feature is used for some drum instruments like hi-hat.
<p>

<code>amplitude</code> and <code>attenuation</code> define
the volume of this voice.
<code>amplitude</code> is a linear volume from 0 to 127,
and <code>amplitude</code> means the attenuation from full level
in 0.375dB order.
For example, a voice with <code>attenuation</code> 40 is reproduced
15dB lower from full scale.
<p>

<code>scaleTuning</code> is a pitch scale tuning ratio, and normally is 100.
<p>

<code>index</code> is an internal sample index, and ignored at loading.
<p>

<code>parm</code> contains the modulation/volume envelopes, LFO's and other
raw parameters of emu8000 chip.
<pre>
typedef struct _awe_voice_parm {
	unsigned short moddelay;	/* modulation delay (ENVVAL) */
	unsigned short modatkhld;	/* modulation attack & hold time (ATKHLD) */
	unsigned short moddcysus;	/* modulation decay & sustain (DCYSUS) */
	unsigned short modrelease;	/* modulation release time (DCYSUS) */
	short modkeyhold, modkeydecay;	/* envelope change per key (not used) */
	unsigned short voldelay;	/* volume delay (ENVVOL) */
	unsigned short volatkhld;	/* volume attack & hold time (ATKHLDV) */
	unsigned short voldcysus;	/* volume decay & sustain (DCYSUSV) */
	unsigned short volrelease;	/* volume release time (DCYSUSV) */
	short volkeyhold, volkeydecay;	/* envelope change per key (not used) */
	unsigned short lfo1delay;	/* LFO1 delay (LFO1VAL) */
	unsigned short lfo2delay;	/* LFO2 delay (LFO2VAL) */
	unsigned short pefe;		/* modulation pitch & cutoff (PEFE) */
	unsigned short fmmod;		/* LFO1 pitch & cutoff (FMMOD) */
	unsigned short tremfrq;		/* LFO1 volume & freq (TREMFRQ) */
	unsigned short fm2frq2;		/* LFO2 pitch & freq (FM2FRQ2) */
	unsigned char cutoff;		/* initial cutoff (upper of IFATN) */
	unsigned char filterQ;		/* initial filter Q [0-15] (upper of CCCA) */
	unsigned char chorus;		/* chorus send */
	unsigned char reverb;		/* reverb send */
	unsigned short reserved[4];	/* not used */
} awe_voice_parm;
</pre>
The values correspond to the register values of emu8000 described in
AWE32 Developer's Information Package (ADIP)
by CreativeLabs.
This record can be initialized internally in the driver
by setting <code>AWE_MODE_INIT_PARM</code> flag in voice_info record.
<p>

After setting these parameters for each voice,
load this patch data on the driver.
<pre>
SEQ_WRPATCH(patch, sizeof(*patch) + patch->len);
</pre>
<p>

<h2>3.2. GUS compatible patches</h2>
From ver.0.2.0, awedrv can receive GUS style patch records.
The GUS patch structure is defined in <code>soundcard.h</code>.
Unlikely to AWE patch, one sample is associated with one voice information
in GUS patch.
<pre>
struct patch_info {
	unsigned short key;		/* Use GUS_PATCH here */
	short device_no;	/* Synthesizer number */
	short instr_no;		/* Midi pgm# */
	unsigned int mode;
	int len;	/* Size of the wave data in bytes */
	int loop_start, loop_end; /* Byte offsets from the beginning */
	unsigned int base_freq;
	unsigned int base_note;
	unsigned int high_note;
	unsigned int low_note;
	int panning;	/* 0 to 15? */
	int detuning;
	unsigned char	env_rate[ 6 ];	 /* GUS HW ramping rate */
	unsigned char	env_offset[ 6 ]; /* 255 == 100% */
	unsigned char	tremolo_sweep;
	unsigned char	tremolo_rate;
	unsigned char	tremolo_depth;
	unsigned char	vibrato_sweep;
	unsigned char	vibrato_rate;
	unsigned char	vibrato_depth;
	int		scale_frequency;
	unsigned int	scale_factor;		/* from 0 to 2048 or 0 to 2 */
        int		volume;
	int		fractions;
        int		spare[3];
	char data[1];	/* The waveform data starts here */
};
</pre>
<code>key</code> must be <code>GUS_PATCH</code> value,
and <code>device_no</code> is the device number of AWE driver.
<p>

<code>instr_no</code> defines the program number of this sample.
The bank number can be defined using the extended control
<code>AWE_SET_GUS_BANK</code> function before loading the samples.
As default, the bank is set to zero.
<p>

<code>mode</code> indicates the flags of this sample.
Backward looping, scaling and fractions are not implemented yet.

<code>len</code> has the length of the sample data in bytes order.
Note that AWE patch holds in words order for 16bit samples, but GUS patch
is always in bytes order.
Similarly, loop position by <code>loop_start</code> and <code>loop_end</code>
is in byte offset.
<p>

<code>base_freq</code>, </code>base_note</code>, <code>high_note</code>,
and <code>low_note</code> are converted in the driver to corresponding
key note and fine tunes.
<p>

<code>panning</code> parameter is passed as the initial position
of dry sounds.
<p>

The 6 points volume envelope, tremolo, and vibrato parameters 
are converted to the AWE32 specific values in the driver.
<p>

Other parameters, <code>detuning</code>,
<code>scale_frequency</code>, <code>scale_factor</code>,
<code>volume</code>, and <code>fractions</code> are ignored.
<p>

The sample data follows after this is converted according to
the flags specified automatically.
<p>

After setting these parameters and copying the sample data from data pointer,
load this patch data on the driver.
<pre>
SEQ_WRPATCH(device, patch, sizeof(patch) + <i>data byte size</i> - 1);
</pre>
<p>

<hr>
<p>

<h1>4. Playing a voice</h1>

<h2>4.1. Playing modes</h2>

The AWE driver has several playing modes depending on its usage.
One is the normal mode, and another is the channel mode.
The former mode is as same as in the other sound driver like GUS and FM.
The driver outputs one sample per one voice.
On the contrast, the latter mode has capability to output two or more
samples simultaneously as one voice.
Many SoundFont files define presets including multiple instruments,
instruments including multiple samples, and stereo sounds.
In such a file, two or more samples are designed to be played at the same time.
To enable this feature, in the channel mode
users must specify the MIDI channel instead of the voice number.
The driver decides the required number of voices, and allocates and
assigns the voices automatically just like <code>sequecer2</code> controls.
<p>

To change the current playing mode, call <code>AWE_CHANNEL_MODE</code> macro.
<pre>
AWE_SET_CHANNEL_MODE(device, mode);
</pre>
where <code>mode</code> is a digit number to specify the playing mode,
0 is the normal mode, and 1 is the channel mode.
Note that the playing mode is reset at each time
the device is closed to the normal mode.
<p>

<h2>4.1. Selecting a program</h2>

The voice program is selected by <code>SEQ_SET_PROGRAM</code> macro.
<pre>
SEQ_SET_PROGRAM(device, voice, program);
</pre>
where <code>voice</code> is the voice or channel number depending on the
current playing mode.
In the normal playing mode,
the voice number usually has a value from 0 to 29.
<code>program</code> is the program number to be played.
AWE32 has 32 individual channels, but when playing samples on DRAM,
the last two channels cannot be used due to DRAM refresh.
Thus, in awedrv, only 30 channels are available.
<p>

In channel playing mode, <code>voice</code> becomes a MIDI channel number
(usually from 0 to 15).  The voices are allocated internally by the driver.
Likewise, in all other sequencer controls, <code>voice</code> becomes the
corresponding MIDI channel number.
<p>

The drum voices are assigned to individual programs with
(<i>key number</i> + 128) by traditional reason.
The awedrv itself has a capability to deal with the drumset as one program.
In such a case, users must specify the preset number as the drumset number
and the fixed bank number 128.
You can also set the drum channels by extension control
<code>AWE_DRUM_CHANNELS</code> with a bit-blt parameter, calculated by
(1 << <i>drum number</i>), where <i>drum number</i> starts from 0.
In these channels, the voices are assumed as a drum set.
<pre>
AWE_DRUM_CHANNELS(device, channels);
</pre>
As default, only channel 10 is assumed as a drum channel,
then the <code>channels</code> value is 0x200.
Some MIDI files use also the channel 16 as a drum.
In such a case, <code>channels</code> becomes 0x8200.
<p>

The awedrv has a bank selection mechanism.
The bank selection can be done through MIDI control message #0,
so is realized by <code>SEQ_CONTROL</code> macro like
<pre>
SEQ_CONTROL(device, voice, CTL_BANK_SELECT, bank);
</pre>
where <code>bank</code> is the bank number of the sample.
For drum voices (set by <code>AWE_DRUM_CHANNELS</code>,
this number corresponds to drumset number.
<p>

<h2>4.2. Setting various effects</h2>

<h3>4.2.1. Pitch control</h3>

To control the sample pitch or frequency,
the pitch wheel control is used ordinally.
The pitch change is calculated from two parameters,
pitch bender range and pitch bending degree.
The former, the pitch wheel, is controlled by
<code>SEQ_BENDER</code> macro, or obsolete <code>SEQ_PITCHBEND</code> macro.
<pre>
SEQ_BENDER(device, voice, value);
</pre>
Be careful that the parameter values are different between them.
<code>SEQ_BENDER</code> has a value from 0 to 16384,
and the center (no pitch shift) is 8192, just as same as in MIDI sequences.
On the other hand,
<code>SEQ_PITCHBEND</code> has a value from -8192 to 8192,
and the center is 0.
In both cases, the smaller than the center means lower pitch shift,
and the larger means upper pitch shift, respectively.
For example, when the bender range (see below) is 200, a value of -4096
indicates one octave flat from the normal pitch.
<p>

The latter control, the bender range,
is done by <code>SEQ_BENDER_RANGE</code> macro.
This function defines the bender range in (octave * 100).
For example,
a value of 400 indicates that the maximum wheel change to be four octave shift
from the normal pitch.
The default value is 200.
<pre>
SEQ_BENDER_RANGE(device, voice, value);
</pre>
<p>

Both of these controls can be changed at real time during playing the sample.
<p>

<h3>4.2.2. Volume control</h3>

The volume of each voice can be controlled by
three parameters: main volume, expression volume, and velocity.
The total volume is calculated from the product of these three values
as (main_volume * expression * velocity).
While the last velocity parameters is specified at starting the sample,
the other two parameters are given usually before playing it
though they can be changed at real time during playing the sample.
<p>

The main volume is set
via <code>SEQ_CONTROL</code> with the proper control code
(<code>CTL_MAIN_VOLUE</code> and <code>CTRL_MAIN_VOLUME</code>),
or obsolete <code>SEQ_MAIN_VOLUME</code> macro.
<pre>
SEQ_CONTROL(device, voice, CTL_MAIN_VOLUME, value);
</pre>
The value for <code>SEQ_MAIN_VOLUME</code> is identical with MIDI value,
from 0 to 127.
When the playing mode is the normal mode,
the control <code>CTL_MAIN_VOLUME</code> has a value from 0 to 20806
(= 16383 * 127 / 100).
In the channel mode, it has the same value as MIDI, from 0 to 127.
The <code>CTRL_MAIN_VOLUME</code> always has the same value as MIDI.
<p>

The expression volume is set via
<code>SEQ_CONTROL</code> with the proper control code
(<code>CTL_EXPRESSION</code> and <code>CTRL_EXPRESSION</code>),
or obsolete <code>SEQ_EXPRESSION</code> macro.
<pre>
SEQ_CONTROL(device, voice, CTL_EXPRESSION, value);
</pre>
The value for <code>SEQ_EXPRESSION</code> is identical with MIDI value,
from 0 to 127.
Similarly, when the playing mode is the normal mode,
the control code<code>CTL_EXPRESSION</code> has a value from 0 to 16256
(= 127 * 128).
In the channel mode, it has the same value as MIDI, from 0 to 127.
The <code>CTRL_EXPRESSION</code> has the same value as MIDI,
from 0 to 127.
<p>

Additionally, the awedrv has a total volume attenuation parameter.
Users can change this initial attenuation using <code>AWE_INITIAL_ATTEN</code>
control (identical with <code>AWE_INITIAL_VOLUME</code>).
<pre>
AWE_INITIAL_ATTEN(device, atten);
</pre>
This value <code>atten</code> is the attenuation volume from full scale
in 0.375 dB order.  For example, a value of 10 means that
3.75 dB lower from full scale.
The initial value is 32, 12dB below from full scale.
<p>

<h3>4.2.3. Panning position</h3>

The panning position is also set via control command,
<code>SEQ_CONTROL</code> with the proper control code (<code>CTL_PAN</code>),
or obsolete <code>SEQ_PANNING</code> macro.
<pre>
SEQ_CONTROL(device, voice, CTL_PAN, value);
</pre>
The value for <code>SEQ_PANNING</code> is from -128(left) to 128(right),
and different from MIDI value
unlike volume controls above.
But the value of <code>CTL_PAN</code> is identical with MIDI value,
from 0(left) to 127(right).
<p>

The panning position can be changed during playing,
but may cause a small clicking noise due to restriction of
emu8000 chip.
<p>

<h3>4.2.4. Chorus and reverb effects</h3>

The AWE32 has chorus and reverb effects for each voice.
In awedrv, these effects are controlled via <code>SEQ_CONTROL</code>
with two control commands,
<code>CTL_CHORUS_DEPTH</code> and <code>CTL_EXT_EFF_DEPTH</code>,
for chorus and reverb, respectively.
<pre>
SEQ_CONTROL(device, voice, CTL_CHORUS_DEPTH, value);
SEQ_CONTROL(device, voice, CTL_EXT_EFF_DEPTH, value);
</pre>
In both cases, the value range is from 0 to 127,
where 127 means 100% of output is send to the corresponding effect processor.
These values cannot be changed during playing the sample.
<p>

Also, AWE32 has eight modes for both chorus and reverb effects.
They can be changed by extended control by
<code>AWE_CHORUS_MODE</code> and <code>AWE_REVERB_MODE</code>, respectively.
<pre>
AWE_CHORUS_MODE(device, mode);
AWE_REVERB_MODE(device, mode);
</pre>
In both cases, the range of the parameter value is from 0 to 7.
The corresponding mode to each value is defined in <code>awe_voice.h</code>,
that is,
Chorus 1 - 4, Feedback, Flanger, Short Delay, and Short Delay 2 for chorus modes,
and
Room 1 - 3, Hall 1/2, Plate, Delay, Panning Delay for reverb modes.
See AWE32 FAQ by CreativeLabs for meaning of each mode.
<p>

<h3>4.2.5. Other effects</h3>

The awedrv has several extended controls
to write raw register values for emu8000 parameters.
Through this function, users can control any function of AWE32 sound effects,
although the parameter value itself is not generic.
<p>

The extended controls are passed through
<code>AWE_SEND_EFFECT</code> macro with
specified commands and values.
<pre>
AWE_SEND_EFFECT(device, voice, command, value);
</pre>
The commands are defined in <code>awe_voice.h</code>, that is,
<pre>
/* 0*/	AWE_FX_ENV1_DELAY,	/* WORD: ENVVAL */
/* 1*/	AWE_FX_ENV1_ATTACK,	/* BYTE: up ATKHLD */
/* 2*/	AWE_FX_ENV1_HOLD,	/* BYTE: lw ATKHLD */
/* 3*/	AWE_FX_ENV1_DECAY,	/* BYTE: lw DCYSUS */
/* 4*/	AWE_FX_ENV1_RELEASE,	/* BYTE: lw DCYSUS */
/* 5*/	AWE_FX_ENV1_SUSTAIN,	/* BYTE: up DCYSUS */
/* 6*/	AWE_FX_ENV1_PITCH,	/* BYTE: up PEFE */
/* 7*/	AWE_FX_ENV1_CUTOFF,	/* BYTE: lw PEFE */

/* 8*/	AWE_FX_ENV2_DELAY,	/* WORD: ENVVOL */
/* 9*/	AWE_FX_ENV2_ATTACK,	/* BYTE: up ATKHLDV */
/*10*/	AWE_FX_ENV2_HOLD,	/* BYTE: lw ATKHLDV */
/*11*/	AWE_FX_ENV2_DECAY,	/* BYTE: lw DCYSUSV */
/*12*/	AWE_FX_ENV2_RELEASE,	/* BYTE: lw DCYSUSV */
/*13*/	AWE_FX_ENV2_SUSTAIN,	/* BYTE: up DCYSUSV */
	
/*14*/	AWE_FX_LFO1_DELAY,	/* WORD: LFO1VAL */
/*15*/	AWE_FX_LFO1_FREQ,	/* BYTE: lo TREMFRQ */
/*16*/	AWE_FX_LFO1_VOLUME,	/* BYTE: up TREMFRQ */
/*17*/	AWE_FX_LFO1_PITCH,	/* BYTE: up FMMOD */
/*18*/	AWE_FX_LFO1_CUTOFF,	/* BYTE: lo FMMOD */

/*19*/	AWE_FX_LFO2_DELAY,	/* WORD: LFO2VAL */
/*20*/	AWE_FX_LFO2_FREQ,	/* BYTE: lo FM2FRQ2 */
/*21*/	AWE_FX_LFO2_PITCH,	/* BYTE: up FM2FRQ2 */

/*22*/	AWE_FX_INIT_PITCH,	/* SHORT: pitch offset */
/*23*/	AWE_FX_CHORUS,		/* BYTE: chorus effects send (0-255) */
/*24*/	AWE_FX_REVERB,		/* BYTE: reverb effects send (0-255) */
/*25*/	AWE_FX_CUTOFF,		/* BYTE: up IFATN */
/*26*/	AWE_FX_FILTERQ,		/* BYTE: up CCCA */

/*27*/	AWE_FX_SAMPLE_START,	/* SHORT: offset */
/*28*/	AWE_FX_LOOP_START,	/* SHORT: offset */
/*29*/	AWE_FX_LOOP_END,	/* SHORT: offset */
/*30*/	AWE_FX_COARSE_SAMPLE_START,	/* SHORT: upper word offset */
/*31*/	AWE_FX_COARSE_LOOP_START,	/* SHORT: upper word offset */
/*32*/	AWE_FX_COARSE_LOOP_END,		/* SHORT: upper word offset */
</pre>
The commands 0 - 7 define parameters of the modulation envelope,
8 - 13 of the volume envelope,
14 - 18 of LFO1,
19 - 21 of LFO2,
22 - 26 of other effect parameters for total voice,
and the later provides sample start position, and loop offset.
See ADIP for the parameter values of envelopes and LFO's.
<p>

GUS compatible extended controls are partly implemented.
<code>GUS_VOICE_POS</code> is interpreted inside as an extension control
27(<code>AWE_FX_SAMPLE_START</code>) and
30(<code>AWE_FX_COARSE_SAMPLE_START</code>).
<p>

<h2>4.3. Starting a note</h2>

There are two ways to start a voice.
The standard method is to call <code>SEQ_START_NOTE</code> macro.
<pre>
SEQ_START_NOTE(device, voice, note, velocity);
</pre>
where <code>note</code> and <code>velocity</code> are the MIDI key and velocity
to be played, respectively.
A sample including the specified note in its key range
is searched from all samples with given bank and program numbers.
Then, the volume and pitch parameters are computed here
from specified note and velocity.
If this sample is an exclusive voice like drum hi-hat sounds,
turn off other voices with the same exclusive key, that is
the other hi-hat sounds which is being played.
After that, start this voice.
<p>

In the normal playing mode,
the note 255 has a special meaning.
When this function is called with the note 255,
only volume is changed according its velocity,
and never affects the envelope change, and so on.
This can be used for dynamic volume control
without using other <code>SEQ_CONTROL</code> functions.
Note that this feature is ignored in the channel playing mode.
<p>

If the velocity is specified as zero, then one channel is allocated,
but the sound is not started.  It starts when volume change control
is received later.
<p>

The another way for start is to call a GUS specific control
<pre>
GUS_VOICEON(device, voice, mode);
</pre>
where <code>mode</code> is a voice mode, but ignored in awedrv.
This simply starts a sound on the channel, so voice parameters
like program, pitch and volume must be set before calling this function.
<p>

<hr>
<p>

<h1>5. Modulating a voice</h1>

<h2>5.1. Changing volume</h2>

Many methods are provided to change the volume of the sample.
One is to use <code>SEQ_KEY_PRESSURE</code> macro,
or <code>AWE_KEY_PRESSURE</code> macro, depending on its playing mode.
Also, you can change all the volume assigned to a certain channel
using <code>SEQ_CHN_PRESSURE</code> or
<code>AWE_CHN_PRESSURE</code> macros.
In the channel playing mode, the former macro
<code>SEQ_KEY_PRESSURE</code> and <code>SEQ_CHN_PRESSURE</code> are ignored
due to compatibility problems.
Use the latter <code>AWE_KEY_PRESSURE</code> and <code>AWE_CHN_PRESSURE</code>
macros instead.
The parameter value is as same as MIDI pressure value, from 0 to 127.
<pre>
AWE_KEY_PRESSURE(device, voice, note, velocity);
AWE_CHN_PRESSURE(device, voice, velocity);
</pre>
<p>

The second way is updating main or expression volume on each channel
by <code>SEQ_CONTROL</code> or other macros (see 4.2.2).
Also, using <code>SEQ_START_NOTE</code> with a special note 255 is
available for changing volume as explained above.
<p>

<h2>5.2. Changing pitch</h2>

You can change pitch of the sound by using the pitch wheel,
or by <code>AWE_SEND_EFFECT</code> with
<code>AWE_FX_INIT_PITCH</code> command
(see 4.2.1).
<p>

<h2>5.3. Changing panning position</h2>

The panning position is able to be changed at real time,
but it may cause a noise as explained above (see 4.2.3).
<p>

<h2>5.4. Changing chorus and reverb</h2>

The chorus and reverb effects can NOT be changed at real time.
However, the chorus and reverb modes are possible to be changed.
<p>

<h2>5.5. Changing other effects</h2>

The LFO1 parameters except delay (frequency, volume, pitch shift, and cutoff
shift), and
LFO2 parameters (frequency, and pitch shift)
can be changed at real time.
Also, total cutoff frequency can be changed.
The values are passed through the extended controls (see 4.2.5).
<p>

<hr>
<p>

<h1>6. Timer control</h1>

The awedrv itself doesn't provide any timer control functions.
Use the standard timer macros, <code>SEQ_START_TIMER</code>,
<code>SEQ_WAIT_TIME</code> or <code>SEQ_DELTA_TIME</code>,
and <code>SEQ_STOP_TIMER</code>.
<p>

<hr>
<p>

<h1>7. Ending a voice</h1>

To end a sound, call <code>SEQ_STOP_NOTE</code> macro.
This releases the sound from the sustain level to silence
according to the volume envelope.
The note and velocity parameters are ignored.
<pre>
SEQ_STOP_NOTE(device, voice, note, velocity);
</pre>
<p>

Or, you can terminate the voice completely by extended control,
<code>AWE_TERMINATE_CHANNEL</code>.
This stops the sound without any releasing echo.
<pre>
AWE_TERMINATE_CHANNEL(device, voice);
</pre>
To terminate all voices, the extended control
<code>AWE_TERMINATE_ALL</code> is available.
<pre>
AWE_TERMINATE_ALL(device);
</pre>
Alternatively, to turn off the all channels similary as SEQ_STOP_NOTE,
use <code>AWE_NOTEOFF_ALL</code>.
<pre>
AWE_NOTEOFF_ALL(device);
</pre>
<p>

<hr>
<p>

<h1>8. Miscellaneous features</h1>

The debug message is toggled on/off by the extended control
<code>AWE_DEBUG_MODE</code>.
<pre>
AWE_DEBUG_MODE(device, mode);
</pre>
The value zero means to turn off debugging messages,
and values larger then zero means to output debugging messages
on syslog, usually <code>/var/adm/syslog</code> or </code>/var/adm/message</code>
(depending on the setting of <code>/etc/syslog.conf</code>).
<p>

The emu8000 chip can be initialized by the extended control
<code>AWE_INITIALIZE_CHIP</code>.
This only re-initializes the AWE32, and doesn't affect other driver-internal
parameters or effects.
<pre>
AWE_INITIALIZE_CHIP(device);
</pre>
<p>

<code>AWE_GET_CURRENT_MODE</code> macro is used to obtain the current status
of the AWE driver.
<pre>
awe_mode_rec rec;
AWE_GET_CURRENT_MODE(device, &rec);
</pre>
The parameter <code>rec</code> is a record of <code>awe_mode_rec</code> type
where the current data is stored in return.
This macro employs the direct <code>write</code> call to the driver
without buffering.
<p>

<p><hr>
Takashi Iwai<br>
<a href=mailto:iwai@dragon.mm.t.u-tokyo.ac.jp>
<i>iwai@dragon.mm.t.u-tokyo.ac.jp</i></a><br>
<a href=http://bahamut.mm.t.u-tokyo.ac.jp/~iwai>
<i>http://bahamut.mm.t.u-tokyo.ac.jp/~iwai</i></a>

</body>
