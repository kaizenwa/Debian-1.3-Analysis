%%*****************************************************************************
%% $Id: bibtool.tex,v 1.15 1996/02/22 21:43:51 gerd Exp gerd $
%%=============================================================================
%%
%% This file is part of BibTool.
%% It is distributed under the GNU General Public License.
%% See the file COPYING for details.
%%
%% (c) 1995-1996 Gerd Neugebauer
%%
%% Net: gerd@informatik.uni-koblenz.de
%%
%%-----------------------------------------------------------------------------
%% Usage:  latex     bibtool
%%         bibtex    bibtool
%%         latex     bibtool
%%         makeindex -s bibtool.ist bibtool
%%         latex     bibtool
%%*****************************************************************************

\ifx\documentclass\undefined
\documentstyle[11pt,dina4,makeidx]{book}
\else
\documentclass[11pt]{book}
\usepackage{makeidx}
\makeatletter
\input{dina4.sty}
\makeatother
\fi

\newcommand\Version{2.34}
\newcommand\Year{1996}

\makeatletter%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
\def\ps@headings{\let\@mkboth\markboth
  \def\@oddfoot{}\def\@evenfoot{}
  \def\@evenhead{\vbox{\vss\hbox to \textwidth{\rm\thepage \hss
        {\scriptsize\sc\ \leftmark}}\kern 1.5mm\hrule depth 0.2 true pt}}
  \def\@oddhead{\vbox{\vss\hbox to \textwidth{\rm{\scriptsize\sc \rightmark\ }
        \hss \thepage}\kern 1.5mm\hrule depth 0.2 true pt}}
  \def\chaptermark##1{\markboth {\ifnum \c@secnumdepth>\m@ne
     \thechapter. \ \fi ##1}{}}
  \def\sectionmark##1{\markright
                      {\ifnum \c@secnumdepth >\z@ \thesection. \ \fi ##1}}}

\pagestyle{headings}
\newcommand\opt[1]{{\tt-#1}\index{#1@{\tt-#1}}}
\newcommand\sh{\smallskip\par\hspace*{2em}\@ifnextchar[{\sh@}{\sh@@}}
\def\sh@[#1]#2{{\tt bibtool -#1 {\it #2}}\index{#1@{\tt-#1}}
        \smallskip\par\noindent\ignorespaces}
\def\sh@@#1{{\tt bibtool {\it #1}}
        \smallskip\par\noindent\ignorespaces}
\newcommand\rsc[1]{{\sf #1}\index{#1@{\sf #1}}}
\newcommand\RSc[2]{\smallskip\par\hspace*{2em}{\sf #1 #2}\index{#1@{\sf #1}}
        \smallskip\par\noindent\ignorespaces}
\newcommand\RSC[2]{\RSc{#1}{= \{#2\}}}
\newcommand\Rsc[2]{\RSc{#1}{= #2}}
\newcommand\env[1]{{\tt #1}\index{#1@{\tt #1}}}

\makeatother%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\newcommand\BS{$\backslash$}

\newcommand\BibTool{{\sc Bib\hskip-.1em
        T\hskip-.15emo\hskip-.05emo\hskip-.05eml}}
\newcommand\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
        T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newfont\cminch{cminch}
\renewcommand\chaptername{\cminch}
\renewcommand\appendixname{\cminch}

\newcommand\rfill[1]{\leaders\hrule height #1\hfill}

\makeindex

\begin{document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\null\vfill
{\begin{center}
\rule{\textwidth}{5pt}%
\bigskip\par
\hbox to \textwidth{\cminch \hss B\hss I\hss B\hss T\hss O\hss O\hss L\hss}
\medskip\par\normalsize
\mbox{}\rfill{5pt}\ A Tool to Manipulate \BibTeX\ Files\ \rfill{5pt}\null
\medskip\par\normalsize          Version  \Version
\vfill\vfill
{\LARGE\it        $\cal G$\kern-.1emerd $\cal N$\kern-.2emeugebauer}
\vfill\vfill
\begin{minipage}{.8\textwidth}\small
  \begin{center} \bf Abstract \end{center}

    \BibTeX\ provides an easy to use means to integrate citations and
    bibliographies into \LaTeX\ documents. But the user is left alone with the
    management of the \BibTeX\ files. The program \BibTool\ is intended to
    fill this gap. \BibTool\ allows the manipulation of \BibTeX\ files which
    goes beyond the possibilities --- and intentions --- of \BibTeX. The
    possibilities of \BibTool{} include sorting and merging of \BibTeX{} data
    bases, generation of uniform reference keys, and selecting of references
    used in a publication.
\end{minipage}\vfill\vfill

{\tiny\sf --- This documentation is still in a rudimentary form and
  needs additional efforts. ---}
\end{center}}
%______________________________________________________________________________
\newpage
\noindent
\begin{minipage}{\textwidth}\parskip=1ex
This file is part of \BibTool{} Version \Version
\medskip

Copyright {\copyright}\Year{} Gerd Neugebauer
\medskip

\BibTool{} is  free software; you can redistribute  it and/or  modify it under
the terms of the GNU General Public License as published  by the Free Software
Foundation; either version 1, or (at your option) any later version.

\BibTool{} is distributed in the hope that it will be  useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received  a copy of the GNU  General Public License along with
this documentation; see the file COPYING.  If not,  write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
\end{minipage}
\vfill\par\noindent
Gerd Neugebauer\\
Mainzer Str.\ 8\\
56321 Rhens (Germany)\smallskip\par\noindent
Net: {\tt gerd@informatik.uni-koblenz.de}\\
\phantom{Net:} {\scriptsize\tt gerd@imn.th-leipzig.de}\\
\phantom{Net:} {\tiny\tt gerd@intellektik.informatik.th-darmstadt.de}
%______________________________________________________________________________
\tableofcontents

%______________________________________________________________________________
\chapter{Introduction}

\section{Related Programs}

\BibTeX{} \cite{lamport:latex,patashnik:bibtexing,patashnik:designing} is a
system for integrating bibliographic information into \LaTeX{}
\cite{lamport:latex} documents. \BibTeX{} is designed to serve exactly this
purpose. It has shown that various tasks in relation with managing
bibliographic databases are not covered by \BibTeX{}.  Usual activities on
bibliographic databases include
\begin{itemize}
  \item inserting new entries
  \item editing
  \item using citations in documents
  \item sorting and merging of bibliographic data bases
  \item extraction of bibliographic data bases
\end{itemize}
%
Since only the integration in documents is covered by \BibTeX{} several
utilities emerged to fill the gaps. We will sketch some of them shortly.
%
\begin{description}
\item [\BibTeX] is a program by Oren Patashnik to select publications used in
  a \LaTeX{} document and format them for inclusion into this document.. This
  program should be part of each \TeX{} installation.

  \item [bibclean] is a program by Nelson H.F.~Beebe to prettyprint \BibTeX{}
    files. It also can act as syntax checker. The C sources can be compiled on
    several systems.
  \item [bibindex/biblook] is a pair of program by Nelson H.F.~Beebe to
    generate an index for a \BibTeX{} file and use it to perform a fast lookup
    of certain entries. The programs so far run only under UNIX.
  \item [bibsort] is a UNIX shell script by Nelson H.F.~Beebe to sort a
    \BibTeX{} file.
  \item [bibclean] is a UNIX shell script by Nelson H.F.~Beebe to extract
    entries from a \BibTeX{} file which are used in a \LaTeX{} document.

  \item [lookbibtex/bibdestringify] are Perl scripts by John Heidemann to
    extract entries from a \BibTeX{} file which are used in a \LaTeX{}
    document and to remove strings from a \BibTeX{} file.

  \item [bibtools] is a collection of UNIX shell scripts by David Kotz to add
    and extract records to bibliographic databases. Several small programs are
    provided to perform special tasks.

  \item [bibview] is a Perl script by Dana Jacobsen to extract entries from a
    \BibTeX{} file which are used in a \LaTeX{} document.

  \item [BibCard] is a program by William C.~Ogden running under X11/xview
    which provides a means to edit bibliographic databases.
  \item [hyperbibtex] Something similar for Macintosh computers.

  \item [xbibtex/bibprocess/bibsearch] are programs by Nicholas J. Kelly
    and	Christian H. Bischof running under X11 which provides a means to edit
    bibliographic databases, add fields to a \BibTeX{} file and extract
    certain entries from a \BibTeX{} file.

  \item [bibview] is an X11 program by Holger Martin, Peter Urban, and Armin
    Liebl to search in and manipulate \BibTeX{} files.

  \item [\BibTeX-Mode] is an extension of the editor GNU-Emacs to provide means
    to edit \BibTeX{} files. Several useful operations are provided.
\end{description}

Some additional information can be found in
\cite[Chapter~13]{goosens.mittelbach.ea:companion}. 

Most of those utilities are tailored towards a special operating system and
thus they are not available on other platforms. Most of these program are
made to perform a single task. Often they can not be configured to suit a
personal taste of a user.

Still there are some points not covered by the utilities mentioned above.
\BibTool{} tries to provide the missing features and integrate others into a
single tool.


%______________________________________________________________________________
\section{Using \BibTool{} --- Some Instructive Examples}

\BibTool\ has been developed on UN*X and UN*X-like machines. This has
influenced many of the design decisions. Version 1 has been controlled using
numerous command line options. This way of controlling has been supplemented
in version 2 by the concept of a resource file. This resource file allows the
modification of various internal parameters determining the behavior of
\BibTool.

When \BibTool\ has been compiled correct there should be an executable file
named {\tt bibtool}\footnote{Maybe with an additional extension.}. We will
assume that you are running \BibTool\ from a command line interpreter. There
you can simply issue the command

\sh{}

Now \BibTool{} will start reading from the standard input lines obeying the
rules of a \BibTeX\ file.\footnote{We assume that no resource file can be
found.  Resource files will be described later.} The entries read are
pretty-printed on the standard output.  It is obvious that this behavior is
not very useful in itself. The origin of this kind of interface lies in the
concepts of UN*X where many commands can act as filters.

Usually we do not intend to use \BibTool{} in this way. Thus we need a way to
specify an input file. This is simply done by adding the file name as argument
after the command name like in

\sh{file.bib}

The result of this command can at once be seen on the screen. The contents of
the file {\tt file.bib} is pretty printed.





After we have seen the simplest case of the application of \BibTool\ we will
the the simplest case of a useful application of \BibTool.  This application
is the syntax check and pretty printing



%______________________________________________________________________________
\subsection{Sorting and Merging}

\BibTeX{} files can be sorted by specifying the the command line option
\opt{s}. The given files are sorted according to the reference key. Several
files can be given at once. If those files are already sorted then the result
of \BibTool{} is merging the files given.

\sh[s]{file1.bib file2.bib}


%______________________________________________________________________________
\subsection{Key Generation}

Once you have a reference and you insert it into a \BibTeX\ file you have to
assign a reference key to it. The problem is to find a key which is unique and
meaningful, i.e.\ easy to remember. The easiest way to remember a key is to
use an algorithm to create it and remember the algorithm --- which is the same
for all keys.

One algorithm which comes to mind is to use the author and (an initial part)
of the title. Alternatively we can use the author and the year. But the
problem are industrious authors writing more than one publication per year.
The necessary disambiguation of such references is not very intuitive.

\BibTool{} contains the possibility to describe desired keys. Thus the
alternatives described above can be realized.


For this section we want to use the following \BibTeX{} entry as our
example:\footnote{Shamelessly stolen from the \BibTeX{} xamples.bib file.}
Suppose it is contained in a file named {\sf sample.bib}.

{\footnotesize\begin{verbatim}
@ARTICLE{article-full,
   author = {L[eslie] A. Aamport},
   title = {The Gnats and Gnus Document Preparation System},
   journal = {\mbox{G-Animal's} Journal},
   year = 1986,
   volume = 41,
   number = 7,
   pages = "73+",
   month = jul,
   note = "This is a full ARTICLE entry",
}
\end{verbatim}}

First, we want to see how we can make keys consisting of author and title.
This is one of my favorite algorithms thus it is rather easy to use it. You
simply have to run the command

\sh [k] {\tt sample.bib -o sample1.bib}

Afterwards the following entry can be found in the file {\sf sample1.bib}:

{\footnotesize\begin{verbatim}
@Article{         aamport:gnats,
  author        = {L[eslie] A. Aamport},
  title         = {The Gnats and Gnus Document Preparation System},
  journal       = {\mbox{G-Animal's} Journal},
  year          = 1986,
  volume        = 41,
  number        = 7,
  pages         = "73+",
  month         = jul,
  note          = "This is a full ARTICLE entry"
}
\end{verbatim}}

You see that the reference key has been changed. It now consists of the last
name and the first relevant word of the title, separated by a colon. Sometimes
it might be desirable to incorporate the initial names as well. This can be
achieved by the command

\sh [K] {\tt sample.bib -o sample1.bib}

The resulting reference key is {\tt aamport.la:gnats}. The initials are
appended after the first name. Thus the usual lexicographic order on the keys
will (hopefully) bring together the publications of the same first author.

Another alternative is to use the author and the year This can be achieved
with the following command:\footnote{Note that some command line interpreters
(like the UN*X shells) require the format string to be quoted (enclosed in
single quotes).}

\sh [f] {\tt \%n(author):\%2d(year) sample.bib -o sample1.bib}

The resulting key is {\tt Aamport:86}. Note that the last example work as
desired for our sample file. But for a real application of this technique a
deep understanding of the key generation mechanism as described in
section~\ref{sec:key.gen} is necessary.


%______________________________________________________________________________
\subsection{Extracting Entries for a Document}

\BibTool{} can be used to extract the references used in a document. For this
purpose \BibTool{} analyzes the \verb|.aux| file and takes the information
given there. This includes the names of the \BibTeX{} files. Thus no \BibTeX{}
files have to be given in the command line. Instead the \verb|.aux| file has
to specified --- preceded by the option \opt{x}.

\sh[x]{document.aux {\tt -o} document.bib}

The second option \opt{o} followed by a file name specifies the destination of
the output. I.e.\ instead of writing the result to the standard output stream
the result is written into this file.

%______________________________________________________________________________
\subsection{Extracting Entries Matching a Regular Expression}

\BibTool{} can be used to extract the references which fulfill certain
criteria. Those criteria can be specified utilizing regular
expressions.\footnote{Those features are only usable if the regular expression
  library has been enabled during the configuration of \BibTool{}---which is
  the default.} As a special case we can extract all entries containing a
certain substring of the key:

\sh[X]{tex all.bib {\tt -o} some.bib}

This instruction selects all records containing the substring {\tt tex} in the
key. The second option \opt{o} followed by a file name specifies the
destination of the output. I.e.\ instead of writing the result to the standard
output stream the result is written into this file.

Next we want to look up all records containing a substring in some of its
fields. For this purpose we search for the string in all fields
first:\footnote{Note that some command line interpreters (e.g the UN*X shells)
  might need additional quoting of the select instruction since it contains
  special characters.}

\sh[-]{select\{"tex"\} all.bib {\tt -o} some.bib}

Note that the comparison is not done case sensitive. Nevertheless this can be
customized (see page~\pageref{sec:extract}).

Finally we want to select only those records containing the substring in one
of certain fields. For this purpose we simply specify the names of those
fields in the {\em select}\/ instruction:

\sh[-]{select\{title booktitle \$key "tex"\} all.bib {\tt -o} some.bib}

This example extracts all records containing the substring {\tt tex} in the
title field, the booktitle field, or the reference key.

After we have come so far we can say that the first example in this section is
in fact a short version of the following command:

\sh[-]{select\{\$key "tex"\} all.bib {\tt -o} some.bib}


%______________________________________________________________________________
\subsection{Translating ISO8859-1 Characters}

Sometimes you need to translate some special characters into \BibTeX\
sequences. Suppose you have edited a \BibTeX\ file and by mistake used those
nice characters that are incompatible with standard ASCII as used in \BibTeX.
You can use \BibTool\ to do the trick:

\sh[r]{iso2tex {\tt -i} iso.bib {\tt -o} ascii.bib}


\section{Getting \BibTool, Hot News, and Bug Reports}

Usually \BibTool{} can be found on the CTAN or one of its
mirrors. Thus you can get \BibTool{} via ftp or extract it from a
CDROM containing a dump of the CTAN. The CTAN (Comprehensive \TeX{}
Archive Network) consists of the following sites:
\begin{itemize}
\item {\tt ftp.dante.de}
\item {\tt ftp.tex.ac.uk}
\item {\tt ftp.shsu.edu}
\end{itemize}
\BibTool{} can be found in the following directory:
\begin{itemize}
\item {\tt tex-archive/biblio/bibtex/utils/bibtool}
\end{itemize}


I have set up a WWW page for BibTool. It contains a short description
of the features and links to the documentation and the current
downloadable version. The URL is:

\verb|http://www.uni-koblenz.de/~gerd/ftp/BibTool|

This page contains additionally the number of the current version of
\BibTool{} and a list of changes in the last few versions.

If you encounter problems installing or using \BibTool{} you can send
me a bug report to my email address {\tt
  gerd@informatik.uni-koblenz.de}. Please include the following
information into a bug report:
\begin{itemize}
\item The version of \BibTool{} you are using.
\item Your hardware specification and operating system version.
\item The C compiler you are using and its version. (Only for
  compilation and installation problems)
\item The resource file yopu are using.
\item A {\em small}\/ \BibTeX{} file showing the problem.
\item The command line options of an invocation of \BibTool{} making
  the problem appear.
\item A short justification why you think that the behaviour is an error.
\end{itemize}

I have made the experience that compiling this information has helped
me finding my own problems in using software. Thus I could fix several
problems before sending a bug report.

On the other side I have unfortunately also made the experience that I
have got complains about problems in my software. After several
questions it turned out that the program has not been used proberly
only.

Oh, sure. There have been bugs and I suppose there are still some bugs in
\BibTool. I am grateful for each hint which helps me eliminating these
bugs.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\chapter{Reference Manual}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\parindent=0pt

This part of the documentation tries to describe all commands and
options. Since the appearance of \BibTool{} can be adjusted at compile
time not all features may be present in your executable. Thus watch
out and complain at the {\em installer}\/ if something is missing.

%______________________________________________________________________________
\section{Command Line Usage and Resource Files}

\BibTool{} cam be controlled either by arguments given in the command line or
by commands given in a file. Those command files are called resource files. If
\BibTool{} is installed correctly you should have the executable command
\verb|bibtool| (maybe with an additional extension). Depending on your
computer and operating system you can start This command in different ways.
This can be done either by issuing a command in a command line interpreter
(shell), by clicking an icon, or by selecting a menu item. In the following
description we will concentrate on the use in a UN*X like shell. There you can
type simply

\sh{}

Now \BibTool{} is waiting for your input. As you type \BibTool{} read what you
type. This input is interpreted as data conforming \BibTeX{} file rules. The
result is immediately printed when an entry is finished.  You can terminate
the reading phase with your End-Of-File character (e.g. Control-C on UN*X, or
Control-Z on MS-D*S)

This application in itself is rather uninteresting. Thus we come to the
possibility to give arguments to \BibTool. The simplest argument is \opt{h} as
in

\sh[h]{}

This command should print the version number and a short description of the
command line arguments to the screen.

The next application is the specification of resources. Resource files can be
given in the command line after the flag \opt{r}.

\sh[r]{resource\_file}

In this way an arbitrary number of resource files can be given. Those resource
files are read in turn and the commands contained are evaluated.  If no
resource file is given in the command line \BibTool{} tries to find one in
standard places. First of all the environment variable \env{BIBTOOLRSC} is
searched. If it is defined then the value is taken as a resource file name.
Otherwise the default resource file (usually the file {\tt .bibtoolrsc}) is
tried to be read in the home directory (determined by the environment variable
\env{HOME}) or the current directory.

The resource files are searched similar to the searching mechanism for
\BibTeX{} files (see section \ref{sec:search}). The extension {\tt .rsc} is
tried and a search path can be used. This search path is initialized from the
environment variable \env{BIBTOOL}. Initially only the current directory is on
the search path. The search path can also be set in a resource file (for
following resource file reading). This can be achieved by setting the resource
\rsc{resource.search.path}.

\Rsc{resource.search.path}{\em path}

When an explicit resource file is given in the command line the defaults are
not used. To incorporate the default resource searching mechanism the command
line option \opt{R} can be used:

\sh[R]{}




Now we have to describe the commands allowed in a resource file.  The
general form of a resource command is of the form

\Rsc{name}{value}

\rsc{name} is the resource name which conforms the rules of \BibTeX{}
reference keys. I.e.\ \rsc{name} can be composed of all characters
but whitespace characters and the exceptions
\begin{verbatim}
    "  #  %  '  (  )  ,  =  {  }
\end{verbatim}

Our resource names are currently composed of letters and the period.
The next component is the equality sign (=). This equality sign is optional.
Nevertheless it helps detecting syntax problems. Whitespace characters
surrounding the equality sign or separating resource name and resource value
are ignored. The resource value can be of the following kind:
\begin{itemize}
  \item A number composed of digits only.
  \item A string conforming the rules of resource names, i.e.\ made up of all
        but the forbidden characters described above.
  \item An string containing arbitrary characters delimited by double quotes
        (") not containing double quotes. Parentheses and curly brackets have
        to come in matching pairs.
  \item An string containing arbitrary characters delimited by curly brackets
        (\{\}). Parentheses and curly brackets have
        to come in matching pairs.
\end{itemize}

You can think of resource names as variables or functions in a programming
language. Resource commands simply set the variables to the given value, add
the value to the old value, or initiate a action.
There are different types of resources
\begin{itemize}
  \item Boolean resources can take only the values \rsc{on} and \rsc{off}.
        \rsc{on}, \rsc{t}, \rsc{true}, 1, and \rsc{yes} are interpreted
        the same. Everything else is interpreted as \rsc{off}.
  \item Numeric resources can take numeric values only.
  \item String resources can take arbitrary strings.
\end{itemize}

Usually whitespace characters are ignored. There is one exception. The
characters \verb|%| and \verb|#| act as comment start characters if given
between resource commands. All characters to the end of the line are ignored
afterwards.


Now we come the description of the first resource available. To read in
additional resource files the resource file may contain the resource

\RSC{resource}{additional/resource/file}

Thus the resource given above has the same functionality as the command line
option \opt{r} described above.

One resource command useful for debugging is the \rsc{print} resource. The
resource value is immediately written to the error stream. The output is
terminated by a newline character. Certain translations are performed during
the reading of a resource which can be observed when printing. Each sequence
of whitespace characters is translated into a single space.

To end this subsection we give an example of the \rsc{print} resource. In this
sample we also see the possibility the omit the equality sign and use quotes
as delimiters.

\RSc{print}{"This is a stupid\ \ \ \ message."}


Finally we can note that the commands given in a resource file can also be
specified on the command line. This can be achieved with the command line
option \opt{-} The next command line argument is taken as a resource command.

\sh[-]{resource\_command}

Be aware that command line interpreters have different ideas about what to do
with a command line before passing the arguments to a program. Thus it might
be necessary to carefully quote the arguments. Especially if the command
contains spaces it is very likely that quoting is needed.


%______________________________________________________________________________
\section{Input File Specification and Search Path}\label{sec:search}

An arbitrary number of input files can be specified. Input files can be
specified in two ways. The command line option \opt{i} is immediately followed
by a file name.

\sh[i]{input\_file}

The resource name \rsc{input} can be used to specify additional input files.

\RSC{input}{input\_file}

Input files are processed in the order they are given. If no input file is
specified the standard input is used to read from.

The files are searched in the following way. The file is can't be opened as
given then the extension {\tt .bib} is appended and another read is tried. In
addition directories can be given which are searched for input files. The
search path can be given in two different ways. First, the resource name
\rsc{bibtex.search.path} can be set to contain a search path specification.

\RSC{bibtex.search.path}{directory1:directory2:directory3}

The elements of the search path are separated by colons. Thus colons are not
allowed as parts of directories.  Another source of the search path is the
environment variable \env{BIBINPUTS}. This environment variable is usually
used by \BibTeX{} to specify the search path. The syntax of the specification
is the same as for the resource \rsc{bibtex.search.path}. To check the
appropriate way to set your environment variable consult the documentation of
your shell, since this is highly dependent on it.

To allow adaption to operating systems other than UN*X the following resources
can be used. The name of the environment \rsc{bibtex.env.name} overwrites the
name of the environment variable which defaults to \env{BIBINPUTS}.

\RSC{bibtex.env.name}{ENVIRONMENT\_VARIABLE}

The first character of the resource \rsc{env.separator} is used as separator
of directories in the resource \rsc{bibtex.search.path} and the environment
variable given as \rsc{bibtex.env.name}.

\RSC{env.separator}{:}

The default character separating directories in a file name is the slash
(\verb|/|). The first character of the resource \rsc{dir.file.separator} can
be used to change this value.

\RSC{dir.file.separator}{$\backslash$}

{\bf Note} that the defaults for \rsc{env.separator} and
\rsc{dir.file.separator} are set at compile time to a value suitable for the
operating system. Usually you don't have to change them at all. E.g. for MSDOS
machines the \rsc{env.separator} is usually set to \verb|;| and the
\rsc{dir.file.separator} is usually set to \verb|\|.


%______________________________________________________________________________
\section{Output File Specification and Status Reporting}

Several output streams can be used to write output to. The processed \BibTeX{}
entries are written to the standard output. This output can be redirected to a
file using the command line option \opt{o} as in

\sh[o]{output\_file}

The resource name \rsc{output.file} can be used for the same purpose.

\RSC{output.file}{output\_file}

No provisions are made to check if the output file is the same as a input
file.

A second output stream is used to display error messages and status reports.
The standard error stream is used for this purpose.

The messages can roughly be divided in three categories: error messages,
warnings, and status reports. Error messages indicate severe problems. They
can not be suppressed. Warnings indicate possible problems which could
(possibly) have been corrected. Usually the are displayed but they can be
suppressed. Status reports are messages during the processing which indicate
actions currently performed. Usually the are suppressed but they can be
enabled.

Warning messages can be suppressed using the command line option \opt{q}. This
option toggles the boolean quiet value.

\sh[q]{}

The same effect can be obtained by assigning the value {\sf on} or {\sf off}
to the resource \rsc{quiet}:

\Rsc{quiet}{on}

Status reports are useful to see the operations performed. They can be enabled
using the command line option \opt{v}. This option toggles the boolean verbose
value.

\sh[v]{}

The same can also be achieved with the boolean resource \rsc{verbose}:

\Rsc{verbose}{on}

Another output stream can be used to select the string definitions. This is
described in section~\ref{sec:macros} on macros.

\iffalse
For completeness we can also mention that the internal symbol table can be
printed using the command line option \opt{\$} or the boolean resource
\rsc{dump.symbols}.  This is mainly meant for debugging purposes. {\em Please
  send me a bug report and the diffs to fix it :-)}
\fi

%______________________________________________________________________________
\section{Parsing and Pretty Printing}

The first and simplest task we have to provide on \BibTeX{} files is the
parsing and pretty printing. This is not superfluous since \BibTeX{} is rather
pedantic about the accepted syntax. Thus I decided to try to be generous and
correct as may errors as I can.

Each input file is parsed and stored in an internal representation.  \BibTeX{}
simply ignores any characters between entries. Thus \BibTool{} mainly adopts
this behavior. This kind of comments is not represented internally. Normally
anything between entries is simply discarded and a warning printed. The
boolean resource \rsc{pass.comments} can be used to change this behavior.

\Rsc{pass.comments}{on}

If this resource is on then the characters between entries are directly passed
to the output file. This transfer starts with the first non-space character
after the end of an entry.

The standard \BibTeX{} styles support a limited number of entry types. Those
are predefined in \BibTool{}. Additional entry types can be defined using the
resource \rsc{new.entry.type} as in

\RSC{new.entry.type}{Anthology}

This option can also be used to redefine the appearance of entry types which
are already defined. Suppose we have defined {\em Anthology}\/ as above.
Afterwards we can redefine this entry type to be printed in upper case with
the following option:

\RSC{new.entry.type}{ANTHOLOGY}

Each undefined entry type leads to an error message.


The internal representation is printed in a format which can be adjusted by
certain options. Those options are available through resource files or
by specifying resources on the command line.

\begin{description}
  \item [\rsc{print.line.length}]
        This numeric resource specifies the desired width of the lines. lines
        which turn out to be longer are tried to split at spaces and continued
        in the next line. The value defaults to 77.
  \item [\rsc{print.indent}]
        This numeric resource specifies indentation of normal items, i.e.\
        items in entries which are no strings or comments. The value defaults
        to 2.
  \item [\rsc{print.align}]
        This numeric resource specifies the column at which the '=' in
        non-comment and non-string entries are aligned. This value defaults
        to 18.
  \item [\rsc{print.align.key}]
        This numeric resource specifies the column at which the '=' in
        non-comment and non-string entries are aligned. This value defaults
        to 18.
  \item [\rsc{print.align.string}]
        This numeric resource specifies the column at which the '=' in string
        entries are aligned. This value defaults to 18.
  \item [\rsc{print.align.preamble}]
        This numeric resource specifies the column at which preamble
        entries are aligned. This value defaults to 11.
  \item [\rsc{print.align.comment}]
        This numeric resource specifies the column at which comment
        entries are aligned. This value defaults to 10.
  \item [\rsc{print.newline}]
        This numeric resource specifies the number of newlines between
        records. This value defaults to 1.
  \item [\rsc{print.use.tab}]
        This boolean resource specifies if the {\tt TAB} character should be
        used for indenting. This use is said to cause portability problems.
        Thus it can be disabled. If disabled then the appropriate number of
        spaces are inserted instead. This value defaults to {\sf on}.
\end{description}

The resource values described above are illustrated by the following examples.
First we look at a string entry.

\noindent
\begin{minipage}{\textwidth}\vspace{1ex}
{\small\tt\setbox0=\hbox{m}\unitlength=\wd0%
\begin{verbatim}
@STRING{macro   = "This is a rather long replacement text which exceeds one
                  line"}
\end{verbatim}
\begin{picture}(0,2)(0,-3)
  \put(18,0){\line(0,1){7}}
  \put(77,0){\line(0,1){7}}
  \put(77,0){\makebox(0,0)[r]{\rsc{print.line.length}}}
  \put(18,0){\makebox(0,0)[l]{\rsc{print.align.string}}}
\end{picture}
}\vspace{1ex}\end{minipage}

Next we look at an unpublished entry. It has a rather long list of authors and
a long title. It shows how the lines are broken.

\noindent
\begin{minipage}{\textwidth}\vspace{1ex}
{\small\tt\setbox0=\hbox{m}\unitlength=\wd0%
\begin{verbatim}
@Unpublished{     unpublished-key,
  author        = "First A. U. Thor and Seco N. D. Author and Third A. Uthor
                  and others",
  title         = "This is a rather long title of an unpublished entry which
                  exceeds one line",
  note          = "Some useless comment"
}
\end{verbatim}
\begin{picture}(0,2)(0,-3)
  \put( 2,0){\line(0,1){14}}
  \put(18,0){\line(0,1){17}}
  \put(77,0){\line(0,1){17}}
  \put(77,0){\makebox(0,0)[r]{\rsc{print.line.length}}}
  \put(18,0){\makebox(0,0)[l]{\rsc{print.align}}}
  \put( 2,0){\makebox(0,0)[l]{\rsc{print.indent}}}
\end{picture}
}\vspace{1ex}\end{minipage}

The field names of an entry are usually printed in lower case. This can be
changed with the resource \rsc{new.field.type}. The argument of this resource
is an equation where left of the '=' sign is the name of a field and on the
right side is it's print name. They should only contain allowed characters.

\RSc{new.field.type}{\{ author = AUTHOR \}}

This feature can be used to rewrite the field types. Thus it is completely
legal to have a different replacement text than the original field:

\RSc{new.field.type}{\{ OPTauthor = Author \}}

String names are used case insensitive by \BibTeX. \BibTool{} normalizes
string names before printing. Per default string names are translated to lower
case.  Currently two other types are supported: translation to upper case and
translation to mixed case, i.e. the first letter upper case and the others in
lower case.

The translation is controlled by the resource
\rsc{symbol.type}.\label{symbol.type} The value is one of the strings
\verb|lower|, \verb|upper|, and \verb|cased|. The resource can be set as in

\Rsc{symbol.type}{upper}

The macro names are passed through the same normalization apparatus as field
types. Thus you can force a rewriting of macro names with the same method as
described above. You should be careful when choosing macro names which are
also used as field types.

The reference key is usually translated to lower case letters unless a new key
is generated (see section~\ref{sec:key.gen}). In this case the chosen format
determines the case of the key. Sometimes it can be desirable to preserve the
case of the key as given (even so \BibTeX{} does not mind). This can be
achieved with the boolean resource \rsc{preserve.key.case}. Usually it is
turned off (because of backward compatibility and the memory used for this
feature). You can turn it on as in

\Rsc{preserve.key.case}{on}

If it is turned on then the keys as they are read are recorded and used when
printing the entries.

%______________________________________________________________________________
\section{Key Generation}\label{sec:key.gen}

The key generation facility provides a mean to uniformly replace the reference
keys by generated values. Two algorithms are compiled in. Additionally a free
formatting facility is provided. This can be used to specify your own
algorithm to generate keys. The generation of new keys can be enabled using
the command line option \opt{f} in the following way:

\sh[f]{format}

This command adds format disjunctively to the formatting instructions already
given. The same effect can be achieved with the resource \rsc{key.format}.

\RSC{key.format}{format}

Some values of {\it format}\/ have a special meaning. Fixed formatting rules
are used when one of them is in effect. The special values are described
below.
\begin{description}
  \item [\rsc{short}]
        If an author or editor field are present, then this field is
        used.  The short version uses last names only. Afterwards a title or
        booktitle field is appended, after the \rsc{fmt.name.title}
        separator has been inserted. Finally if all else fails then the
        default key \rsc{default.key} is used. The result is disambiguated.
  \item [\rsc{long}]
        The long version acts like the short version but incorporates initials
        when formatting names.
  \item [\rsc{short.need}]
        This version formats like \rsc{short} but only if the given key field
        is empty.
  \item [\rsc{long.need}]
        This version formats like \rsc{long} but only if the given key field
        is empty.
  \item [\rsc{empty}]
        The empty version clears the key entirely. The result does not
        conform to the \BibTeX{} syntax rules. This feature can be used to
        generate keys only if required.
\end{description}

In contrast to the command line option the resource instruction only modifies
the formatting specification. The key generation has to be activated
explicitly. This can be done using the command line option \opt{F} as in

\sh[F]{}

Alternatively the boolean resource \rsc{key.generation} can be used in a
resource file:

\Rsc{key.generation}{on}


As we have seen there are options to adapt the behavior of formatting. Before
we will explain the free formating specification in section
\ref{sec:key.format} we will present the formatting options. Those options can
be activated from a resource file exclusively.

\begin{description}
  \item [\rsc{default.key}]
        The value of this resource is used by the styles \rsc{short} and
        \rsc{long} if nothing else can be used.
        The default value is \verb|**key*|.
  \item [\rsc{key.base}]
        The value of this resource is used to determine the kind of formatting
        the disambiguating number. Possible values are \rsc{upper},
        \rsc{lower}, and \rsc{digit}. Uppercase letters, lower case letters,
        or digits are used respectively.
  \item [\rsc{key.number.separator}]
        The value of this resource is used to separate the disambiguating
        number from the rest of the key.
        The default value is \verb|*|.
  \item [\rsc{key.expand.macros}]
        The value of this boolean resource is used to indicate whether
        macros should be expanded while generating a key.
        The default value is \verb|off|.
  \item [\rsc{fmt.name.title}]
        The value of this resource is used by the styles \rsc{short} and
        \rsc{long} to separate names and titles.
        The default value is \verb|:|.
  \item [\rsc{fmt.title.title}]
        The value of this resource is used to separate words inside titles.
        The default value is \verb|:|.
  \item [\rsc{fmt.name.name}]
        The value of this resource is used to separate different names (where
        the \BibTeX{} file has \verb|and|) when formatting names.
        The default value is \verb|.|.
  \item [\rsc{fmt.inter.name}]
        The value of this resource is used to separate parts of multi-word
        names when formatting names.
        The default value is \verb|-|.
  \item [\rsc{fmt.name.pre}]
        The value of this resource is used to separate names and first names
        when formatting names.
        The default value is \verb|.|.
  \item [\rsc{fmt.et.al}]
        The value of this resource is used to format \verb|and others| parts
        of a name list.
        The default value is \verb|.ea|.
\end{description}


The key style \rsc{short} can be formulated in terms of the format
specification given in section \ref{sec:key.format} as follows:

{\small
\begin{verbatim}
{
  { %-2n(author)
  # %-2n(editor)
  }
  { %s($fmt.name.title) %-1T(title)
  # %s($fmt.name.title) %-1T(booktitle)
  #
  }
}
#
{ { %s($fmt.name.title) %-1T(title)
  # %s($fmt.name.title) %-1T(booktitle)
  }
}
# %s($default.key)
\end{verbatim}%$
}

The syntax and meaning of such format specifications is explained in section
\ref{sec:key.format}.


%______________________________________________________________________________
\section{Format Specification}\label{sec:key.format}

\subsection{Constant Parts}

The simplest component of a format is a constant string. Such strings are
made up of any character except whitespace and the following ten characters

\begin{verbatim}
    "  #  %  '  (  )  ,  =  {  }
\end{verbatim}

This choice of special characters is the same as the special characters of
\BibTeX. Since no means is provided to include a special character into a
format string we guarantee that the resulting key string is conform to the
\BibTeX{} rules.

For example the following strings are legal constant
parts of a format:
\begin{verbatim}
  Key
  the_name.of-the-@uthor-is:
\end{verbatim}


Now we come to explain the meaning of the special characters. The first case
consists of the whitespace characters. They are simply ignored. Thus the
following format strings are equal:\footnote{Well, this is not the whole
truth. Internally it makes a difference whether there is a space or not. In
the presence of spaces more memory is used. But you shouldn't worry too much
about this.}
\begin{verbatim}
  Author Or Editor
  AuthorOrEditor
  A u t h o r   O r   E d i t o r
\end{verbatim}


\subsection{Formatting Fields}\label{ssec:fields}

The next component of formats are made up formating instructions which are
starting with a \verb|%| character. The general idea has been inspired by
formating facilities of C. Since there are several different types of
information in a \BibTeX{} entry we provide several primitives for formating.
The simplest form is for instance
\begin{verbatim}
  %N(author)
\end{verbatim}

The \verb|%| character is followed by a single character --- here \verb|N| ---
which indicates the way of formating and the name of the field to be formatted
enclosed in parenthesis. The example above requests to format the field
\verb|author| according to formatting rules for names (\verb|N|).

The general form is

\begin{itemize}
  \item [] {\tt\%}{\it sign pre.post qualifier letter}{\tt(}{\it field}{\tt)}
\end{itemize}

In this specification {\it sign}\/ is \verb|+| or \verb|-|. \verb|+| means
that all characters will be translated to upper case. \verb|-| means that all
characters will be translated to lower case. If no sign is given, the case of
the field is preserved.

{\it pre}\/ and {\it post}\/ are positive integers whose meaning
depends on the format letter {\it letter}. {\it qualifier letter} is a
one letter specification indicating the desired formatting type
optionally preceeded by the qualifier \verb|#|. Possible values are as
described in the following list:

\begin{itemize}
  \item [\tt p] Format names according to the format specifier number
        {\it post}. In a list of names at most {\it pre}\/ names are
        used. If there are more names they are treated as given as
        \verb|and others|.

        {\it pre}\/ defaults to 2 and {\it post}\/ defaults to 0.

        See section~\ref{sec:names} for a description of how to
        specify name formats.

  \item [\tt n] Format last names only.\\
        In a list of names at most {\it pre}\/ last names are used. If there
        are more names they are treated as given as \verb|and others|.
        If {\it post}\/ is greater than 0 then at most {\it post}
        characters per name are used. Otherwise the whole name is
        considered.

        {\it pre}\/ defaults to 2 and {\it post}\/ defaults to 0.

        This is the same as using the {\tt p} format specifier with
        the post value of 0. The {\it post}\/ value of the {\tt n}
        specifier is used as the {\it len} value of the first item of
        the name format specifier. (See also section~\ref{sec:names})

  \item [\tt N] Format names with last names and initials.\\
        In a list of names at most {\it pre}\/ last names are used. If there
        are more names they are treated as given as \verb|and others|.
        If {\it post}\/ is greater than 0 then at most {\it post}
        characters per name are used. Otherwise the whole name is
        considered.

        {\it pre}\/ defaults to 2 and {\it post}\/ defaults to 0.

        This is the same as using the {\tt p} format specifier with
        the post value of 1. The {\it post}\/ value of the {\tt n}
        specifier is used as the {\it len} value of the first item of
        the name format specifier. (See also section~\ref{sec:names})

  \item [\tt d] Format a number, e.g.\ a year.\\
        The first number in the field is searched. At most {\it pre}\/ digits
        --- counted from the right --- are used. E.g.\ the field 
        \verb|"june 1958"| formatted with \verb|%2d| results in \verb|58|.

        {\it pre}\/ defaults to a large number.

  \item [\tt s] Take a field as is (after translation of special characters).\\
        At most {\it pre}\/ characters are used.

        {\it pre}\/ defaults to a large number.

  \item [\tt T] Format sentences. Certain words are ignored.\\
        At most {\it pre}\/ words are used. The other words are ignored. If
        {\it pre}\/ is 0 then no artificial limit is forced. If {\it post}\/
        is positive then at most {\it post}\/ letters of each word are
        considered. Otherwise the complete words are used.

        New words to be ignored can be added with the resource
        \rsc{ignored.word}.

        {\it pre}\/ defaults to 1 and {\it post}\/ defaults to 0.

  \item [\tt t] Format sentences. In contrast to the format letter {\tt T} no
        words are ignored.\\
        At most {\it pre}\/ words are used. The other words are ignored. If
        {\it pre}\/ is 0 then no artificial limit is forced. If {\it post}\/
        is positive then at most {\it post}\/ letters of each word are
        considered. Otherwise the complete words are used.

        {\it pre}\/ defaults to 1 and {\it post}\/ defaults to 0.

  \item [\tt W] Format word lists.\\
        This specifier acts like {\tt T} except that nothing is inserted
        between words.

  \item [\tt w] Format word lists.\\
        This specifier acts like {\tt t} except that nothing is inserted
        between words.

  \item [\tt \#p] Count the number of names.

    If no {\it sign}\/ is given or the {\it sign}\/ is \verb|+| then
    the following rules apply. If the count is less than {\it pre}\/
    or the count is greater than {\it post} then this specifier fails.
    Otherwise it succeeds without adding something to the key.

    If the {\it sign}\/ is \verb|-| then the specifier succeeds if
    and only if the specifier without this sign succeeds. Thus the
    \verb|-| acts like a negation of the condition.

    If post has the value 0 than this is treated like $\infty$.

    {\it pre}\/ and {\it post}\/ both defaults to 0.
    
  \item [\tt \#n] Is the same as {\tt \#p}.
  \item [\tt \#N] Is the same as {\tt \#p}.

  \item [\tt \#s] Count the number of allowed characters.

    If no {\it sign}\/ is given or the {\it sign}\/ is \verb|+| then
    the following rules apply. If the count is less than {\it pre}\/
    or the count is greater than {\it post} then this specifier fails.
    Otherwise it succeeds without adding something to the key.

    If the {\it sign}\/ is \verb|-| then the specifier succeeds if
    and only if the specifier without this sign succeeds. Thus the
    \verb|-| acts like a negation of the condition.

    If post has the value 0 than this is treated like $\infty$.

    {\it pre}\/ and {\it post}\/ both default to 0.
 
  \item [\tt \#w] Count the number of words. All words are considered
    as valid. The division into words is performed after de\TeX{}ing
    the field.

    If no {\it sign}\/ is given or the {\it sign}\/ is \verb|+| then
    the following rules apply. If the count is less than {\it pre}\/
    or the count is greater than {\it post} then this specifier fails.
    Otherwise it succeeds without adding something to the key.

    If the {\it sign}\/ is \verb|-| then the specifier succeeds if
    and only if the specifier without this sign succeeds. Thus the
    \verb|-| acts like a negation of the condition.

    If post has the value 0 than this is treated like $\infty$.

    {\it pre}\/ and {\it post}\/ both default to 0.

   \item [\tt \#t] Is the same as {\tt \#w}.

   \item [\tt \#W] Count the number of words. Certain words are
     ignored. The ignored words are determined by the resource
     \rsc{ignored.word}. The division into words is performed after
     de\TeX{}ing the field.

    If no {\it sign}\/ is given or the {\it sign}\/ is \verb|+| then
    the following rules apply. If the count is less than {\it pre}\/
    or the count is greater than {\it post} then this specifier fails.
    Otherwise it succeeds without adding something to the key.

    If the {\it sign}\/ is \verb|-| then the specifier succeeds if
    and only if the specifier without this sign succeeds. Thus the
    \verb|-| acts like a negation of the condition.

    If post has the value 0 than this is treated like $\infty$.

    {\it pre}\/ and {\it post}\/ both default to 0.

   \item [\tt \#T] Is the same as {\tt \#W}.

\end{itemize}

The field specification {\it (field)} selects the field of the entry to be
formatted. As usual in \BibTeX{} the case of the letters is ignored.  If the
field does not exist then the formatting fails and continues at the next
alternative (see below). In addition to the ordinary fields of an entry there
are several pseudo fields.

\begin{description}
  \item [\tt \$key]\label{pseudo:key}
        This pseudo field contains the old reference key --- before generating
        a new one. If none has been given then the access fails.
  \item [\tt \$default.key]
        This pseudo field contains the value of the resource \rsc{default.key}
        similarly the resources  \rsc{fmt.name.title}, \rsc{fmt.title.title},
        \rsc{fmt.name.name}, \rsc{fmt.inter.name}, \rsc{fmt.name.pre}, and
        \rsc{fmt.et.al} can be accessed.
  \item [\tt \$type]
        This pseudo field contains the type of the entry, i.e.\ the string
        following the initial \verb|@| of an \BibTeX{} entry. E.g.\
        \verb|article|. It is always present.
  \item [\tt @\it type]
        This pseudo field is matched against the type of the entry. If they
        are identical (ignoring cases) then the type is returned. Otherwise
        the access fails.

        In an article item the specification \verb|%s(@Article)| succeeds and
        returns \verb|Article| whereas \verb|%s(@Book)| fails.
\end{description}



\subsection{Expanding \TeX/\LaTeX{} Macros}

When fields are formatted certain \LaTeX{} macros may be replaced by pure text.
Each macro not defined is simply ignored. Initially no \LaTeX{} macro is
defined. The resource \rsc{tex.define} can be used to define \LaTeX{} macros.
The syntax is very close to \LaTeX. The simplest form is the following
definition.

\RSC{tex.define}{\it macro=replacement text}

This resource defines a simple macro which is replaced by the replacement
text. This replacement text may in turn contain macros.

In addition to this simple macro also macros involving arguments can be
defined. As in \LaTeX's \verb|\newcommand| the number of arguments is appended
after the macro name.

\RSC{tex.define}{\it macro{\tt[}arg{\tt]}=replacement text}

The number of arguments may not exceed 9. The actual parameters are addressed
by writing {\tt \#}{\it n}, where {\it n} is the number of the argument.

For instance, this feature can be used to ignore certain arguments of macros.

Note that there should be no spaces between the macro head and the equality
sign (\verb|=|). Similarly any unwanted spaces after the equality sign may
have strange effects.

Usually the macro name starts with a backslash (\verb|\|). If the macro name
starts with another character then this character is made active (cf.\
\cite{knuth:texbook}). This feature is especially useful for translating
characters with an extended ASCII code ($\geq128$) to the appropriate \TeX{}
macros. 

For instance the following definition forces the expansion of the macro
\verb|\TeX| to the string \verb|TeX|.

\RSC{tex.define}{\BS TeX=TeX}

Without this definition the title \verb|The \TeX{}book| would result in
\verb|book|. With this definition the same title results in \verb|TeXbook|.

Suppose you have an input file containing 8-bit characters (e.g. ISO 8859-1
encoding). The following definition can be used to map this character into a
pure ASCII string\footnote{To add an e is the German convention for umlaut
  characters.} 

\RSC{tex.define}{{\"u}=ue}

Some useful definitions can be found in the libraries distributed with
\BibTool{} (see also appendix \ref{chap:resource.files}). 


\subsection{Name Formatting}\label{sec:names}

Names are a complicated thing. \BibTool{} tries to analyze names and
``understand'' them correctly. According to the \BibTeX{} definition a
name consists of four types of components:
\begin{itemize}
\item The first names are any names before the last names which start
  with an upper case letter.\\
  E.g. for the name ``Ludwig van Beethoven'' the first name is ``Ludwig''.
\item The last name is the last word (or group of words) which does
  not belong to the junior part.\\
  E.g. for the name ``Ludwig van Beethoven'' the last name is ``Beethoven''.
\item The von part are the names before the last name which start with
  lower case lettern.\\
  E.g. for the name ``Ludwig van Beethoven'' the von part consists or
  the word ``van''.
\item The junior part of a name is an appendix following the last
  name. \BibTool{} knows only a small number of words that can appear
  in the junior part: junior, jr., senior, sen., Esq., PhD., and roman
  numerals up to XXX.
\end{itemize}

Everything except the last name is optional. Each part can also
consist of several words. More on names can be found in
\cite{lamport:latex} and \cite{patashnik:designing}.

\BibTool{} provides a means to specify how the various parts of a name
should be used to construct a string. This string can be used as part
of a key with the \verb|%p| format specifier (see above).

\BibTool{} uses a small number of name format specifiers.\footnote{The
  exact number can be changed in the configuration file before
  compilation. The default is 128.} Initially most of them are
  undefined. The name format specifier 0 is initially set to the value
  \verb|%l[|{\em fmt.inter.name}\/\verb|]|. The name format specifier 0 is initially set to the value
  \verb|%l[|{\em fmt.inter.name}\/\verb|]%1f[|{\em fmt.inter.name}\/\verb|]|. 

  The name format specifiers 0 and 1 are used by the formatting
  instructions \verb|%N| and \verb|%n|. Thus you should be careful
  when redefining them. To help you having an eye on these two name
  format specifiers \BibTool{} issues a warning when they are modified.

  The resource \rsc{new.format.type} can be used to assign values to
  those name format specifiers:

\RSC{new.format.type}{17="\%f\%v\%l"}

This instruction sets the name format specifier number 17 to the given
value. This value is a string of characters to be used directly.
There is only one construct which is not used literally. This
construct is started by a \% sign optionally followed by a \verb|+| or
a \verb|-| and a number. Next comes one of the letters {\tt f}, {\tt
  v}, {\tt l}, or {\tt j}. Finally there are three optional arguments
enclosed in brackets.

Thus the general form looks as follows:

\begin{itemize}
  \item [] {\tt\%}{\it sign len letter}{\tt[}{\it mid}{\tt][}{\it
      pre}{\tt][}{\it post}{\tt]} 
\end{itemize}

The letter {\tt f} denotes all first names.  The letter {\tt l}
denotes all last names.  The letter {\tt v} denotes all words in the
von part.  The letter {\tt j} denotes all words in the junior part.

If {\it sign} is \verb|+| then the words are translated to upper case.
If {\it sign} is \verb|-| then the words are translated to lower case.
If no sign is given then no conversion is performed.

The number {\it len}\/ can be used to specify the number of characters
to be used. Each word is truncated to at most {\it len}\/ characters
if {\it len}\/ is greater than 0. Otherwise no truncation is
performed. I.e. a value of $0$ acts like $\infty$.

If {\tt[}{\it mid}{\tt]} is given then this string is used between
several words of the given part. If none is given then the empty
string is used.

If {\tt[}{\it pre}{\tt]} is given then this string is used before the
given part, but only if the part is not empty. If none is given then
the empty string is used.

If {\tt[}{\it post}{\tt]} is given then this string is used after the
given part, but only if the part is not empty. If none is given then
the empty string is used.




Now we can come to an example. Suppose the name field contains the
value {\tt Cervantes Saavedra, Miguel de}\footnote{This is the author
  of ``Don Quixote''}. This name has two last names, one first name and
one word in the von part.

We want to apply the following name format specifier

\begin{itemize}
  \item [] \verb|%1f[.][][.]%1v[.][][.]%3l[-]%1j| 
\end{itemize}

This means we want to use abbreviation of first name, von and junior
part to one letter and of three letters of the last name. Thus we will
get the result \verb|M.d.Cer-Saa|.

Note that the name specifier does not take care to include only
allowed letters into a key. Thus watch out and avoid special
characters as whitesapace and comma.


\subsection{Conjunctions}

Conjunctions are formatting instructions evaluated in sequence. The
conjunctions are simply written by successive formatting instructions. A
conjunction succeeds if every part succeeds. The empty conjunction always
succeeds.

Suppose an \BibTeX{} entry contains fields for {\tt editor} and {\tt year}.
Then the following conjunction succeeds:

\begin{itemize}
  \item [] \verb|%-3n(editor) : %2d(year)|
\end{itemize}

If the value of the {\tt editor} field is \verb|"|\verb|E.D. Itor"| and the
{\tt year} field contains \verb|"1992"| then the result is \verb|itor:92|.

\subsection{If-Then-Else}\label{ssec:if-then-else}

Depending on the presence of a (pseudo-) field formatting instructions can be
issued. This corresponds to an if-then-else statement in a {\sc Pascal}-like
language. The syntax is as follows:

\begin{itemize}
  \item [] {\it\verb|(|field\/\verb|)|\/\verb|{|then-part\/\verb|}|
        \verb|{|else-part\/\verb|}|}
\end{itemize}

If the access to the (pseudo-) field as described in \ref{ssec:fields} succeeds
then the {\it then-part}\/ is evaluated. Otherwise the {\it else-part}\/ is
evaluated. Both parts may be empty. Nevertheless the braces are required.

Let us look at an example. The following construction can be used to format a
field {\tt author} if it is present or print an constant string.

\begin{itemize}
  \item [] \verb|(author){%N(author)}{--no-author--}|
\end{itemize}


\subsection{Alternatives}

Alternatives (disjunctives) are separated by the hash mark (\verb|#|). The
general form is

\begin{itemize}
  \item [] {\it alternative-1 \verb|#| alternative-2 \verb|#| ...
        \verb|#| alternative-n}
\end{itemize}

The alternatives are evaluated from left to right. The first one that succeeds
terminates the processing of all alternatives with success. If no alternative
is successful then the whole construct fails.

An alternative can be empty. The empty alternative succeeds without any other
effect.

The example given in subsection \ref{ssec:if-then-else} can be also written as

\begin{itemize}
  \item [] \verb|%N(author) # --no-author--|
\end{itemize}

If the author field is accessible the the first alternative succeeds and
terminates the construct. Otherwise the constant string is used. This constant
string always succeeds.


\subsection{Grouping}

Any number of constructs can be enclosed in braces (\verb|{}|) for grouping.
Thus the precedence of operators can be bypassed.

Coming back to our example from the previous subsection. To complicate the
example we want to append an optional title, or an constant string. This is
accomplished as follows.


\begin{itemize}
  \item [] \verb|{ %N(author) # --no-author-- } |
           \verb|{ %T(title) # --no-title-- } |
\end{itemize}

The grouping allows to restrict the range of the alternative operator \verb|#|
in this example.

%______________________________________________________________________________
\section{Sorting}\label{sorting}

The entries can be sorted according to a certain sort key. The sort key is by
default the reference key. Sorting can enabled with the command line switches
\opt{s} and \opt{S} as in

\sh[s]{}\vspace{-4ex}
\sh[S]{}

The first variant sorts in ascending ASCII order (including differentiation of
upper and lower case). The second form sorts in descending ASCII order.
The same effect can be achieved with the boolean resource values \rsc{sort}
and \rsc{sort.reverse} respectively.

\RSC{sort}{on}\vspace{-4ex}
\RSC{sort.reverse}{on}

An alternate format of the sort key can be specified like for the key format
described in section \ref{sec:key.gen}. The associated resource name is
\rsc{sort.format}. Several formats are combined as alternatives.

\RSC{sort.format}{\%N(author)}\vspace{-4ex}
\RSC{sort.format}{\%N(editor)}

Those two lines are equivalent with the single resource

\RSC{sort.format}{\it \%N(author) \# \%N(editor)}

%______________________________________________________________________________
\section{Selecting Items}

\subsection{Extracting by {\tt aux} Files}

\BibTool{} includes a module to extract \BibTeX{} entries required for a
document. This is accomplished by analyzing the {\tt aux} file of the
document. The {\tt aux} file is usually produced by \LaTeX{}. It contains the
information which \BibTeX{} files and which references are used in the
document.  Only those entries mentioned in the {\tt aux} file are selected for
printing. Since the \BibTeX{} files are already named in the {\tt aux} file it
is not necessary to specify an input file.

To use an {\tt aux} file the command line option \opt{x} can be given. This
option is followed by the name of the {\tt aux} file.

\sh[x]{file.aux}

Multiple files can be given this way. As always the same functionality can be
requested with a resource. The resource \rsc{extract.file} can be used for
this purpose.

\RSC{extract.file}{\it file.aux}

A small difference exists between the two variants. the command line
option automatically sets the resource \rsc{print.all.strings} to
\verb|off|. This has to be done in the resource file manually.


One special feature of \BibTeX{} is supported. If the command
\verb|\nocite{*}| is given in the \LaTeX{} file then all entries of the
bibliography files are included in the bibliography. The same behavior is
imitated by the extracting mechanism of \BibTool.


\subsection{Extracting with Regular Expressions}\label{sec:extract}

Another selecting mechanism uses regular expressions to select items. This
feature can be used in addition to the selection according to {\tt aux} files.

The regular expression syntax is identical to the one used in GNU Emacs. For a
description see section \ref{sec:regex}.

The resource \rsc{select} allows to specify which fields should be used to
select records. The general form is as follows:

\RSC{select}{\it field$_1$ $\ldots$ field$_n$ "regular\_expression"}

If no field is specified then the regular expression is searched in each
field. 

Any number of selection rules can be given. A record is selected if one of
those rules selects it. The select rule selects a record if this record has a
field named {\em field}\/ which has a substring matching {\em
  regular\_expression}. The field can be missing in which case the regular
expression is tried to match against any field in turn.

The pseudo fields \verb|$key|, \verb|$type|, and \verb|@|{\em type}\/ can be
used to access the key and the type of the record. See page
\pageref{pseudo:key} for details. The routines used there are the same as those
used here.

The boolean resource \rsc{select.case.sensitive} can be used to determine
whether the selection is performed case sensitive or not:

\Rsc{select.case.sensitive}{off}


A regular expression can be specified in the command line using the option
\opt{X} as in

\sh[X]{regular\_expression}

The fields compared against this regular expression are given in the string
valued resource \rsc{select.fields}. Initially this resource has the value
\verb|$key|. In general the value is a list of fields and pseudo fields to be
considered.  The elements of the list are separated by spaces. If the list is
empty then all fields and the key are considered for comparison.

Thus the following setting means that the regular only the fields \verb|author|
and \verb|editor| are considered when doing a selection.

\Rsc{select.fields}{"author editor"}

Without changing the resource \rsc{select.fields} the command line given
previously is equivalent to the (longer) command

\sh[-]{\{\$key "regular\_expression"\}}

Note that the resources \rsc{select.case.sensitive} and \rsc{select.fields} are
used for all regular expressions following their definition until they are
redefined. This means that it is possible to specify that some comparisons are
done case sensitive and others are not done case sensitive.



Finally the resource \rsc{extract.regex} can be used as in

\RSC{extract.regex}{\it regular\_expression}

This is equivalent to specifying a single regular expression to be matched
against the key. This feature is kept for backward compatibility only. It is
not encouraged and will vanish in a future release.

%______________________________________________________________________________
\section{Regular Expression Matching}\label{sec:regex}

A concise description of regular expressions is contained in the document {\sf
Regex/regex.texi} contained in the \BibTool{} distribution. In any cases of
doubt this documentation is preferable. The remainder of this section contains
a short description of regular expressions.

\begin{description}
\item[Ordinary characters] match only to themself or their upper or lower case
  counterpart. Any character not mentioned as special is an oridinary
  character. Amoung others letters and digits are ordinary characters.

  E.g. the regular expression {\em abc}\/ matches the string {\em abc}.  

\item[The period] (\verb|.|) matches any single character.

  E.g. the regular expression {\em a.c}\/ matches the string {\em abc}\/ but it
  does not match the string {\em abbc}.

\item[The star] (\verb|*|) ist used to denote any number of repetitions of the
  preceeding regular expression. If no regular expression preceeds the star
  then it is an ordinary character.

  E.g. the regular expression {\em ab*c}\/ matches any string which starts with
  a followed by an arbitrary number of b and ended by a c. Thus it matches {\em
    ac}\/ and {\em abbbc}. But it does not match the string {\em abcc}.

\item[The plus] (\verb|+|) is used to denote any number of repetitions of the
  preceeding regular expression, but at least one. Thus it is the same as the
  star operator except that the empty string does not match. If no regular
  expression preceeds the plus then it is an ordinary character.

  E.g. the regular expression {\em ab+c}\/ matches any string which starts with
  a followed by one or more b and ended by a c. Thus it matches {\em abbbc}.
  But it does not match the string {\em ac}.

\item[The question mark] (\verb|?|) is used to denote an optional regular
  expression. The preceeding regular expression matches zero or one times. If
  no regular expression preceeds the question mark then it is an ordinary
  character.

  E.g. the regular expression {\em ab?c}\/ matches any string which starts with
  a followed by at most one b and ended by a c. Thus it matches {\em abc}. But
  it does not match the string {\em abbc}.

\item[The bar] (\verb/|/) separates two regular expressions. The combined
  regular expresion matches a string if one of the alternative separated by
  the bar does.

  E.g. the regular expression {\em abc|def}\/ matches the string {\em abc} and
  the string {\em def}.

\item[Parentheses] (\verb/()/) can be used to group regular expressions. A
  group is enclosed in parentheses. It matches a string if the enclosed
  regular expression does.

  E.g. the regular expression {\em a(b|d)c}\/ matches the strings {\em abc}\/
  and {\em adc}.
  
\item[The dollar] (\verb|$|)%$
  matches the empty string at the end of the string. It can be used to anchor
  a regular expression at the end.  If the dollar is not the beginning of the
  regular expression then it is an ordinary character.

  E.g. the regular expression {\em abc\$}\/ matches the strings {\em aaaabc}\/
  but does not match the string {\em abcdef}.

\item[The hat] (\verb|^|) matches the empty string at the beginning of the
  string. It can be used to anchor a regular expression at the beginning.
  If the hat is not the beginning of the regular expression then it is an
  ordinary character. There is one additional context in which the hat has a
  special meaning. This context is the list operator described below.

  E.g. the regular expression {\em \verb|^|abc}\/ matches the strings {\em
    abcccc}\/ but does not match the string {\em aaaabc}.

\item[The brackets] (\verb|[]|) are used to denote a list of characters. If
  the first character of the list is the hat (\verb|^|) then the list matches
  any character not contained in the list. Otherwise it matches any characters
  contained in the list.

  E.g. the regular expression {\em [abc]}\/ matches the single letter strings
  {\em a}, {\em b}, and {\em c}. It does not match {\em d}.

  The regular expression {\em [\^{}abc]} matches any single letter string not
  consisting of a, b, or c.

\item[The backslash] (\verb|\|) is used for several purposes. Primarily it can
  be used to quote any special character. I.e. if a special character is
  preceded by the backslash then it is treated as if it were an ordinary
  character. 

  If the backslash is followed by a digit $d$\/ then this construct is the same
  as the $d$\/th matching group.
  
  E.g. the regular expression {\em (an)$\backslash$1as} matches the string
  {\em ananas}\/ since the first group matches {\em an}.

  If the backslash is followed by the character {\tt n} then this is equivalent
  to entering a newline.

  If the backslash is followed by the character {\tt t} then this is equivalent
  to entering a single tab character.

\end{description}


%______________________________________________________________________________
\section{Field Manipulation}

%______________________________________________________________________________
\subsection{Adding or Deleting Fields}

Certain fields can be added or deleted. This feature can be used to update
time stamps. For this purpose it is important to know that deletion is done
before addition.

Two resources are provided to accomplish adding and deleting fields:
\rsc{add.field} and \rsc{delete.field}

\RSC{add.field}{\it field=value}

\RSC{delete.field}{\it field}

Suppose a time stamp is stored in the field {\tt time}.
With these resources the update of a time-stamp can be achieved using the
resource instructions

\RSC{delete.field}{time}\vspace{-3ex}
\RSC{add.field}{time="jun 13, 1995"}

%______________________________________________________________________________
\subsection{Field Rewriting}\label{sec:field.rewriting}

To modify the value of fields can be used to optimize or normalize the
appearance of a \BibTeX{} data base. The powerful facility of
regular expression matching is used for this purpose.

The resource \rsc{rewrite.rule} can be used to specify rewrite rules. The
general form is as follows:

\RSc{rewrite.rule}{\em \{ field$_1$ $\ldots$ field$_n$ \# pattern \# replacement\_text\}}

{\em field$_1$ $\ldots$ field$_n$}\/ is a list of field names. The rewrite
rule is only applied to those fields which have one of those names. If no
field name is given then the rewrite rule is applied to all fields.

\RSc{rewrite.rule}{\em \{ pattern \# replacement\_text\}}

Next there is the separator '\#'. This separator is optional. It can also be
the equality sign '='.

{\em pattern}\/ is a regular expression enclosed in double quotes ("). This
pattern is matched against substrings of the field value --- including the
delimiters. If a match is found then the matching substring is replaced by the
replacement text or the field deleted if no replacement text is given.

{\em replacement\_text}\/ is the string to be inserted for the matching
substring of the field value. The backslash '\BS' is used as escape character.
'\BS$n$' is replaced by the $n$\/th matching group of {\em pattern}. $n$\/ is
a single digit (1-9). Otherwise The character following the backslash is
inserted.\footnote{Future releases may use backslash followed by letters for
special purposes. It is not save to rely on escaping letters.} Thus it is
possible to have double quotes inside the replacement text.

Other specials are
\begin{itemize}
  \item [\BS\$]%$
    which is replaced by the key of the current record.
  \item [\BS@]
    which is replaced by the type of the current record.
\end{itemize}

If no replacement text is given then the whole field is deleted. This is
illustrated in the following examples:

\RSc{rewrite.rule}{\em \{ field \# pattern \}}\\[-7ex]
\RSc{rewrite.rule}{\em \{ pattern \}}

Usually the matching is not done case sensitive. This means that any upper
case letter matches its lower counterpart and vice versa. This
behavior is controlled by the boolean resource \rsc{rewrite.case.sensitive}
which is ON by default. Changing this variable influences only rewrite rules
specified later.

\Rsc{rewrite.case.sensitive}{off}

A problem occurs e.g. when a string is replaced by a string containing the
original one.  To avoid infinite recursion in such cases the numeric resource
\rsc{rewrite.limit} controls the number of applications of each rewrite
rule. If the number given in \rsc{rewrite.limit} is not negative and this
limit is exceeded then a warning is printed and further applications of this
rule are stopped. A negative value of the resource \rsc{rewrite.limit}
indicates that no limitation should be used.



Next we will investigate some concrete examples. Note that in these examples
the character '{\tt\char32}' denotes a single space. It is used to highlight
places where spaces have to be used which would be hard to recognize
otherwise.

\begin{itemize}
  \item Empty entries are composed of delimiters --- either double quotes or
        curly braces which enclose an arbitrary number of spaces. If we want
        to delete empty entries we can use the following two rules.

        \RSc{rewrite.rule}
            {\tt\char"7B "\char"5E\char"5C"\char32*\char"5C"\$" \char"7D}\\[-9ex]
        \RSc{rewrite.rule}
            {\tt\char"7B "\char"5E\char"7B\char32*\char"7D\$" \char"7D}

        The caret '{\tt\char"5E}' denotes the beginning of the whole string
        and the dollar is its end. The star is an operator which says that an
        arbitrary number of the preceding regular expression --- i.e.\ the
        space --- can occur at this point.

  \item Ranges of pages should usually be composed of numbers separated by an
        n-dash ({\tt -{}-}). The next example shows how the pages field can be
        normalized. Spaces are deleted and a single minus sign is replaced by
        a double minus.

        \RSc{rewrite.rule}{\tt\char"7B pages \#
            "\char"5C(\char"5B
            0-9\char"5D+\char"5C)\char32*-\char32*\char"5C(\char"5B
            0-9\char"5D+\char"5C)" 
            = "\char"5C 1--\char"5C 2" \char"7D}

\end{itemize}

%______________________________________________________________________________
\subsection{Field Ordering}

Fields can be reordered within an entry. This feature is controlled by the
presence of a specification for the order to use. The order is specified with
the resource \rsc{sort.order}. The general form is as follows:

\RSc{sort.order}{\em \{ entry = field1 \# field2 \# ... \}}

{\em entry} is the name of an entry like {\tt book}. The {\em field}s are an
arbitrary number of field names like {\tt author}. This specification says
that {\em field1}\/ should precede {\em field2}\/ etc. Fields which are not in
this list are arranged after the specified ones. The are left in the same
order as they appear in the entry.

Another possibility is to specify the entry {\tt *}. Such a sorting order is
applicable to any kind of entry. If no specific sort order is found then this
general order is used if one has been specified.

Any sorting order is added to a list of sorting orders if it has not been
defined before. If a sorting order is specified again, the old one is simply
overwritten.

Consider the following part of a resource file:

\RSC{sort.order}{* = author \# title}\\[-8ex]
\RSC{sort.order}{misc = author \# title \# howpublished \# year \# month
  \# note}

This means that the author field goes before the title field in any entry
type. For the misc entries additional specifications are made.

The library {\sf sort\_fld.rsc} contains a sample sorting order for the
standard entry types.



%______________________________________________________________________________
\section{Semantic Checks}

Semantic checks can be enabled in addition to the syntactic checks performed
during parsing.

\subsection{Finding Double Entries}

When merging several bibliographic data bases a common problem is the occurrence
of doubled entries in the resulting data base.  When searching for double
entries several problems arise. Which entries should be considered equal and
what should happen to double entries.

The first question is answered as follows. Two entries are considered equal if
their sort key is identical and they are adjacent in the final output. The
first condition of identical sort keys allows the user to specify which
criteria should be used when comparing entries. This can be achieved with the
resource \rsc{sort.format} (see \ref{sorting}). The second condition can
easily be achieved by additionally turn on sorting when requesting checking of
doubles.

It remains the question what to do with the doubles. Usually it is not
desirable to keep double entries in one data base. Thus only one entry which
is considered equal is kept. The others are printed as comments, i.e.\ the
initial '@' is replaced by '\#\#\#{\'{}}. Thus all information is still present
but inactive in the \BibTeX{} file. The very first entry found is put into the
data base file.


The resource \rsc{check.double} can be used to turn on the checking of
doubles. This feature is turned off initially.

\Rsc{check.double}{ON}

Checking of doubles can also be turned on with the command line option
\opt{d}:

\sh[d]{}


\subsection{Regular Expression Checks}

The regular expressions (see section \ref{sec:regex}) which are used to
rewrite fields (see section \ref{sec:field.rewriting}) can also be used to
perform semantic checks on fields. For this purpose the resource
\rsc{check.rule} is provided. The syntax of \rsc{check.rule} is the same as
for \rsc{rewrite.rule}.

\RSc{check.rule}{\em \{ field \# pattern \# message\}}

Again {\em field}\/ and {\em message}\/ is optional. The separator
\# can also be written as equality sign (=) or omitted.

Each field is processed as follows. Each check.rule is tried in turn until one
rule is found where {\em field}\/  (if given) is identical to the field name
and {\em pattern}\/ matches a substring of the field value. If such a rule is
found then the {\em message}\/ is written to the error stream. If no message
is given then nothing is printed and the processing of the current field is
ended.

{\em message}\/ is treated like the replacement text in \rsc{rewrite.rule},
I.e.\ the special character combinations described in section
\ref{sec:field.rewriting} are expanded.


Usually the matching is not done case sensitive. This means that any upper
case letter matches its lower counterpart and vice versa. This
behavior is controlled by the boolean resource \rsc{check.case.sensitive}
which is ON by default. Changing this variable influences only rewrite rules
specified later.

\Rsc{check.case.sensitive}{off}


Consider the following example. We want to check that the year field contains
only years from 1800 to 1999. Additionally we want to allow two digit
abbreviations.

\RSc{check.rule}{\tt \{ year "\^{}[\BS"\{]1[89][0-9][0-9][\BS"\}]\$" \}}\\[-7ex]
\RSc{check.rule}{\tt \{ year "\^{}[\BS"\{][0-9][0-9][\BS"\}]\$" \}}\\[-7ex]
\RSc{check.rule}{\tt \{ year "" "\BS@ \BS\$: Year has to be a suitable number"\}}

The first rule matches any number starting with 1 followed by 8 or 9 and
finally two digits. The whole number may be enclosed in double quotes or curly
braces.\footnote{In fact the regular expression allows also strings starting
with a quote and ending in a curly brace. But this syntactical nonsense is
ruled out by the parser already.} The hat at the beginning and the dollar at
the end force that the pattern matches against the whole field value only.

The next rule covers years consisting of two digits. The first two rules
produce no error message but end the search for further matches. Thus is
something suitable is found then one of the first two rules finds it.
Otherwise we have to produce an error message. This is done with the third
rule. The empty pattern matches against any value of the year field. In this
case we print an error message. {\tt \BS@} is replaced by the current type and
{\tt \BS\$} by the current key.

%______________________________________________________________________________
\section{Strings --- also called Macros}\label{sec:macros}

Strings in \BibTeX{} files play an important role when managing large
bibliographic data bases. Thus the deserve special treatment.
If the resource \rsc{macro.file} is defined then the macros are written to
this file. The argument is a file name as in

\RSC{macro.file}{\it macro/file/name}

The boolean resource \rsc{print.all.strings} indicates if all macros defined
in the \BibTeX{} file should be printed or only those macros actually used.

\Rsc{print.all.strings}{ON}

The appearance of string names is controlled by the resource \rsc{symbol.type}
(see \pageref{symbol.type}).

Strings can be expanded when printing records. This feature of \BibTool{} is
controlled by the resource \rsc{expand.macros} as in

\Rsc{expand.macros}{ON}

The effect is that all known strings in normal records are replaced by their
values. If the values are not defined at the time of expansion then the macro
name remains untouched. As a side effect strings concatenations are
simplified. Imagine the following \BibTeX{} file.
\begin{verbatim}
  @string{ WGA = " World Gnus Almanac" }

  @Book{ almanac-66,
          title =  1967 # WGA,
          month = "1~" # jan
  }
\end{verbatim}
If \BibTool{} is applied with \rsc{expand.macros} turned on this results in
the following output --- if the default settings are used for any other
resource.
\begin{verbatim}
  @STRING{wga   = " World Gnus Almanac" }

  @Book{          almanac-66,
    title       = {1967 World Gnus Almanac},
    month       = {1~} # jan
  }
\end{verbatim}
The macro {\tt WGA} has been expanded and merged with \verb|1967|. Note that
the string \verb|jan| has not been expanded since the value should be defined
in a \BibTeX{} style file ({\sf .bst}).

The delimiters of entries is normalized, i.e.\ only one style is used. In this
example braces are used. The alternative would be to use double quotes. This
behavior is controlled by the resource \rsc{print.braces}. If this resource
is on then braces are used otherwise double quotes are taken. It can be
changed like in

\Rsc{print.braces}{OFF}

The delimiters of the whole record are recommended to be braces. For
compatibility with Scribe it is also allowed that parentheses are used
for those delimiters. This behavior can be achieved with the boolean
resource \rsc{print.parentheses}. Initially this resource is off. It
can be set like in the following instruction:

\Rsc{print.parentheses}{ON}

%______________________________________________________________________________
\section{Statistics}

Some information can be obtained at the end of a \BibTool{} run. The number of
\BibTeX{} items read and written is printed. To enable this feature the
resources \rsc{count.all} and \rsc{count.used} are provided.

\Rsc{count.all}{ON}

\Rsc{count.used}{ON}

\rsc{count.all} indicates that all known types of \BibTeX{} items should be
listed. \rsc{count.used} forces only those types of \BibTeX{} items to be
listed which have been found in the input files.


%______________________________________________________________________________
%______________________________________________________________________________
\chapter{Limitations}

\section{Limits of \BibTool}

\BibTool{} has been written with dynamic memory management wherever possible.
Thus \BibTool{} should be limited by the memory available only.

\section{Bugs and Problems}

Problems currently known are the following ones. They are not considered to be
bugs.
\begin{itemize}
\item The referencing feature of \BibTeX{} is not supported. \verb|\cite|
  macros can be contained in fields (e.g. notes). Such things can be confused.
\item The memory management uses dynamic memory. This memory is reused but not
  returned to the operating system. Thus \BibTool{} may run out of memory even
  if a more elaborated memory management may find free memory. This is a
  design decision and I don't think that I will change it.
\item The \TeX{} reading apparatus is only imitated to a certain limit. But
  this should be enough for most applications to produce satisfactory results.
\item In several modules ASCII encoding is assumed. I do not know to which
  extend this influences the functionality since I don't have access to
  non-ASCII machines.
\item Macro expansion uses a dynamic array which can turn out to be too
  short. This will be corrected as soon as I have an example where this bug
  shows up. 
\end{itemize}


%______________________________________________________________________________
%______________________________________________________________________________
\chapter{Sample Resource Files}\label{chap:resource.files}

Sample resource files are included in the distribution of \BibTool{} in the
directory {\sf Lib}. Only some of them are reproduced in this section.

\section{The Default Settings}

\newenvironment{Resource}%
  {\begingroup\scriptsize\tt\obeylines\obeyspaces%
  }{\endgroup}

\begin{Resource}
bibtex.env.name        = "BIBINPUTS"
check.double           = off
check.case.sensitive   = on
count.all              = off
count.used             = off
default.key            = "**key*"
dir.file.separator     = "/"
env.separator          = ":"
expand.macros          = on
fmt.et.al              = ".ea"
fmt.inter.name         = "-"
fmt.name.name          = "."
fmt.name.pre           = "."
fmt.name.title         = ":"
fmt.title.title        = "-"
ignored.word           = "{a}"
ignored.word           = "{a}n"
ignored.word           = "the"
ignored.word           = "le"
ignored.word           = "les"
ignored.word           = "la"
ignored.word           = "{}un"
ignored.word           = "{}une"
ignored.word           = "{}el"
ignored.word           = "{}il"
ignored.word           = "der"
ignored.word           = "die"
ignored.word           = "das"
ignored.word           = "{}ein"
ignored.word           = "{}eine"
key.base               = lower
key.expand.macros      = on
key.format             = short
key.generation         = off
key.number.separator   = "*"
new.entry.type         = "{}Article"    
new.entry.type         = "Book" 
new.entry.type         = "Booklet"
new.entry.type         = "Conference"
new.entry.type         = "{}InBook"     
new.entry.type         = "{}InCollection"
new.entry.type         = "{}InProceedings"
new.entry.type         = "Manual"       
new.entry.type         = "MastersThesis"
new.entry.type         = "Misc" 
new.entry.type         = "PhDThesis"
new.entry.type         = "Proceedings"
new.entry.type         = "TechReport"
new.entry.type         = "{}Unpublished"
preserve.key.case      = off
print.align            = 18
print.align.string     = 18
print.align.preamble   = 11
print.align.comment    = 10
print.align.key        = 18
print.braces           = on
print.all.strings      = on
print.indent           = 2
print.line.length      = 77
print.newline          = 1
print.parentheses      = off
print.use.tab          = on
rewrite.case.sensitive = on
rewrite.limit          = 512
quiet                  = off
select.case.sensitive  = off
select.field           = "\$key"
sort                   = off
sort.format            = "\$key"
sort.reverse           = off
symbol.type            = lower
verbose                = off
\end{Resource}

\section{Useful Translations}

This resource file translates international characters into plain text
representations. Especially the German umlaut sequences are translated. E.g.\
the letter {\"A} which is written as \verb|{\"A}| in a \BibTeX{} file is
translated to \verb|Ae|.

Additionally some logos are defined.
\medskip\def\bs{{\tt \char"5C}\ignorespaces}

\begin{Resource}
tex.define \{\bs"[1]=\#1e\}
tex.define \{\bs ss=ss\}
tex.define \{\bs AE=AE\}
tex.define \{\bs OE=OE\}
tex.define \{\bs aa=aa\}
tex.define \{\bs AA=AA\}
tex.define \{\bs o=o\}
tex.define \{\bs O=O\}
tex.define \{\bs l=l\}
tex.define \{\bs L=L\}
tex.define \{\bs TeX=TeX\}
tex.define \{\bs LaTeX=LaTeX\}
tex.define \{\bs LaTeXe=LaTeX2e\}
tex.define \{\bs BibTeX=BibTeX\}
tex.define \{\bs AMSTeX=AMSTeX\}
\end{Resource}

\section{Other Resource Files}

The distribution contains additional resource files. Some of them are sketched
here. Others may be contained in the distribution as well. Look in the
appropriate directory.

\begin{description}
  \item [{\tt iso2tex}]\ \\
    define rewrite rules to translate ISO8859-1 characters into \BibTeX\
    compatible sequences.
  \item [{\tt iso\_def}]\ \\
    define macro equivalents for ISO8859-1 characters into \TeX{}
    compatible sequences.
  \item [{\tt sort\_fld}]\ \\
    defines a sort order for the common \BibTeX\ entry types.
  \item [{\tt check\_y}]\ \\
    contains a sample for semantic checks. The year field is checked to be a
    suitable number.
  \item [{\tt month}]\ \\
    tries to introduce \BibTeX\ strings for month names.  Provisions are made
    to preserve other information contained in the month field.
  \item [{\tt opt}]\ \\
    copes with {\tt OPT} prefixes as introduced e.g. by bibtex-mode.
\end{description}


%______________________________________________________________________________
\bibliographystyle{alpha}
\bibliography{bibtool}

\ifx\ptt\undefined\global\let\ptt=\tt\fi
\ifx\psf\undefined\global\let\psf=\sf\fi
\ifx\pdollar\undefined\global\let\pdollar=\$\fi

\printindex

\end{document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Local Variables:
% mode: latex
% TeX-master: nil
% End:
