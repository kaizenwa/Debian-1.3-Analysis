#!/bin/sh
# Use this script as a wrapper when running executables linked to shared
# libraries on systems that use the $LD_LIBRARY_PATH variable and don't embed
# the soname's path within the linked executable (such as IRIX), e.g,
#
#	shlib knight
#
# Setting LD_LIBRARY_PATH, overrides/supplements the loader's normal search
# path, and works on most systems.  The drawback is that then the environment
# variable has to be set to run the programs within this directory tree.
#
# For Linux (and other systems using the GNU loader), we can use the rpath
# directive, which embeds the pathname of the library within the executable.
# Using the Linux loader's rpath directive introduces a constraint, since
# it's embedded into the binary, and means that the binary cannot be moved
# around (though it'll work if the $exec_prefix convention that puts the bin
# and lib directories under the same parent is followed).
#
# Using the actual soname (e.g., ../lib/libncurses.so) alone, is a more
# flexible solution; you can link without having to set the environment
# variable, and on some systems (IRIX) you can even run the resulting binaries
# without setting LD_LIBRARY_PATH.
#
# Using a conventional link, with -L and -l options on Linux results in a
# statically linked executable, which we don't want at all.
#
q=
for p in lib ../lib
do
	if test -d $p; then
		q="$p"
	fi
done
if test -n "$LD_LIBRARY_PATH"; then
	LD_LIBRARY_PATH="$q:$LD_LIBRARY_PATH"
else
	LD_LIBRARY_PATH="$q"
fi
export LD_LIBRARY_PATH
eval "$*"
