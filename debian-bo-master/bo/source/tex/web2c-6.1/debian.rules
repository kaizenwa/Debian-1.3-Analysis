#!/usr/bin/make -f
# debian.rules file for packages consisting of one source
# producing multiple binary packages.
#
# Theory of operation:
# ====================
# There is a  debian.control specifying the source package
# and debian.{control,preinst,prerm,...}.<package> files specifying
# the binary packages.
#   For each <package> a Makefile.<package> specifies how to
# install the files belonging to it. It only needs to create
# the directories and install the files there. debian.multipckg
# knows how to create the corresponding .deb file and the announce.
#   There is also a Makefile (without .<package> extension),
# specifying how to compile the source and how to clean up everything.
#   The master Makefile (i.e. this file) uses Makefile to build the
# source. To build the binaries it will for every <package> set
# PACKAGE to the name, and then call debian.multipckg which in turn
# will first call Makefile.<package> to install the corresponding files
# to the debian-tmp tree and then produce
# <package>-<version>-<revision>.{deb,announce}.
#   Making a source and context diff is the duty of this makefile.
# It uses debian.control (without .<package> extension) to get
# Name, Maintainer, version and revision numbers.
#
# Invoke each target with: debian.rules <target>
# All should be invoked with the package root as the current directory
.PHONY: build checkdir checkroot announce

# Put the name of the desired packages here.
# The first one defines the name of the announcement.
packages = texbin mfbin bibtex

p := $(shell grep "Package:" debian.control | cut -d' ' -f2)
v := $(shell grep "Version:" debian.control | cut -d' ' -f2)
r := $(shell grep "Package_Revision:" debian.control | cut -d' ' -f2)
description := $(shell grep "Description:" debian.control | cut -d' ' -f2-)
maintainer := $(shell grep "Maintainer:" debian.control | cut -d' ' -f2-3)

pv  = $(p)-$(v)
pvr = $(p)-$(v)-$(r)

INST_BIN	=	install -g root -o root -m 755
INST_DIR	=	install -g root -o root -d -m 755
INST_DAT	=	install -g root -o root -m 644

deb-tmp		=	debian-tmp
DEBIAN		=	$(deb-tmp)/DEBIAN
USR		=	$(deb-tmp)/usr

build: checkdir
# Builds the binary package.
	make
	touch stamp-build

clean: checkroot
# Undoes the effect of `make -f debian.rules build'.
	make clean
	rm -f stamp-build
	rm -rf debian-tmp

binary: checkroot
# Makes a binary package.
	test -f stamp-build || make -f debian.rules build
	for p in $(packages); do			\
		make -f debian.multipckg PACKAGE=$$p binary;	\
	done

announce:
	FILES="";							\
	for pck in $(packages); do					\
	   P=`grep "Package:" debian.control.$$pck | cut -d' ' -f2`;	\
	   V=`grep "Version:" debian.control.$$pck | cut -d' ' -f2`;	\
	   R=`grep "Package_Revision:" debian.control.$$pck | cut -d' ' -f2`; \
	   FILES="$$FILES $$P-$$V-$$R.deb";					\
	done;								\
	cd ..; dchanges -C $(pv)/debian.changes $$FILES $(pvr).tar.gz $(pvr).diff.gz

source: checkdir
# Makes a source package.
	-test -f stamp-build && make -f debian.rules clean
	( cd .. && tar cf $(pvr).tar $(pv) && gzip -9f $(pvr).tar )

diff: checkdir
# Makes a context diff.
	-test -f stamp-build && make -f debian.rules clean
	test -d ../$(pv).orig || echo "Original in ../$(pv).orig?" || false
	( cd .. && \
	  ( diff -cNr $(pv).orig $(pv) > $(pvr).diff; \
	  [ $$? = 1 ] ) && \
	  gzip -9f $(pvr).diff )

# Prepares the package for distribution.
dist: binary source diff announce

onetar: ../$(pvr).deb ../$(pvr).diff.gz ../$(pvr).tar.gz ../$(pvr).announce
# Makes one tar file (packagename) containing Binary, source and diff.
	( cd .. && tar --create --remove-files --file=$(p).tar $(pvr).* )

checkdir:
	test -d ../$(pv)

checkroot: checkdir
	test root = "`whoami`"
 
stamp-build:
	make -f debian.rules build

# Local Variables:
#   mode: makefile
# End:
