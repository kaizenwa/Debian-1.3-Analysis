*** ../../../tk4.1b3/generic/tkMain.c	Fri Mar  8 17:16:22 1996
--- tkXshell.c	Sat Mar 16 22:57:27 1996
***************
*** 1,3 ****
--- 1,21 ----
+ /*
+  * tkXshell.c
+  *
+  * Version of Tk main modified for TclX to support SIGINT and use some of
+  * the TclX utility procedures.
+  *-----------------------------------------------------------------------------
+  * Copyright 1991-1996 Karl Lehenbauer and Mark Diekhans.
+  *
+  * Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appear in all copies.  Karl Lehenbauer and
+  * Mark Diekhans make no representations about the suitability of this
+  * software for any purpose.  It is provided "as is" without express or
+  * implied warranty.
+  *-----------------------------------------------------------------------------
+  * $Id: tkXshell.c.diff,v 7.0 1996/06/16 05:33:47 markd Exp $
+  *-----------------------------------------------------------------------------
+  */
  /* 
   * tkMain.c --
   *
***************
*** 18,31 ****
  
  #include <ctype.h>
  #include <stdio.h>
! #include <string.h>
! #include <tcl.h>
  #include <tk.h>
- #ifdef NO_STDLIB_H
- #   include "../compat/stdlib.h"
- #else
- #   include <stdlib.h>
- #endif
  
  /*
   * Declarations for various library procedures and variables (don't want
--- 36,43 ----
  
  #include <ctype.h>
  #include <stdio.h>
! #include <tclExtdInt.h>
  #include <tk.h>
  
  /*
   * Declarations for various library procedures and variables (don't want
***************
*** 36,70 ****
   * some systems.
   */
  
- extern int		isatty _ANSI_ARGS_((int fd));
- extern int		read _ANSI_ARGS_((int fd, char *buf, size_t size));
  extern char *		strrchr _ANSI_ARGS_((CONST char *string, int c));
  
- /*
-  * Global variables used by the main program:
-  */
- 
- static Tcl_Interp *interp;	/* Interpreter for this application. */
- static Tcl_DString command;	/* Used to assemble lines of terminal input
- 				 * into Tcl commands. */
- static Tcl_DString line;	/* Used to read the next line from the
-                                  * terminal input. */
- static int tty;			/* Non-zero means standard input is a
- 				 * terminal-like device.  Zero means it's
- 				 * a file. */
- 
- /*
-  * Forward declarations for procedures defined later in this file.
-  */
- 
- static void		Prompt _ANSI_ARGS_((Tcl_Interp *interp, int partial));
- static void		StdinProc _ANSI_ARGS_((ClientData clientData,
- 			    int mask));
  
  /*
   *----------------------------------------------------------------------
   *
!  * Tk_Main --
   *
   *	Main program for Wish and most other Tk-based applications.
   *
--- 48,60 ----
   * some systems.
   */
  
  extern char *		strrchr _ANSI_ARGS_((CONST char *string, int c));
  
  
  /*
   *----------------------------------------------------------------------
   *
!  * TkX_Main --
   *
   *	Main program for Wish and most other Tk-based applications.
   *
***************
*** 81,87 ****
   */
  
  void
! Tk_Main(argc, argv, appInitProc)
      int argc;				/* Number of arguments. */
      char **argv;			/* Array of argument strings. */
      Tcl_AppInitProc *appInitProc;	/* Application-specific initialization
--- 71,77 ----
   */
  
  void
! TkX_Main(argc, argv, appInitProc)
      int argc;				/* Number of arguments. */
      char **argv;			/* Array of argument strings. */
      Tcl_AppInitProc *appInitProc;	/* Application-specific initialization
***************
*** 94,99 ****
--- 84,97 ----
      int code;
      size_t length;
      Tcl_Channel inChannel, outChannel, errChannel, chan;
+     Tcl_Interp *interp;
+     int tty;
+ 
+     TclX_SetAppInfo (TRUE,
+                      "wishx",
+                      "Extended Wish",
+                      TKX_VERSION,
+                      TCLX_PATCHLEVEL);
  
      Tcl_FindExecutable(argv[0]);
      interp = Tcl_CreateInterp();
***************
*** 154,171 ****
      Tcl_SetVar(interp, "tcl_interactive",
  	    ((fileName == NULL) && tty) ? "1" : "0", TCL_GLOBAL_ONLY);
  
      /*
       * Invoke application-specific initialization.
       */
  
      if ((*appInitProc)(interp) != TCL_OK) {
! 	errChannel = Tcl_GetStdChannel(TCL_STDERR);
! 	if (errChannel) {
!             Tcl_Write(errChannel,
! 		    "application-specific initialization failed: ", -1);
!             Tcl_Write(errChannel, interp->result, -1);
!             Tcl_Write(errChannel, "\n", 1);
!         }
      }
  
      /*
--- 152,166 ----
      Tcl_SetVar(interp, "tcl_interactive",
  	    ((fileName == NULL) && tty) ? "1" : "0", TCL_GLOBAL_ONLY);
  
+     if ((fileName == NULL) && tty)
+         TclX_SetupSigInt ();
+ 
      /*
       * Invoke application-specific initialization.
       */
  
      if ((*appInitProc)(interp) != TCL_OK) {
!         TclX_ErrorExit (interp, 255);
      }
  
      /*
***************
*** 173,179 ****
       */
  
      if (fileName != NULL) {
! 	code = Tcl_EvalFile(interp, fileName);
  	if (code != TCL_OK) {
  	    goto error;
  	}
--- 168,177 ----
       */
  
      if (fileName != NULL) {
! 	code = TclX_Eval (interp,
!                           TCLX_EVAL_GLOBAL | TCLX_EVAL_FILE |
!                           TCLX_EVAL_ERR_HANDLER,
!                           fileName);
  	if (code != TCL_OK) {
  	    goto error;
  	}
***************
*** 187,226 ****
  	 * input, and print a prompt if the input device is a terminal.
  	 */
  
! 	fileName = Tcl_GetVar(interp, "tcl_rcFileName", TCL_GLOBAL_ONLY);
! 
! 	if (fileName != NULL) {
! 	    Tcl_DString buffer;
! 	    char *fullName;
!     
! 	    fullName = Tcl_TranslateFileName(interp, fileName, &buffer);
! 	    if (fullName == NULL) {
! 		errChannel = Tcl_GetStdChannel(TCL_STDERR);
! 		if (errChannel) {
!                     Tcl_Write(errChannel, interp->result, -1);
!                     Tcl_Write(errChannel, "\n", 1);
!                 }
! 	    } else {
! 
!                 /*
!                  * NOTE: The following relies on O_RDONLY==0.
!                  */
!                 
!                 chan = Tcl_OpenFileChannel(interp, fullName, "r", 0);
!                 if (chan != (Tcl_Channel) NULL) {
!                     Tcl_Close(NULL, chan);
!                     if (Tcl_EvalFile(interp, fullName) != TCL_OK) {
! 			errChannel = Tcl_GetStdChannel(TCL_STDERR);
! 			if (errChannel) {
!                             Tcl_Write(errChannel, interp->result, -1);
!                             Tcl_Write(errChannel, "\n", 1);
!                         }
!                     }
!                 }
!             }
!             
! 	    Tcl_DStringFree(&buffer);
! 	}
  
  	/*
  	 * Establish a channel handler for stdin.
--- 185,191 ----
  	 * input, and print a prompt if the input device is a terminal.
  	 */
  
!         TclX_EvalRCFile (interp);
  
  	/*
  	 * Establish a channel handler for stdin.
***************
*** 228,247 ****
  
  	inChannel = Tcl_GetStdChannel(TCL_STDIN);
  	if (inChannel) {
! 	    Tcl_CreateChannelHandler(inChannel, TCL_READABLE, StdinProc,
! 		    (ClientData) inChannel);
! 	}
! 	if (tty) {
! 	    Prompt(interp, 0);
! 	}
      }
  
      outChannel = Tcl_GetStdChannel(TCL_STDOUT);
      if (outChannel) {
  	Tcl_Flush(outChannel);
      }
-     Tcl_DStringInit(&command);
-     Tcl_DStringInit(&line);
      Tcl_ResetResult(interp);
  
      /*
--- 193,210 ----
  
  	inChannel = Tcl_GetStdChannel(TCL_STDIN);
  	if (inChannel) {
!             if (TclX_AsyncCommandLoop (interp,
!                                        tty ? (TCLX_CMDL_INTERACTIVE |
!                                               TCLX_CMDL_EXIT_ON_EOF) : 0,
!                                        NULL, NULL, NULL) == TCL_ERROR)
!                 goto error;
!         }
      }
  
      outChannel = Tcl_GetStdChannel(TCL_STDOUT);
      if (outChannel) {
  	Tcl_Flush(outChannel);
      }
      Tcl_ResetResult(interp);
  
      /*
***************
*** 262,432 ****
          Tcl_Write(errChannel, msg, -1);
          Tcl_Write(errChannel, "\n", 1);
      }
!     Tcl_Exit(1);
! }
! 
! /*
!  *----------------------------------------------------------------------
!  *
!  * StdinProc --
!  *
!  *	This procedure is invoked by the event dispatcher whenever
!  *	standard input becomes readable.  It grabs the next line of
!  *	input characters, adds them to a command being assembled, and
!  *	executes the command if it's complete.
!  *
!  * Results:
!  *	None.
!  *
!  * Side effects:
!  *	Could be almost arbitrary, depending on the command that's
!  *	typed.
!  *
!  *----------------------------------------------------------------------
!  */
! 
!     /* ARGSUSED */
! static void
! StdinProc(clientData, mask)
!     ClientData clientData;		/* Not used. */
!     int mask;				/* Not used. */
! {
!     static int gotPartial = 0;
!     char *cmd;
!     int code, count;
!     Tcl_Channel chan = (Tcl_Channel) clientData;
! 
!     count = Tcl_Gets(chan, &line);
! 
!     if (count < 0) {
! 	if (!gotPartial) {
! 	    if (tty) {
! 		Tcl_Exit(0);
! 	    } else {
! 		Tcl_DeleteChannelHandler(chan, StdinProc, (ClientData) chan);
! 	    }
! 	    return;
! 	} else {
! 	    count = 0;
! 	}
!     }
! 
!     (void) Tcl_DStringAppend(&command, Tcl_DStringValue(&line), -1);
!     cmd = Tcl_DStringAppend(&command, "\n", -1);
!     Tcl_DStringFree(&line);
!     
!     if (!Tcl_CommandComplete(cmd)) {
!         gotPartial = 1;
!         goto prompt;
!     }
!     gotPartial = 0;
! 
!     /*
!      * Disable the stdin channel handler while evaluating the command;
!      * otherwise if the command re-enters the event loop we might
!      * process commands from stdin before the current command is
!      * finished.  Among other things, this will trash the text of the
!      * command being evaluated.
!      */
! 
!     Tcl_CreateChannelHandler(chan, 0, StdinProc, (ClientData) chan);
!     code = Tcl_RecordAndEval(interp, cmd, TCL_EVAL_GLOBAL);
!     Tcl_CreateChannelHandler(chan, TCL_READABLE, StdinProc,
! 	    (ClientData) chan);
!     Tcl_DStringFree(&command);
!     if (*interp->result != 0) {
! 	if ((code != TCL_OK) || (tty)) {
! 	    /*
! 	     * The statement below used to call "printf", but that resulted
! 	     * in core dumps under Solaris 2.3 if the result was very long.
!              *
!              * NOTE: This probably will not work under Windows either.
! 	     */
! 
! 	    puts(interp->result);
! 	}
!     }
! 
!     /*
!      * Output a prompt.
!      */
! 
!     prompt:
!     if (tty) {
! 	Prompt(interp, gotPartial);
!     }
!     Tcl_ResetResult(interp);
! }
! 
! /*
!  *----------------------------------------------------------------------
!  *
!  * Prompt --
!  *
!  *	Issue a prompt on standard output, or invoke a script
!  *	to issue the prompt.
!  *
!  * Results:
!  *	None.
!  *
!  * Side effects:
!  *	A prompt gets output, and a Tcl script may be evaluated
!  *	in interp.
!  *
!  *----------------------------------------------------------------------
!  */
! 
! static void
! Prompt(interp, partial)
!     Tcl_Interp *interp;			/* Interpreter to use for prompting. */
!     int partial;			/* Non-zero means there already
! 					 * exists a partial command, so use
! 					 * the secondary prompt. */
! {
!     char *promptCmd;
!     int code;
!     Tcl_Channel outChannel, errChannel;
! 
!     errChannel = Tcl_GetChannel(interp, "stderr", NULL);
! 
!     promptCmd = Tcl_GetVar(interp,
! 	partial ? "tcl_prompt2" : "tcl_prompt1", TCL_GLOBAL_ONLY);
!     if (promptCmd == NULL) {
! defaultPrompt:
! 	if (!partial) {
! 
!             /*
!              * We must check that outChannel is a real channel - it
!              * is possible that someone has transferred stdout out of
!              * this interpreter with "interp transfer".
!              */
! 
! 	    outChannel = Tcl_GetChannel(interp, "stdout", NULL);
!             if (outChannel != (Tcl_Channel) NULL) {
!                 Tcl_Write(outChannel, "% ", 2);
!             }
! 	}
      } else {
! 	code = Tcl_Eval(interp, promptCmd);
! 	if (code != TCL_OK) {
! 	    Tcl_AddErrorInfo(interp,
! 		    "\n    (script that generates prompt)");
!             /*
!              * We must check that errChannel is a real channel - it
!              * is possible that someone has transferred stderr out of
!              * this interpreter with "interp transfer".
!              */
!             
! 	    errChannel = Tcl_GetChannel(interp, "stderr", NULL);
!             if (errChannel != (Tcl_Channel) NULL) {
!                 Tcl_Write(errChannel, interp->result, -1);
!                 Tcl_Write(errChannel, "\n", 1);
!             }
! 	    goto defaultPrompt;
! 	}
!     }
!     outChannel = Tcl_GetChannel(interp, "stdout", NULL);
!     if (outChannel != (Tcl_Channel) NULL) {
!         Tcl_Flush(outChannel);
      }
  }
--- 225,234 ----
          Tcl_Write(errChannel, msg, -1);
          Tcl_Write(errChannel, "\n", 1);
      }
!     if (!tclDeleteInterpAtEnd) {
!         Tcl_Exit(1);
      } else {
!         Tcl_DeleteInterp (interp);
!         Tcl_Exit(1);
      }
  }
