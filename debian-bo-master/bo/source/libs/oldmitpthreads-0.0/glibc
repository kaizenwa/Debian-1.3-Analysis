We use weak aliase to allow the user to use the same symbol for non-ANSI
purpose. But libc may use a different symbol name to access the
non-ANSI functions for internal use. Pthreads can override it for MT.
If the programmer knows what he/she is doing, he/she can also
override the non-ANSI function via the internal name.

For an ANSI function foo (), we use foo () to access it and pthreads
will override it for MT if necessary.

Basically, as far as the C library is concerned, __libc_foo ()
is for non-ANSI function and foo () is for ANSI. If feasible, we
can make it all __libc_foo () and make foo () an aliase for
__libc_foo () for an ANSI function, foo ().

1. All none ANSI symbols are exported as weak symbols.
2. All none ANSI functions should reference the none ANSI symbols
   fooo () via the internal names, that is __libc_foo ().
3. System calls using file descriptor are ST.
4. The glibc should provide the pthread support with minimum overhead
   to single thread programs:

	A. If there is foo_r () in pthread, we can leave foo () alone.
	   Programmers should use foo_r () for thread.
	B. If foo () is thread-safe, we leave it alone.
	C. For foo (), the filename should be foo.c and no leading
	   '_'.
	D. For a non-ANSI function, foo (), users can redefine foo ()
	   in his/her programs without interferring the C library.
	   __libc_foo () is provided as a way for internal access
	   to the libc definition of foo () and for pthreads to
	   override it with a MT safe version.

		a. If it is thread-safe, it is defined as
		   __libc_MT_foo (). We make __libc_foo () as an
		   aliase and foo () as a weak aliase of
		   __libc_MT_foo ().
		b. If it is not thread-safe, it is defined as
		   __libc_ST_foo (). We make __libc_foo () and
		   foo () as weak aliases of __libc_ST_foo ().

	E. For an ANSI function, foo ():

		a. If it is thread-safe, it is defined as foo ().
		b. If it is not thread-safe, it is defined as
		   __libc_ST_foo (). We make foo () as a weak aliases
		   of __libc_ST_foo ().

	F. If foo () is in libpthreads:

		a. If it is not ANSI, we defined it as __libc_MT_foo ()
		   which can call __libc_ST_foo () if necessary. We
		   make foo () as a weak () alias of __libc_MT_foo ().
		b. If it is ANSI, we defined it as foo () which also
		   can call __libc_ST_foo () if necessary.

	G. The pthread support will be provided as a shared library
	   only, libpthreads.so.

The purpose of this proposal is to find to provide a consistent API
for both MT and ST programs.

For C library users:

1. For ANSI function, a ST foo () will be provided by default. With
   -lpthreads, a MT foo () will be provided.
2. For non-ANSI function, user can use open (), read () .... for
   other purpose without disturbing C library.

For C library developers:

1. For ANSI function,

	A. If it is not MT, foo () will get __libc_ST_foo () by
	   default.  With -lpthreads, __lib_MT_foo () in libpthreads
	   will be used. __libc_ST_foo () can be used to get the ST
	   version of foo ().
	B. If it is MT, foo () is foo ().

2. For non-ANSI function,

	A. If it is not MT, __libc_foo () will get __libc_ST_foo () by
	   default. With -lpthreads, __lib_MT_foo () in libpthreads
	   will be used. __libc_ST_foo () can be used to get the ST
	   version of foo ().
	B. If it is MT, __libc_foo () is __libc_foo ().
