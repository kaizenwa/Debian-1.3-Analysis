diff cxxstyle.tex /home/bruce/v112/doc/cxxstyle.tex
diff quickref.tex /home/bruce/v112/doc/quickref.tex
211,212d210
<         virtual int GetHScroll(int& Shown, int& Top);
<         virtual int GetVScroll(int& Shown, int& Top);
diff release.tex /home/bruce/v112/doc/release.tex
54c54
< \LaTeX files. Other versions, including dvi and Postscript, are available from
---
> documentation. Both \code{dvi} and postscript versions are available from
342c342
< \item The \code{vMemoryDC} drawing canvas, including new methods
---
> \item The \code{vMemoryDC} drawing canvas, which includes the new methods
diff tutapndx.tex /home/bruce/v112/doc/tutapndx.tex
diff vgeneric.tex /home/bruce/v112/doc/vgeneric.tex
diff vrefch1.tex /home/bruce/v112/doc/vrefch1.tex
diff vrefch2.tex /home/bruce/v112/doc/vrefch2.tex
diff vrefch3.tex /home/bruce/v112/doc/vrefch3.tex
24c24,25
< with an example \V\ application. 
---
> with an example \V\ application. The tutorial application
> described in this chapter is an excellent example.
26,38c27,29
< The \V application generator, \code{vgen}, included with the
< \V distribution is the easiest way to begin building a \V
< application. Run \code{vgen}, select the basic options you
< want to include in your application, select the directory
< to save the generated code in, and then generate the basic
< skeleton application. From the skeleton app, it is relatively
< easy to add your own functionality.
< 
< The tutorial application described in this chapter is also an
< excellent \V example. Start by getting the example to compile.
< Then modify the code to add or remove features. Before long, you
< will have a good feel for \V, and be able to add all the features
< you need.
---
> Start by getting the example to compile. Then modify the code
> to add or remove features. Before long, you will have a good feel
> for \V, and be able to add all the features you need.
205,249d195
< \section{Special V Applications}
< 
< \subsection*{Windows MDI/SDI}
< \index{MDI model}\index{SDI model}
< 
< The basic standard \V application includes a command window
< with a menu, a command bar, a canvas, and a status bar. While
< this model suits most applications, there are some special
< cases that \V supports.
< 
< First, on Windows, \V supports the standard Windows MDI model
< (Multiple Document Interface)
< by default. The MDI model consists of a parent window that
< can contain several children canvases, each with a different
< menu that changes in the main parent window when a child
< gets focus. In practice, the menus are usually the same for
< all children windows, and each window is used to hold a
< new document or data object. One of the main advantages
< of the MDI model is that each application has a main window
< to distinguish it from other Windows applications, and
< as many child windows as it needs to manipulate its data.
< 
< On X versions, there is no need for a special parent window.
< Each time you open a new command window, you get a new window
< on the X display.
< 
< The Windows MDI model forces some screen decorations that
< are not appropriate for all applications. Thus, \V also supports
< the standard Windows SDI model. The SDI model allows only one
< canvas/command window combination. There is a parameter to
< the \code{vApp} constructor that tells \V to use the SDI model.
< This parameter is not used on the X version.
< 
< \subsection*{Canvasless, menuless V Application}
< 
< Sometimes an application needs just a command bar with no menu or
< canvas. By setting the \code{simSDI} parameter to 1, and
< supplying a width and height value to the \code{vApp}
< constructor, \V allows this kind of simple interface. Instead of
< adding a menu and a canvas as is done for normal \V apps, a
< menuless and canvasless app just defines a command pane for the
< command bar. The height and width are used to specify the height
< and width of the application, and require different values for
< Windows or X.
< 
361,363c307,309
< This version is for Gnu make, which has features different
< than some other flavors of make. It should still serve as a
< decent example.
---
> This version is for Gnu make, which has some features different
> than some flavors of make. It should still serve as a decent
> example.
diff vrefch4.tex /home/bruce/v112/doc/vrefch4.tex
64d63
< \Meth{vApp(char* appName, simSDI = 0, int fh = 0, int fw = 0)}
77,83d75
< \Param {simSDI} This \emph{optional} parameter is used to specify
< that \V should start as a Windows SDI application if it is set
< to 1. This parameter has no effect for the X version.
< 
< \Param{fw, fh} These are used to specify the size of a
< menuless and canvasless \V application, and are optional.
< 
442,443c434,435
< \code{WorkSlice} method every \code{slice} milliseconds.
< The \code{WorkSlice} method of every open \code{vCommandWindow}
---
> \code{WorkSlice} will be called every \code{slice} milliseconds.
> Also, the \code{WorkSlice} method of every open \code{vCommandWindow}
455,458c447,449
< When a \code{EnableWorkSlice} has been called with a positive value,
< \V\ calls \code{vApp::WorkSlice} at approximately the specified
< interval (or more
< likely, the overridden method in your app), as well as the
---
> When a \code{EnableWorkSlice} positive interval has been called,
> \V\ will periodically call \code{vApp::WorkSlice} (or more
> likely, the overridden method in your app), and the 
461,462c452,453
< method to perform short, periodic computations. Theses
< computations should be shorter than the time interval specified for
---
> method to perform short, periodic computations. These
> computations should be shorter than the interval specified to
537a529
> 
diff vrefch5.tex /home/bruce/v112/doc/vrefch5.tex
diff vrefch6.tex /home/bruce/v112/doc/vrefch6.tex
192,200d191
< The type \code{ItemVal} exists for historical reasons, and
< is equivalent to an int, and will remain so. Thus, the easiest
< way to assign and maintain unique ids for your controls
< is to use a C++ \code{enum}. As many as possible examples
< in this manual will use \code{enums}, but examples using the old style
< \code{const} code{ItemVal} declarations may
< continue to exist. There is more discussion of assigning ids
< in the following example.
< 
276,282c267,268
< button on the bottom row. The ids in this example are
< defined using an \code{enum}. Remember that your ids must be
< less than 30,000, and using 0 is not a good idea.
< Thus, the \code{enum} in this example gives the ids
< values from 101 to 106.
< An alternative used in \V\ code prior to release 1.13 was
< to provide \code{const}
---
> button on the bottom row. The ids (1 to 6) in this example are
> provided as integer constants. You normally would provide \code{const}
284,291d269
< Many examples of this type of id declaration will likely
< persist.
< 
< It also helps to use a consistent naming convention for ids.
< The quick reference appendix lists suggested prefixes for
< each control type under the \code{CmdType} section. For
< example, use an id of the form \code{btnXXX} for buttons.
< Predefined ids follow the form \code{M_XXX}.
307d284
< enum {lbl1 = 101, frm1, btn1, btn2,
310,313c287,290
<     {C_Label, lbl1, 0,"Sample",NoList,CA_MainMsg,isSens,NoFrame,0,0},
<     {C_Frame, frm1, 0, "", NoList,CA_None,isSens,NoFrame,0,lbl1},
<     {C_Button, btn1, 0, "Button 1", NoList, CA_None, isSens,frm1,0,0},
<     {C_Button, btn2, 0, "Button 2", NoList, CA_None, isSens,frm1,btn1,0},
---
>     {C_Label, 1, 0,"Sample",NoList,CA_MainMsg,isSens,NoFrame,0,0},
>     {C_Frame, 2, 0, "", NoList,CA_None,isSens,NoFrame,0,1},
>     {C_Button, 3, 3, "Button 1", NoList, CA_None, isSens,2,0,0},
>     {C_Button, 4, 4, "Button 2", NoList, CA_None, isSens,2,3,0},
315c292
<         isSens, NoFrame,0,frm1},
---
>         isSens, NoFrame,0,2},
409c386
<  {C_Button, btnId, 0,"Save",NoList,CA_None,isSens,NoFrame,0,0}
---
>  {C_Button, BtnId, BtnId,"Save",NoList,CA_None,isSens,NoFrame,0,0}
418,419c395,396
< a safe convention is to a 0 for
< the \code{retVal}. You can put any label you
---
> a safe convention is to use the same id (\code{BtnId} here) for
> both \code{cmdId} and \code{retVal}. You can put any label you
430,431c407,408
< \code{SetString(btnId,} \code{"New Label")}. You can change the
< sensitivity of a button with \code{SetValue(btnID, OnOrOff,
---
> \code{SetString(BtnId,} \code{"New Label")}. You can change the
> sensitivity of a button with \code{SetValue(BtnID, OnOrOff,
462c439
<  {C_CheckBox, chkId, 1,"Show Details",NoList,CA_None,isSens,NoFrame,0,0}
---
>  {C_CheckBox, ChkId, 1,"Show Details",NoList,CA_None,isSens,NoFrame,0,0}
472c449
< You can change the label of a check box with: \code{SetString(chkId,}
---
> You can change the label of a check box with: \code{SetString(ChkId,}
474,475c451,452
< box with \code{SetValue(chkID, OnOrOff,Sensitive)}. You can
< change the checked state with \code{SetValue(chkID, OnOrOff,
---
> box with \code{SetValue(ChkID, OnOrOff,Sensitive)}. You can
> change the checked state with \code{SetValue(ChkID, OnOrOff,
543,545c520,522
<     // part of a CommandObject definition
<     {C_ColorButton, cbt1, 0, "", (void*)&btncolor,
<         CA_None, isSens, NoFrame, 0, btnXXX},
---
>     // in a CommandObject definition
>     {C_ColorButton, 8, 0, "", (void*)&btncolor,
>         CA_None, isSens, NoFrame, 0, 60},
551c528
<     SetValue(cbt1,0,btncolor);
---
>     SetValue(7,0,btncolor);
553,554c530,531
<     SetValue(cbt1,(ItemVal)btncolor.r(),Red);
<     SetValue(cbt1,(ItemVal)btncolor.g(),Green);
---
>     SetValue(7,(ItemVal)btncolor.r(),Red);
>     SetValue(7,(ItemVal)btncolor.g(),Green);
556c533
<     SetValue(cbt1,(ItemVal)btncolor.b(),Blue);
---
>     SetValue(7,(ItemVal)btncolor.b(),Blue);
617c594
< enum { cbxId = 300 };
---
> const int ComboId = 300;
628c605
<     {C_ComboBox, cbxId, 2, "A Combo Box", (void*)comboList,
---
>     {C_ComboBox, ComboId, 2, "A Combo Box", (void*)comboList,
640c617
<     cval = ld.GetValue(cbxId);  // Retrieve the item selected
---
>     cval = ld.GetValue(ComboId);  // Retrieve the item selected
748c725
<  {C_Label, lblId,0,"Select Options",NoList,CA_None,isSens,NoFrame,0,0, 0,0}
---
>  {C_Label, LblId,0,"Select Options",NoList,CA_None,isSens,NoFrame,0,0, 0,0}
753c730
< \code{SetString(lblId,} \code{"New Label")}, they are usually static
---
> \code{SetString(LblId,} \code{"New Label")}, they are usually static
758,760c735,736
< A \code{C\_ColorLabel} is a label that uses the
< List parameter of the \code{CommandObject} array to
< specify a \code{vColor}. You can
---
> A \code{C\_ColorLabel} is a label with a \code{vColor} used
> for the List parameter of the \code{CommandObject} array. You can
803,804c779,780
< Change the contents of the list with
< \code{vDialog::SetValue} using either \code{ChangeList} or
---
> You can change the contents of the list by using 
> \code{vDialog::SetValue} with either  \code{ChangeList} or
815c791
< enum {lstId = 200 };
---
> const int ListId = 200;
826c802
<     {C_List, lstId, 0, "A List", (void*)testList,
---
>     {C_List, ListId, 0, "A List", (void*)testList,
829c805
<        CA_DefaultButton, isSens, NoFrame, 0, lstId},
---
>        CA_DefaultButton, isSens, NoFrame, 0, ListId},
837c813
<     ld.SetValue(lstId,8,Value);  // pre-select 8th item
---
>     ld.SetValue(ListId,8,Value);  // pre-select 8th item
839c815
<     lval = ld.GetValue(lstId);  // Retrieve the item selected
---
>     lval = ld.GetValue(ListId);  // Retrieve the item selected
883d858
< enum{frm1 = 200, lbl1, pbrH, pbrV, ... };
888,891c863,866
<     {C_Frame, frm1, 0, "",NoList,CA_None,isSens,NoFrame, 0,0},
<     {C_Label, lbl1, 0, "Progress",NoList,CA_None,isSens,frm1,0,0},
<     {C_ProgressBar, pbrH, 50, "", NoList,
<         CA_Horizontal,isSens,frm1, 0, lbl1},  // Horiz, with label
---
>     {C_Frame, 70, 0, "",NoList,CA_None,isSens,NoFrame, 0,0},
>     {C_Label, 71, 0, "Progress",NoList,CA_None,isSens,70,0,0},
>     {C_ProgressBar, 72, 50, "", NoList,
>         CA_Horizontal,isSens,70, 0, 71},  // Horiz, with label
893,894c868,869
<     {C_ProgressBar, pbrV, 50, "", NoList,  // Vertical, no value
<       CA_Vertical | CA_Small, isSens,NoFrame, 0, frm1},
---
>     {C_ProgressBar, 76, 50, "", NoList,  // Vertical, no value
>       CA_Vertical | CA_Small, isSens,NoFrame, 0, 70},
899,900c874,875
<   SetValue(pbrH,retval,Value);    // The horizontal bar
<   SetValue(pbrV,retval,Value);    // The vertical bar
---
>   SetValue(72,retval,Value);    // The horizontal bar
>   SetValue(76,retval,Value);    // The vertical bar
952,955c927,931
< enum {
<     frmV1 = 200, rdb1, rdb2, rdb3, ...
< ...
<   };
---
> const ItemVal FrmV1 = 106;
> const ItemVal RB1 = 107;
> const ItemVal RB2 = 108;
> const ItemVal RB3 = 109;
> const ItemVal BtnOK = 110;
959,962c935,938
<     {C_Frame, frmV1, 0,"Radios",NoList,CA_Vertical,isSens,NoFrame,0,0},
<     {C_RadioButton, rdb1, 1, "KOB",  NoList,CA_None,isSens, fmV1,0,0},
<     {C_RadioButton, rdb2, 0, "KOAT", NoList,CA_None, isSens,frmV1,0,0},
<     {C_RadioButton, rdb3, 0, "KRQE", NoList,CA_None, isSens,frmV1,0,0},
---
>     {C_Frame, FrmV1, 0,"Radios",NoList,CA_Vertical,isSens,NoFrame,0,0},
>     {C_RadioButton, RB1, 1, "KOB",  NoList,CA_None,isSens, mdFrmV1,0,0},
>     {C_RadioButton, RB2, 0, "KOAT", NoList,CA_None, isSens,mdFrmV1,0,0},
>     {C_RadioButton, RB3, 0, "KRQE", NoList,CA_None, isSens,mdFrmV1,0,0},
964c940
<         isSens, NoFrame, 0, frmV1},
---
>         isSens, NoFrame, 0, mdFrmV1},
966c942
<         isSens, NoFrame, M_Cancel, frmV1},
---
>         isSens, NoFrame, M_Cancel, mdFrmV1},
974c950
<         case rdb1:            // Radio Button KOB
---
>         case RB1:            // Radio Button KOB
1028d1003
< enum { frm1 = 80, sld1, txt1 };
1032,1034c1007,1009
<     {C_Frame, frm1, 0, "",NoList,CA_None,isSens,NoFrame,0,0},
<     {C_Slider, sld1, 50, "",NoList,CA_Horizontal,isSens,frm1,0,0},
<     {C_Text, txt1, 0, "", "50",CA_None,isSens, frm1, sld1, 0},
---
>     {C_Frame, 86, 0, "",NoList,CA_None,isSens,NoFrame,0,0},
>     {C_Slider, 87, 50, "",NoList,CA_Horizontal,isSens,86,0,0},
>     {C_Text, 88, 0, "", "50",CA_None,isSens, 86, 87, 0},
1045c1020
<         case sld1:    // The slider
---
>         case 87:    // The slider
1049c1024
<             SetString(txt1,buff);      // Show value
---
>             SetString(88,buff);      // Show value
1109d1083
<   enum { spnColor = 300, spnMinMax, spnInt, ... };
1113c1087
<       {C_Spinner,spnColor,0,"Vbox", // A text list.
---
>       {C_Spinner,idColor,0,"Vbox", // A text list.
1116c1090
<       {C_Spinner,spnMinMax,0,"Vbox", // a range -10 to 10
---
>       {C_Spinner,idMinMax,0,"Vbox", // a range -10 to 10
1119c1093
<       {C_Spinner,spnInt,32,"Vbox",  // int values step by 1
---
>       {C_Spinner,idInt,32,"Vbox",  // int values step by 1
1156c1130
<  {C_Text, txtId, 0, "", "This is an example\nof a two line text.",
---
>  {C_Text, TextId, 0, "", "This is an example\nof a two line text.",
1162c1136
< \code{SetString(txtId,} \code{"New text} \code{to show.")}.
---
> \code{SetString(TextId,} \code{"New text} \code{to show.")}.
1193,1202d1166
< There are two ways to control the size of the TextIn control.
< If you specify \code{CA\_None}, you will get a TextIn
< useful form most simple input commands. Using \code{CA_Large}
< gets a wider TextIn, while \code{CA+Small} gets a smaller
< TextIn. You can also use the \code{size} field of the
< \code{CommandObject} to explicitly specify a width in
< characters. When you specify a size, that number of
< characters will fit in the TextIn, but the control
< does \emph{not} enforce that size as a limit.
< 
1212c1176
<     {C_TextIn, txiId,0,"",NoList,CA_None,isSens,NoFrame,0,0},
---
>     {C_TextIn, TxtId,0,"",NoList,CA_None,isSens,NoFrame,0,0},
1224c1188
<     (void) md.GetTextIn(txiId, text_buff, 254); // get the string
---
>     (void) md.GetTextIn(2, text_buff, 254); // get the string
1342,1343d1305
<     enum {lbl1 = 400, tbt1, tbt2, tbt3, frm1, tfr1, tfr2,
<           btnA1, btnB1, btnA2, btnB2 };
1347c1309
<         {C_Label,lbl1,0,"Tab Frame Demo",NoList,CA_None,isSens,
---
>         {C_Label,400,0,"Tab Frame Demo",NoList,CA_None,isSens,
1349,1354c1311,1316
<         {C_ToggleButton,tbt1,1,"Tab 1",NoList, CA_None, isSens, 
<                  lbl1, 0, 0},
<         {C_ToggleButton,tbt2,0,"Tab 2",NoList, CA_None, isSens, 
<                  lbl1, tbt, 0},
<         {C_ToggleButton,tbt3,0,"Tab 3",NoList, CA_None, isSens,
<                  lbl1, tbt2 0},
---
>         {C_ToggleButton,401,1,"Tab 1",NoList, CA_None, isSens, 
>                  400, 0, 0},
>         {C_ToggleButton,402,0,"Tab 2",NoList, CA_None, isSens, 
>                  400, 401, 0},
>         {C_ToggleButton,403,0,"Tab 3",NoList, CA_None, isSens,
>                  400, 402, 0},
1357c1319
<         {C_Frame,frm1,0, "", NoList,CA_None,isSens,lbl1,0,tbt1},
---
>         {C_Frame,409,0, "", NoList,CA_None,isSens,400,0,401},
1360,1362c1322,1324
<         {C_ToggleFrame, tfr1,1,"",NoList, CA_NoBorder,isSens,frm1,0,0},
<         {C_Button,btnA1,0,"Button A(1)",NoList,CA_None,isSens,tfr1,0,0},
<         {C_Button,btnB1,0,"Button B(1)",NoList,CA_None,isSens,tfr1,0,btnA1},
---
>         {C_ToggleFrame, 410,1,"",NoList, CA_NoBorder,isSens,409,0,0},
>         {C_Button,411,0,"Button A(1)",NoList,CA_None,isSens,410,0,0},
>         {C_Button,412,0,"Button B(1)",NoList,CA_None,isSens,410,0,411},
1365,1368c1327,1330
<         {C_ToggleFrame,tfr2,0,"",NoList,CA_NoBorder | CA_Hidden,
<                 isSens,frm1,0,0},
<         {C_Button,btnA2,0,"Button A(2)",NoList,CA_Hidden,isSens,tfr2,0,0},
<         {C_Button,btnB2,0,"Button B(2)",NoList,CA_Hidden,isSens,tfr2,btnA2,0},
---
>         {C_ToggleFrame,420,0,"",NoList,CA_NoBorder | CA_Hidden,
>                 isSens,409,0,0},
>         {C_Button,421,0,"Button A(2)",NoList,CA_Hidden,isSens,420,0,0},
>         {C_Button,422,0,"Button B(2)",NoList,CA_Hidden,isSens,420,421,0},
1380c1342
<         case tbt1:       // For toggle buttons, assume toggle to ON
---
>         case 401:       // For toggle buttons, assume toggle to ON
1383,1385c1345,1347
<             SetValue(tbt2,0,Value);    // other one off
<             SetValue(tfr2,0,Value);    // Toggle other frame off
<             SetValue(tfr1,1,Value);    // and ours on
---
>             SetValue(402,0,Value);    // other one off
>             SetValue(420,0,Value);    // Toggle other frame off
>             SetValue(410,1,Value);    // and ours on
1389c1351
<         case tbt2:       // Toggle 2
---
>         case 402:       // Toggle 2
1392,1394c1354,1356
<             SetValue(tbt1,0,Value);    // other off
<             SetValue(tfr1,0,Value);    // Toggle other off
< 	    SetValue(tfr2,1,Value);    // and ours on
---
>             SetValue(401,0,Value);    // other off
>             SetValue(410,0,Value);    // Toggle other off
>             SetValue(420,1,Value);    // and ours on
1811c1773
<         {C_Label, lbl1, 0, "Label",NoList,CA_MainMsg,isSens,0,0},
---
>         {C_Label, 1, 1, "Label",NoList,CA_MainMsg,isSens,0,0},
1813c1775
<             CA_DefaultButton, isSens,lbl1,0},
---
>             CA_DefaultButton, isSens,1,0},
1871,1872c1833
< The various types of command objects that can be added include
< (with suggested id prefix in parens):
---
> The various types of command objects that can be added include:
1877,1897c1838,1854
<     C_Blank:       filler to help RightOfs, Belows work (blk)
<     C_BoxedLabel:  a label with a box (bxl)
<     C_Button:      Button (btn)
<     C_CheckBox:    Checked Item (chk)
<     C_ColorButton: Colored button (cbt)
<     C_ColorLabel:  Colored label (clb)
<     C_ComboBox:    Popup combo list (cbx)
<     C_Frame:       General purpose frame (frm)
<     C_Icon:        a display only Icon (ico)
<     C_IconButton:  a command button Icon (icb)
<     C_Label:       Regular text label (lbl)
<     C_List:        List of items (lst)
<     C_ProgressBar: Bar to show progress (pbr)
<     C_RadioButton: Radio button (rdb)
<     C_Slider:      Slider to enter value (sld)
<     C_Spinner:     Spinner value entry (spn)
<     C_TextIn:      Text input field (txi)
<     C_Text:        wrapping text out (txt)
<     C_ToggleButton: a toggle button (tbt)
<     C_ToggleFrame: a toggle frame (tfr)
<     C_ToggleIconButton:  a toggle Icon button (tib)
---
>     C_Blank:       filler to help RightOfs, Belows work
>     C_Button:      Button
>     C_CheckBox:    Checked Item
>     C_ColorButton: Colored button
>     C_ColorLabel:  Colored label
>     C_ComboBox:    Popup combo list
>     C_Frame:       General purpose frame
>     C_Icon:        a display only Icon
>     C_IconButton:  a command button Icon
>     C_Label:       Regular text label
>     C_List:        List of items (scrollable)
>     C_ProgressBar: Bar to show progress 
>     C_RadioButton: Radio button
>     C_Slider:      Slider to enter value
>     C_Spinner:     A value spinner
>     C_TextIn:      Text input field
>     C_Text:        wrapping text out
diff vrefch7.tex /home/bruce/v112/doc/vrefch7.tex
441,456d440
< \Meth{virtual int GetHScroll(int& Shown, int& Top)}
< \Indextt{GetHScroll}
< 
< Get the status of the Horizontal Scroll bar. Returns 1 if the
< scroll bar is displayed, 0 if not. Returns in \code{Shown} and
< \code{Top} the current values of the scroll bar. See \code{SetVScroll}
< for a description of the meanings of parameters.
< 
< %............................................................
< \Meth{virtual int GetVScroll(int& Shown, int& Top)}
< \Indextt{GetVScroll}
< 
< Get the status of the Vertical Scroll bar. See
< \code{GetHScroll} for details.
< 
< %............................................................
985c969
< destY, int srcX = 0, int srcY = 0, int srcW = 0, int srcH = 0)}
---
> destY)}
992,1000c976
< canvas (which will usually be 0,0). If you use the default
< values for \code{srcX=0}, \code{srcY=0}, \code{srcW=0}, and
< \code{srcH=0}, the entire source canvas will be copied.
< 
< Beginning with \V release 1.13, \code{CopyFromMemoryDC} provides
< the extra parameters to specify an area of the source to copy.
< You can specify the source origin, and its width and height.
< The default values for these allow backward call and behavior
< compatibility.
---
> canvas (which will usually be 0,0).
diff vrefch8.tex /home/bruce/v112/doc/vrefch8.tex
diff vrefch9.tex /home/bruce/v112/doc/vrefch9.tex
diff vrefman.tex /home/bruce/v112/doc/vrefman.tex
103,104c103,104
< Version 1.13 \\
< August 15, 1996
---
> Version 1.12 \\
> July 12, 1996
122c122
< \emph{V - A C++ GUI Framework}, Version 1.13,
---
> \emph{V - A C++ GUI Framework}, Version 1.12,
182c182
< \input{vtools.tex}
---
> \input{iconed.tex}
diff vtools.tex /home/bruce/v112/doc/vtools.tex
diff vwebref.tex /home/bruce/v112/doc/vwebref.tex
88c88
< Version 1.13 -- August 15, 1996 \\
---
> Version 1.12 -- July 12, 1996 \\
103c103
< \emph{V - A C++ GUI Framework}, Version 1.13,
---
> \emph{V - A C++ GUI Framework}, Version 1.12,
185,191c185
< \begin{rawhtml}
< <IMG BORDER=0 ALIGN=BOTTOM ALT="" SRC="../fig/vapphier.gif">
< \end{rawhtml}
< 
< \begin{latexonly}
< \input{fig/vapphier}
< \end{latexonly}
---
> \input{fig/vapphier.tex}
