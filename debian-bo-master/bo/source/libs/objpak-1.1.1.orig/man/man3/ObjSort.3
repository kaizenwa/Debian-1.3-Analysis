.TH "ObjSort" 3 "Oct 30, 1996"
.SH CLASS
.B
ObjSort
.SH SUPERCLASS
ObjPak
.SH DESCRIPTION
.PP

.B
ObjSort 
instances are groups of objects that are kept in sorted order (by default, the first object is the smallest with respect to 
.B
compare:
).  Inserting and searching objects in such a sorted collection can be faster than using, say an 
.B
ObjCltn 
object collection.
.PP
.B
Creating An Instance
.PP

The method 
.B
new 
creates an instance that sorts its elements with respect to 
.B
compare:.  
The method 
.B
newDictCompare 
sends 
.B
dictCompare: 
messages to compare pairs of elements.
.PP
.B
Adding Objects
.PP

Normally, you insert an object with the 
.B
add: 
method.  This method allows you to add an object to the collection, even when it is equal to an element in the collection (when the comparison method returns zero; because you can use a different method than 
.B
compare:
, this doesn\&'t necessarily mean that 
.B
isEqual: 
returns YES).
.PP

You can also choose not to add duplicate entries.  The 
.B
addNTest: 
method adds if the object was absent and returns a value that can be used to test whether the object was found or not. The 
.B
filter: 
method frees a new entry when it\&'s a duplicate.  The 
.B
replace: 
method always replaces duplicates (returning the object that was previously in the collection).
.SH METHOD TYPES
.PP
.B
Creation
.RS 3
new
.br
newDictCompare
.br
copy
.br
deepCopy
.br
emptyYourself
.br
freeContents
.br
free
.br
.RE
.PP
.B
Interrogation
.RS 3
size
.br
isEmpty
.br
eachElement
.br
.RE
.PP
.B
Comparing
.RS 3
hash
.br
isEqual:
.br
.RE
.PP
.B
Adding
.RS 3
add:
.br
addNTest:
.br
filter:
.br
replace:
.br
.RE
.PP
.B
Removing
.RS 3
remove:
.br
.RE
.PP
.B
Adding and Removing Contents
.RS 3
addContentsTo:
.br
addContentsOf:
.br
removeContentsOf:
.br
removeContentsFrom:
.br
.RE
.PP
.B
Locating
.RS 3
find:
.br
contains:
.br
.RE
.PP
.B
Printing
.RS 3
printToFile:
.br
.RE
.PP
.B
NextStep Archiving
.RS 3
write:
.br
read:
.br
.RE
.SH METHODS
.PP
.B
new
.RS 1
+
.B
new
.RE
.PP

Returns a new instance that sorts its contents with respect to 
.B
compare:.
.PP
.B
newDictCompare
.RS 1
+
.B
newDictCompare
.RE
.PP

Returns a new instance that sorts its contents with respect to 
.B
dictCompare:.
.PP
.B
copy
.RS 1
-
.B
copy
.RE
.PP

Returns a new copy of the object (without copying the elements).
.PP
.B
deepCopy
.RS 1
-
.B
deepCopy
.RE
.PP

Returns a new copy of the object.  The elements in the new copy are deep copies of the elements in the original object.
.PP
.B
emptyYourself
.RS 1
-
.B
emptyYourself
.RE
.PP

Empties all the members of the object (without freeing them).  Returns the receiver.
.PP
.B
freeContents
.RS 1
-
.B
freeContents
.RE
.PP

Removes and frees the contents of the object, but doesn\&'t free the object itself.  Returns the receiver.
.PP
.B
free
.RS 1
-
.B
free
.RE
.PP

Frees the object, but not its contents.  Returns 
.B
nil.  
Do :
.RS 3

aSort = [[aSort freeObjects] free];
.br
.RE
.PP

if you want to free the object and its contents.
.PP
.B
size
.RS 1
- (unsigned)
.B
size
.RE
.PP

Returns the number of elements in the object.
.PP
.B
isEmpty
.RS 1
- (BOOL)
.B
isEmpty
.RE
.PP

Whether the number of elements is equal to zero.
.PP
.B
eachElement
.RS 1
-
.B
eachElement
.RE
.PP

Returns a sequence of sorted elements.  The first element in the sequence is the smallest with respect to the ordering.
.RS 3

aSeq = [aSort eachElement];
.br
while ((anElement = [aSeq next])) {
.br
    /* do something */
.br
}
.br
aSeq = [aSeq free];
.br
.RE
.PP
.B
hash
.RS 1
- (unsigned)
.B
hash
.RE
.PP

Returns a hash value based on the receiver\&'s address and the results of sending the 
.B
hash 
message to the contents.
.PP
.B
isEqual:
.RS 1
- (BOOL)
.B
isEqual:
.I
aSort
.RE
.PP

Returns YES if 
.I
aSort 
is an 
.B
ObjSort 
instance, and if each member of its contents responds affirmatively to the message 
.B
isEqual: 
when compared to the corresponding member of the receiver\&'s contents.
.PP
.B
add:
.RS 1
-
.B
add:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
to the receiver, keeping the contents of the object sorted.  Duplicate entries are allowed.  Returns the receiver.
.PP
.B
addNTest:
.RS 1
-
.B
addNTest:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
if it was not previously in the set.  Returns 
.I
anObject 
if the addition takes place, otherwise returns 
.B
nil.
.PP
.B
filter:
.RS 1
-
.B
filter:
.I
anObject
.RE
.PP

If 
.I
anObject 
compares equally to some object in the contents of the receiver, then 
.I
anObject 
is freed, and the matching object is returned.  Otherwise, 
.I
anObject 
is added and returned.
.PP
.B
replace:
.RS 1
-
.B
replace:
.I
anObject
.RE
.PP

If a matching object is found, then 
.I
anObject 
replaces that object, and the matching object is returned.  If there is no matching object, 
.I
anObject 
is added to the receiver, and 
.B
nil 
is returned.
.PP
.B
remove:
.RS 1
-
.B
remove:
.I
oldObject
.RE
.PP

Removes 
.I
oldObject 
or the element that matches (when the compare method returns zero).  Returns the removed entry, or 
.B
nil 
if there is no matching entry.
.PP
.B
Note:

Not implemented
.PP
.B
addContentsTo:
.RS 1
-
.B
addContentsTo:
.I
aCol
.RE
.PP

Adds every element of the receiver to 
.I
aCol 
and returns 
.I
aCol.  
If 
.I
aCol 
is 
.B
nil
, returns 
.B
nil.  
The argument 
.I
aCol 
need not actually be a collection, as long as it responds to 
.B
add: 
in the same way as collections do.
.PP
.B
addContentsOf:
.RS 1
-
.B
addContentsOf:
.I
aCol
.RE
.PP

Adds each member of 
.I
aCol 
to the receiver.  Returns the receiver.  If 
.I
aCol 
is 
.B
nil
, no action is taken.  The argument 
.I
aCol 
need not be a collection, so long as it responds to 
.B
eachElement 
in the same way as collections do.
.PP
.B
removeContentsOf:
.RS 1
-
.B
removeContentsOf:
.I
aCol
.RE
.PP

Removes each of the members of 
.I
aCol 
from the receiver.  Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
eachElement 
as collections do.
.PP

If 
.I
aCol 
is the same object as the receiver, it empties itself using 
.B
emptyYourself 
and returns the receiver.
.PP
.B
removeContentsFrom:
.RS 1
-
.B
removeContentsFrom:
.I
aCol
.RE
.PP

Removes each of the members of the receiver from 
.I
aCol.  
Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
remove: 
in the same way as collections.
.PP
.B
find:
.RS 1
-
.B
find:
.I
anObject
.RE
.PP

Returns any element in the receiver which 
.B
isEqual: 
to 
.I
anObject.  
Otherwise, returns 
.B
nil.
.PP
.B
contains:
.RS 1
- (BOOL)
.B
contains:
.I
anObject
.RE
.PP

Returns YES if the receiver contains 
.I
anObject.  
Otherwise, returns NO.  Implementation is in terms of the receiver\&'s 
.B
find: 
method.
.PP
.B
printToFile:
.RS 1
-
.B
printToFile:
(FILE *)
.I
aFile
.RE
.PP

Prints a comma separated list of the objects in the set by sending each individual object a 
.B
printToFile: 
message.  Returns the receiver.
.PP
.B
write:
.RS 1
-
.B
write:
(NXTypedStream *)
.I
stream
.RE
.PP

Writes the set and all its elements to the typed stream 
.I
stream.  
Returns the receiver.
.PP
.B
read:
.RS 1
-
.B
read:
(NXTypedStream *)
.I
stream
.RE
.PP

Reads the set and all its elements from the typed stream 
.I
stream.  
Returns the receiver.
