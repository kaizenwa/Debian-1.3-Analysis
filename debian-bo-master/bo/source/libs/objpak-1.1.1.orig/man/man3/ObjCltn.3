.TH "ObjCltn" 3 "Oct 30, 1996"
.SH CLASS
.B
ObjCltn
.SH SUPERCLASS
ObjPak
.SH DESCRIPTION
.PP

.B
ObjCltn 
instances are ordered collections of objects : you can access, add or remove elements at a specified offset in the array of elements.  
.B
ObjCltn 
takes care of the memory allocation issues to hold the objects.
.PP

There can be no 
.B
nil 
entries between the first (at offset 0) and last  elements (at 
.B
size 
minus one).  For this reason, all methods that add objects refuse to add 
.B
nil
\&'s.  When entries are added or removed, the offsets of the remaining entries change.
.PP

Offsets into collections are traditionally unsigned integers.  Methods that return an offset, e.g., 
.B
offsetOf: 
and 
.B
lastOffset 
return a value of (unsigned)-1 to indicate that an object has not been found.
.PP

There are many methods for adding or inserting members into a collection.  Although members may be added at any point in the collection, they are generally added at the end using 
.B
add:.
.PP

A member may be searched for using either the 
.B
find: 
or 
.B
findMatching: 
method.  In the first case, the member in the collection must be an exact match.  In the second case, the member must match in the sense of the 
.B
isEqual: 
method.
.SH METHOD TYPES
.PP
.B
Creation
.RS 3
new
.br
copy
.br
deepCopy
.br
emptyYourself
.br
freeContents
.br
free
.br
.RE
.PP
.B
Interrogation
.RS 3
size
.br
isEmpty
.br
lastOffset
.br
eachElement
.br
firstElement
.br
lastElement
.br
.RE
.PP
.B
Comparing
.RS 3
hash
.br
isEqual:
.br
.RE
.PP
.B
Adding
.RS 3
add:
.br
addFirst:
.br
addLast:
.br
addIfAbsent:
.br
addIfAbsentMatching:
.br
.RE
.PP
.B
Insertion
.RS 3
at:insert:
.br
insert:after:
.br
insert:before:
.br
.RE
.PP
.B
Relative Accessing
.RS 3
after:
.br
before:
.br
at:
.br
at:put:
.br
.RE
.PP
.B
Removing
.RS 3
removeFirst
.br
removeLast
.br
removeAt:
.br
remove:
.br
.RE
.PP
.B
Adding and Removing Contents
.RS 3
addContentsTo:
.br
addContentsOf:
.br
removeContentsOf:
.br
removeContentsFrom:
.br
.RE
.PP
.B
Locating
.RS 3
find:
.br
findMatching:
.br
findSTR:
.br
contains:
.br
offsetOf:
.br
.RE
.PP
.B
Printing
.RS 3
printToFile:
.br
.RE
.PP
.B
NextStep Archiving
.RS 3
write:
.br
read:
.br
.RE
.SH METHODS
.PP
.B
new
.RS 1
+
.B
new
.RE
.PP

Returns a new empty collection.
.PP
.B
copy
.RS 1
-
.B
copy
.RE
.PP

Returns a new copy of the collection.
.PP
.B
deepCopy
.RS 1
-
.B
deepCopy
.RE
.PP

Returns a new copy of the collection.  The members in the new collection are deep copies of the members in the original collection.
.PP
.B
emptyYourself
.RS 1
-
.B
emptyYourself
.RE
.PP

Removes all the members of the collection (without freeing them).  Returns the receiver.
.PP
.B
freeContents
.RS 1
-
.B
freeContents
.RE
.PP

Removes and frees all the members of the receiver, but doesn\&'t free the receiver itself.  Returns the receiver.
.PP
.B
free
.RS 1
-
.B
free
.RE
.PP

Frees the collection, but not its contents.  Returns 
.B
nil.  
Do :
.RS 3

aCltn = [[aCltn freeObjects] free];
.br
.RE
.PP

if you want to free the collection and its contents.
.PP
.B
size
.RS 1
- (unsigned)
.B
size
.RE
.PP

Returns the number of objects in the collection.
.PP
.B
isEmpty
.RS 1
- (BOOL)
.B
isEmpty
.RE
.PP

Whether the number of objects in the collection is equal to zero.
.PP
.B
lastOffset
.RS 1
- (unsigned)
.B
lastOffset
.RE
.PP

Returns the offset of the last element.  If there are no elements it returns (unsigned)-1.
.PP
.B
eachElement
.RS 1
-
.B
eachElement
.RE
.PP

Returns a sequence of the elements in the collection.
.RS 3

aSeq = [aCltn eachElement];
.br
while ((anElement = [aSeq next])) {
.br
    /* do something */
.br
}
.br
aSeq = [aSeq free];
.br
.RE
.PP
.B
firstElement
.RS 1
-
.B
firstElement
.RE
.PP

Returns the first element in the collection.  If there are no elements, returns 
.B
nil.
.PP
.B
lastElement
.RS 1
-
.B
lastElement
.RE
.PP

Returns the last element in the collection.  If there are no elements, returns 
.B
nil.
.PP
.B
hash
.RS 1
- (unsigned)
.B
hash
.RE
.PP

Returns a hash value based on the receiver\&'s address and the results of sending the 
.B
hash 
message to the contents.
.PP
.B
isEqual:
.RS 1
- (BOOL)
.B
isEqual:
.I
aCltn
.RE
.PP

Returns YES if 
.I
aCltn 
is a collection, and if each member of its contents responds affirmatively to the message 
.B
isEqual: 
when compared to the corresponding member of the receiver\&'s contents.
.PP
.B
add:
.RS 1
-
.B
add:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
to the collection as the last element and returns the receiver.
.PP
.B
addFirst:
.RS 1
-
.B
addFirst:
.I
newObject
.RE
.PP

Adds 
.I
newObject 
as the first (zero-th) element of the collection.  Returns the receiver.  Any elements at this offset or higher are relocated to the next higher offset to make room.
.PP
.B
addLast:
.RS 1
-
.B
addLast:
.I
newObject
.RE
.PP

Identical to the 
.B
add: 
method.
.PP
.B
addIfAbsent:
.RS 1
-
.B
addIfAbsent:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
to the collection only if the collection does not have that same object, i.e., one that is pointer equal.  Returns the receiver.
.PP
.B
addIfAbsentMatching:
.RS 1
-
.B
addIfAbsentMatching:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
to the collection only if the collection does not have a matching object, i.e., one that is 
.B
isEqual:.  
Returns the receiver.
.PP
.B
at:insert:
.RS 1
-
.B
at:
(unsigned )
.I
anOffset
.B
insert:
.I
anObject
.RE
.PP

Inserts 
.I
anObject 
at offset 
.I
anOffset 
and returns the receiver.  Any elements at this offset or higher are relocated to the next higher offet to make room.  If 
.I
anOffset 
is greater than the size of the collection, an error is generated.
.PP
.B
insert:after:
.RS 1
-
.B
insert:
.I
newObject
.B
after:
.I
oldObject
.RE
.PP

Searches for 
.I
oldObject 
in the collection, and inserts 
.I
newObject 
after 
.I
oldObject
, moving later elements if necessary to make room.  If 
.I
oldObject 
is not found, an error is generated.  Returns the receiver.
.PP
.B
insert:before:
.RS 1
-
.B
insert:
.I
newObject
.B
before:
.I
oldObject
.RE
.PP

First searches for 
.I
oldObject 
in the collection, and inserts the 
.I
newObject 
before 
.I
oldObject.  
If 
.I
oldObject 
is not found, an error is generated.  Returns the receiver.
.PP
.B
after:
.RS 1
-
.B
after:
.I
anObject
.RE
.PP

Searches for 
.I
anObject 
in the collection and, if found, returns the next object.  If 
.I
anObject 
is the last element in the array, returns 
.B
nil.  
Generates an error if 
.I
anObject 
cannot be found.
.PP
.B
before:
.RS 1
-
.B
before:
.I
anObject
.RE
.PP

Searches for 
.I
anObject 
in the collection and, if found, returns the object before it.  If 
.I
anObject 
is the first element in the array, returns 
.B
nil.  
Generates an error if 
.I
anObject 
cannot be found.
.PP
.B
at:
.RS 1
-
.B
at:
(unsigned )
.I
anOffset
.RE
.PP

Returns the object at 
.I
anOffset 
with 
.I
anObject 
and returns the old member at 
.I
anOffset.  
Generates an error if 
.I
anOffset 
is greater than the size of the collection.
.PP
.B
at:put:
.RS 1
-
.B
at:
(unsigned )
.I
anOffset
.B
put:
.I
anObject
.RE
.PP

Replaces the object at 
.I
anOffset 
with 
.I
anObject 
and returns the old member at 
.I
anOffset.  
Generates an error if 
.I
anOffset 
is greater than the size of the collection.  Returns 
.B
nil 
if 
.I
anObject 
is 
.B
nil.
.PP
.B
removeFirst
.RS 1
-
.B
removeFirst
.RE
.PP

Removes the first element.  Returns that element or 
.B
nil 
if there are no elements.
.PP
.B
removeLast
.RS 1
-
.B
removeLast
.RE
.PP

Removes the last element.  Returns that element or 
.B
nil 
if there are no elements.
.PP
.B
removeAt:
.RS 1
-
.B
removeAt:
(unsigned )
.I
anOffset
.RE
.PP

Removes the object at 
.I
anOffset.  
When an object is removed, the remaining elements are adjusted so that there are no 
.B
nil 
entries between the first and last element.  This adjustment shrinks the collection and changes the offset of the entries.  Returns the object removed.
.PP
.B
remove:
.RS 1
-
.B
remove:
.I
oldObject
.RE
.PP

Removes 
.I
oldObject 
from the collection if 
.I
oldObject 
is found, and returns 
.I
oldObject.  
Otherwise returns 
.B
nil.
.PP
.B
addContentsTo:
.RS 1
-
.B
addContentsTo:
.I
aCol
.RE
.PP

Adds every element of the receiver to 
.I
aCol 
and returns 
.I
aCol.  
If 
.I
aCol 
is 
.B
nil
, returns 
.B
nil.  
The argument 
.I
aCol 
need not actually be a collection, as long as it responds to 
.B
add: 
in the same way as collections do.
.PP
.B
addContentsOf:
.RS 1
-
.B
addContentsOf:
.I
aCol
.RE
.PP

Adds each member of 
.I
aCol 
to the receiver.  Returns the receiver.  If 
.I
aCol 
is 
.B
nil
, no action is taken.  The argument 
.I
aCol 
need not be a collection, so long as it responds to 
.B
eachElement 
in the same way as collections do.
.PP
.B
removeContentsOf:
.RS 1
-
.B
removeContentsOf:
.I
aCol
.RE
.PP

Removes each of the members of 
.I
aCol 
from the receiver.  Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
eachElement 
as collections do.
.PP

If 
.I
aCol 
is the same object as the receiver, it empties itself using 
.B
emptyYourself 
and returns the receiver.
.PP
.B
removeContentsFrom:
.RS 1
-
.B
removeContentsFrom:
.I
aCol
.RE
.PP

Removes each of the members of the receiver from 
.I
aCol.  
Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
remove: 
in the same way as collections.
.PP
.B
find:
.RS 1
-
.B
find:
.I
anObject
.RE
.PP

Returns the first member which is the same as 
.I
anObject
, i.e., which is pointer equal.  If none is found, returns 
.B
nil.
.PP
.B
findMatching:
.RS 1
-
.B
findMatching:
.I
anObject
.RE
.PP

Returns the first member which matches 
.I
anObject
, i.e., using 
.B
isEqual: 
for comparison.  If none is found, returns 
.B
nil.
.PP
.B
findSTR:
.RS 1
-
.B
findSTR:
(STR )
.I
strValue
.RE
.PP

Returns the first member whose string contents matches 
.I
strValue
, using the 
.B
isEqualSTR: 
method for comparison.  If none is found, returns 
.B
nil.
.PP
.B
contains:
.RS 1
- (BOOL)
.B
contains:
.I
anObject
.RE
.PP

Returns YES if the receiver contains 
.I
anObject.  
Otherwise, returns NO.  Implementation is in terms of the receiver\&'s 
.B
find: 
method.
.PP
.B
offsetOf:
.RS 1
- (unsigned)
.B
offsetOf:
.I
anObject
.RE
.PP

Searches for 
.I
anObject 
in the contents and returns the offset of the 
.B
first 
pointer equal object it finds.  Otherwise, returns (unsigned)-1.  If 
.I
anObject 
is 
.B
nil
, also returns (unsigned)-1.
.PP
.B
printToFile:
.RS 1
-
.B
printToFile:
(FILE *)
.I
aFile
.RE
.PP

Prints a list of the objects in the objects by sending each individual object a 
.B
printToFile: 
message.  Returns the receiver.
.PP
.B
write:
.RS 1
-
.B
write:
(NXTypedStream *)
.I
stream
.RE
.PP

Writes the collection and all its elements to the typed stream 
.I
stream.  
Returns the receiver.
.PP
.B
read:
.RS 1
-
.B
read:
(NXTypedStream *)
.I
stream
.RE
.PP

Reads the collection and all its members from the typed stream 
.I
stream.  
Returns the receiver.
