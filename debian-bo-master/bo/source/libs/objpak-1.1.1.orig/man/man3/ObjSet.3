.TH "ObjSet" 3 "Oct 30, 1996"
.SH CLASS
.B
ObjSet
.SH SUPERCLASS
ObjPak
.SH DESCRIPTION
.PP

.B
ObjSet 
instances are sets of objects with no duplicate (in the sense of 
.B
isEqual:
) entries.  The 
.B
ObjDic 
class provides a key-value based interface to sets, and may sometimes be more convenient to use.
.PP

To make Sets correctly work, the objects have to implement a pair of comparison methods which must act in a coordinated way :
.PP

The message
.RS 3

[newElement isEqual:oldElement]
.br
.RE
.PP

is expected to report whether 
.I
newElement 
is equal to 
.I
oldElement.
.PP

The message
.RS 3

[newElement hash]
.br
.RE
.PP

should return an integer which is equal for all objects for which 
.B
isEqual: 
is true. 
.PP

Sets place all objects added to them into a hash table based on the results of sending the objects the 
.B
hash 
message.  
.B
ObjSet 
assumes that, after being added to a set, objects, and their hash value, will not be changed.  If any object does change, it will not be located properly in the set.  The result of this is that the object will not be found or that it will be added to the set more than once.
.PP
.B
Adding Objects
.PP

The methods 
.B
add:
, 
.B
addNTest:
, 
.B
filter: 
and 
.B
replace: 
are used to add objects to a set.  The difference between these methods is the procedure used in adding, how duplicates are handled and what value is returned.
.SH METHOD TYPES
.PP
.B
Creation
.RS 3
new
.br
copy
.br
deepCopy
.br
emptyYourself
.br
freeContents
.br
free
.br
.RE
.PP
.B
Interrogation
.RS 3
size
.br
isEmpty
.br
eachElement
.br
.RE
.PP
.B
Comparing
.RS 3
hash
.br
isEqual:
.br
.RE
.PP
.B
Adding
.RS 3
add:
.br
addNTest:
.br
filter:
.br
replace:
.br
.RE
.PP
.B
Removing
.RS 3
remove:
.br
.RE
.PP
.B
Adding and Removing Contents
.RS 3
addContentsTo:
.br
addContentsOf:
.br
removeContentsOf:
.br
removeContentsFrom:
.br
.RE
.PP
.B
Locating
.RS 3
find:
.br
contains:
.br
occurrencesOf:
.br
.RE
.PP
.B
Combining
.RS 3
intersection:
.br
union:
.br
difference:
.br
.RE
.PP
.B
Printing
.RS 3
printToFile:
.br
.RE
.PP
.B
NextStep Archiving
.RS 3
write:
.br
read:
.br
.RE
.SH METHODS
.PP
.B
new
.RS 1
+
.B
new
.RE
.PP

Returns a new empty set.
.PP
.B
copy
.RS 1
-
.B
copy
.RE
.PP

Returns a new copy of the set.
.PP
.B
deepCopy
.RS 1
-
.B
deepCopy
.RE
.PP

Returns a new copy of the set.  The elements in the new set are deep copies of the elements in the original set.
.PP
.B
emptyYourself
.RS 1
-
.B
emptyYourself
.RE
.PP

Empties all the members of the set (without freeing them).  Returns the receiver.
.PP
.B
freeContents
.RS 1
-
.B
freeContents
.RE
.PP

Removes and frees all the members of the set, but doesn\&'t free the set itself.  Returns the receiver.
.PP
.B
free
.RS 1
-
.B
free
.RE
.PP

Frees the set, but not its elements.  Returns 
.B
nil.  
Do :
.RS 3

aSet = [[aSet freeObjects] free];
.br
.RE
.PP

if you want to free the set and its contents.
.PP
.B
size
.RS 1
- (unsigned)
.B
size
.RE
.PP

Returns the number of elements in the set.
.PP
.B
isEmpty
.RS 1
- (BOOL)
.B
isEmpty
.RE
.PP

Whether the number of objects in the set is equal to zero.
.PP
.B
eachElement
.RS 1
-
.B
eachElement
.RE
.PP

Returns a sequence of elements in the set.
.RS 3

aSeq = [aSet eachElement];
.br
while ((anElement = [aSeq next])) {
.br
    /* do something */
.br
}
.br
aSeq = [aSeq free];
.br
.RE
.PP
.B
hash
.RS 1
- (unsigned)
.B
hash
.RE
.PP

Returns a hash value based on the receiver\&'s address and the results of sending the 
.B
hash 
message to the contents.
.PP
.B
isEqual:
.RS 1
- (BOOL)
.B
isEqual:
.I
aSet
.RE
.PP

Returns YES if 
.I
aSet 
is a set, and if each member of its contents responds affirmatively to the message 
.B
isEqual: 
when compared to the corresponding member of the receiver\&'s contents.
.PP
.B
add:
.RS 1
-
.B
add:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
if it was not previously in the set, but doesn\&'t inform the caller about the addition because the receiver is always returned.
.PP
.B
addNTest:
.RS 1
-
.B
addNTest:
.I
anObject
.RE
.PP

Adds 
.I
anObject 
if it was not previously in the set.  Returns 
.I
anObject 
if the addition takes place, otherwise returns 
.B
nil.
.PP
.B
filter:
.RS 1
-
.B
filter:
.I
anObject
.RE
.PP

The 
.B
filter: 
method has a special purpose.  If there is a matching object in the set, then 
.I
anObject 
is freed, and the matching object is returned.  Otherwise, 
.I
anObject 
is added and returned.
.PP
.B
replace:
.RS 1
-
.B
replace:
.I
anObject
.RE
.PP

If a matching object is found, then 
.I
anObject 
replaces that object, and the matching object is returned.  If there is no matching object, 
.I
anObject 
is added to the receiver, and 
.B
nil 
is returned.
.PP
.B
remove:
.RS 1
-
.B
remove:
.I
oldObject
.RE
.PP

Removes 
.I
oldObject 
or the element which matches it using 
.B
isEqual:.  
Returns the removed entry, or 
.B
nil 
if there is no matching entry.
.PP
.B
addContentsTo:
.RS 1
-
.B
addContentsTo:
.I
aCol
.RE
.PP

Adds every element of the receiver to 
.I
aCol 
and returns 
.I
aCol.  
If 
.I
aCol 
is 
.B
nil
, returns 
.B
nil.  
The argument 
.I
aCol 
need not actually be a collection, as long as it responds to 
.B
add: 
in the same way as collections do.
.PP
.B
addContentsOf:
.RS 1
-
.B
addContentsOf:
.I
aCol
.RE
.PP

Adds each member of 
.I
aCol 
to the receiver.  Returns the receiver.  If 
.I
aCol 
is 
.B
nil
, no action is taken.  The argument 
.I
aCol 
need not be a collection, so long as it responds to 
.B
eachElement 
in the same way as collections do.
.PP
.B
removeContentsOf:
.RS 1
-
.B
removeContentsOf:
.I
aCol
.RE
.PP

Removes each of the members of 
.I
aCol 
from the receiver.  Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
eachElement 
as collections do.
.PP

If 
.I
aCol 
is the same object as the receiver, it empties itself using 
.B
emptyYourself 
and returns the receiver.
.PP
.B
removeContentsFrom:
.RS 1
-
.B
removeContentsFrom:
.I
aCol
.RE
.PP

Removes each of the members of the receiver from 
.I
aCol.  
Returns the receiver.  The argument 
.I
aCol 
need not be a collection, as long as it responds to 
.B
remove: 
in the same way as collections.
.PP
.B
find:
.RS 1
-
.B
find:
.I
anObject
.RE
.PP

Returns any element in the receiver which 
.B
isEqual: 
to 
.I
anObject.  
Otherwise, returns 
.B
nil.
.PP
.B
contains:
.RS 1
- (BOOL)
.B
contains:
.I
anObject
.RE
.PP

Returns YES if the receiver contains 
.I
anObject.  
Otherwise, returns NO.  Implementation is in terms of the receiver\&'s 
.B
find: 
method.
.PP
.B
occurrencesOf:
.RS 1
- (unsigned)
.B
occurrencesOf:
.I
anObject
.RE
.PP

Returns 1 if 
.I
anObject 
is in the receiver, otherwise returns 0.  Implementation is in terms of the receiver\&'s 
.B
find: 
method.
.PP
.B
intersection:
.RS 1
-
.B
intersection:
.I
aSet
.RE
.PP

Returns a new set which is the intersection of the receiver and 
.I
aSet.  
The new set contains only those elements that were in both the receiver and 
.I
aSet.  
The argument 
.I
aSet 
need not be an actual 
.B
ObjSet 
instance, as long as it implements 
.B
find: 
as sets do.
.PP
.B
union:
.RS 1
-
.B
union:
.I
aSet
.RE
.PP

Returns a new set which is the union of the receiver and 
.I
aSet.  
The new set returned has all the elements from both the receiver and 
.I
aSet.  
The argument 
.I
aSet 
need not be an actual 
.B
ObjSet 
instance, as long as it implements 
.B
eachElement: 
as sets do.
.PP
.B
difference:
.RS 1
-
.B
difference:
.I
aSet
.RE
.PP

Returns a new set which is the difference of the receiver and 
.I
aSet.  
The new set returned has only those elements in the receiver that are not in 
.I
aSet.
.PP
.B
printToFile:
.RS 1
-
.B
printToFile:
(FILE *)
.I
aFile
.RE
.PP

Prints a list of the objects in the set by sending each individual object a 
.B
printToFile: 
message.  Returns the receiver.
.PP
.B
write:
.RS 1
-
.B
write:
(NXTypedStream *)
.I
stream
.RE
.PP

Writes the set and all its elements to the typed stream 
.I
stream.  
Returns the receiver.
.PP
.B
read:
.RS 1
-
.B
read:
(NXTypedStream *)
.I
stream
.RE
.PP

Reads the set and all its elements from the typed stream 
.I
stream.  
The implementation of 
.B
hash 
of an element may not change during unarchiving. Returns the receiver.
