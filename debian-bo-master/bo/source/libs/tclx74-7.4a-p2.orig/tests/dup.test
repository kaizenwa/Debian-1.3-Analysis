#
# dup.test
#
# Tests for the dup command.
#---------------------------------------------------------------------------
# Copyright 1992-1995 Karl Lehenbauer and Mark Diekhans.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies.  Karl Lehenbauer and
# Mark Diekhans make no representations about the suitability of this
# software for any purpose.  It is provided "as is" without express or
# implied warranty.
#------------------------------------------------------------------------------
# $Id: dup.test,v 5.0 1995/07/25 05:40:56 markd Rel $
#------------------------------------------------------------------------------
#

if {[info procs test] != "test"} then {source testlib.tcl}


# Create a test file

unlink -nocomplain {DUP.TMP DUP2.TMP}

set testFH [open DUP.TMP w]
for {set cnt 0} {$cnt < 100} {incr cnt} {
     puts $testFH [GenRec $cnt]
}
close $testFH

Test dup-1.1 {dup tests} {
    set testFH [open DUP.TMP]
    set testFH2 [dup $testFH]
    gets $testFH2 testRec
    close $testFH
    close $testFH2
    set testRec
} 0 [GenRec 0]

Test dup-1.2 {dup tests} {
    set testFH [open DUP.TMP]
    set testFH2 [open DUP2.TMP w]
    set testFH2 [dup $testFH $testFH2]
    gets $testFH2 testRec
    close $testFH
    close $testFH2
    set testRec
} 0 [GenRec 0]

set data {{now is the time}    {for all good programmers} 
          {to come to the aid} {of their software}}
set inFH [open INCMDS.TMP w]
catch {unlink OUTPUT.TMP}
foreach line $data {
    puts $inFH "puts stdout \"$line\""
}
puts $inFH {flush stdout}
puts $inFH {exit 0}
close $inFH

flush stdout
flush stderr

if {[set childPid [fork]] == 0} {
    set inFH  [open INCMDS.TMP r]
    set outFH [open OUTPUT.TMP w]

    dup $inFH stdin
    close $inFH

    dup $outFH stdout
    close $outFH
        
    catch {
        execl $TCL_PROGRAM [list -qc {commandloop {} {}}]
    } msg
    puts stderr "execl failed: $msg"
    exit 1
}

Test dup-1.3 {dup tests} {
    wait $childPid
} 0 "$childPid EXIT 0"

set outFH [open OUTPUT.TMP r]
foreach line $data {
    Test dup-1.4 {dup tests} {
        gets $outFH
    } 0 $line
}
close $outFH

# Test binding of open files to ids.  Solaris opens pipes RDWR (I don't know
# why), so skip some tests if this is the case.

pipe fromChild toParent
pipe fromParent toChild

flush stdout
flush stderr

if {[set childPid [fork]] == 0} {
    catch {
        close $fromChild
        close $toChild
        set toParent [crange $toParent 4 end]
        set fromParent [crange $fromParent 4 end]
        set childProgram {}
        append childProgram "set toParent \[dup $toParent\]" \n
        append childProgram "set fromParent \[dup $fromParent\]" \n
        append childProgram {if ![fcntl $fromParent RDWR] } "{\n"
        append childProgram {    catch {puts $fromParent arf} msg} \n
        append childProgram {    puts $toParent "msg1: $msg"} \n
        append childProgram {    flush $toParent} \n
        append childProgram {    catch {gets $toParent} msg} \n
        append childProgram {    puts $toParent "msg2: $msg"} \n
        append childProgram {    flush $toParent} \n
        append childProgram "}\n"
        append childProgram {while {[gets $fromParent msg] >= 0} {
            puts $toParent "got: $msg"; flush $toParent}}
        execl $TCL_PROGRAM [list -qc $childProgram]
    } msg
    puts stderr "child failed: $msg"
    exit 1
}
close $toParent
close $fromParent

if ![fcntl $toChild RDWR] {

    Test dup-2.1 {dup tests} {
        set msg [gets $fromChild]
        if [regexp {^msg1: "file.*" wasn't opened for writing} $msg] {
            list OK
        } else {
            list $msg
        }
    } 0 {OK}

    Test dup-2.2 {dup tests} {
        set msg [gets $fromChild]
        if [regexp {^msg2: "file.*" wasn't opened for reading} $msg] {
            list OK
        } else {
            list $msg
        }
    } 0 {OK}
}

Test dup-2.2 {dup tests} {
    puts $toChild "test 2.2"
    flush $toChild
    gets $fromChild
} 0 {got: test 2.2}

Test dup-2.3 {dup tests} {
    puts $toChild "test 2.3"
    flush $toChild
    gets $fromChild
} 0 {got: test 2.3}

Test dup-2.4 {dup tests} {
    close $toChild
    close $fromChild
    wait $childPid
} 0 [list $childPid EXIT 0]

Test dup-2.5 {dup tests} {
   set stat [catch {dup 100}]
   list $stat [lrange $errorCode 0 1]
} 0 {1 {POSIX EBADF}}


unlink -nocomplain {DUP.TMP DUP2.TMP INCMDS.TMP OUTPUT.TMP}

