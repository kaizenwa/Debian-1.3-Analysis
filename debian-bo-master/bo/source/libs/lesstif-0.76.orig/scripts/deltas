#!/bin/sh
#
# create a patch file, based on deltas between two source trees.  The patch
# file is prepared for inclusion in a mail message, unless you use the
# -no-uuencode.  The script should be run in the directory above the source
# trees, or should use absolute paths to the different source trees.
# NOTE: this script will clean the source trees.  You have been warned.
# If you don't want to distclean the sourcetrees (which means that you don't
# want "configure" nuked), then set DISTCLEAN to 0.
#
# To summarize:
#   o by default, you will generate a gzipped, uuencoded patch between the
#     directories "lesstif" and "ltn"
#   o to skip the uuencode, use the "-no-uuencode" flag.
#   o if you want to dist-clean the trees, use the "-distclean" flag.  This
#     is mostly intended for developers.  If you have autoconf installed,
#     this flag shouldn't frighten you.  If you accidently set it, just run
#     'autoconf' and 'autoheader' in the root of the source tree to regenerate
#     the 'configure' file.  This is useful for developers that change the
#     'configure.in' script.
#
# Users will probably want to use the default settings.
#
ENCODE=1
ORIGDIR="lesstif"
NEWDIR="ltn"
DISTCLEAN=0
ARGSLEFT=1

#
# trap some common signals
#
trap "rm -f patch.$$ patch.$$.gz; echo 'Caught signal.  Exiting." INT QUIT KILL

#
# parse the args
#
if [ $# -ne 0 ]
then
	while [ $ARGSLEFT -ne 0 ]
	do
		if [ "x$1" = "x-no-uuencode" ]
		then
			ENCODE=0
			shift
		else
			if [ "x$1" = "x-distclean" ]
			then
				DISTCLEAN=1
				shift
			else
				ARGSLEFT=0
			fi
		fi
	
	done
fi

#
# sort out the directory names
#
if [ $# -ge 1 ]
then
	ORIGDIR=$1
fi
if [ $# -eq 2 ]
then
	NEWDIR=$2
fi

#
# tell 'em what's happening
#
echo "$0: using the following setup:"
echo "  original source tree: $ORIGDIR"
echo "  changed source tree : $NEWDIR"
if [ $DISTCLEAN -ne 0 ]
then
	echo "  distclean -ing the trees"
else
	echo "  clean -ing the trees"
fi
echo "  gzipping the output"
if [ $ENCODE -ne 0 ]
then
	echo "  UUENCODEing the patch"
else
	echo "  NOT UUENCODEing the patch"
fi

#
# do the cleanup.
#
echo "Cleaning..."
CURDIR=`pwd`
if [ $DISTCLEAN ]
then
	if [ -f $ORIGDIR/Makefile ]
	then
		cd $ORIGDIR
		make distclean
		if [ $? -ne 0 ]
		then
			echo "ERROR: Distclean of $ORIGDIR failed."
			cd $CURDIR
			exit 10
		fi
		cd $CURDIR
	fi

	if [ -f $NEWDIR/Makefile ]
	then
		cd $NEWDIR
		make distclean
		if [ $? -ne 0 ]
		then
			echo "ERROR: Distclean of $NEWDIR failed."
			cd $CURDIR
			exit 10
		fi
		cd $CURDIR
	fi
else
	if [ -f $ORIGDIR/Makefile ]
	then
		cd $ORIGDIR
		make clean
		if [ $? -ne 0 ]
		then
			echo "ERROR: Clean of $ORIGDIR failed."
			cd $CURDIR
			exit 10
		fi
		cd $CURDIR
	fi

	if [ -f $NEWDIR/Makefile ]
	then
		if [ $? -ne 0 ]
		then
			echo "ERROR: Clean of $NEWDIR failed."
			cd $CURDIR
			exit 10
		fi
		cd $CURDIR
	fi
fi

#
# We require gnu diff, or a diff that can generate unified diffs.
# These diffs are extremely easy to read.
# We also require that you have gzip around.
#
echo "Creating unified diff patch..."
diff -u --recursive --new-file $ORIGDIR $NEWDIR > patch.$$
#
# it would be nice to do this, but GNU diff exits "1" after this.  Why?
#
#if [ $? -ne 0 ]
#then
#	echo "ERROR: diff (patch) generation failed."
#	rm -f patch.$$
#	exit 10
#fi

#
# prepare it for transport
#
if [ -f patch.$$ ]
then
	echo "Gzip' ing the patch..."

	gzip patch.$$
	if [ $? -ne 0 ]
	then
		"ERROR: gzip of patch.$$ failed."
		rm -f patch.$$ patch.$$.gz
		exit 10
	fi

	if [ $ENCODE -ne 0 ]
	then
		uuencode patch.$$.gz patch.diff.gz > patch.uu
		if [ $? -ne 0 ]
		then
			"ERROR: UUENCODE of patch failed."
			rm -f patch.$$ patch.$$.gz patch.uu
			exit 10
		fi
	fi
	echo "Done!"
else
	echo "Couldn't find the patch!"
	exit 10
fi
