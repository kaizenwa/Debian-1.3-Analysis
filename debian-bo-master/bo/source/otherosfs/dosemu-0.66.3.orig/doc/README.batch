
Running a DOS-application directly from Unix shell
==================================================

Method A:
---------

Make use of the keystroke configure option and the -I commandline option
of DOSEMU (>=dosemu-0.66.2) such as

   dos -D-a -I 'keystroke "dir > C:\\garbage\rexitemu\r"'

The "..." will be 'typed in' by dosemu exactly as if you had them
typed at the keyboard. The advantage of this technique is, that all
DOS applications will except them, even interactive ones. A '\' is
interpreted as in C and leads in ESC-codes. Here a list of of the
current implemented ones:

  \r     Carriage return == <ENTER>
  \n     LF
  \t     tab
  \b     backspace
  \f     formfeed
  \a     bell
  \v     vertical tab


  \^x    <Ctrl>x, where X is one of the usual C,M,L,[ ...
         (e.g.: \^[ == <Ctrl>[ == ESC )

  \Ax    <Alt>x, hence  \Ad means <Alt>d

  \Fn;   Function key Fn. Note that the trailing ';' is needed.
         (e.g.:  \F10;  == F10 )

  \Pn;   Set the virtual typematic rate, thats the speed for autotyping in.
         It is given in unix timer ticks to wait between two strokes.
         A value of 7 for example leads to a rate of 100/7=14 cps.

  \pn;   Before typing the next stroke wait n unix ticks.
         This is usefull, when the DOS-application fushes the keybord buffer
         on startup. Your strokes would be discared, if you don't wait.

When using X, the keystroke feature can be used to directly fire up a
DOS application with one click, if you have the right entry in your .fvwmrc





Method B:
--------


1. Make a file "FILE" containing all keystrokes you need to boot dosemu
   and to start your dos-application, ... and don't forget to have CRLF
   for 'ENTER'. FILE may look like this (as on my machine):

     2^M                    <== this chooses point 2 of the boot menu
     dir > C:\garbage^M     <== this executes 'dir', result to 'garbage'
     exitemu^M              <== this terminates dosemu

   (the ^M stands for CR)

2. execute dosemu on a spare (not used) console, maybe /dev/tty20
   such like this:

   # dos -D-a 2>/dev/null <FILE >/dev/tty20

   This will _not_ switch to /dev/tty20, but silently execute dosemu
   and you will get the '#' prompt back, when dosemu returns.

I tested this with dosemu-0.64.4/Linux-2.0.28 and it works fine.

When your dos-app does only normal printout (text), then you may
even do this

   # dos -D-a 2>/dev/null <FILE >FILE.out

FILE.out then contains the output from the dos-app, but merged with
ESC-sequences from Slang.

You may elaborate this technique by writing a script, which gets the
dos-command to execute from the commandline and generate 'FILE' for you.

When you try to use one of the above to start dosemu out of a crontab,
then you have to asure, that the process has a proper environement set up
( especially the TERM and/or TERMCAP variable ).

Hans
<lermen@fgan.de>
