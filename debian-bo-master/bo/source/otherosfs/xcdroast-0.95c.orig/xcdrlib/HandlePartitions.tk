# Module: HandlePartitions.tk
# 27.1.96 T.Niederreiter
#
# External called functions:
# - selectlockpartitions { w }: opens dialog to select partions to lock
#                           read and writes XCDR_LOCKPART
# - selectimagepartition { w }: select your image-partition
#
# - updateselimagetextbox { }: updates the image-part-textbox
# 
# - selectdatapartition { w }: select your master-source-partition
#
# - updateseldatatextbox { }: update the master-source-textbox
#
# - updateseldatatextbox2 { }: update the master-textbox
#
# - selectimagemntpnt { w }: select image-mountpoint
#
# - selectdatamntpnt { w } : select master-data-mountpoint
#
# - selectdatadir { w } : select master-data-directory
# 
# - CheckImagePartition { w }: Check status of image-partition 
#

# This procedure creates inside the main frame of the select-partition
# window a new frame for a harddrive and puts its partition as selectable
# buttons inside.
# Also pre-select all buttons, that correspond to the global variable
# XCDR_LOCKPART

proc makepartframe_lck { w blkdev i } {
global partinfo
global XCDR_LOCKPART

	# if variable XCDR_LOCKPART is not defined, define it, so
	# we don't get errors

	if { ![info exists XCDR_LOCKPART] } {
		set XCDR_LOCKPART [list {}]
	}

	set fixedfont "-*-fixed-medium-*-*--15-*-*-*-*-*-*-*"
	set blkname [convertblkdevicetoname $blkdev]
	set j $i

	tixLabelFrame $w.mid.$i -label $blkname
	pack $w.mid.$i -ipadx 5 -ipady 3	

	set f [$w.mid.$i subwidget frame]
	tixSelect $f.sel -allowzero true -radio false \
		-orientation vertical 
	pack $f.sel

	global sellockpart_$i
	set sellockpart_$i {}
	while { [string range $partinfo($j,0) 0 7] == $blkdev } {
		set tmpout [format "%-10s %5sMB \[%2s %-21s\]" $partinfo($j,0) $partinfo($j,1) $partinfo($j,2) $partinfo($j,3)]
		$f.sel add $j -text $tmpout -font $fixedfont

		# look if that partition is already in the XCDR_LOCKPART-list
		# if so, tag it as "selected"
		if { [lsearch $XCDR_LOCKPART [string trim $partinfo($j,0)]] != -1 } {
			set sellockpart_$i [eval concat \$sellockpart_$i $j]
		}
		incr j
	}
	$f.sel config -variable sellockpart_$i 
	pack $w.mid.$i
}

# Create a new window, prompting the user to select all partition
# he want's to lock. A locked partition cannot be accessed in the
# further program. This is preventing for an accidentially erasing
# of system-partitions.

proc selectlockpartitions { w } {
global partinfo

	frame $w.header
	label $w.header.text -text "Select partitions to lock" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header.text -fill x -expand 1 -ipady 10 -pady 5
	pack $w.header -fill x -expand 1 

	frame $w.mid
	pack $w.mid

	set i 0
	set olddev ""

	# Search the part-list for all harddrives. 
	while { $partinfo($i,0) != "x" } {
		set blkdev [string range $partinfo($i,0) 0 7]
		if { $blkdev != $olddev } {
			makepartframe_lck $w $blkdev $i
			set olddev $blkdev
		}
		incr i
	}

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "lockbox:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1
}

# Execucted by the OK-button
# Looks for global variables that contain information, how the buttons
# were pressed and calculates then a single list with that information

proc lockbox:ok_cmd { w } {
eval global [info globals sellockpart*]
global XCDR_LOCKPART
global partinfo

	set XCDR_LOCKPART {}
	set tmplist {}

	foreach i [info globals sellockpart*] {
		eval set varvalue \$$i
		lappend tmplist $varvalue
	}
	# we have now several lists with the number of the buttons
	# concat them to a single list
	set tmplist [eval concat $tmplist]
	set tmplist [eval concat $tmplist]

	foreach i $tmplist {
		set XCDR_LOCKPART [concat $XCDR_LOCKPART $partinfo($i,0)]
	}

	destroy $w 
}



# This procedure creates inside the main frame of the select-partition
# window a new frame for a harddrive and puts its partition as selectable
# buttons inside.
# Also disable all buttons, that correspond to the global variable
# XCDR_LOCKPART

proc makepartframe_sel { w blkdev i } {
global partinfo
global XCDR_LOCKPART

	# if variable XCDR_LOCKPART is not defined, define it, so
	# we don't get errors

	if { ![info exists XCDR_LOCKPART] } {
		set XCDR_LOCKPART [list {}]
	}

	set fixedfont "-*-fixed-medium-*-*--15-*-*-*-*-*-*-*"
	set blkname [convertblkdevicetoname $blkdev]
	set j $i

	tixLabelFrame $w.mid.$i -label $blkname
	pack $w.mid.$i -ipadx 5 -ipady 3	

	set f [$w.mid.$i subwidget frame]
	tixSelect $f.sel -allowzero true -radio true \
		-orientation vertical -command "resetselection" 
	pack $f.sel

	global selimgpart_$i
	set selimgpart_$i {}
	while { [string range $partinfo($j,0) 0 7] == $blkdev } {
		set tmpout [format "%-10s %5sMB \[%2s %-21s\]" $partinfo($j,0) $partinfo($j,1) $partinfo($j,2) $partinfo($j,3)]
		$f.sel add $j -text $tmpout -font $fixedfont

		# look if that partition is already in the XCDR_LOCKPART-list
		# if so, disable it 
		if { [lsearch $XCDR_LOCKPART [string trim $partinfo($j,0)]] != -1 } {
			set tmp [$f.sel subwidget $j]
			$tmp configure -state disabled 
		}
		incr j
	}
	$f.sel config -variable selimgpart_$i 
	pack $w.mid.$i
}

# Create a new window, prompting the user to select a partition
# that will be used as storage for image-files.

proc selectimagepartition { w } {
global partinfo
global XCDR_IMAGE_PART

	frame $w.header
	label $w.header.text -text "Select Image-Partition" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header.text -fill x -expand 1 -ipady 10 -pady 5
	pack $w.header -fill x -expand 1 

	frame $w.mid
	pack $w.mid

	set i 0
	set olddev ""

	# Search the part-list for all harddrives. 
	while { $partinfo($i,0) != "x" } {
		set blkdev [string range $partinfo($i,0) 0 7]
		if { $blkdev != $olddev } {
			makepartframe_sel $w $blkdev $i
			set olddev $blkdev
		}
		incr i
	}

	# Preselect the button that corresponds to XCDR_IMAGE_PART
	set j 0
 	while { $XCDR_IMAGE_PART != $partinfo($j,0) && $partinfo($j,0) != "x" } {
		incr j
	}

	if { $partinfo($j,0) != "x" } {
		# Partition valid, set button 
		# by simulating a mouseklick on it
		resetselection $j 1	
	}	

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "selbox:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1
}

# Execucted by the OK-button 

proc selbox:ok_cmd { w } {
eval global [info globals selimgpart*]
global partinfo
global XCDR_IMAGE_PART

	set tmplist {}
	set XCDR_IMAGE_PART "" 

	foreach i [info globals selimgpart*] {
		eval set varvalue \$$i
		lappend tmplist $varvalue
	}
	# we have now several lists with the number of the buttons
	# concat them to a single list
	# Do this twice due some list-incompatibilites in newer tcl/tk

	set tmplist [eval concat $tmplist]
	set tmplist [eval concat $tmplist]

	# there should be only one partition in the tmplist,
	# but too avoid errors, we always select the last element
	# in list.
	foreach i $tmplist {
		set XCDR_IMAGE_PART $partinfo($i,0)
	}

	#update select-image-partition-textbox
	updateselimagetextbox 

	destroy $w 
}

# This procedure allows that several selection-clusters work like
# one. Works only with "radio true", "allowzero true"-selections.
# Everytime the user presses a button in the selection, this 
# procedure is called with the ID of the button and if it was 
# selected of deselected.
# We then reset all selections (nothing selected) and force
# all selection-variables to that ID of the button pressed.
# One one selection this will work. 
# With the catch-command we prevent error-messages we would bet
# from all other selections.

proc resetselection { button sel } {
eval global [info globals selimgpart*]

	if { $sel == 1 } {
		foreach i [info globals selimgpart*] {
			set $i ""
			catch { set $i $button }
		}
	}
}

# Updates the Display in the Image-Partition-Textbox according
# to content of $XCDR_IMAGE_PART
# If the partition in XCDR_IMAGE_PART is not valid, then set it to none
# and delete any text in the textbox.

proc updateselimagetextbox {} {
global TMP_imgprt_id	;# name of image-partition-textbox
global partinfo
global XCDR_IMAGE_PART

	set blkname [convertblkdevicetoname [string range $XCDR_IMAGE_PART 0 7]]
	set j 0
 	while { $XCDR_IMAGE_PART != $partinfo($j,0) && $partinfo($j,0) != "x" } {
		incr j
	}

	if { $partinfo($j,0) == "x" } {
		# Partition not valid, set to none
		set XCDR_IMAGE_PART ""
		$TMP_imgprt_id configure -text ""
		return
	}
	
	set tmpout [format "%-10s %5sMB \[%-15s\]" $partinfo($j,0) \
		 $partinfo($j,1) [string range $partinfo($j,3) 0 14]]
	$TMP_imgprt_id configure -text "$blkname\n$tmpout"
}


# Create a new window, prompting the user to select a partition
# that will be used as read-devices for master-data.

proc selectdatapartition { w } {
global partinfo
global MSTR_DATA_PART

	frame $w.header
	label $w.header.text -text "Select Data-Partition" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header.text -fill x -expand 1 -ipady 10 -pady 5
	pack $w.header -fill x -expand 1 

	frame $w.mid
	pack $w.mid

	set i 0
	set olddev ""

	# Search the part-list for all harddrives. 
	while { $partinfo($i,0) != "x" } {
		set blkdev [string range $partinfo($i,0) 0 7]
		if { $blkdev != $olddev } {
			makepartframe_sel $w $blkdev $i
			set olddev $blkdev
		}
		incr i
	}

	# Preselect the button that corresponds to XCDR_IMAGE_PART
	set j 0
 	while { $MSTR_DATA_PART != $partinfo($j,0) && $partinfo($j,0) != "x" } {
		incr j
	}

	if { $partinfo($j,0) != "x" } {
		# Partition valid, set button 
		# by simulating a mouseklick on it
		resetselection $j 1	
	}	

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "selbox2:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1
}

# Execucted by the OK-button 

proc selbox2:ok_cmd { w } {
eval global [info globals selimgpart*]
global partinfo
global MSTR_DATA_PART

	set tmplist {}
	set MSTR_DATA_PART "" 

	foreach i [info globals selimgpart*] {
		eval set varvalue \$$i
		lappend tmplist $varvalue
	}
	# we have now several lists with the number of the buttons
	# concat them to a single list
	set tmplist [eval concat $tmplist]
	set tmplist [eval concat $tmplist]

	# there should be only one partition in the tmplist,
	# but too avoid errors, we always select the last element
	# in list.
	foreach i $tmplist {
		set MSTR_DATA_PART $partinfo($i,0)
	}

	#update select-image-partition-textbox
	updateseldatatextbox 

	destroy $w 
}


# The same as above, only for the master-source-setup-menu

proc updateseldatatextbox {} {
global TMP_imgprt_id	;# name of image-partition-textbox
global partinfo
global MSTR_DATA_PART
global MSTR_FROM

	set blkname [convertblkdevicetoname [string range $MSTR_DATA_PART 0 7]]
	set j 0
 	while { $MSTR_DATA_PART != $partinfo($j,0) && $partinfo($j,0) != "x" } {
		incr j
	}

	if { $partinfo($j,0) == "x" } {
		# Partition not valid, set to none
		set MSTR_DATA_PART ""
		$TMP_imgprt_id configure -text ""
		return
	}
	
	set tmpout [format "%-10s %5sMB \[%-15s\]" $partinfo($j,0) \
		 $partinfo($j,1) [string range $partinfo($j,3) 0 14]]
	$TMP_imgprt_id configure -text "$blkname\n$tmpout"

}


# The same as above, only for the master-menu, handles also the case
# of a premounted directory

proc updateseldatatextbox2 {} {
global TMP_imgprt_id	;# name of image-partition-textbox
global partinfo
global MSTR_DATA_PART
global MSTR_DATA_MNTPNT
global MSTR_DIR
global MSTR_FROM

	if { $MSTR_FROM == "prem" } {
		$TMP_imgprt_id configure -text "Premounted Directory"
	} else {

		set blkname [convertblkdevicetoname [string range $MSTR_DATA_PART 0 7]]
		set j 0
 		while { $MSTR_DATA_PART != $partinfo($j,0) && $partinfo($j,0) != "x" } {
			incr j
		}

		if { $partinfo($j,0) == "x" } {
			# Partition not valid, set to none
			set MSTR_DATA_PART ""
			$TMP_imgprt_id configure -text ""
		} else {
	
			set tmpout [format "%-10s %5sMB \[%-15s\]" $partinfo($j,0) \
				 $partinfo($j,1) [string range $partinfo($j,3) 0 14]]
			$TMP_imgprt_id configure -text "$blkname\n$tmpout\nMountpoint: $MSTR_DATA_MNTPNT"
		}
	}

   	# get the text from the messagebox and append the master-dir
        set tmptxt [$TMP_imgprt_id cget -text]
        append tmptxt "\nMaster-Directory: $MSTR_DIR"
        $TMP_imgprt_id configure -text $tmptxt
}

# Creates a window with a directory-listing. Prompts the user
# to select the Image-Mountpoint.

proc selectimagemntpnt { w } {

	label $w.header -text "Select Image-Mountpoint" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header -fill x -expand 1 -ipadx 10 -ipady 10 -pady 5

	tixDirTree $w.dir -directory "/"
	pack $w.dir -fill x -expand 1

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "mntpntbox:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1

}

# Called by OK-Button of selectimagemntpnt

proc mntpntbox:ok_cmd { w } {
global XCDR_IMAGE_MNTPNT

	set XCDR_IMAGE_MNTPNT [$w.dir cget -directory]
	destroy $w
}

# Creates a window with a directory-listing. Prompts the user
# to select the Data-Mountpoint.

proc selectdatamntpnt { w } {

	label $w.header -text "Select Data-Mountpoint" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header -fill x -expand 1 -ipadx 10 -ipady 10 -pady 5

	tixDirTree $w.dir -directory "/"
	pack $w.dir -fill x -expand 1

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "mntpntbox2:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1

}

# Called by OK-Button of selectdatamntpnt

proc mntpntbox2:ok_cmd { w } {
global MSTR_DATA_MNTPNT

	set MSTR_DATA_MNTPNT [$w.dir cget -directory]
	destroy $w
}


# Creates a window with a directory-listing. Prompts the user
# to select the Data-Directory.

proc selectdatadir { w } {

	label $w.header -text "Select Data-Directory" -relief sunken \
		-borderwidth 2 -anchor c
	pack $w.header -fill x -expand 1 -ipadx 10 -ipady 10 -pady 5

	tixDirTree $w.dir -directory "/"
	pack $w.dir -fill x -expand 1

	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "mntpntbox3:ok_cmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1

}

# Called by OK-Button of selectdatadir

proc mntpntbox3:ok_cmd { w } {
global MSTR_DIR

	set MSTR_DIR [$w.dir cget -directory]
	destroy $w
}


# File-Selector-Box for prompting the user to enter a filename
# for the logfile.

proc selectlogfilename { w } {
global efdlg_filename

	if { ![info exists efdlg_filename] } {
		set efdlg_filename ""
	}

	label $w.header -text "Select Log-Filename" -relief sunken \
		-borderwidth 2 -anchor c -width 40 
	pack $w.header -fill x -expand 1 -ipadx 10 -ipady 10 -pady 5

	tixFileSelectBox $w.dlg -browsecmd efdlg:select_file \
		-command efdlg:select_file \
		-pattern {*.log} 
	pack $w.dlg -fill x -expand 1


	tixButtonBox $w.box -orientation horizontal
	$w.box add ok -text "OK" -width 5 -command "efdlg:okcmd $w"
	$w.box add cancel -text "Cancel" -width 5 -command "destroy $w"
	pack $w.box -fill x -expand 1

}

# Update the global variable storing the actual selection everytime
# the user clicks on a filename in the box

proc efdlg:select_file { file } {
global efdlg_filename

	set efdlg_filename $file

}

# Called by OK-Button from File-Selector-Box

proc efdlg:okcmd { w } {
global XCDR_LOGNAME
global efdlg_filename

	set XCDR_LOGNAME $efdlg_filename
	destroy $w
}

# Checks the status of the Image-Partition and mount/umount it.
# Returns: 0 = Unknown Partition, not mounted
#          1 = ISO9660-Image on Partition, not mounted
#          2 = Ext2-Partition, mounted on mountpoint

proc CheckImagePartition { w } {
global XCDR_IMAGE_MNTPNT
global XCDR_IMAGE_PART
global partinfo
global TMP_imgprt_id

	set i 0
	set mntpnt [ getmountpnt $XCDR_IMAGE_PART ] 

        # check if the image-device is mounted on the right dir
        set actmntdev [checkmountpnt $XCDR_IMAGE_MNTPNT]
        if { $actmntdev != $XCDR_IMAGE_PART && $actmntdev != "" } {
 
                # try to umount that dir
                set mstat [doumount $actmntdev]
		if { $mstat == 0 } {
			# umount failed?
                	puts "Unrecoverable Error: On the Image-Mountdirectory $XCDR_IMAGE_MNTPNT "
                	puts "   is $actmntdev mounted instead of $XCDR_IMAGE_PART"
			puts "-> Failed to umount $actmntdev"
			exit
		}
        }

	# Partition is mounted
	if { $mntpnt != "" } {
		# Mounted on right mountpoint ?
		if { $mntpnt != $XCDR_IMAGE_MNTPNT } {
			set stat [Msg_ImgPartWrongMnt .wrngmnt $w] 
			if { $stat == 0 } { 	;# Use mountpnt
				set XCDR_IMAGE_MNTPNT $mntpnt
				# Update Image-Display
				set w1 [$w.devs subwidget frame]
				set TMP_imgprt_id $w1.2.imgt
				updateselimagetextbox				
        			# get the text from the messagebox and append the mountpoint
        			set tmptxt [$w1.2.imgt cget -text]
        			append tmptxt "\nMountpoint: $XCDR_IMAGE_MNTPNT"
        			$w1.2.imgt configure -text $tmptxt
			} else {
				exit
			}
		}

		# Check if mounted-partition is ISO9660
		if { [isiso $XCDR_IMAGE_PART] } {
			Msg_MountedISO .mntiso $w
			if { [doumount $XCDR_IMAGE_PART] } {
				Msg_Umounted .umntok $w $XCDR_IMAGE_PART
			} else {
				Msg_FatalUmntFail .umntnok $w
				exit
			}
			return 1
		} else {
		# Not ISO9660 -> Then its most likely ext2
		#	puts "Found mounted FS on /..."
			return 2
		}
	} else {
	# Not Mounted
		if { [isiso $XCDR_IMAGE_PART] } {
			# puts "Partition contains an ISO9660-Image"
			return 1
		} else {
			# Try to mount partition 
			if { [domount $XCDR_IMAGE_PART $XCDR_IMAGE_MNTPNT] } {
				Msg_Mounted .mntd $w $XCDR_IMAGE_PART $XCDR_IMAGE_MNTPNT
				return 2
			} else {
				# Type is unknown
			#	puts "mount failed"
				return 0
			}
		}
	}	 
	return 0	;# Should never be reached
}

