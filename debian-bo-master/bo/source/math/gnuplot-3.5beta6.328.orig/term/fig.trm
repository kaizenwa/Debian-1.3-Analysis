/*
 * $Id: fig.trm,v 1.51 1996/12/19 19:13:37 drd Exp $
 */

/* GNUPLOT - fig.trm */
/*
 * Copyright (C) 1990, 1991, 1992, 1993, 1996
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the modified code.  Modifications are to be distributed
 * as patches to released version.
 *
 * This software  is provided "as is" without express or implied warranty.
 *
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *  Fig graphics language
 *
 * AUTHORS
 *  Micah Beck, David Kotz
 *
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 *
 */

/*
 * Original for Fig code output by Micah Beck, 1989
 * Department of Computer Science, Cornell University
 * Updated by David Kotz for gnuplot 2.0
 * More efficient output by Ian Dall
 * Updated to FIG 2.1 (with color) format by Vivek Khera
 * Updated to FIG 3.1 (higher resolution) format by Ian MacPhedran, Jan 1995
 * Updated to conform to newterm format Ian MacPhedran, Apr 1995
 * Point-count option joachim.selinger@ins.uni-stuttgart.de Feb  9 1996
 * More options (portrait/landscape, metric/inches, size, fontsize, thickness)
 * plus symbols and depth/thickness by bernlohr@eu1.mpi-hd.mpg.de Aug 15 1996
 */

#ifndef GOT_DRIVER_H
#include "driver.h"
#endif /* GOT_DRIVER_H */

#ifdef TERM_REGISTER
register_term(fig)
#endif /* TERM_REGISTER */

#ifdef TERM_PROTO
TERM_PUBLIC void FIG_options __PROTO((void));
TERM_PUBLIC void FIG_init __PROTO((void));
TERM_PUBLIC void FIG_graphics __PROTO((void));
TERM_PUBLIC void FIG_text __PROTO((void));
TERM_PUBLIC void FIG_linetype __PROTO((int linetype));
TERM_PUBLIC void FIG_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void FIG_vector __PROTO((unsigned int ux, unsigned int uy));
TERM_PUBLIC void FIG_arrow __PROTO((unsigned int sx, unsigned int sy, unsigned int ex, unsigned int ey, TBOOLEAN head));
TERM_PUBLIC void FIG_put_text __PROTO((unsigned int x, unsigned int y, char *str));
TERM_PUBLIC int FIG_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC int FIG_text_angle __PROTO((int angle));
TERM_PUBLIC void FIG_reset __PROTO((void));
TERM_PUBLIC void FIG_lpoint __PROTO((unsigned int x, unsigned int y, int number));

#define GOT_FIG_PROTO
#endif /* TERM_PROTO */

#ifndef TERM_PROTO_ONLY
#ifdef TERM_BODY

#include "object.h"             /* modified from the XFig distribution */
#define FIG_DEFAULT DEFAULT
#define FIG_ROMAN_FONT (0)	/* actually, the default font */
 
#ifndef FIG_RES
/* This is now 1200 per inch */
#define FIG_RES         (1200)
#endif
 
#define FIG_COORD_SYS   2
#define FIG_ORIENT (FIG_portrait?"Portrait":"Landscape")
/* Could be "Portrait" */
#define FIG_JUST "Center"
/* Could be "Flush Left" */
#define FIG_UNIT (FIG_inches?"Inches":"Metric")
/* Could be "Inches" */
 
#define FIG_MAGIC       "#FIG 3.1"
#define FIG_HTIC        (5*FIG_RES/80)
#define FIG_VTIC        (5*FIG_RES/80)
#define FIG_FONT_S      (10)	/* size in points */
#define FIG_MAX_POINTS  99999L /* almost infinite ;-) */

#define FIG_to_pixel_v(s) ((s)*FIG_RES/72*3/4) /* height of font in pixels */
/* This is fudged to enlarge the drawing area, but gives fairly good results */
#define FIG_to_pixel_h(s) (FIG_to_pixel_v(s)*6/10) /* this is a guess at the width */

#define FIG_VCHAR       FIG_to_pixel_v(FIG_FONT_S) /* just for default, */
#define FIG_HCHAR       FIG_to_pixel_h(FIG_FONT_S) /* not really used   */

enum FIG_poly_stat {FIG_poly_new, FIG_poly_part};
 
static int FIG_posx;
static int FIG_posy;
static long FIG_poly_vec_cnt;
static int FIG_depth = 10;
static int FIG_linedepth = 10;
static int FIG_thickness = 1;
static int FIG_default_thickness = 1;

/* Maximum number of points per POLYLINE. 
   Default 1000 (hardcoded in help section as well) */
static int FIG_poly_vec_max = 999; /* JFS */

static enum FIG_poly_stat FIG_polyvec_stat;

/* 5 inches wide by 3 inches high */
#define FIG_XMAX (5 * FIG_RES)
#define FIG_YMAX (3 * FIG_RES)
 
#define FIG_XOFF (FIG_RES/4)
#define FIG_YOFF (FIG_RES/4)


#define BFIG_HTIC       (7*FIG_RES/80)
#define BFIG_VTIC       (7*FIG_RES/80)
#define BFIG_FONT_S     (16)	/* size in points */
#define BFIG_VCHAR      FIG_to_pixel_v(BFIG_FONT_S) /* height in pixels of font */
#define BFIG_HCHAR      FIG_to_pixel_h(BFIG_FONT_S) /* this is a guess at the width */

static  F_point *FIG_points = NULL; /* Array for the collection of points for 
				       POLYLINE, allocated on demand. */
static	F_line	FIG_line;
 
/* 8 inches wide by 5 inches high */
#define BFIG_XMAX (8 * FIG_RES)
#define BFIG_YMAX (5 * FIG_RES)
 
#define BFIG_XOFF (FIG_RES/2)
#define BFIG_YOFF (FIG_RES/2)
 

static int FIG_type;            /* negative types use real lines */
static float FIG_spacing;       /* length of dash or dot spacing */
static int FIG_justify;         /* Fig justification T_*_JUSTIFIED */
static float FIG_angle;         /* Fig text angle 0=horiz, Pi/2=vert */
static int FIG_use_color = FALSE;	/* do we use color or not? */
static int FIG_is_big = FALSE;	/* big plot ? */
static int FIG_color = DEFAULT;	/* which color to use */
static int FIG_xoff = FIG_XOFF;
static int FIG_yoff = FIG_YOFF;
static int FIG_font_s = FIG_FONT_S;
static int FIG_portrait = FALSE;
static int FIG_inches = FALSE; 

static void FIG_poly_clean __PROTO((enum FIG_poly_stat stat));


#define FIG_POINT_TYPES POINT_TYPES /* we use the same points */

 
static void
  FIG_poly_clean(stat)
enum FIG_poly_stat stat;
{
  int i,j;
  if(stat == FIG_poly_part) {
	fprintf(outfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %ld\n\t",
	 O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
	 FIG_line.pen_color, FIG_line.fill_color, FIG_line.depth,
	 FIG_line.pen_style, FIG_line.fill_style, FIG_line.style_val,
	 FIG_line.join_style, FIG_line.cap_style, FIG_line.radius,
	 0, 0, FIG_poly_vec_cnt);

	j = 0;
	for(i=0;i<FIG_poly_vec_cnt;i++)
	{
	  fprintf(outfile," %d %d",FIG_points[i].x,FIG_points[i].y);
	  if (j++ > 4) { fprintf(outfile,"\n\t"); j = 0;} /* JFS */
	}
	if (j != 0) {fprintf(outfile,"\n");}
	/* Give the memory back to the system because we are done with this 
	 * polyline. Make sure FIG_points contains NULL afterwards!
	 */
	free(FIG_points);
	FIG_points = NULL;
  }
  FIG_polyvec_stat = FIG_poly_new;
}
 
TERM_PUBLIC void FIG_options()
{
   static char *options_list = /* sun cc does not concat strings */
"expecting monochrome, color, small, big, portrait, landscape,\n\
 \t inches, metric, size <number> <number>,  fontsize <number>,\n\
 \t thickness <numer>, depth <number> or pointsmax <number>";

   int parse_error=FALSE;
   long temp_max;
   struct value a;
   unsigned int tmax;
   double xsize, ysize;

   FIG_use_color = FALSE;	/* default */
   FIG_is_big = FALSE;	/* default */
   FIG_portrait = FALSE;
   FIG_font_s = 0;
   FIG_default_thickness = 1;
   xsize = ysize = 0.;
#if METRIC
   FIG_inches = FALSE;
#else
   FIG_inches = TRUE;
#endif
   while (!END_OF_COMMAND) {
      if (almost_equals(c_token,"mo$nochrome")) {
         FIG_use_color=FALSE;
	 c_token++;
      }
      else if (almost_equals(c_token,"c$olor")) {
         FIG_use_color=TRUE;
	 c_token++;
      }
      else if (almost_equals(c_token,"sm$all")) {
	 FIG_is_big=FALSE;
	 c_token++;
      }
      else if (almost_equals(c_token,"b$ig")) {
	 FIG_is_big=TRUE;
	 c_token++;
      }
      else if (almost_equals(c_token,"in$ches")) { /* KB */
	 FIG_inches=TRUE;
	 c_token++;
      }
      else if (almost_equals(c_token,"me$tric")) { /* KB */
	 FIG_inches=FALSE;
	 c_token++;
      }
      else if (almost_equals(c_token,"por$trait")) { /* KB */
         /* KB: Would have preferred "p$ortrait" but that would */
         /*     collide with "p$ointsmax" below. */
         FIG_portrait = TRUE;
	 c_token++;
      }
      else if (almost_equals(c_token,"l$andscape")) { /* KB */
         FIG_portrait = FALSE;
	 c_token++;
      }
      else if (almost_equals(c_token,"si$ze")) { /* KB */
	 c_token++;
	 if (END_OF_COMMAND) {
	    int_error("size: 2 numbers expected",c_token);
         }  else {
            xsize = real(const_express(&a));
	    if (END_OF_COMMAND) {
	       int_error("size: 2 numbers expected",c_token);
	       xsize = 0.;
            }  else {
               ysize = real(const_express(&a));
            }
            if ( xsize < 2. || ysize < 2. || xsize > 99. || ysize > 99. ) {
               if ( xsize != 0. || ysize != 0. )
                  int_error("size: out of range",c_token);
               xsize = ysize = 0.;
            }
         }
      }
      else if (almost_equals(c_token,"f$ontsize")) { /* KB */
	 c_token++;
	 if (END_OF_COMMAND) {
	    int_error("fontsize: number expected",c_token);
         }  else {
	    FIG_font_s = (int)real(const_express(&a));
	    if ( FIG_font_s < 5 || FIG_font_s > 36 ) {
	       int_error("fontsize out of range",c_token-1);
	       FIG_font_s = 0;
	    }
         }
      }
      else if (almost_equals(c_token,"t$hickness")) { /* KB */
	 c_token++;
	 if (END_OF_COMMAND)  {
	    int_error("thickness: number expected",c_token);
         }  else {
	    FIG_default_thickness = (int)real(const_express(&a));
	    if ( FIG_default_thickness < 1 || FIG_default_thickness > 10 )
	    {
	       int_error("thickness out of range",c_token-1);
	       FIG_default_thickness = 1;
	    }
         }
      }
      else if (almost_equals(c_token,"d$epth")) { /* KB */
	 c_token++;
	 if (END_OF_COMMAND) {
	    int_error("depth: number expected",c_token);
         }  else {
	    FIG_depth = (int)real(const_express(&a));
	    if ( FIG_depth < 0 || FIG_depth > 99 )
	    {
	       int_error("depth out of range",c_token-1);
	       FIG_depth = 10;
	    }
	    FIG_linedepth = FIG_depth;
         }
      }
      else if (almost_equals(c_token,"poi$ntsmax")) { /* JFS */
	 /* Skip the word and then expect the number ! */
	 c_token++;
	 if (END_OF_COMMAND) {
	    int_error("max. points per polyline: number expected",c_token);
         }  else {
	    temp_max = (long)real(const_express(&a));
	    /* Now check the range for the number */
	    if ( (temp_max > 1) && ( temp_max < (FIG_MAX_POINTS+ 2)) ) {
	       /* OK. subtract one to the right number! See other numbers... */
	       FIG_poly_vec_max = temp_max- 1;
	    } else {
	       char t[128];

	       sprintf( t, "pointsmax: number out of range (2,%ld)", 
		  (FIG_MAX_POINTS+ 1));
	       int_error( t, c_token);
	    }
	 }
      }
      else {
	 parse_error=TRUE;
	 int_error(options_list,c_token);
      }
   }

   sprintf(term_options,"%s %s %s %d %s %s %s %d %s %d %s %d",
	FIG_use_color ? "color" : "monochrome",
	FIG_is_big ? "big" : "small",
	"pointsmax",
	FIG_poly_vec_max+ 1,
	FIG_portrait ? "portrait" : "landscape",
	FIG_inches ? "inches" : "metric",
	"fontsize", (FIG_font_s>0 ? FIG_font_s : 
	    (FIG_is_big?BFIG_FONT_S:FIG_FONT_S)),
	"thickness", FIG_default_thickness, "depth", FIG_depth); /* JFS, KB */
   if ( xsize > 0. && ysize > 0. ) {
      if ( xsize-(int)xsize==0. && ysize-(int)ysize==0. )
         sprintf(term_options+strlen(term_options),
           " size %d %d",(int)xsize,(int)ysize);
      else
         sprintf(term_options+strlen(term_options),
           " size %f %f",xsize,ysize);
   }

   if(!FIG_is_big) {
      if ( FIG_font_s == 0 ) /* KB */
         FIG_font_s = FIG_FONT_S;
      term->xmax  = FIG_XMAX;
      term->ymax  = FIG_YMAX;
      term->v_tic = FIG_VTIC;
      term->h_tic = FIG_HTIC;
      FIG_xoff    = FIG_XOFF;
      FIG_yoff    = FIG_YOFF;
   } else {
      if ( FIG_font_s == 0 ) /* KB */
         FIG_font_s = BFIG_FONT_S;
      term->xmax  = BFIG_XMAX;
      term->ymax  = BFIG_YMAX;
      term->v_tic = BFIG_VTIC;
      term->h_tic = BFIG_HTIC;
      FIG_xoff    = BFIG_XOFF;
      FIG_yoff    = BFIG_YOFF;
   }
   if ( FIG_portrait ) { /* KB */
      tmax = term->xmax;
      term->xmax = term->ymax;
      term->ymax = tmax;
   }
   if ( xsize > 0. && ysize > 0. ) {
      if ( FIG_inches ) {
         term->xmax = (unsigned int) (xsize * FIG_RES);
         term->ymax = (unsigned int) (ysize * FIG_RES);
      } else {
         term->xmax = (unsigned int) (xsize/2.54 * FIG_RES);
         term->ymax = (unsigned int) (ysize/2.54 * FIG_RES);
      }
   }
   term->v_char = FIG_to_pixel_v(FIG_font_s);
   term->h_char = FIG_to_pixel_h(FIG_font_s);
   FIG_thickness = FIG_default_thickness;
   if(parse_error) { /* JFS, KB */
      int_error(options_list,c_token);
   }
}

TERM_PUBLIC void FIG_init()
{
    FIG_posx = FIG_posy = 0;
    FIG_polyvec_stat = FIG_poly_new;
    FIG_linetype(-1);
    FIG_justify_text(LEFT);
    FIG_text_angle(0);

    FIG_line.tagged = FIG_DEFAULT;
    FIG_line.distrib = FIG_DEFAULT;
    FIG_line.type = T_POLYLINE;
    FIG_line.style = 0;
    FIG_line.thickness = FIG_thickness;
    FIG_line.fill_style = -1;
    FIG_line.depth = FIG_linedepth;
    FIG_line.pen_style =  0;
    FIG_line.for_arrow = NULL;
    FIG_line.back_arrow = NULL;
    FIG_line.cap_style = 0;
    FIG_line.join_style = 0;
    FIG_line.style_val = 0.0;
    FIG_line.radius = 0;
    FIG_line.pic = NULL;
    FIG_line.next = NULL;

    fprintf(outfile, "%s\n", FIG_MAGIC);
    fprintf(outfile, "%s\n%s\n%s\n%d %d\n", FIG_ORIENT, FIG_JUST,
	FIG_UNIT, FIG_RES, FIG_COORD_SYS);
}
 
 
TERM_PUBLIC void FIG_graphics()
{
    FIG_posx = FIG_posy = 0;
    FIG_polyvec_stat = FIG_poly_new;
    /* there is no way to have separate pictures in a FIG file */
}
 
 
TERM_PUBLIC void FIG_text()
{
    /* there is no way to have separate pictures in a FIG file */
    FIG_poly_clean(FIG_polyvec_stat);
    FIG_posx = FIG_posy = 0;
    fflush(outfile);
}
 
 
/* Line types for FIG work like this:
 *  for monochrome:
 *  -2 : solid (border)
 *  -1 : dotted 4 (axes)
 *   0 : solid (first curve)
 *   1 : dotted 3
 *   2 : dashed 3
 *   3 : dotted 6
 *   4 : dashed 6
 *   ... ...
 *  for color, cycle through colors. once colors are used up, repeat colors
 *   but start using dashed lines of different dash length. don't use white
 *   as a color.
 */
 
TERM_PUBLIC void FIG_linetype(linetype)
        int linetype;                   /* expect linetype >= -2 */
{
    int last_FIG_type = FIG_type;
    int last_FIG_spacing = FIG_spacing;
    int last_FIG_color = FIG_color;
    int last_FIG_depth = FIG_linedepth;
    int last_FIG_thickness = FIG_thickness;
    
    FIG_linedepth = FIG_depth;
    FIG_thickness = FIG_default_thickness;
    FIG_color = DEFAULT;
    
    if ( linetype < -2 )
       linetype = -2;

    switch (linetype) {
           case 0:
           case -2: {
                  FIG_type = SOLID_LINE;
                  FIG_spacing = 0.0;
		  if (FIG_use_color) FIG_color = BLACK;
                  break;
           }
           case -1: {
                  FIG_type = DOTTED_LINE;
                  FIG_spacing = 4.0; /* gap */
		  if (FIG_use_color) FIG_color = BLACK;
                  break;
           }
           default: {
                /* now linetype >= 1 */ /* shouldn't be negative anyway */
      	        FIG_linedepth = FIG_depth + linetype/1000;
      	        linetype %= 1000;
      	        if ( (FIG_thickness = linetype / 100) == 0 )
      	           FIG_thickness = FIG_default_thickness;
      	        linetype %= 100;
 		if (FIG_use_color) {
		  FIG_type = (linetype >= WHITE);	/* dashed line */
		  FIG_color = linetype % WHITE;
		  FIG_spacing = (linetype / WHITE) * 3;
		} else { /* monochrome */
                  FIG_type = linetype % 2 + 1; /* dotted, dashed, ... */
                  FIG_spacing = (linetype+1) / 2 * 3;
		}
                  break;
           }
    }
    if (FIG_type != last_FIG_type || FIG_spacing != last_FIG_spacing ||
        FIG_color != last_FIG_color || FIG_linedepth != last_FIG_depth ||
        FIG_thickness != last_FIG_thickness)
      FIG_poly_clean(FIG_polyvec_stat);
}
 
TERM_PUBLIC void FIG_move(x,y)
        unsigned int x,y;
{
    int last_FIG_posx = FIG_posx;
    int last_FIG_posy = FIG_posy;
    FIG_posx = x;
    FIG_posy = y;
    if (FIG_posx != last_FIG_posx || FIG_posy != last_FIG_posy)
          FIG_poly_clean(FIG_polyvec_stat);
}
 
 
TERM_PUBLIC void FIG_vector(ux,uy)
     unsigned int ux,uy;
{
  int x=ux, y=uy;
 
  if (FIG_polyvec_stat != FIG_poly_part) {
	FIG_line.pen_color = FIG_color;
	FIG_line.fill_color = FIG_color;
	FIG_line.style = FIG_type;
	FIG_line.style_val = FIG_spacing;
	FIG_line.depth = FIG_linedepth;
	FIG_line.thickness = FIG_thickness;
	FIG_poly_vec_cnt = 0;
	/* allocate memory for the first point */
	FIG_points = ( F_point *) ralloc( FIG_points, sizeof( F_point), "FIG_points"); /* JFS */
	FIG_points[FIG_poly_vec_cnt].x=FIG_xoff + FIG_posx;
	FIG_points[FIG_poly_vec_cnt].y=term->ymax
	 + FIG_yoff - FIG_posy;

        FIG_poly_vec_cnt = 1;
        FIG_polyvec_stat = FIG_poly_part;
    }
  /* allocate memory for the next point */
  FIG_points = ( F_point *) ralloc( FIG_points, (FIG_poly_vec_cnt+ 1)* 
	sizeof( F_point), "FIG_points"); /* JFS */
  FIG_points[FIG_poly_vec_cnt].x = FIG_xoff +  x;
  FIG_points[FIG_poly_vec_cnt].y = term->ymax + FIG_yoff - y;

  FIG_poly_vec_cnt++;
  if (FIG_poly_vec_cnt > FIG_poly_vec_max)
    FIG_poly_clean(FIG_polyvec_stat);
 
  FIG_posx = x;
  FIG_posy = y;
}
 
 
TERM_PUBLIC void FIG_arrow(sx, sy, ex, ey, head)
        unsigned int sx, sy;     /* start coord */
        unsigned int ex, ey;     /* end coord */
	TBOOLEAN head;
{
	FIG_poly_clean(FIG_polyvec_stat);
        fprintf(outfile, "%d %d %d %d %d %d %d %d %d %9.3f %d %d %d %d %d %d\n",
         O_POLYLINE, FIG_line.type, FIG_line.style, FIG_line.thickness,
         FIG_line.pen_color, FIG_line.fill_color, FIG_line.depth,
         FIG_line.pen_style, FIG_line.fill_style, FIG_line.style_val,
         FIG_line.join_style, FIG_line.cap_style, FIG_line.radius,
         head ? 1 : 0, 0, 2);

        /* arrow line */
	if ( head )
	        fprintf(outfile, "%d %d %.3f %.3f %.3f\n",
        	        0, 0, 1.0,
			(double)(term->h_tic/2 + 1),
			(double)term->h_tic        );
        fprintf(outfile, "%d %d %d %d\n",
                FIG_xoff + sx, FIG_yoff + term->ymax - sy,
		FIG_yoff + ex, FIG_yoff + term->ymax - ey);
 
        FIG_posx = ex;
        FIG_posy = ey;
}
 
 
TERM_PUBLIC void FIG_put_text(x, y, str)
        unsigned int x, y;
        char *str;
{
  if (strlen(str) == 0) return;
  FIG_poly_clean(FIG_polyvec_stat);
  y -= term->v_char/2;	/* assuming vertical center justified */
 
    fprintf(outfile, "%d %d %d %d %d %d %6.3f %6.3f %d %6.3f %6.3f %d %d %s\\001\n",
                  O_TEXT, FIG_justify, FIG_color, 0, FIG_DEFAULT,
                  FIG_ROMAN_FONT, (float)FIG_font_s,
		  FIG_angle, SPECIAL_TEXT, (float)term->v_char,
		  (float)term->h_char*strlen(str),
		  FIG_xoff + x, term->ymax + FIG_yoff-y, str);
}
 
TERM_PUBLIC int FIG_justify_text(mode)
        enum JUSTIFY mode;
{
    switch(mode) {
           case LEFT: FIG_justify = T_LEFT_JUSTIFIED; break;
           case CENTRE: FIG_justify = T_CENTER_JUSTIFIED; break;
           case RIGHT: FIG_justify = T_RIGHT_JUSTIFIED; break;
           /* shouldn't happen */
           default: FIG_justify = T_LEFT_JUSTIFIED; return (FALSE); break;
    }
    return (TRUE);
}
 
TERM_PUBLIC int FIG_text_angle(angle)
        int angle;
{
    if (angle)
         FIG_angle = Pi / 2.0;  /* vertical is pi/2 radians */
    else
         FIG_angle = 0.0;               /* horizontal */
    return (TRUE);
}

TERM_PUBLIC void FIG_lpoint(x,y,number)
unsigned int x,y;
int number;
{
    FIG_type = 0; /* Solid lines for marker outline */
    if ( number%100 >= 49 && number%100 < 99 ) { /* circles, squares, triangles */
       int r, d, h, xpc, ypc;
       int line_color, fill_color, fill_style;
       int cnum, tnum, color, depth;

       FIG_poly_clean(FIG_polyvec_stat);
       depth = FIG_linedepth - 1; /* Above error bars */
       if ( number > 1000 )
          depth = FIG_depth + number/1000 - 1;
       number %= 1000;
       if ( depth < 0 )
          depth = 0;
       if ( number < 100 )
          color = FIG_color;
       else if ( FIG_use_color )
          color = number/100 - 1;
       else if ( number/100 >= WHITE )
          color = WHITE;
       else
          color = DEFAULT;
       number %= 100;
       cnum = (number+1) % 10;
       tnum = (number-49) / 10;
       if ( cnum < 5 )
          line_color = (FIG_use_color ? BLACK : DEFAULT);
       else
          line_color = FIG_color;
       fill_color = color;
       if ( cnum == 0 || cnum == 5 )
          fill_style = -1;
       else
          fill_style = (cnum%5)*5;
          
       xpc = FIG_xoff + x;
       ypc = term->ymax + FIG_yoff - y;
       
       if ( tnum == 0 ) { /* circle */
    	   r = term->v_char/4 + 1;
    	   fprintf(outfile,
    	     "1 3 %d %d %d %d %d %d %d %6.3f 1 0.000 %d %d %d %d %d %d %d %d\n",
    	     FIG_type, FIG_thickness, line_color,
    	     fill_color, depth, 0, fill_style, FIG_spacing,
    	     xpc, ypc, r, r, xpc, ypc, xpc, ypc-r);
       } else {
          fprintf(outfile,"2 3 %d %d %d %d %d %d %d %6.3f 0 0 0 0 0 ",
    	     FIG_type, FIG_thickness, line_color,
    	     fill_color, depth, 0, fill_style, FIG_spacing);
           
          if ( tnum == 1 ) { /* square */
             d = term->v_char/4 + 1;
    	     fprintf(outfile,"5\n\t%d %d %d %d %d %d %d %d %d %d\n",
    		xpc-d,ypc-d, xpc-d,ypc+d, xpc+d,ypc+d, xpc+d,ypc-d, xpc-d,ypc-d);
	  }
	  else if ( tnum == 2 ) { /* diamond */
             d = term->v_char/3 + 1;
    	     fprintf(outfile,"5\n\t%d %d %d %d %d %d %d %d %d %d\n",
    		xpc-d,ypc, xpc,ypc+d, xpc+d,ypc, xpc,ypc-d, xpc-d,ypc);
	  }
	  else if ( tnum == 3 ) { /* triangle up */
             d = term->v_char/3 + 1;
             h = d*4/7; /* About d times one 3rd of sqrt(3) */
    	     fprintf(outfile,"4\n\t%d %d %d %d %d %d %d %d\n",
    		xpc-d,ypc+h, xpc,ypc-2*h, xpc+d,ypc+h, xpc-d,ypc+h);
	  }
	  else if ( tnum == 4 ) { /* triangle down */
             d = term->v_char/3 + 1;
             h = d*4/7; 
    	     fprintf(outfile,"4\n\t%d %d %d %d %d %d %d %d\n",
    		xpc-d,ypc-h, xpc,ypc+2*h, xpc+d,ypc-h, xpc-d,ypc-h);
	  }
       }
    }
    else
       do_point(x,y,number);
}
 
TERM_PUBLIC void FIG_reset()
{
    FIG_poly_clean(FIG_polyvec_stat);
    FIG_posx = FIG_posy = 0;
    fflush(outfile);
}
#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(fig_driver)
   "fig", "FIG 3.1 graphics language: X graphics editor",
  	   FIG_XMAX, FIG_YMAX, FIG_VCHAR, FIG_HCHAR, 
  	   FIG_VTIC, FIG_HTIC, FIG_options, FIG_init, FIG_reset, 
  	   FIG_text, null_scale, FIG_graphics, FIG_move, FIG_vector,
  	   FIG_linetype, FIG_put_text, FIG_text_angle, FIG_justify_text,
  	   FIG_lpoint, FIG_arrow, set_font_null
TERM_TABLE_END(fig_driver)

#undef LAST_TERM
#define LAST_TERM fig_driver
#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */

#ifdef TERM_HELP
START_HELP(fig)
"1 fig",
"?set terminal fig",
"?terminal fig",
"?fig",
" The `fig` terminal device generates output in the Fig graphics language.",
"",
" Syntax:",
"       set terminal fig {monochrome | color} {small | big}",
"                        {pointsmax <max_points>}",
"                        {landscape | portrait}",
"                        {metric | inches}",
"                        {fontsize <fsize>}",
"                        {size <xsize> <ysize>}",
"                        {thickness <units>}",
"                        {depth <layer>}",
"",
" `monochrome` and `color` determine whether the picture is black-and-white or",
" `color`.  `small` and `big` produce a 5x3 or 8x5 inch graph in the default",
" `landscape` mode and 3x5 or 5x8 inches in `portrait` mode.  <max_points>",
" sets the maximum number of points per polyline.  Default units for editing",
" with \"xfig\" may be `metric` or `inches`.  `fontsize` sets the size of the",
" text font to <fsize> points.  `size` sets (overrides) the size of the drawing",
" area to <xsize>*<ysize> in units of inches or centimeters depending on the",
" `inches` or `metric` setting in effect.  `depth` sets the default depth layer",
" for all lines and text.  The default depth is 10 to leave room for adding",
" material with \"xfig\" on top of the plot.", 
"",
" `thickness` sets the default line thickness, which is 1 if not specified.",
" Overriding the thickness can be achieved by adding a multiple of 100 to the",
" to the `linetype` value for a `plot` command.  In a similar way the `depth`",
" of plot elements (with respect to the default depth) can be controlled by",
" adding a multiple of 1000 to <linetype>.  The depth is then <layer> +",
" <linetype>/1000 and the thickness is (<linetype>%1000)/100 or, if that is",
" zero, the default line thickness.",
""
" Additional point-plot symbols are also available with the `fig` driver. The",
" symbols can be used through `pointtype` values % 100 above 50, with different",
" fill intensities controlled by <pointtype> % 5 and outlines in black (for",
" <pointtype> % 10 < 5) or in the current color.  Available symbols are",
"         50 - 59:  circles",
"         60 - 69:  squares",
"         70 - 79:  diamonds",
"         80 - 89:  upwards triangles",
"         90 - 99:  downwards triangles",
" The size of these symbols is linked to the font size.  The depth of symbols",
" is by default one less than the depth for lines to achieve nice error bars.",
" If <pointtype> is above 1000, the depth is <layer> + <pointtype>/1000-1.  If",
" <pointtype>%1000 is above 100, the fill color is (<pointtype>%1000)/100-1.",
"",
" Available fill colors are (from 1 to 9): black, blue, green, cyan, red,",
" magenta, yellow, white and dark blue (in monochrome mode: black for 1 to 6",
" and white for 7 to 9).",
"",
" See `plot with` for details of <linetype> and <pointtype>.",
"",
" The `big` option is a substitute for the `bfig` terminal in earlier versions,",
" which is no longer supported.",
"",
" Examples:",
"       set terminal fig monochrome small pointsmax 1000  # defaults",
"",
"       plot 'file.dat' with points linetype 102 pointtype 759",
" would produce circles with a blue outline of width 1 and yellow fill color.",
"",
"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 554",
" would produce errorbars with black lines and circles filled red.  These",
" circles are one layer above the lines (at depth 9 by default).",
"",
" To plot the error bars on top of the circles use",
"       plot 'file.dat' using 1:2:3 with err linetype 1 pointtype 2554"
END_HELP(fig)
#endif
