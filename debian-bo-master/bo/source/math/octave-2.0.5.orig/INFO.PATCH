Octave depends on being able to call the GNU info reader with the
command line arguments

  --index-search STRING

to find individual entries in the manual.  The following patch
implements this option.  It is relative to the version of info
distributed with texinfo-3.9.

The patch has already been applied to the info sources distributed
with Octave.  It is only provided here in case you want to add this
option to some other version of info that you may have.

This patch has been submitted to the maintainers of Texinfo, so maybe
someday it will not be necessary.

jwe


Tue Nov 12 14:44:00 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>

	* info/session.c (initialize_info_session): New arg,
	clear_screen.  Change all callers.

	* info/info.c (main): Handle new option, --index-search STRING.
	(index_search_p, index_search_string): New static variables, used
	to handle --index-search option.

	* info/indices.h (do_info_index_search, index_intry_exists):
	Provide declarations here.

	* info/indices.c (do_info_index_search): New function, extracted
	from info_index_search.
	(info_index_search): Simply call do_info_index_search() with
	search_string set to NULL.
	(index_entry_exists): New function.


diff -cNr texinfo-3.9/info/indices.c texinfo-3.9.local/info/indices.c
*** texinfo-3.9/info/indices.c	Fri Jun 16 12:59:55 1995
--- texinfo-3.9.local/info/indices.c	Tue Nov 12 15:09:58 1996
***************
*** 174,180 ****
  }
  
  DECLARE_INFO_COMMAND (info_index_search,
!    "Look up a string in the index for this file")
  {
    FILE_BUFFER *fb;
    char *line;
--- 174,191 ----
  }
  
  DECLARE_INFO_COMMAND (info_index_search,
!   "Look up a string in the index for this file")
! {
!   do_info_index_search (window, count, 0);
! }
! 
! /* Look up SEARCH_STRING in the index for this file.  If SEARCH_STRING
!    is NULL, prompt user for input.  */ 
! void
! do_info_index_search (window, count, search_string)
!      WINDOW *window;
!      int count;
!      char *search_string;
  {
    FILE_BUFFER *fb;
    char *line;
***************
*** 204,239 ****
        return;
      }
  
!   /* Okay, there is an index.  Let the user select one of the members of it. */
!   line =
!     info_read_maybe_completing (window, "Index entry: ", index_index);
! 
!   window = active_window;
! 
!   /* User aborted? */
!   if (!line)
      {
!       info_abort_key (active_window, 1, 0);
!       return;
!     }
  
!   /* Empty line means move to the Index node. */
!   if (!*line)
!     {
!       free (line);
  
!       if (initial_index_filename && initial_index_nodename)
  	{
! 	  NODE *node;
! 
! 	  node =
! 	    info_get_node (initial_index_filename, initial_index_nodename);
! 	  set_remembered_pagetop_and_point (window);
! 	  window_set_node_of_window (window, node);
! 	  remember_window_and_node (window, node);
! 	  window_clear_echo_area ();
  	  return;
  	}
      }
  
    /* The user typed either a completed index label, or a partial string.
--- 215,256 ----
        return;
      }
  
!   /* Okay, there is an index.  Look for SEARCH_STRING, or, if it is
!      empty, prompt for one.  */
!   if (search_string && *search_string)
!     line = strdup (search_string);
!   else
      {
!       line =
! 	info_read_maybe_completing (window, "Index entry: ", index_index);
  
!       window = active_window;
  
!       /* User aborted? */
!       if (!line)
  	{
! 	  info_abort_key (active_window, 1, 0);
  	  return;
  	}
+ 
+       /* Empty line means move to the Index node. */
+       if (!*line)
+ 	{
+ 	  free (line);
+ 
+ 	  if (initial_index_filename && initial_index_nodename)
+ 	    {
+ 	      NODE *node;
+ 
+ 	      node =
+ 		info_get_node (initial_index_filename, initial_index_nodename);
+ 	      set_remembered_pagetop_and_point (window);
+ 	      window_set_node_of_window (window, node);
+ 	      remember_window_and_node (window, node);
+ 	      window_clear_echo_area ();
+ 	      return;
+ 	    }
+ 	}
      }
  
    /* The user typed either a completed index label, or a partial string.
***************
*** 265,270 ****
--- 282,334 ----
      if (index_offset == old_offset)
        index_offset = 0;
    }
+ }
+ 
+ int
+ index_entry_exists (window, string)
+      WINDOW *window;
+      char *string;
+ {
+   register int i;
+   FILE_BUFFER *fb;
+ 
+   /* If there is no previous search string, the user hasn't built an index
+      yet. */
+   if (!string)
+     return 0;
+ 
+   fb = file_buffer_of_window (window);
+   if (!initial_index_filename ||
+       (strcmp (initial_index_filename, fb->filename) != 0))
+     {
+       info_free_references (index_index);
+       index_index = info_indices_of_file_buffer (fb);
+     }
+ 
+   /* If there is no index, that is an error. */
+   if (!index_index)
+     return 0;
+ 
+   for (i = 0; (i > -1) && (index_index[i]); i++)
+     if (strcmp (string, index_index[i]->label) == 0)
+       break;
+ 
+   /* If that failed, look for the next substring match. */
+   if ((i < 0) || (!index_index[i]))
+     {
+       for (i = 0; (i > -1) && (index_index[i]); i++)
+ 	if (string_in_line (string, index_index[i]->label) != -1)
+ 	  break;
+ 
+       if ((i > -1) && (index_index[i]))
+ 	string_in_line (string, index_index[i]->label);
+     }
+ 
+   /* If that failed, return 0. */
+   if ((i < 0) || (!index_index[i]))
+     return 0;
+ 
+   return 1;
  }
  
  DECLARE_INFO_COMMAND (info_next_index_match,
diff -cNr texinfo-3.9/info/indices.h texinfo-3.9.local/info/indices.h
*** texinfo-3.9/info/indices.h	Fri Jun 16 13:01:54 1995
--- texinfo-3.9.local/info/indices.h	Tue Nov 12 15:01:54 1996
***************
*** 35,39 ****
--- 35,41 ----
  
  /* User visible functions declared in indices.c. */
  extern void info_index_search (), info_next_index_match ();
+ extern void do_info_index_search ();
+ extern int index_intry_exists ();
  
  #endif /* !_INDICES_H_ */
diff -cNr texinfo-3.9/info/info.c texinfo-3.9.local/info/info.c
*** texinfo-3.9/info/info.c	Fri Oct  4 13:19:54 1996
--- texinfo-3.9.local/info/info.c	Tue Nov 12 15:21:19 1996
***************
*** 39,44 ****
--- 39,52 ----
  /* Variable containing the string to search for when apropos_p is non-zero. */
  static char *apropos_search_string = (char *)NULL;
  
+ /* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike
+    apropos, this puts the user at the node, running info. */
+ static int index_search_p = 0;
+ 
+ /* Variable containing the string to search for when index_search_p is
+    non-zero. */ 
+ static char *index_search_string = (char *)NULL;
+ 
  /* Non-zero means print version info only. */
  static int print_version_p = 0;
  
***************
*** 70,75 ****
--- 78,84 ----
  #define APROPOS_OPTION 1
  #define DRIBBLE_OPTION 2
  #define RESTORE_OPTION 3
+ #define IDXSRCH_OPTION 4
  static struct option long_options[] = {
    { "apropos", 1, 0, APROPOS_OPTION },
    { "directory", 1, 0, 'd' },
***************
*** 81,86 ****
--- 90,96 ----
    { "version", 0, &print_version_p, 1 },
    { "dribble", 1, 0, DRIBBLE_OPTION },
    { "restore", 1, 0, RESTORE_OPTION },
+   { "index-search", 1, 0, IDXSRCH_OPTION },
    {NULL, 0, NULL, 0}
  };
  
***************
*** 181,186 ****
--- 191,203 ----
  	  info_set_input_from_file (optarg);
  	  break;
  
+ 	  /* User has specified a string to search all indices for. */
+ 	case IDXSRCH_OPTION:
+ 	  index_search_p = 1;
+ 	  maybe_free (index_search_string);
+ 	  index_search_string = strdup (optarg);
+ 	  break;
+ 
  	default:
  	  usage ();
  	}
***************
*** 286,291 ****
--- 303,345 ----
  	begin_multiple_window_info_session (user_filename, user_nodenames);
  
        exit (0);
+     }
+ 
+   /* If the user specified `--index-search string', start the info
+      session in the node corresponding to the first match. */
+   if (index_search_p)
+     {
+       int status = 0;
+ 
+       initialize_info_session (initial_node, 0);
+ 
+       if (index_entry_exists (windows, index_search_string))
+ 	{
+ 	  terminal_clear_screen ();
+ 	  terminal_prep_terminal ();
+ 	  display_update_display (windows);
+ 	  info_last_executed_command = (VFunction *)NULL;
+ 
+ 	  do_info_index_search (windows, 0, index_search_string);
+ 
+ 	  info_read_and_dispatch ();
+ 
+ 	  terminal_unprep_terminal ();
+ 
+ 	  /* On program exit, leave the cursor at the bottom of the
+ 	     window, and restore the terminal IO. */
+ 	  terminal_goto_xy (0, screenheight - 1);
+ 	  terminal_clear_to_eol ();
+ 	  fflush (stdout);
+ 	}
+       else
+ 	{
+ 	  fprintf (stderr, "no entries found\n");
+ 	  status = -1;
+ 	}
+ 
+       close_dribble_file (); 
+       exit (status);
      }
  
    /* If there are arguments remaining, they are the names of menu items
diff -cNr texinfo-3.9/info/session.c texinfo-3.9.local/info/session.c
*** texinfo-3.9/info/session.c	Fri Jul 19 09:56:01 1996
--- texinfo-3.9.local/info/session.c	Tue Nov 12 15:33:08 1996
***************
*** 92,98 ****
        /* If this is the first node, initialize the info session. */
        if (!window)
  	{
! 	  initialize_info_session (node);
  	  window = active_window;
  	}
        else
--- 92,98 ----
        /* If this is the first node, initialize the info session. */
        if (!window)
  	{
! 	  initialize_info_session (node, 1);
  	  window = active_window;
  	}
        else
***************
*** 145,151 ****
       char *format;
       void *arg;
  {
!   initialize_info_session (initial_node);
    info_error (format, arg, (void *)NULL);
    info_session ();
  }
--- 145,151 ----
       char *format;
       void *arg;
  {
!   initialize_info_session (initial_node, 1);
    info_error (format, arg, (void *)NULL);
    info_session ();
  }
***************
*** 155,161 ****
  begin_info_session (initial_node)
       NODE *initial_node;
  {
!   initialize_info_session (initial_node);
    display_startup_message_and_start ();
  }
  
--- 155,161 ----
  begin_info_session (initial_node)
       NODE *initial_node;
  {
!   initialize_info_session (initial_node, 1);
    display_startup_message_and_start ();
  }
  
***************
*** 260,269 ****
  extern void initialize_info_signal_handler ();
  
  /* Initialize the first info session by starting the terminal, window,
!    and display systems. */
  void
! initialize_info_session (node)
       NODE *node;
  {
    char *getenv (), *term_name;
  
--- 260,271 ----
  extern void initialize_info_signal_handler ();
  
  /* Initialize the first info session by starting the terminal, window,
!    and display systems.  If CLEAR_SCREEN is 0, don't clear the
!    screen.  */
  void
! initialize_info_session (node, clear_screen)
       NODE *node;
+      int clear_screen;
  {
    char *getenv (), *term_name;
  
***************
*** 279,285 ****
        exit (1);
      }
  
!   terminal_clear_screen ();
    initialize_info_keymaps ();
    window_initialize_windows (screenwidth, screenheight);
    initialize_info_signal_handler ();
--- 281,289 ----
        exit (1);
      }
  
!   if (clear_screen)
!     terminal_clear_screen ();
! 
    initialize_info_keymaps ();
    window_initialize_windows (screenwidth, screenheight);
    initialize_info_signal_handler ();

