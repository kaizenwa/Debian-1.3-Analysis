This is Info file octave.info, produced by Makeinfo version 1.67 from
the input file ./octave.texi.

START-INFO-DIR-ENTRY
* Octave: (octave).	Interactive language for numerical computations.
END-INFO-DIR-ENTRY

   Copyright (C) 1996, 1997 John W. Eaton.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: octave.info,  Node: Timing Utilities,  Next: Filesystem Utilities,  Prev: System Utilities,  Up: System Utilities

Timing Utilities
================

   Octave's core set of functions for manipulating time values are
patterned after the corresponding functions from the standard C library.
Several of these functions use a data structure for time that includes
the following elements:

`usec'
     Microseconds after the second (0-999999).

`sec'
     Seconds after the minute (0-61).  This number can be 61 to account
     for leap seconds.

`min'
     Minutes after the hour (0-59).

`hour'
     Hours since midnight (0-23).

`mday'
     Day of the month (1-31).

`mon'
     Months since January (0-11).

`year'
     Years since 1900.

`wday'
     Days since Sunday (0-6).

`yday'
     Days since January 1 (0-365).

`isdst'
     Daylight Savings Time flag.

`zone'
     Time zone.

In the descriptions of the following functions, this structure is
referred to as a TM_STRUCT.

 - Loadable Function:  time ()
     Return the current time as the number of seconds since the epoch.
     The epoch is referenced to 00:00:00 CUT (Coordinated Universal
     Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at
     07:15:06 CUT, the value returned by `time' was 856163706.

 - Function File:  ctime (T)
     Convert a value returned from `time' (or any other nonnegative
     integer), to the local time and return a string of the same form as
     `asctime'.  The function `ctime (time)' is equivalent to `asctime
     (localtime (time))'.  For example,

          ctime (time ())
               => "Mon Feb 17 01:15:06 1997"

 - Loadable Function:  gmtime (T)
     Given a value returned from time (or any nonnegative integer),
     return a time structure corresponding to CUT.  For example,

          gmtime (time ())
               => {
                     usec = 0
                     year = 97
                     mon = 1
                     mday = 17
                     sec = 6
                     zone = CST
                     min = 15
                     wday = 1
                     hour = 7
                     isdst = 0
                     yday = 47
                   }

 - Loadable Function:  localtime (T)
     Given a value returned from time (or any nonnegative integer),
     return a time structure corresponding to the local time zone.

          localtime (time ())
               => {
                     usec = 0
                     year = 97
                     mon = 1
                     mday = 17
                     sec = 6
                     zone = CST
                     min = 15
                     wday = 1
                     hour = 1
                     isdst = 0
                     yday = 47
                   }

 - Loadable Function:  mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the
     number of seconds since the epoch.  For example,

          mktime (localtime (time ())
               => 856163706

 - Function File:  asctime (TM_STRUCT)
     Convert a time structure to a string using the following five-field
     format: Thu Mar 28 08:40:14 1996.  For example,

          asctime (localtime (time ())
               => "Mon Feb 17 01:15:06 1997\n"

     This is equivalent to `ctime (time ())'.

 - Loadable Function:  strftime (TM_STRUCT)
     Format a time structure in a flexible way using `%' substitutions
     similar to those in `printf'.  Except where noted, substituted
     fields have a fixed size; numeric fields are padded if necessary.
     Padding is with zeros by default; for fields that display a single
     number, padding can be changed or inhibited by following the `%'
     with one of the modifiers described below.  Unknown field
     specifiers are copied as normal characters.  All other characters
     are copied to the output without change.  For example,

          strftime ("%r (%Z) %A %e %B %Y", localtime (time ())
               => "01:15:06 AM (CST) Monday 17 February 1997"

     Octave's `strftime' function supports a superset of the ANSI C
     field specifiers.

     Literal character fields:

    `%'
          % character.

    `n'
          Newline character.

    `t'
          Tab character.

     Numeric modifiers (a nonstandard extension):

    `- (dash)'
          Do not pad the field.

    `_ (underscore)'
          Pad the field with spaces.

     Time fields:

    `%H'
          Hour (00-23).

    `%I'
          Hour (01-12).

    `%k'
          Hour (0-23).

    `%l'
          Hour (1-12).

    `%M'
          Minute (00-59).

    `%p'
          Locale's AM or PM.

    `%r'
          Time, 12-hour (hh:mm:ss [AP]M).

    `%R'
          Time, 24-hour (hh:mm).

    `%s'
          Time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard
          extension).

    `%S'
          Second (00-61).

    `%T'
          Time, 24-hour (hh:mm:ss).

    `%X'
          Locale's time representation (%H:%M:%S).

    `%Z'
          Time zone (EDT), or nothing if no time zone is determinable.

     Date fields:

    `%a'
          Locale's abbreviated weekday name (Sun-Sat).

    `%A'
          Locale's full weekday name, variable length (Sunday-Saturday).

    `%b'
          Locale's abbreviated month name (Jan-Dec).

    `%B'
          Locale's full month name, variable length (January-December).

    `%c'
          Locale's date and time (Sat Nov 04 12:02:33 EST 1989).

    `%C'
          Century (00-99).

    `%d'
          Day of month (01-31).

    `%e'
          Day of month ( 1-31).

    `%D'
          Date (mm/dd/yy).

    `%h'
          Same as %b.

    `%j'
          Day of year (001-366).

    `%m'
          Month (01-12).

    `%U'
          Week number of year with Sunday as first day of week (00-53).

    `%w'
          Day of week (0-6).

    `%W'
          Week number of year with Monday as first day of week (00-53).

    `%x'
          Locale's date representation (mm/dd/yy).

    `%y'
          Last two digits of year (00-99).

    `%Y'
          Year (1970-).

   Most of the remaining functions described in this section are not
patterned after the standard C library.  Some are available for
compatiblity with MATLAB and others are provided because they are
useful.

 - Function File:  clock ()
     Return a vector containing the current year, month (1-12), day
     (1-31), hour (0-23), minute (0-59) and second (0-61).  For example,

          clock ()
               => [ 1993, 8, 20, 4, 56, 1 ]

     The function clock is more accurate on systems that have the
     `gettimeofday' function.

 - Function File:  date ()
     Return the date as a character string in the form DD-MMM-YY.  For
     example,

          date ()
               => "20-Aug-93"

 - Function File:  etime (T1, T2)
     Return the difference (in seconds) between two time values
     returned from `clock'.  For example:

          t0 = clock ();
          # many computations later...
          elapsed_time = etime (clock (), t0);

     will set the variable `elapsed_time' to the number of seconds since
     the variable `t0' was set.

 - Built-in Function: [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.  The first output
     is the total time spent executing your process and is equal to the
     sum of second and third outputs, which are the number of CPU
     seconds spent executing in user mode and the number of CPU seconds
     spent executing in system mode, respectively.  If your system does
     not have a way to report CPU time usage, `cputime' returns 0 for
     each of its output values.  Note that because Octave used some CPU
     time to start, it is reasonable to check to see if `cputime' works
     by checking to see if the total CPU time used is nonzero.

 - Function File:  is_leap_year (YEAR)
     Return 1 if the given year is a leap year and 0 otherwise.  If no
     arguments are provided, `is_leap_year' will use the current year.
     For example,

          is_leap_year (2000)
               => 1

 - Function File:  tic ()
 - Function File:  toc ()
     These functions set and check a wall-clock timer.  For example,

          tic ();
          # many computations later...
          elapsed_time = toc ();

     will set the variable `elapsed_time' to the number of seconds since
     the most recent call to the function `tic'.

     If you are more interested in the CPU time that your process used,
     you should use the `cputime' function instead.  The `tic' and
     `toc' functions report the actual wall clock time that elapsed
     between the calls.  This may include time spent processing other
     jobs or doing nothing at all.  For example,

          tic (); sleep (5); toc ()
               => 5
          t = cputime (); sleep (5); cputime () - t
               => 0

     (This example also illustrates that the CPU timer may have a fairly
     coarse resolution.)

 - Built-in Function:  pause (SECONDS)
     Suspend the execution of the program.  If invoked without any
     arguments, Octave waits until you type a character.  With a
     numeric argument, it pauses for the given number of seconds.  For
     example, the following statement prints a message and then waits 5
     seconds before clearing the screen.

          fprintf (stderr, "wait please...\n");
          pause (5);
          clc;

 - Built-in Function:  sleep (SECONDS)
     Suspend the execution of the program for the given number of
     seconds.

 - Built-in Function:  usleep (MICROSECONDS)
     Suspend the execution of the program for the given number of
     microseconds.  On systems where it is not possible to sleep for
     periods of time less than one second, `usleep' will pause the
     execution for `round (MICROSECONDS / 1e6)' seconds.


File: octave.info,  Node: Filesystem Utilities,  Next: Controlling Subprocesses,  Prev: Timing Utilities,  Up: System Utilities

Filesystem Utilities
====================

   Octave includes the following functions for renaming and deleting
files, creating, deleting, and reading directories, and for getting
information about the status of files.

 - Built-in Function: [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [ERR, MSG] = unlink (FILE)
     Delete FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [FILES, ERR, MSG] = readdir (DIR)
     Return names of the files in the directory DIR as an array of
     strings.  If an error occurs, return an empty matrix in FILES.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [ERR, MSG] = mkdir (DIR)
     Create a directory named DIR.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [ERR, MSG] = rmdir (DIR)
     Remove the directory named DIR.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [ERR, MSG] = mkfifo (NAME)
     Create a FIFO special file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function:  umask (MASK)
     Set the permission mask for file creation.  The parameter MASK is
     interpreted as an octal number.

 - Built-in Function: [INFO, ERR, MSG] = stat (FILE)
 - Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
     Return a structure S containing the following information about
     FILE.

    `dev'
          ID of device containing a directory entry for this file.

    `ino'
          File number of the file.

    `modestr'
          File mode, as a string of ten letters or dashes as would be
          returned by `ls -l'.

    `nlink'
          Number of links.

    `uid'
          User ID of file's owner.

    `gid'
          Group ID of file's group.

    `rdev'
          ID of device for block or character special files.

    `size'
          Size in bytes.

    `atime'
          Time of last access in the same form as time values returned
          from `time'.  *Note Timing Utilities::.

    `mtime'
          Time of last modification in the same form as time values
          returned from `time'.  *Note Timing Utilities::.

    `ctime'
          Time of last file status change in the same form as time
          values returned from `time'.  *Note Timing Utilities::.

    `blksize'
          Size of blocks in the file.

    `blocks'
          Number of blocks allocated for file.

     If the call is successful ERR is 0 and MSG is an empty string.  If
     the file does not exist, or some other error occurs, S is an empty
     matrix, ERR is -1, and MSG contains the corresponding system error
     message.

     If FILE is a symbolic link, `stat' will return information about
     the actual file the is referenced by the link.  Use `lstat' if you
     want information about the symbolic link itself.

     For example,

          [s, err, msg] = stat ("/vmlinuz")
          
               => s =
                  {
                    atime = 855399756
                    rdev = 0
                    ctime = 847219094
                    uid = 0
                    size = 389218
                    blksize = 4096
                    mtime = 847219094
                    gid = 6
                    nlink = 1
                    blocks = 768
                    modestr = -rw-r--r--
                    ino = 9316
                    dev = 2049
                  }
          
               => err = 0
          
               => msg =

 - Built-in Function:  glob (PATTERN)
     Given an array of strings in PATTERN, return the list of file
     names that any of them, or an empty string if no patterns match.
     Tilde expansion is performed on each of the patterns before
     looking for matching file names.  For example,

          glob ("/vm*")
               => "/vmlinuz"

     Note that multiple values are returned in a string matrix with the
     fill character set to ASCII NUL.

 - Built-in Function:  fnmatch (PATTERN, STRING)
     Return 1 or zero for each element of STRING that matches any of
     the elements of the string array PATTERN, using the rules of
     filename pattern matching.  For example,

          fnmatch ("a*b", ["ab"; "axyzb"; "xyzab"])
               => [ 1; 1; 0 ]

 - Built-in Function:  file_in_path (PATH, FILE)
     Return the absolute name name of FILE if it can be found in PATH.
     The value of PATH should be a colon-separated list of directories
     in the format described for the built-in variable `LOADPATH'.

     If the file cannot be found in the path, an empty matrix is
     returned.  For example,

          file_in_path (LOADPATH, "nargchk.m")
               => "/usr/local/share/octave/2.0/m/general/nargchk.m"

 - Built-in Function:  tilde_expand (STRING)
     Performs tilde expansion on STRING.  If STRING begins with a tilde
     character, (`~'), all of the characters preceding the first slash
     (or all characters, if there is no slash) are treated as a
     possible user name, and the tilde and the following characters up
     to the slash are replaced by the home directory of the named user.
     If the tilde is followed immediately by a slash, the tilde is
     replaced by the home directory of the user running Octave.  For
     example,

          tilde_expand ("~joeuser/bin")
               => "/home/joeuser/bin"
          tilde_expand ("~/bin")
               => "/home/jwe/bin"


File: octave.info,  Node: Controlling Subprocesses,  Next: Process ID Information,  Prev: Filesystem Utilities,  Up: System Utilities

Controlling Subprocesses
========================

   Octave includes some high-level commands like `system' and `popen'
for starting subprocesses.  If you want to run another program to
perform some task and then look at its output, you will probably want
to use these functions.

   Octave also provides several very low-level Unix-like functions which
can also be used for starting subprocesses, but you should probably only
use them if you can't find any way to do what you need with the
higher-level functions.

 - Built-in Function:  system (STRING, RETURN_OUTPUT, TYPE)
     Execute a shell command specified by STRING.  The second argument
     is optional.  If TYPE is `"async"', the process is started in the
     background and the process id of the child process is returned
     immediately.  Otherwise, the process is started, and Octave waits
     until it exits.  If TYPE argument is omitted, a value of `"sync"'
     is assumed.

     If two input arguments are given (the actual value of
     RETURN_OUTPUT is irrelevant) and the subprocess is started
     synchronously, or if SYSTEM is called with one input argument and
     one or more output arguments, the output from the command is
     returned.  Otherwise, if the subprocess is executed synchronously,
     it's output is sent to the standard output.  To send the output of
     a command executed with SYSTEM through the pager, use a command
     like

          disp (system (cmd, 1));

     or

          printf ("%s\n", system (cmd, 1));

     The `system' function can return two values.  The first is any
     output from the command that was written to the standard output
     stream, and the second is the output status of the command.  For
     example,

          [output, status] = system ("echo foo; exit 2");

     will set the variable `output' to the string `foo', and the
     variable `status' to the integer `2'.

 - Built-in Function: fid = popen (COMMAND, MODE)
     Start a process and create a pipe.  The name of the command to run
     is given by COMMAND.  The file identifier corresponding to the
     input or output stream of the process is returned in FID.  The
     argument MODE may be

    `"r"'
          The pipe will be connected to the standard output of the
          process, and open for reading.

    `"w"'
          The pipe will be connected to the standard input of the
          process, and open for writing.

     For example,

          fid = popen ("ls -ltr / | tail -3", "r");
          while (isstr (s = fgets (fid)))
            fputs (stdout, s);
          endwhile
               -| drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
               -| drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
               -| drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp

 - Built-in Function:  pclose (FID)
     Close a file identifier that was opened by `popen'.  You may also
     use `fclose' for the same purpose.

 - Built-in Function: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.  The name of the
     process is given by COMMAND, and ARGS is an array of strings
     containing options for the command.  The file identifiers for the
     input and output streams of the subprocess are returned in IN and
     OUT.  If execution of the command is successful, PID contains the
     process ID of the subprocess.  Otherwise, PID is -1.

     For example,

          [in, out, pid] = popen2 ("sort", "-nr");
          fputs (in, "these\nare\nsome\nstrings\n");
          fclose (in);
          while (isstr (s = fgets (out)))
            fputs (stdout, s);
          endwhile
          fclose (out);
               -| are
               -| some
               -| strings
               -| these

 - Built-in Variable: EXEC_PATH
     The variable `EXEC_PATH' is a colon separated list of directories
     to search when executing subprograms.  Its initial value is taken
     from the environment variable `OCTAVE_EXEC_PATH' (if it exists) or
     `PATH', but that value can be overridden by the the command line
     argument `--exec-path PATH', or by setting the value of
     `EXEC_PATH' in a startup script.  If the value of `EXEC_PATH'
     begins (ends) with a colon, the directories

          OCTAVE_HOME/libexec/octave/site/exec/ARCH
          OCTAVE_HOME/libexec/octave/VERSION/exec/ARCH

     are prepended (appended) to `EXEC_PATH', where OCTAVE_HOME is the
     top-level directory where all of Octave is installed (the default
     value is `/usr/local').  If you don't specify a value for
     `EXEC_PATH' explicitly, these special directories are prepended to
     your shell path.

   In most cases, the following functions simply decode their arguments
and make the corresponding Unix system calls.  For a complete example
of how they can be used, look at the definition of the function
`popen2'.

 - Built-in Function: [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

    > 0
          You are in the parent process.  The value returned from
          `fork' is the process id of the child process.  You should
          probably arrange to wait for any child processes to exit.

    0
          You are in the child process.  You can call `exec' to start
          another process.  If that fails, you should probably call
          `exit'.

    < 0
          The call to `fork' failed for some reason.  You must take
          evasive action.  A system dependent error message will be
          waiting in MSG.

 - Built-in Function: [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.  Calling `exec' without
     first calling `fork' will terminate your current Octave process and
     replace it with the program named by FILE.  For example,

          exec ("ls" "-l")

     will run `ls' and return you to your shell prompt.

     If successful, `exec' does not return.  If `exec' does return, ERR
     will be nonzero, and MSG will contain a system-dependent error
     message.

 - Built-in Function: [FILE_IDS, ERR, MSG] = pipe ()
     Create a pipe and return the vector FILE_IDS, which corresponding
     to the reading and writing ends of the pipe.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.

 - Built-in Function: [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file
     ID.  Otherwise, FID is negative and MSG contains a
     system-dependent error message.

 - Built-in Function: [PID, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.  The PID argument can be:

    -1
          Wait for any child process.

    0
          Wait for any child process whose process group ID is equal to
          that of the Octave interpreter process.

    > 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be:

    0
          Wait until signal is received or a child process exits (this
          is the default if the OPTIONS argument is missing).

    1
          Do not hang if status is not immediately available.

    2
          Report the status of any child processes that are stopped,
          and whose status has not yet been reported since they stopped.

    3
          Implies both 1 and 2.

     If the returned value of PID is greater than 0, it is the process
     ID of the child process that exited.  If an error occurs, PID will
     be less than zero and MSG will contain a system-dependent error
     message.

 - Built-in Function: [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.  The following values
     may be passed as REQUEST:

    `F_DUPFD'
          Return a duplicate file descriptor.

    `F_GETFD'
          Return the file descriptor flags for FID.

    `F_SETFD'
          Set the file descriptor flags for FID.

    `F_GETFL'
          Return the file status flags for FID.  The following codes
          may be returned (some of the flags may be undefined on some
          systems).

         `O_RDONLY'
               Open for reading only.

         `O_WRONLY'
               Open for writing only.

         `O_RDWR'
               Open for reading and writing.

         `O_APPEND'
               Append on each write.

         `O_NONBLOCK'
               Nonblocking mode.

         `O_SYNC'
               Wait for writes to complete.

         `O_ASYNC'
               Asynchronous I/O.

    `F_SETFL'
          Set the file status flags for FID to the value specified by
          ARG.  The only flags that can be changed are `O_APPEND' and
          `O_NONBLOCK'.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise,
     ERR is nonzero and MSG contains a system-dependent error message.


File: octave.info,  Node: Process ID Information,  Next: Environment Variables,  Prev: Controlling Subprocesses,  Up: System Utilities

Process, Group, and User IDs
============================

 - Built-in Function:  getpgrp ()
     Return the process group id of the current process.

 - Built-in Function:  getpid ()
     Return the process id of the current process.

 - Built-in Function:  getppid ()
     Return the process id of the parent process.

 - Built-in Function:  geteuid ()
     Return the effective user id of the current process.

 - Built-in Function:  getuid ()
     Return the real user id of the current process.

 - Built-in Function:  getegid ()
     Return the effective group id of the current process.

 - Built-in Function:  getgid ()
     Return the real group id of the current process.


File: octave.info,  Node: Environment Variables,  Next: Current Working Directory,  Prev: Process ID Information,  Up: System Utilities

Environment Variables
=====================

 - Built-in Function:  getenv (VAR)
     Return the value of the environment variable VAR.  For example,

          getenv ("PATH")

     returns a string containing the value of your path.

 - Built-in Function:  putenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.


File: octave.info,  Node: Current Working Directory,  Next: Password Database Functions,  Prev: Environment Variables,  Up: System Utilities

Current Working Directory
=========================

 - Command: cd DIR
 - Command: chdir DIR
     Change the current working directory to DIR.  For example,

          cd ~/octave

     Changes the current working directory to `~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

 - Built-in Function:  pwd ()
     Return the current working directory.

 - Built-in Variable: PWD
     The current working directory.  The value of `PWD' is updated each
     time the current working directory is changed with the `cd'
     command.

 - Command: ls OPTIONS
 - Command: dir OPTIONS
     List directory contents.  For example,

          ls -l
               -| total 12
               -| -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
               -| -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m

     The `dir' and `ls' commands are implemented by calling your
     system's directory listing command, so the available options may
     vary from system to system.


File: octave.info,  Node: Password Database Functions,  Next: Group Database Functions,  Prev: Current Working Directory,  Up: System Utilities

Password Database Functions
===========================

   Octave's password database functions return information in a
structure with the following fields.

`name'
     The user name.

`passwd'
     The encrypted password, if available.

`uid'
     The numeric user id.

`gid'
     The numeric group id.

`gecos'
     The GECOS field.

`dir'
     The home directory.

`shell'
     The initial shell.

   In the descriptions of the following functions, this data structure
is referred to as a PW_STRUCT.

 - Loadable Function: PW_STRUCT =  getpwent ()
     Return a structure containing an entry from the password database,
     opening it if necessary. Once the end of the data has been reached,
     `getpwent' returns 0.

 - Loadable Function: PW_STRUCT =  getpwuid (UID).
     Return a structure containing the first entry from the password
     database with the user ID UID.  If the user ID does not exist in
     the database, `getpwuid' returns 0.

 - Loadable Function: PW_STRUCT =  getpwnam (NAME)
     Return a structure containing the first entry from the password
     database with the user name NAME.  If the user name does not exist
     in the database, `getpwname' returns 0.

 - Loadable Function:  setpwent ()
     Return the internal pointer to the beginning of the password
     database.

 - Loadable Function:  endpwent ()
     Close the password database.


File: octave.info,  Node: Group Database Functions,  Next: System Information,  Prev: Password Database Functions,  Up: System Utilities

Group Database Functions
========================

   Octave's group database functions return information in a structure
with the following fields.

`name'
     The user name.

`passwd'
     The encrypted password, if available.

`gid'
     The numeric group id.

`mem'
     The members of the group.

   In the descriptions of the following functions, this data structure
is referred to as a GRP_STRUCT.

 - Loadable Function: GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.
     Once the end of the data has been reached, `getgrent' returns 0.

 - Loadable Function: GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID
     GID.  If the group ID does not exist in the database, `getgrgid'
     returns 0.

 - Loadable Function: GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name
     NAME.  If the group name does not exist in the database,
     `getgrname' returns 0.

 - Loadable Function:  setgrent ()
     Return the internal pointer to the beginning of the group database.

 - Loadable Function:  endgrent ()
     Close the group database.


File: octave.info,  Node: System Information,  Prev: Group Database Functions,  Up: System Utilities

System Information
==================

 - Built-in Function:  computer ()
     Print or return a string of the form CPU-VENDOR-OS that identifies
     the kind of computer Octave is running on.  If invoked with an
     output argument, the value is returned instead of printed.  For
     example,

          computer ()
               -| i586-pc-linux-gnu
          
          x = computer ()
               => x = "i586-pc-linux-gnu"

 - Built-in Function:  isieee ()
     Return 1 if your computer claims to conform to the IEEE standard
     for floating point calculations.

 - Built-in Function:  version ()
     Return Octave's version number as a string.  This is also the
     value of the built-in variable `OCTAVE_VERSION'.

 - Built-in Variable: OCTAVE_VERSION
     The version number of Octave, as a string.

 - Built-in Function:  octave_config_info ()
     Return a structure containing configuration and installation
     information.

 - Loadable Function:  getrusage ()
     Return a structure containing a number of statistics about the
     current Octave process.  Not all fields are available on all
     systems.  If it is not possible to get CPU time statistics, the
     CPU time slots are set to zero.  Other missing data are replaced
     by NaN.  Here is a list of all the possible fields that can be
     present in the structure returned by `getrusage':

    `'
    `idrss'
          Unshared data size.

    `inblock'
          Number of block input operations.

    `isrss'
          Unshared stack size.

    `ixrss'
          Shared memory size.

    `majflt'
          Number of major page faults.

    `maxrss'
          Maximum data size.

    `minflt'
          Number of minor page faults.

    `msgrcv'
          Number of messages received.

    `msgsnd'
          Number of messages sent.

    `nivcsw'
          Number of involuntary context switches.

    `nsignals'
          Number of signals received.

    `nswap'
          Number of swaps.

    `nvcsw'
          Number of voluntary context switches.

    `oublock'
          Number of block output operations.

    `stime'
          A structure containing the system CPU time used.  The
          structure has the elements `sec' (seconds) `usec'
          (microseconds).

    `utime'
          A structure containing the user CPU time used.  The structure
          has the elements `sec' (seconds) `usec' (microseconds).


File: octave.info,  Node: Tips,  Next: Trouble,  Prev: System Utilities,  Up: Top

Tips and Standards
******************

   This chapter describes no additional features of Octave.  Instead it
gives advice on making effective use of the features described in the
previous chapters.

* Menu:

* Style Tips::                  Writing clean and robust programs.
* Coding Tips::                 Making code run faster.
* Documentation Tips::          Writing readable documentation strings.
* Comment Tips::                Conventions for writing comments.
* Function Headers::            Standard headers for functions.


File: octave.info,  Node: Style Tips,  Next: Coding Tips,  Prev: Tips,  Up: Tips

Writing Clean Octave Programs
=============================

   Here are some tips for avoiding common errors in writing Octave code
intended for widespread use:

   * Since all global variables share the same name space, and all
     functions share another name space, you should choose a short word
     to distinguish your program from other Octave programs.  Then take
     care to begin the names of all global variables, constants, and
     functions with the chosen prefix.  This helps avoid name conflicts.

     If you write a function that you think ought to be added to Octave
     under a certain name, such as `fiddle_matrix', don't call it by
     that name in your program.  Call it `mylib_fiddle_matrix' in your
     program, and send mail to <bug-octave@bevo.che.wisc.edu>
     suggesting that it be added to Octave.  If and when it is, the
     name can be changed easily enough.

     If one prefix is insufficient, your package may use two or three
     alternative common prefixes, so long as they make sense.

     Separate the prefix from the rest of the symbol name with an
     underscore `_'.  This will be consistent with Octave itself and
     with most Octave programs.

   * When you encounter an error condition, call the function `error'
     (or `usage').  The `error' and `usage' functions do not return.
     *Note Errors::.

   * Please put a copyright notice on the file if you give copies to
     anyone.  Use the same lines that appear at the top of the function
     files distributed with Octave.  If you have not signed papers to
     assign the copyright to anyone else, then place your name in the
     copyright notice.


File: octave.info,  Node: Coding Tips,  Next: Documentation Tips,  Prev: Style Tips,  Up: Tips

Tips for Making Code Run Faster.
================================

   Here are some ways of improving the execution speed of Octave
programs.

   * Avoid looping wherever possible.

   * Use iteration rather than recursion whenever possible.  Function
     calls are slow in Octave.

   * Avoid resizing matrices unnecessarily.  When building a single
     result matrix from a series of calculations, set the size of the
     result matrix first, then insert values into it.  Write

          result = zeros (big_n, big_m)
          for i = over:and_over
            r1 = ...
            r2 = ...
            result (r1, r2) = new_value ();
          endfor

     instead of

          result = [];
          for i = ever:and_ever
            result = [ result, new_value() ];
          endfor

   * Avoid calling `eval' or `feval' whenever possible, because they
     require Octave to parse input or look up the name of a function in
     the symbol table.

     If you are using `eval' as an exception handling mechanism and not
     because you need to execute some arbitrary text, use the `try'
     statement instead.  *Note The try Statement::.

   * If you are calling lots of functions but none of them will need to
     change during your run, set the variable
     `ignore_function_time_stamp' to `"all"' so that Octave doesn't
     waste a lot of time checking to see if you have updated your
     function files.


File: octave.info,  Node: Documentation Tips,  Next: Comment Tips,  Prev: Coding Tips,  Up: Tips

Tips for Documentation Strings
==============================

   Here are some tips for the writing of documentation strings.

   * Every command, function, or variable intended for users to know
     about should have a documentation string.

   * An internal variable or subroutine of an Octave program might as
     well have a documentation string.

   * The first line of the documentation string should consist of one
     or two complete sentences that stand on their own as a summary.

     The documentation string can have additional lines that expand on
     the details of how to use the function or variable.  The
     additional lines should also be made up of complete sentences.

   * For consistency, phrase the verb in the first sentence of a
     documentation string as an infinitive with "to" omitted.  For
     instance, use "Return the frob of A and B." in preference to
     "Returns the frob of A and B."  Usually it looks good to do
     likewise for the rest of the first paragraph.  Subsequent
     paragraphs usually look better if they have proper subjects.

   * Write documentation strings in the active voice, not the passive,
     and in the present tense, not the future.  For instance, use
     "Return a list containing A and B." instead of "A list containing
     A and B will be returned."

   * Avoid using the word "cause" (or its equivalents) unnecessarily.
     Instead of, "Cause Octave to display text in boldface," write just
     "Display text in boldface."

   * Do not start or end a documentation string with whitespace.

   * Format the documentation string so that it fits in an Emacs window
     on an 80-column screen.  It is a good idea for most lines to be no
     wider than 60 characters.

     However, rather than simply filling the entire documentation
     string, you can make it much more readable by choosing line breaks
     with care.  Use blank lines between topics if the documentation
     string is long.

   * *Do not* indent subsequent lines of a documentation string so that
     the text is lined up in the source code with the text of the first
     line.  This looks nice in the source code, but looks bizarre when
     users view the documentation.  Remember that the indentation
     before the starting double-quote is not part of the string!

   * The documentation string for a variable that is a yes-or-no flag
     should start with words such as "Nonzero means...", to make it
     clear that all nonzero values are equivalent and indicate
     explicitly what zero and nonzero mean.

   * When a function's documentation string mentions the value of an
     argument of the function, use the argument name in capital letters
     as if it were a name for that value.  Thus, the documentation
     string of the operator `/' refers to its second argument as
     `DIVISOR', because the actual argument name is `divisor'.

     Also use all caps for meta-syntactic variables, such as when you
     show the decomposition of a list or vector into subunits, some of
     which may vary.


File: octave.info,  Node: Comment Tips,  Next: Function Headers,  Prev: Documentation Tips,  Up: Tips

Tips on Writing Comments
========================

   Here are the conventions to follow when writing comments.

`#'
     Comments that start with a single sharp-sign, `#', should all be
     aligned to the same column on the right of the source code.  Such
     comments usually explain how the code on the same line does its
     job.  In the Emacs mode for Octave, the `M-;'
     (`indent-for-comment') command automatically inserts such a `#' in
     the right place, or aligns such a comment if it is already present.

`##'
     Comments that start with two semicolons, `##', should be aligned to
     the same level of indentation as the code.  Such comments usually
     describe the purpose of the following lines or the state of the
     program at that point.

The indentation commands of the Octave mode in Emacs, such as `M-;'
(`indent-for-comment') and `TAB' (`octave-indent-line') automatically
indent comments according to these conventions, depending on the number
of semicolons.  *Note Manipulating Comments: (emacs)Comments.


File: octave.info,  Node: Function Headers,  Prev: Comment Tips,  Up: Tips

Conventional Headers for Octave Functions
=========================================

   Octave has conventions for using special comments in function files
to give information such as who wrote them.  This section explains these
conventions.

   The top of the file should contain a copyright notice, followed by a
block of comments that can be used as the help text for the function.
Here is an example:

     ## Copyright (C) 1996 John W. Eaton
     ##
     ## This file is part of Octave.
     ##
     ## Octave is free software; you can redistribute it and/or
     ## modify it under the terms of the GNU General Public
     ## License as published by the Free Software Foundation;
     ## either version 2, or (at your option) any later version.
     ##
     ## Octave is distributed in the hope that it will be useful,
     ## but WITHOUT ANY WARRANTY; without even the implied
     ## warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     ## PURPOSE.  See the GNU General Public License for more
     ## details.
     ##
     ## You should have received a copy of the GNU General Public
     ## License along with Octave; see the file COPYING.  If not,
     ## write to the Free Software Foundation, 59 Temple Place -
     ## Suite 330, Boston, MA 02111-1307, USA.
     
     ## usage: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     ##
     ## Start a subprocess with two-way communication.  COMMAND
     ## specifies the name of the command to start.  ARGS is an
     ## array of strings containing options for COMMAND.  IN and
     ## OUT are the file ids of the input and streams for the
     ## subprocess, and PID is the process id of the subprocess,
     ## or -1 if COMMAND could not be executed.
     ##
     ## Example:
     ##
     ##  [in, out, pid] = popen2 ("sort", "-nr");
     ##  fputs (in, "these\nare\nsome\nstrings\n");
     ##  fclose (in);
     ##  while (isstr (s = fgets (out)))
     ##    fputs (stdout, s);
     ##  endwhile
     ##  fclose (out);

   Octave uses the first block of comments in a function file that do
not appear to be a copyright notice as the help text for the file.  For
Octave to recognize the first comment block as a copyright notice, it
must match the regular expression

     ^ Copyright (C).*\n\n This file is part of Octave.

or

     ^ Copyright (C).*\n\n This program is free softwar

(after stripping the leading comment characters).  This is a fairly
strict requirement, and may be relaxed somewhat in the future.

   After the copyright notice and help text come several "header
comment" lines, each beginning with `## HEADER-NAME:'.  For example,

     ## Author: jwe
     ## Keywords: subprocesses input-output
     ## Maintainer: jwe

   Here is a table of the conventional possibilities for HEADER-NAME:

`Author'
     This line states the name and net address of at least the principal
     author of the library.

          ## Author: John W. Eaton <jwe@bevo.che.wsic.edu>

`Maintainer'
     This line should contain a single name/address as in the Author
     line, or an address only, or the string `jwe'.  If there is no
     maintainer line, the person(s) in the Author field are presumed to
     be the maintainers.  The example above is mildly bogus because the
     maintainer line is redundant.

     The idea behind the `Author' and `Maintainer' lines is to make
     possible a function to "send mail to the maintainer" without
     having to mine the name out by hand.

     Be sure to surround the network address with `<...>' if you
     include the person's full name as well as the network address.

`Created'
     This optional line gives the original creation date of the file.
     For historical interest only.

`Version'
     If you wish to record version numbers for the individual Octave
     program, put them in this line.

`Adapted-By'
     In this header line, place the name of the person who adapted the
     library for installation (to make it fit the style conventions, for
     example).

`Keywords'
     This line lists keywords.  Eventually, it will be used by an
     apropos command to allow people will find your package when
     they're looking for things by topic area.  To separate the
     keywords, you can use spaces, commas, or both.

   Just about every Octave function ought to have the `Author' and
`Keywords' header comment lines.  Use the others if they are
appropriate.  You can also put in header lines with other header
names--they have no standard meanings, so they can't do any harm.


File: octave.info,  Node: Trouble,  Next: Installation,  Prev: Tips,  Up: Top

Known Causes of Trouble
***********************

   This section describes known problems that affect users of Octave.
Most of these are not Octave bugs per se--if they were, we would fix
them.  But the result for a user may be like the result of a bug.

   Some of these problems are due to bugs in other software, some are
missing features that are too much work to add, and some are places
where people's opinions differ as to what is best.

* Menu:

* Actual Bugs::                 Bugs we will fix later.
* Reporting Bugs::
* Bug Criteria::
* Bug Lists::
* Bug Reporting::
* Sending Patches::
* Service::


File: octave.info,  Node: Actual Bugs,  Next: Reporting Bugs,  Prev: Trouble,  Up: Trouble

Actual Bugs We Haven't Fixed Yet
================================

   * Output that comes directly from Fortran functions is not sent
     through the pager and may appear out of sequence with other output
     that is sent through the pager.  One way to avoid this is to force
     pending output to be flushed before calling a function that will
     produce output from within Fortran functions.  To do this, use the
     command

          fflush (stdout)

     Another possible workaround is to use the command

          page_screen_output = "false"

     to turn the pager off.

   * If you get messages like

          Input line too long

     when trying to plot many lines on one graph, you have probably
     generated a plot command that is too larger for `gnuplot''s
     fixed-length buffer for commands.  Splitting up the plot command
     doesn't help because replot is implemented in gnuplot by simply
     appending the new plotting commands to the old command line and
     then evaluating it again.

     You can demonstrate this `feature' by running gnuplot and doing
     something like

            plot sin (x), sin (x), sin (x), ... lots more ..., sin (x)

     and then

            replot sin (x), sin (x), sin (x), ... lots more ..., sin (x)

     after repeating the replot command a few times, gnuplot will give
     you an error.

     Also, it doesn't help to use backslashes to enter a plot command
     over several lines, because the limit is on the overall command
     line length, once the backslashed lines are all pasted together.

     Because of this, Octave tries to use as little of the command-line
     length as possible by using the shortest possible abbreviations for
     all the plot commands and options.  Unfortunately, the length of
     the temporary file names is probably what is taking up the most
     space on the command line.

     You can buy a little bit of command line space by setting the
     environment variable `TMPDIR' to be "." before starting Octave, or
     you can increase the maximum command line length in gnuplot by
     changing the following limits in the file plot.h in the gnuplot
     distribution and recompiling gnuplot.

          #define MAX_LINE_LEN 32768  /* originally 1024 */
          #define MAX_TOKENS 8192     /* originally 400 */

     Of course, this doesn't really fix the problem, but it does make it
     much less likely that you will run into trouble unless you are
     putting a very large number of lines on a given plot.

   A list of ideas for future enhancements is distributed with Octave.
See the file `PROJECTS' in the top level directory in the source
distribution.

