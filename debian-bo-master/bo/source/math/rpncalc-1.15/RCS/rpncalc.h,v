head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	97.01.19.19.00.59;	author david;	state Rel;
branches;
next	1.2;

1.2
date	96.10.26.15.15.26;	author david;	state Rel;
branches;
next	1.1;

1.1
date	96.07.13.20.54.40;	author david;	state Rel;
branches;
next	1.0;

1.0
date	95.12.31.18.18.10;	author david;	state Rel;
branches;
next	;


desc
@Added operation completion prototypes; renaming of 'times' due to linting.
@


1.3
log
@Provided all declarations of all functions and moved cmdtab[] into rpncalc.c
@
text
@/************************************************************************
 * rpncalc.h								*
 *									*
 * Refer to rpncalc.c for copyrights and license permissions.           *
 ************************************************************************/

/* $Id: rpncalc.h,v 1.3 1997/01/19 18:19:23 david Exp $
 * $Log: rpncalc.h,v $
 * Revision 1.3  1997/01/19 18:19:23  david
 * Provided all declarations; moved cmdtab into rpncalc.c
 *
 * Revision 1.1  1996/07/13 20:54:40  david
 * Added operator completion prototypes; renaming of times due to linting.
 * ,
 *
 * Revision 1.0  1995/12/31 18:18:10  david
 * Initial revision
 *
 * Revision 1.0  1995/12/31 18:17:22  david
 * Initial revision
 *
 * Revision 1.2  1995/11/25 21:59:51  david
 * Cleaned up the cmd table. The stack operations have now the right
 * value in the cmd->argno field; even at the expense of superfluous
 * push/pops, unfortunately.
 * */

#ifdef HAVE_READLINE
char *command_generator(char *text, int state);
char **rpncalc_completion(char *text, int start, int end);
void initialize_readline(int interactive);
#endif
@


1.2
log
@Changes in order to make rpncalc compile under SunOs 5.5
@
text
@d4 1
a4 19
 * A little RPN (Reverse Polish Notation) calculator,                   *
 * rudimentary emulating a HP 28S  					*
 * 									*
 * rpncalc is (c) David Frey, 1993, 1994, 1995				*
 * 									*
 * This program is free software; you can redistribute it and/or modify *
 * it under the terms of the GNU General Public License as published by *
 * the Free Software Foundation; either version 2 of the License, or    *
 * (at your option) any later version.                                  *
 *									* 
 * This program is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
 * GNU General Public License for more details.                         *
 *									* 
 * You should have received a copy of the GNU General Public License    *
 * along with this program; if not, write to the Free Software          *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
 *									* 
d7 1
a7 1
/* $Id: rpncalc.h,v 1.1 1996/07/13 20:54:40 david Rel $
d9 3
a27 139
#include <math.h>

#ifndef linux
extern double pow10(double y);
extern double pow2(double y);
#endif

extern double push(double elem);
extern double pop(void);
extern double pick(double op1);
extern double drop(void);
extern double dupel(double d);
extern double dupel2(double d);
extern double dupn(double n, double d);
extern double dropn(double n);
extern double clear(void);
extern double over(void);
extern double depth(void);
extern double swap(void);
extern double roll(void);
extern double showstack(void);
extern double sethex(void);
extern double setdec(void);
extern double setoct(void);
extern double pi(void);
extern double e(void);
extern double chs(double f);
extern double sqr(double f);
extern double inv(double f);
extern double log2(double f);
extern double fact(double n);
extern double prec(double p);
extern double not(double l);
extern double plus(double s1, double s2);
extern double minus(double s, double m);
extern double multiply(double f1, double f2);
extern double divide(double n, double d);
extern double idiv(double n, double d);
extern double mod(double n, double d);
extern double gcd(double n, double d);
extern double and(double l1, double l2);
extern double or(double l1, double l2);
extern double xor(double l1, double l2);
extern double sum(void);
extern double prod(void);
extern double help(void);
extern double warranty(void);

/* The idea of the following was taken out of the Bison Manual p. 31 */
/* Sorting and lsearch out of iX 11/1995 */
struct cmd 
{
  char *fname;
  short argno;			/* 0..2: no of arguments */
  short pushrestostack;
  double  (*fnct)();
};

struct cmd cmdtab[] =
{
  { "show"    , 0, 0, showstack },
  { "push"    , 1, 0, push      },
  { "pop"     , 0, 0, pop       },
  { "pick"    , 1, 1, pick      },
  { "swap"    , 0, 0, swap      },
  { "over"    , 0, 0, over      },
  { "roll"    , 0, 0, roll      },
  { "dup"     , 1, 0, dupel     },
  { "dup2"    , 1, 0, dupel2    },
  { "dupn"    , 2, 0, dupn      },
  { "drop"    , 0, 0, drop      },
  { "dropn"   , 1, 0, dropn     },
  { "depth"   , 0, 1, depth     },
  { "prec"    , 1, 0, prec      },
  { "clear"   , 0, 0, clear     },
  { "chs"     , 1, 1, chs       },
  { "+"       , 2, 1, plus      },
  { "-"       , 2, 1, minus     },
  { "*"       , 2, 1, multiply  },
  { "/"       , 2, 1, divide    },
  { "^"       , 2, 1, pow       },
  { "inv"     , 1, 1, inv       },
  { "sqrt"    , 1, 1, sqrt      }, 
  { "sqr"     , 1, 1, sqr       },
  { "sin"     , 1, 1, sin       },
  { "cos"     , 1, 1, cos       },
  { "tan"     , 1, 1, tan       },
  { "asin"    , 1, 1, asin      },
  { "acos"    , 1, 1, acos      },
  { "atan"    , 1, 1, atan      },
  { "atan2"   , 2, 1, atan2     },
  { "sinh"    , 1, 1, sinh      },
  { "cosh"    , 1, 1, cosh      },
  { "tanh"    , 1, 1, tanh      }, 
  { "asinh"   , 1, 1, asinh     },
  { "acosh"   , 1, 1, acosh     },
  { "atanh"   , 1, 1, atanh     },
  { "ln"      , 1, 1, log       },
  { "log"     , 1, 1, log10     },
  { "ld"      , 1, 1, log2      },
  { "exp"     , 1, 1, exp       },
  { "alog"    , 1, 1, pow10     },
  { "shl"     , 1, 1, pow2      },
  { "j0"      , 1, 1, j0        },
  { "j1"      , 1, 1, j1        },
  { "jn"      , 2, 1, jn        },
  { "y0"      , 1, 1, y0        },
  { "y1"      , 1, 1, y1        },
  { "yn"      , 2, 1, yn        },
  { "erf"     , 1, 1, erf       },
  { "erfc"    , 1, 1, erfc      },
  { "lgamma"  , 1, 1, lgamma    },
  { "abs"     , 1, 1, fabs      },
  { "ceil"    , 1, 1, ceil      },
  { "fact"    , 1, 1, fact      },
  { "mod"     , 2, 1, mod       },
  { "div"     , 2, 1, idiv      },
  { "gcd"     , 2, 1, gcd       },
  { "sum"     , 0, 1, sum       },	/* special case, takes all elements */
  { "prod"    , 0, 1, prod      },	/* special case, takes all elements */
  { "hex"     , 0, 0, sethex    },
  { "dec"     , 0, 0, setdec    },
  { "oct"     , 0, 0, setoct    },
  { "and"     , 2, 1, and       },
  { "&"       , 2, 1, and       },
  { "or"      , 2, 1, or        },
  { "|"       , 2, 1, or        },
  { "xor"     , 2, 1, xor       },	/* ^ for XOR would be irritating */
  { "not"     , 1, 1, not       },
  { "!"       , 1, 1, not       },
  { "pi"      , 0, 1, pi        },
  { "e"       , 0, 1, e         },
  { "help"    , 0, 0, help      },
  { "?"       , 0, 0, help      },
  { "warranty", 0, 0, warranty  },
};

#define NCMDTAB (sizeof cmdtab / sizeof cmdtab[0])

d30 2
a31 1
char **rpncalc_completion();
@


1.1
log
@Added operator completion prototypes; renaming of times due to linting.
,
@
text
@d25 1
a25 1
/* $Id: rpncalc.h,v 1.0 1995/12/31 18:18:10 david Rel david $
d27 4
d45 5
a185 1

@


1.0
log
@Initial revision
@
text
@d25 1
a25 1
/* $Id: rpncalc.h,v 1.0 1995/12/31 18:17:22 david Exp david $
d27 3
d39 1
a39 1
#define LINEFRAGMENT 32		/* allocate 32 bytes at a time */
d69 1
a69 1
extern double times(double f1, double f2);
d92 1
a92 1
static struct cmd cmdtab[] =
d112 1
a112 1
  { "*"       , 2, 1, times     },
d172 6
@


1.0
log
@Initial revision
@
text
@/************************************************************************
 * rpncalc.h								*
 *									*
 * A little RPN (Reverse Polish Notation) calculator,                   *
 * rudimentary emulating a HP 28S  					*
 * 									*
 * rpncalc is (c) David Frey, 1993, 1994, 1995				*
 * 									*
 * This program is free software; you can redistribute it and/or modify *
 * it under the terms of the GNU General Public License as published by *
 * the Free Software Foundation; either version 2 of the License, or    *
 * (at your option) any later version.                                  *
 *									* 
 * This program is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
 * GNU General Public License for more details.                         *
 *									* 
 * You should have received a copy of the GNU General Public License    *
 * along with this program; if not, write to the Free Software          *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
 *									* 
 ************************************************************************/

/* $Id: calc.h,v 1.2 1995/11/25 21:59:51 david Rel david $
 * $Log: calc.h,v $
 * Revision 1.2  1995/11/25 21:59:51  david
 * Cleaned up the cmd table. The stack operations have now the right
 * value in the cmd->argno field; even at the expense of superfluous
 * push/pops, unfortunately.
 * */

#define LINEFRAGMENT 32		/* allocate 32 bytes at a time */

extern double push(double elem);
extern double pop(void);
extern double pick(double op1);
extern double drop(void);
extern double dupel(double d);
extern double dupel2(double d);
extern double dupn(double n, double d);
extern double dropn(double n);
extern double clear(void);
extern double over(void);
extern double depth(void);
extern double swap(void);
extern double roll(void);
extern double showstack(void);
extern double sethex(void);
extern double setdec(void);
extern double setoct(void);
extern double pi(void);
extern double e(void);
extern double chs(double f);
extern double sqr(double f);
extern double inv(double f);
extern double log2(double f);
extern double fact(double n);
extern double prec(double p);
extern double not(double l);
extern double plus(double s1, double s2);
extern double minus(double s, double m);
extern double times(double f1, double f2);
extern double divide(double n, double d);
extern double idiv(double n, double d);
extern double mod(double n, double d);
extern double gcd(double n, double d);
extern double and(double l1, double l2);
extern double or(double l1, double l2);
extern double xor(double l1, double l2);
extern double sum(void);
extern double prod(void);
extern double help(void);
extern double warranty(void);

/* The idea of the following was taken out of the Bison Manual p. 31 */
/* Sorting and lsearch out of iX 11/1995 */
struct cmd 
{
  char *fname;
  short argno;			/* 0..2: no of arguments */
  short pushrestostack;
  double  (*fnct)();
};

static struct cmd cmdtab[] =
{
  { "show"    , 0, 0, showstack },
  { "push"    , 1, 0, push      },
  { "pop"     , 0, 0, pop       },
  { "pick"    , 1, 1, pick      },
  { "swap"    , 0, 0, swap      },
  { "over"    , 0, 0, over      },
  { "roll"    , 0, 0, roll      },
  { "dup"     , 1, 0, dupel     },
  { "dup2"    , 1, 0, dupel2    },
  { "dupn"    , 2, 0, dupn      },
  { "drop"    , 0, 0, drop      },
  { "dropn"   , 1, 0, dropn     },
  { "depth"   , 0, 1, depth     },
  { "prec"    , 1, 0, prec      },
  { "clear"   , 0, 0, clear     },
  { "chs"     , 1, 1, chs       },
  { "+"       , 2, 1, plus      },
  { "-"       , 2, 1, minus     },
  { "*"       , 2, 1, times     },
  { "/"       , 2, 1, divide    },
  { "^"       , 2, 1, pow       },
  { "inv"     , 1, 1, inv       },
  { "sqrt"    , 1, 1, sqrt      }, 
  { "sqr"     , 1, 1, sqr       },
  { "sin"     , 1, 1, sin       },
  { "cos"     , 1, 1, cos       },
  { "tan"     , 1, 1, tan       },
  { "asin"    , 1, 1, asin      },
  { "acos"    , 1, 1, acos      },
  { "atan"    , 1, 1, atan      },
  { "atan2"   , 2, 1, atan2     },
  { "sinh"    , 1, 1, sinh      },
  { "cosh"    , 1, 1, cosh      },
  { "tanh"    , 1, 1, tanh      }, 
  { "asinh"   , 1, 1, asinh     },
  { "acosh"   , 1, 1, acosh     },
  { "atanh"   , 1, 1, atanh     },
  { "ln"      , 1, 1, log       },
  { "log"     , 1, 1, log10     },
  { "ld"      , 1, 1, log2      },
  { "exp"     , 1, 1, exp       },
  { "alog"    , 1, 1, pow10     },
  { "shl"     , 1, 1, pow2      },
  { "j0"      , 1, 1, j0        },
  { "j1"      , 1, 1, j1        },
  { "jn"      , 2, 1, jn        },
  { "y0"      , 1, 1, y0        },
  { "y1"      , 1, 1, y1        },
  { "yn"      , 2, 1, yn        },
  { "erf"     , 1, 1, erf       },
  { "erfc"    , 1, 1, erfc      },
  { "lgamma"  , 1, 1, lgamma    },
  { "abs"     , 1, 1, fabs      },
  { "ceil"    , 1, 1, ceil      },
  { "fact"    , 1, 1, fact      },
  { "mod"     , 2, 1, mod       },
  { "div"     , 2, 1, idiv      },
  { "gcd"     , 2, 1, gcd       },
  { "sum"     , 0, 1, sum       },	/* special case, takes all elements */
  { "prod"    , 0, 1, prod      },	/* special case, takes all elements */
  { "hex"     , 0, 0, sethex    },
  { "dec"     , 0, 0, setdec    },
  { "oct"     , 0, 0, setoct    },
  { "and"     , 2, 1, and       },
  { "&"       , 2, 1, and       },
  { "or"      , 2, 1, or        },
  { "|"       , 2, 1, or        },
  { "xor"     , 2, 1, xor       },	/* ^ for XOR would be irritating */
  { "not"     , 1, 1, not       },
  { "!"       , 1, 1, not       },
  { "pi"      , 0, 1, pi        },
  { "e"       , 0, 1, e         },
  { "help"    , 0, 0, help      },
  { "?"       , 0, 0, help      },
  { "warranty", 0, 0, warranty  },
};

#define NCMDTAB (sizeof cmdtab / sizeof cmdtab[0])
@
