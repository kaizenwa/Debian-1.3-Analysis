head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	97.01.19.20.01.18;	author david;	state Rel;
branches;
next	1.4;

1.4
date	97.01.19.18.49.47;	author david;	state Rel;
branches;
next	1.3;

1.3
date	96.10.26.15.15.26;	author david;	state Rel;
branches;
next	1.2;

1.2
date	96.09.13.20.21.29;	author david;	state Rel;
branches;
next	1.1;

1.1
date	96.07.13.20.49.35;	author david;	state Rel;
branches;
next	1.0;

1.0
date	95.12.31.18.21.07;	author david;	state Rel;
branches;
next	;


desc
@Simple rpn calculator, tries to emulate a HP28.
The commands itselves
@


1.5
log
@FreeBSD `port': Added #define EOVERFLOW ERANGE.
@
text
@/************************************************************************
 * cmds.c -- part of rpncalc.c						*
 *									*
 * Refer to rpncalc.c for copyrights and license permissions.           *
 ************************************************************************/

/* $Id: cmds.c,v 1.4 1997/01/19 18:49:47 david Rel david $
 * $Log: cmds.c,v $
 * Revision 1.4  1997/01/19 18:49:47  david
 * Removed some casts to make gcc -Wall -W... happy.
 *
 * Revision 1.4  1997/01/19 18:19:23  david
 * Removed some casts to make gcc -Wall -W... happy.
 *
 * Revision 1.2  1996/09/13 20:21:29  david
 * lclint additions
 *
 * Revision 1.1  1996/07/13 20:49:35  david
 * Cleanup and renaming due to linting of the source.
 *
 * Revision 1.0  1995/12/31 18:21:07  david
 * Initial revision
 * */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>
#include <limits.h>

#include "cmds.h"

extern int errno;
extern int pushtostack;
extern int digits;
extern enum BASE base;

static double res;

/* -------------------------------------------------------- constants */

double pi(void) { return M_PI; }

double e(void)  { return M_E; }

/* -------------------------------------------------------- unary operators */
#ifndef linux
double pow10(double y) { return pow(10,y); }

double pow2(double y)  { return pow(2,y); }
#endif

#ifdef freebsd
#define EOVERFLOW ERANGE
#endif

double chs(double f)   { return -f; }

double sqr(double f)   { return f * f; }

double inv(double f)
{
  if (f != 0)   res = 1 / f;
  else          { res = HUGE_VAL; errno = ERANGE; }	    
  return res;
}

double log2(double f)  { return log(f) / M_LN2; }

double fact(double d)
{
  long int i, n;

  n=(long int)d;
  if (n < 0)
  {
    fprintf(stderr, "defined only for arguments >= 0.\n");
    pushtostack=0;
  }
  else 
  {
    if ((n == 0) || (n == 1)) res = 1;
    else
    {
      res = 1;
      for (i = n; i > 1; i--) res *= i;
    }
  }
  return res;
}

double prec(double p)
{
  digits=ceil(p); pushtostack=0;
  return 0.0; /* dummy value */
}

double not(double l) { return (double)(~(long int)l); }

/* ------------------------------------------------------- binary operators */

double plus(double s1, double s2) { return s1 + s2; }

double minus(double s, double m)  { return  s-m; }

double multiply(double f1, double f2) { return f1 * f2; }

double divide(double n, double d)
{
  if (d != 0) res = n / d;
  else      { res = HUGE_VAL; errno = ERANGE; }	    
  return res;
}

#ifndef sunos4
static ldiv_t quotrem;

double idiv(double dn, double dd)
{
  long int n, d;

  n=(long int)dn; d=(long int)dd;
  if ((n <= LONG_MAX) && (d <= LONG_MAX))
  {
    if (d != 0)
    {
      quotrem = ldiv(n,d); 
      res = (double)quotrem.quot;
    }
    else
    { 
      res = HUGE_VAL; errno = ERANGE; 
    }	 
  }
  else
  { 
    errno = EOVERFLOW; pushtostack=0;
  }	    
  return res;
}
#else
double idiv(double dn, double dd)
{
  long int n, d;

  res=(long)(n/d);
  return res;
}
#endif

#ifndef sunos4
double mod(double dn, double dd)
{
 long int n, d;

 n=(long int)dn; d=(long int)dd;
 if ((n <= LONG_MAX) && (d <= LONG_MAX))
 {
   if (d != 0)
   {
     quotrem = ldiv(n,d);
     res = (double)quotrem.rem;  
   }
   else
   { 
     res = HUGE_VAL; errno = ERANGE; 
   }	    
 }
 else
 {	
   errno = EOVERFLOW; pushtostack=0;
 }	    
 return res;
}
#else
double mod(double dn, double dd)
{
 res=fmod(dn, dd);
 return res;
}
#endif

/* Stein's Greatest Common Divisor (GCD) algorithm */
long int stein(double d1, double d2)
{
  long int n1, n2;
  long int d;				 /* difference */
  long int c;				 /* c: shift-count (see below) */
  long int t;				 /* temporary */

  c = 0; n1=(long int)d1; n2=(long int)d2;
  /* both integers are even; shift them until one gets odd. */
  while (((n1 & 1) == 0) && ((n2 & 1) == 0))
  {
    n1 >>= 1; n2 >>= 1;  c++;
  }

  do
  {
    if ((n2 & 1) == 0) { t = n1; n1 = n2; n2 = t; }
    
    while ((n1 & 1) == 0)
      n1 >>= 1;

    /*
     * shift n1 until it gets odd.
     */
    d = n1 - n2;
    if (d < 0) { n2 = n1; d = -d; }
    n1 = d >> 1;
  }
  while (n1 > 0);

  return (n2 * (1 << c));
}

double gcd(double dn, double dd)
{
  long int n, d;

  n=(long int)dn; d=(long int)dd;
  if ((n <= LONG_MAX) && (d <= LONG_MAX))
  {
    if (d != 0) res = stein(dn,dd);
    else      { res = HUGE_VAL; errno = ERANGE; }
  }
  else
  {
#ifndef sunos4	      
    errno = EOVERFLOW;	
#endif
    pushtostack = 0;
  }
  return res;
}

double and(double l1, double l2)
{
  return (double)((long int)l1 & (long int)l2);
}

double or(double l1, double l2)
{
  return (double)((long int)l1 | (long int)l2);
}

double xor(double l1, double l2)
{
  return (double)((long int)l1 ^ (long int)l2);
}

/* ------------------------------------------------------- n-ary operators */
double sum(void)
{
  long int i,n;

  n = depth(); res = 0;
  for(i=1;i<=n;i++) res += pick((double)i);
  return res;
}

double prod(void)
{
  long int i,n;

  n = depth(); res = 1;
  for(i=1;i<=n;i++) res *= pick((double)i);
  return res;
}
@


1.4
log
@Removed some casts to make gcc -Wall -W... happy.
@
text
@d7 1
a7 1
/* $Id: cmds.c,v 1.4 1997/01/19 18:19:23 david Exp david $
d9 3
d53 4
d115 1
a115 1
#ifndef sun_sunos4
d151 1
a151 1
#ifndef sun_sunos4
d229 1
a229 1
#ifndef sun_sunos4	      
@


1.3
log
@Changes in order to make rpncalc compile under SunOs 5.5
@
text
@d4 1
a4 19
 * A little RPN (Reverse Polish Notation) calculator,                   *
 * rudimentary emulating a HP 28S. 					*
 * 								        *
 * rpncalc is (c) David Frey, 1993, 1994, 1995				*
 *								        * 
 * This program is free software; you can redistribute it and/or modify *
 * it under the terms of the GNU General Public License as published by *
 * the Free Software Foundation; either version 2 of the License, or    *
 * (at your option) any later version.                                  *
 *									* 
 * This program is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
 * GNU General Public License for more details.                         *
 *									* 
 * You should have received a copy of the GNU General Public License    *
 * along with this program; if not, write to the Free Software          *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
 *									* 
d7 1
a7 1
/* $Id: cmds.c,v 1.2 1996/09/13 20:21:29 david Rel $
d9 3
d39 1
a39 4
double pi(void)
{
  return M_PI;
}
d41 1
a41 4
double e(void)
{
  return M_E;
}
d45 1
a45 4
double pow10(double y)
{
  return pow(10,y);
}
d47 1
a47 4
double pow2(double y)
{
  return pow(2,y);
}
d50 1
a50 4
double chs(double f)
{
  return -f;
}
d52 1
a52 4
double sqr(double f)
{
  return f * f;
}
d61 1
a61 4
double log2(double f)
{
  return log(f) / M_LN2;
}
d87 1
a87 1
  digits=(int)ceil(p); pushtostack=0;
d91 1
a91 4
double not(double l)
{
  return (double)(~(long int)l);
}
d95 1
a95 4
double plus(double s1, double s2)
{
  return s1 + s2;
}
d97 1
a97 4
double minus(double s, double m)
{
  return  s-m;
}
d99 1
a99 4
double multiply(double f1, double f2)
{
  return f1 * f2;
}
d108 1
d120 1
a120 1
      quotrem = ldiv((long int)n,(long int)d); 
d134 9
d144 1
d154 1
a154 1
     quotrem = ldiv((long int)n,(long int)d);
d168 7
d177 1
a177 1
static long int stein(double d1, double d2)
d217 1
a217 1
    if (d != 0) res = (double)stein(dn,dd);
d221 6
a226 3
  {	      
    errno = EOVERFLOW;	pushtostack = 0;
  }	    
d250 1
a250 1
  n = (long int)depth(); res = 0;
d259 1
a259 1
  n = (long int)depth(); res = 1;
@


1.2
log
@lclint additions
@
text
@d25 1
a25 1
/* $Id: cmds.c,v 1.1 1996/07/13 20:49:35 david Rel david $
d27 3
d65 11
@


1.1
log
@Cleanup and renaming due to linting of the source.
@
text
@d25 1
a25 1
/* $Id: cmds.c,v 1.0 1995/12/31 18:21:07 david Rel david $
d27 3
d85 1
a85 1
double fact(double n)
d87 1
a87 1
  int i;
d89 1
d93 1
a93 1
    pushtostack=FALSE;
d109 1
a109 1
  digits=p; pushtostack=FALSE;
d144 1
a144 1
double idiv(double n, double d)
d146 3
d154 1
a154 1
      res = quotrem.quot;
d163 1
a163 1
    errno = EOVERFLOW; pushtostack=FALSE;
d168 1
a168 1
double mod(double n, double d)
d170 3
d178 1
a178 1
     res = quotrem.rem;  
d187 1
a187 1
   errno = EOVERFLOW; pushtostack=FALSE;
d226 1
a226 1
double gcd(double n, double d)
d228 3
d233 1
a233 1
    if (d != 0) res = stein(n,d);
d238 1
a238 1
    errno = EOVERFLOW;	pushtostack = FALSE;
d261 1
a261 1
  int i,n;
d263 2
a264 2
  n = depth(); res = 0;
  for(i=1;i<=n;i++) res += pick(i);
d270 1
a270 1
  int i,n;
d272 2
a273 2
  n = depth(); res = 1;
  for(i=1;i<=n;i++) res *= pick(i);
@


1.0
log
@Initial revision
@
text
@d25 5
a29 2
/* $Id$
 * $Log$ */
d44 1
a44 1
double res;
d126 1
a126 1
double times(double f1, double f2)
d138 1
a138 1
ldiv_t quotrem;
d183 1
a183 1
long int stein(double d1, double d2)
a245 2
int i,n;

d248 2
d257 2
@
