<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 475 pri 0"><a name="ref 476 pri 0"><center><h3><a name="section 4.9.6">
Section 4.9.6<br>Average Function</h3></center>
Now things get interesting. Above, we began to see how pigments and normals can fade from one to the other when we used them in maps. But how about if we want a smooth blend of patterns all the way through? That is where a new feature called <strong>average</strong> can come in very handy. Average works with pigment, normal, and texture maps, although the syntax is a little bit different, and when we are not expecting it, the change can be confusing. Here is a simple example. We use our standard includes, camera and light source from above, and enter the following object.<p>
<listing>
  plane { -z, 0
    pigment { White }
    normal {
      average
      normal_map {
        [ gradient x ]
        [ gradient y ]
      }
    }
  }
</listing>
<p>
What we have done here is pretty self explanatory as soon as we render it. We have combined a vertical with a horizontal gradient bump pattern, creating crisscrossing gradients. Actually, the crisscrossing effect is a smooth blend of gradient x with gradient y all the way across our plane. Now, what about that syntax difference?<p>
We see how our normal map has changed from earlier examples. The floating point value to the lefthand side of each map entry has been removed. That value usually helps in procedurally mapping each entry to the pattern we have selected, but average is a smooth blend all the way through, not a pattern, so it cannot use those values. In fact, including them may sometimes lead to unexpected results, such as entries being lost or misrepresented in some way. To ensure that we'll get the pattern blend we anticipate, we leave off the floating point value.<hr>
<a name="ref 477 pri 0"><a name="ref 478 pri 0"><center><h3><a name="section 4.9.7">
Section 4.9.7<br>Working With Layered Textures</h3></center>
With the multitudinous colors, patterns, and options for creating complex textures in POV-Ray, we can easily become deeply engrossed in mixing and tweaking just the right textures to apply to our latest creations. But as we go, sooner or later there is going to come that <strong>special</strong> texture. That texture that is sort of like wood, only varnished, and with a kind of spotty yellow streaking, and some vertical gray flecks, that looks like someone started painting over it all, and then stopped, leaving part of the wood visible through the paint.<p>
Only... now what? How do we get all that into one texture? No pattern can do that many things. Before we panic and say <strong>image map</strong> there is at least one more option: <strong>layered textures</strong>.<p>
With layered textures, we only need to specify a series of textures, one after the other, all associated with the same object. Each texture we list will be applied one on top of the other, from bottom to top in the order they appear.<p>
It is very important to note that we must have some degree of transparency (filter or transmit) in the pigments of our upper textures, or the ones below will get lost underneath. We won't receive a warning or an error - technically it is legal to do this: it just doesn't make sense. It is like spending hours sketching an elaborate image on a bare wall, then slapping a solid white coat of latex paint over it.<p>
Let's design a very simple object with a layered texture, and look at how it works. We create a file called <b>LAYTEX.POV</b> and add the following lines.<p>
<listing>
  #include &quot;colors.inc&quot;
  #include &quot;textures.inc&quot;

  camera {
    location &lt;0, 5, -30&gt;
    look_at &lt;0, 0, 0&gt;
  }

  light_source { &lt;-20, 30, -50&gt; color White }

  plane { y, 0 pigment { checker color Green color Yellow  } }

  background { rgb &lt;.7, .7, 1&gt; }

  box { &lt;-10, 0, -10&gt;, &lt;10, 10, 10&gt;
    texture {
      Silver_Metal // a metal object ...
      normal {     // ... which has suffered a beating
        dents 2
        scale 1.5
      }
    } // (end of base texture)

    texture { // ... has some flecks of rust ...
      pigment {
        granite
        color_map {
          [0.0 rgb &lt;.2, 0, 0&gt; ]
          [0.2 color Brown ]
          [0.2 rgbt &lt;1, 1, 1, 1&gt; ]
          [1.0 rgbt &lt;1, 1, 1, 1&gt; ]
        }
        frequency 16
      }
    } // (end rust fleck texture)

    texture { // ... and some sooty black marks
      pigment {
        bozo
        color_map {
          [0.0 color Black ]
          [0.2 color rgbt &lt;0, 0, 0, .5&gt; ]
          [0.4 color rgbt &lt;.5, .5, .5, .5&gt; ]
          [0.5 color rgbt &lt;1, 1, 1, 1&gt; ]
          [1.0 color rgbt &lt;1, 1, 1, 1&gt; ]
        }
        scale 3
      }
    } // (end of sooty mark texture)

  } // (end of box declaration)
</listing>
<p>
Whew. This gets complicated, so to make it easier to read, we have included comments showing what we are doing and where various parts of the declaration end (so we don't get lost in all those closing brackets!). To begin, we created a simple box over the classic checkerboard floor, and give the background sky a pale blue color. Now for the fun part...<p>
To begin with we made the box use the <strong>Silver_Metal</strong> texture as declared in textures.inc (for bonus points, look up <b>textures.inc</b> and see how this standard texture was originally created sometime). To give it the start of its abused state, we added the dents normal pattern, which creates the illusion of some denting in the surface as if our mysterious metal box had been knocked around quite a bit.<p>
The flecks of rust are nothing but a fine grain granite pattern fading from dark red to brown which then abruptly drops to fully transparent for the majority of the color map. True, we could probably come up with a more realistic pattern of rust using pigment maps to <strong>cluster</strong> rusty spots, but pigment maps are a subject for another tutorial section, so let's skip that just now.<p>
Lastly, we have added a third texture to the pot. The randomly shifting <strong>bozo</strong> texture gradually fades from blackened centers to semi-transparent medium gray, and then ultimately to fully transparent for the latter half of its color map. This gives us a look of sooty burn marks further marring the surface of the metal box. The final result leaves our mysterious metal box looking truly abused, using multiple texture patterns, one on top of the other, to produce an effect that no single pattern could generate!<hr>
<a name="ref 479 pri 0"><a name="ref 480 pri 0"><center><h3><a name="section 4.9.7.1">
Section 4.9.7.1<br>Declaring Layered Textures</h3></center>
In the event we want to reuse a layered texture on several objects in our scene, it is perfectly legal to declare a layered texture. We won't repeat the whole texture from above, but the general format would be something like this:<p>
<listing>
  #declare Abused_Metal =
    texture { /* insert your base texture here... */ }
    texture { /* and your rust flecks here... */ }
    texture { /* and of course, your sooty burn marks here */ }
</listing>
<p>
POV-Ray has no problem spotting where the declaration ends, because the textures follow one after the other with no objects or directives in between. The layered texture to be declared will be assumed to continue until it finds something other than another texture, so any number of layers can be added in to a declaration in this fashion.<p>
One final word about layered textures: whatever layered texture we create, whether declared or not, we must not leave off the texture <strong>wrapper</strong>. In conventional single textures a common shorthand is to have just a pigment, or just a pigment and finish, or just a normal, or whatever, and leave them outside of a texture statement. This shorthand does not extend to layered textures. As far as POV-Ray is concerned we can layer entire textures, but not individual pieces of textures. For example<p>
<listing>
  #declare Bad_Texture =
    texture { /* insert your base texture here... */ }
    pigment { Red filter .5 }
    normal { bumps 1 }
</listing>
<p>
will not work. The pigment and the normal are just floating there without being part of any particular texture. Inside an object, with just a single texture, we can do this sort of thing, but with layered textures, we would just generate an error whether inside the object or in a declaration.<hr>
<a name="ref 481 pri 0"><a name="ref 482 pri 0"><center><h3><a name="section 4.9.7.2">
Section 4.9.7.2<br>Another Layered Textures Example</h3></center>
To further explain how layered textures work another example is described in detail. A tablecloth is created to be used in a picnic scene. Since a simple red and white checked cloth looks entirely too new, too flat, and too much like a tiled floor, layered textures are used to <strong>stain</strong> the cloth.<p>
We're going to create a scene containing four boxes. The first box has that plain red and white texture we started with in our picnic scene, the second adds a layer meant to realistically fade the cloth, the third adds some wine stains, and the final box adds a few wrinkles (not another layer, but we must note when and where adding changes to the surface normal have an effect in layered textures).<p>
We start by placing a camera, some lights, and the first box. At this stage, the texture is plain tiling, not layered. See file <b>layered1.pov</b>.<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    location &lt;0, 0, -6&gt;
    look_at &lt;0, 0, 0&gt;
  }

  light_source { &lt;-20, 30, -100&gt; color White }
  light_source { &lt;10, 30, -10&gt; color White }
  light_source { &lt;0, 30, 10&gt; color White }

  #declare PLAIN_TEXTURE =
    // red/white check
    texture {
      pigment {
        checker
        color rgb&lt;1.000, 0.000, 0.000&gt;
        color rgb&lt;1.000, 1.000, 1.000&gt;
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }

  // plain red/white check box

  box { &lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;
    texture {
      PLAIN_TEXTURE
    }
    translate  &lt;-1.5, 1.2, 0&gt;
  }
</listing>
<p>
We render this scene. It is not particularly interesting, isn't it? That is why we will use some layered textures to make it more interesting.<p>
First, we add a layer of two different, partially transparent greys. We tile them as we had tiled the red and white colors, but we add some turbulence to make the fading more realistic. We add following box to the previous scene and re-render (see file <b>layered2.pov</b>).<p>
<listing>
  #declare FADED_TEXTURE =
    // red/white check texture
    texture {
      pigment {
        checker
        color rgb&lt;0.920, 0.000, 0.000&gt;
        color rgb&lt;1.000, 1.000, 1.000&gt;
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }
    // greys to fade red/white
    texture {
      pigment {
        checker
        color rgbf&lt;0.632, 0.612, 0.688, 0.698&gt;
        color rgbf&lt;0.420, 0.459, 0.520, 0.953&gt;
        turbulence 0.500
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }

  // faded red/white check box

  box { &lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;
    texture {
      FADED_TEXTURE
    }
    translate  &lt;1.5, 1.2, 0&gt;
  }
</listing>
<p>
Even though it is a subtle difference, the red and white checks no longer look quite so new.<p>
Since there is a bottle of wine in the picnic scene, we thought it might be a nice touch to add a stain or two. While this effect can almost be achieved by placing a flattened blob on the cloth, what we really end up with is a spill effect, not a stain. Thus it is time to add another layer.<p>
Again, we add another box to the scene we already have scripted and re-render (see file <b>layered3.pov</b>).<p>
<listing>
  #declare STAINED_TEXTURE =
    // red/white check
    texture {
      pigment {
        checker
        color rgb&lt;0.920, 0.000, 0.000&gt;
        color rgb&lt;1.000, 1.000, 1.000&gt;
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }
    // greys to fade check
    texture {
      pigment {
        checker
        color rgbf&lt;0.634, 0.612, 0.688, 0.698&gt;
        color rgbf&lt;0.421, 0.463, 0.518, 0.953&gt;
        turbulence 0.500
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }
    // wine stain
    texture {
      pigment {
        spotted
        color_map {
          [ 0.000  color rgb&lt;0.483, 0.165, 0.165&gt; ]
          [ 0.329  color rgbf&lt;1.000, 1.000, 1.000, 1.000&gt; ]
          [ 0.734  color rgbf&lt;1.000, 1.000, 1.000, 1.000&gt; ]
          [ 1.000  color rgb&lt;0.483, 0.165, 0.165&gt; ]
        }
        turbulence 0.500
        frequency 1.500
      }
    }

  // stained box

  box { &lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;
    texture {
      STAINED_TEXTURE
    }
    translate  &lt;-1.5, -1.2, 0&gt;
  }
</listing>
<p>
Now there's a tablecloth texture with personality.<p>
Another touch we want to add to the cloth are some wrinkles as if the cloth had been rumpled. This is not another texture layer, but when working with layered textures, we must keep in mind that changes to the surface normal must be included in the uppermost layer of the texture. Changes to lower layers have no effect on the final product (no matter how transparent the upper layers are).<p>
We add this final box to the script and re-render (see file <b>layered4.pov</b>)<p>
<listing>
  #declare WRINKLED_TEXTURE =
    // red and white check
    texture {
      pigment {
        checker
        color rgb&lt;0.920, 0.000, 0.000&gt;
        color rgb&lt;1.000, 1.000, 1.000&gt;
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }
    // greys to &quot;fade&quot; checks
    texture {
      pigment {
        checker
        color rgbf&lt;0.632, 0.612, 0.688, 0.698&gt;
        color rgbf&lt;0.420, 0.459, 0.520, 0.953&gt;
        turbulence 0.500
        scale &lt;0.2500, 0.2500, 0.2500&gt;
      }
    }
    // the wine stains
    texture {
      pigment {
        spotted
        color_map {
          [ 0.000  color rgb&lt;0.483, 0.165, 0.165&gt; ]
          [ 0.329  color rgbf&lt;1.000, 1.000, 1.000, 1.000&gt; ]
          [ 0.734  color rgbf&lt;1.000, 1.000, 1.000, 1.000&gt; ]
          [ 1.000  color rgb&lt;0.483, 0.165, 0.165&gt; ]
        }
        turbulence 0.500
        frequency 1.500
      }
      normal {
        wrinkles 5.0000
      }
    }

  // wrinkled box

  box { &lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;
    texture {
      WRINKLED_TEXTURE
    }
    translate  &lt;1.5, -1.2, 0&gt;
  }
</listing>
<p>
Well, this may not be the tablecloth we want at any picnic we're attending, but if we compare the final box to the first, we see just how much depth, dimension, and personality is possible just by the use of creative texturing.<p>
One final note: the comments concerning the surface normal do not hold true for finishes. If a <strong>lower</strong> layer contains a specular finish and an <strong>upper</strong> layer does not, any place where the upper layer is transparent, the specular will show through.<hr>
<a name="ref 483 pri 0"><a name="ref 484 pri 0"><center><h3><a name="section 4.9.8">
Section 4.9.8<br>When All Else Fails: Material Maps</h3></center>
We have some pretty powerful texturing tools at our disposal, but what if we want a more <strong>free form</strong> arrangement of complex textures? Well, just as image maps do for pigments, and bump maps do for normals, whole textures can be mapped using a material map, should the need arise.<p>
Just as with image maps and bump maps, we need a source image in bitmapped format which will be called by POV-Ray to serve as the map of where the individual textures will go, but this time, we need to specify what texture will be associated with which palette index. To make such an image, we can use a paint program which allows us to select colors by their palette index number (the actual color is irrelevant, since it is only a map to tell POV-Ray what texture will go at that location). Now, if we have the complete package that comes with POV-Ray, we have in our include files an image called <b>povmap.gif</b> which is a bitmapped image that uses only the first four palette indices to create a bordered square with the words <strong>Persistance of Vision</strong> in it. This will do just fine as a sample map for the following example. Using our same include files, the camera and light source, we enter the follow object.<p>
<listing>
  plane { -z, 0
    texture {
      material_map {
        gif &quot;povmap.gif&quot;
        interpolate 2
        once
        texture { PinkAlabaster }          // the inner border
        texture { pigment { DMFDarkOak } } // outer border
        texture { Gold_Metal }             // lettering
        texture { Chrome_Metal }           // the window panel
      }
      translate &lt;-0.5, -0.5, 0&gt;
      scale 5
    }
  }
</listing>
<p>
The position of the light source and the lack of foreground objects to be reflected do not show these textures off to their best advantage. But at least we can see how the process works. The textures have simply been placed according to the location of pixels of a particular palette index. By using the <strong>once</strong> keyword (to keep it from tiling), and translating and scaling our map to match the camera we have been using, we get to see the whole thing laid out for us.<p>
Of course, that is just with palette mapped image formats, such as GIF and certain flavors of PNG. Material maps can also use non-paletted formats, such as the TGA files that POV-Ray itself outputs. That leads to an interesting consquence: We can use POV-Ray to produce source maps for POV-Ray! Before we wrap up with some of the limitations of special textures, let's do one more thing with material maps, to show how POV-Ray can make its own source maps.<p>
To begin with, if using an non-paletted image, POV-Ray looks at the 8 bit red component of the pixel's color (which will be a value from 0 to 255) to determine which texture from the list to use. So to create a source map, we need to control very precisely what the red value of a given pixel will be. We can do this by<p>
<center><table border><tr><td valign=top>1.)</td><td valign=top>Using an rgb statement to choose our color such as rgb &lt;x/255, 0, 0&gt;, where &quot;x&quot; is the red value we want to assign that pigment, and then...</td></tr>
<tr><td valign=top>2.)</td><td valign=top>Use no light sources and apply a finish of finish { ambient 1 } to all objects, to ensure that highlighting and shadowing will not interfere.</td></tr>

</td></tr></table></center>

<p>
Confused? Alright, here is an example, which will generate a map very much like <b>povmap.gif</b> which we used earlier, except in TGA file format. We notice that we have given the pigments blue and green components too. POV-Ray will ignore that in our final map, so this is really for us humans, whose unaided eyes cannot tell the difference between red variances of 0 to 4/255ths. Without those blue and green variances, our map would look to our eyes like a solid black screen. That may be a great way to send secret messages using POV-Ray (plug it into a material map to decode) but it is no use if we want to see what our source map looks like to make sure we have what we expected to.<p>
We render the following code, and name the resulting file <b>povmap.tga</b>.<p>
<listing>
  camera {
    orthographic
    up &lt;0, 5, 0&gt;
    right &lt;5, 0, 0&gt;
    location &lt;0, 0, -25&gt;
    look_at &lt;0, 0, 0&gt;
  }

  plane { -z, 0
    pigment { rgb &lt;1/255, 0, 0.5&gt; }
    finish { ambient 1 }
  }

  box { &lt;-2.3, -1.8, -0.2&gt;, &lt;2.3, 1.8, -0.2&gt;
    pigment { rgb &lt;0/255, 0, 1&gt; }
    finish { ambient 1 }
  }

  box { &lt;-1.95, -1.3, -0.4&gt;, &lt;1.95, 1.3, -0.3&gt;
    pigment { rgb &lt;2/255, 0.5, 0.5&gt; }
    finish { ambient 1 }
  }

  text { ttf &quot;crystal.ttf&quot;, &quot;The vision&quot;, 0.1, 0
    scale &lt;0.7, 1, 1&gt;
    translate &lt;-1.8, 0.25, -0.5&gt;
    pigment { rgb &lt;3/255, 1, 1&gt; }
    finish { ambient 1 }
  }

  text { ttf &quot;crystal.ttf&quot;, &quot;Persists!&quot;, 0.1, 0
    scale &lt;0.7, 1, 1&gt;
    translate &lt;-1.5, -1, -0.5&gt;
    pigment { rgb &lt;3/255, 1, 1&gt; }
    finish { ambient 1 }
  }
</listing>
<p>
All we have to do is modify our last material map example by changing the material map from GIF to TGA and modifying the filename. When we render using the new map, the result is extremely similar to the pallette mapped GIF we used before, except that we didn't have to use an external paint program to generate our source: POV-Ray did it all!<hr>

<center>
<a href="pov30011.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
