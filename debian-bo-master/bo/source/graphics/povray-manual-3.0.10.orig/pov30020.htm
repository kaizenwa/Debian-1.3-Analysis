<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 1208 pri 0"><a name="ref 1209 pri 1"><center><h3><a name="section 7.5.2.6">
Section 7.5.2.6<br>Julia Fractal</h3></center>
A <a name="ref 1209 pri 1"><strong>julia fractal</strong> object is a 3-D <a name="ref 863 pri 1"><strong>slice</strong> of a 4-D object created by generalizing the process used to create the classic Julia sets. You can make a wide variety of strange objects using <a name="ref 870 pri 1"><strong>julia_fractal</strong>, including some that look like bizarre blobs of twisted taffy.<p>
The <a name="ref 870 pri 2"><strong>julia_fractal</strong> syntax (with default values listed in comments) is:<p>
<listing>
  julia_fractal {
    4DJULIA_PARAMETER                 // default is &lt;1,0,0,0&gt;
    [ quaternion | hypercomplex ]     // default is quaternion
    [ sqr | cube | exp |
      reciprocal | sin | asin |
      sinh | asinh | cos | acos |
      cosh | acosh | tan | atan |
      tanh | atanh | log | pwr(X,Y) ] // default is sqr
    [ max_iteration MAX_ITERATION ]   // default value 20
    [ precision PRECISION ]           // default value 20
    [ slice 4DNORMAL, DISTANCE ]      // default &lt;0,0,0,1&gt;,0
  }
</listing>
<p>
The 4-D vector <strong>4DJULIA_PARAMETER</strong> is the classic Julia parameter p in the iterated formula f(h) + p.<p>
The julia fractal object is calculated by using an algorithm that determines whether an arbitrary point h(0) in 4-D space is inside or outside the object. The algorithm requires generating the sequence of vectors h(0), h(1), ... by iterating the formula<p>
<pre>
  h(n+1) = f(h(n)) + p (n = 0, 1, ..., max_iteration-1)
</pre>
<p>
<a name="ref 910 pri 2">where p is the fixed 4-D vector parameter of the julia fractal and f() is one of the functions sqr, cube, ... specified by the presence of the corresponding keyword. The point h(0) that begins the sequence is considered inside the julia fractal object if none of the vectors in the sequence escapes a hypersphere of radius 4 about the origin before the iteration number reaches the max_iteration value. As you increase max_iteration, some points escape that did not previously escape, forming the julia fractal. Depending on the <strong>JULIA_PARAMETER</strong>, the julia fractal object is not necessarily connected; it may be scattered fractal <strong>dust</strong>. Using a low max_iteration can fuse together the dust to make a solid object. A high max_iteration is more accurate but slows rendering. Even though it is not accurate, the solid shapes you get with a low_maximum iteration value can be quite interesting.<p>
<a name="ref 863 pri 3">Since the mathematical object described by this algorithm is four-dimensional and POV-Ray renders three dimensional objects, there must be a way to reduce the number of dimensions of the object from four dimensions to three. This is accomplished by intersecting the 4-D fractal with a 3-D <strong>plane</strong> defined by the <a name="ref 863 pri 5"><strong>slice</strong> field and then projecting the intersection to 3-D space. The slice plane is the 3-D space that is perpendicular to <strong>NORMAL4D</strong> and is <strong>DISTANCE</strong> units from the origin. Zero length <strong>NORMAL4D</strong> vectors or a <strong>NORMAL4D</strong> vector with a zero fourth component are illegal.<p>
You can get a good feel for the four dimensional nature of a julia fractal by using POV-Ray's animation feature to vary a slice's <strong>DISTANCE</strong> parameter. You can make the julia fractal appear from nothing, grow, then shrink to nothing as <strong>DISTANCE</strong> changes, much as the cross section of a 3-D object changes as it passes through a plane.<p>
<a name="ref 1007 pri 5">The <a name="ref 1007 pri 6"><strong>precision</strong> parameter is a tolerance used in the determination of whether points are inside or outside the fractal object. Larger values give more accurate results but slower rendering. Use as low a value as you can without visibly degrading the fractal object's appearance.<p>
<a name="ref 843 pri 6"><a name="ref 1021 pri 6">The presence of the keywords <a name="ref 1021 pri 7"><strong>quaternion</strong> or <a name="ref 843 pri 8"><strong>hypercomplex</strong> determine which 4-D algebra is used to calculate the fractal. Both are 4-D generalizations of the complex numbers but neither satisfies all the field properties (all the properties of real and complex numbers that many of us slept through in high school). Quaternions have non-commutative multiplication and hypercomplex numbers can fail to have a multiplicative inverse for some non-zero elements (it has been proved that you cannot successfully generalize complex numbers to four dimensions with all the field properties intact, so something has to break). Both of these algebras were discovered in the 19th century. Of the two, the quaternions are much better known, but one can argue that hypercomplex numbers are more useful for our purposes, since complex valued functions such as sin, cos, etc. can be generalized to work for hypercomplex numbers in a uniform way.<p>
For the mathematically curious, the algebraic properties of these two algebras can be derived from the multiplication properties of the unit basis vectors 1 = &lt;1,0,0,0&gt;, i=&lt; 0,1,0,0&gt;, j=&lt;0,0,1,0&gt; and k=&lt; 0,0,0,1&gt;. In both algebras 1 x = x 1 = x for any x (1 is the multiplicative identity). The basis vectors 1 and i behave exactly like the familiar complex numbers 1 and i in both algebras.<p>
Quaternion basis vector multiplication rules:<p>
<pre>
  ij = k;            jk  = i;   ki = j
  ji = -k;           kj  = -i;  ik = -j
  ii = jj = kk = -1; ijk = -1;
</pre>
<p>
Hypercomplex basis vector multiplication rules:<p>
<pre>
  ij = k;            jk = -i;   ki = -j
  ji = k;            kj = -i;   ik = -j
  ii = jj = kk = -1; ijk = 1;
</pre>
<p>
A distance estimation calculation is used with the quaternion calculations to speed them up. The proof that this distance estimation formula works does not generalize from two to four dimensions but the formula seems to work well anyway, the absence of proof notwithstanding!<p>
The presence of one of the function keywords <a name="ref 882 pri 8"><strong>sqr</strong>, <a name="ref 958 pri 8"><strong>cube</strong>, etc. determines which function is used for f(h) in the iteration formula h(n+1) = f(h(n)) + p. Most of the function keywords work only if the hypercomplex keyword is present. Only sqr and cube work with quaternions. The functions are all familiar complex functions generalized to four dimensions.<p>
<a name="ref 882 pri 9"><a name="ref 958 pri 10"><a name="ref 1009 pri 11"><a name="ref 820 pri 11"><a name="ref 855 pri 12"><a name="ref 847 pri 13"><a name="ref 860 pri 13"><a name="ref 849 pri 13"><a name="ref 947 pri 14"><a name="ref 950 pri 14"><a name="ref 825 pri 14"><a name="ref 918 pri 15"><a name="ref 853 pri 16"><a name="ref 920 pri 16"><a name="ref 858 pri 16"><a name="ref 884 pri 17"><a name="ref 1013 pri 17"><pre>
  Function Keyword    Maps 4-D value h to:
================================================
  sqr                 h*h
  cube                h*h*h
  exp                 e raised to the power h
  reciprocal          1/h
  sin                 sine of h
  asin                arcsine of h
  sinh                hyperbolic sine of h
  asinh               inverse hyperbolic sine of h
  cos                 cosine of h
  acos                arccosine of h
  cosh                hyperbolic cos of h
  acosh               inverse hyperbolic cosine of h
  tan                 tangent of h
  atan                arctangent of h
  tanh                hyperbolic tangent of h
  atanh               inverse hyperbolic tangent of h
  log                 natural logarithm of h
  pwr(x,y)            h raised to the complex power x+iy
</pre>
<p>
A simple example of a julia fractal object is:<p>
<listing>
  julia_fractal {
    &lt;-0.083,0.0,-0.83,-0.025&gt;
    quaternion
    sqr
    max_iteration 8
    precision 15
  }
</listing>
<p>
The first renderings of julia fractals using quaternions were done by Alan Norton and later by John Hart in the '80's. This new POV-Ray implementation follows <b>Fractint</b> in pushing beyond what is known in the literature by using hypercomplex numbers and by generalizing the iterating formula to use a variety of transcendental functions instead of just the classic Mandelbrot z^2 + c formula. With an extra two dimensions and eighteen functions to work with, intrepid explorers should be able to locate some new fractal beasties in hyperspace, so have at it!<hr>
<a name="ref 1210 pri 0"><a name="ref 873 pri 2"><a name="ref 873 pri 2"><center><h3><a name="section 7.5.2.7">
Section 7.5.2.7<br>Lathe</h3></center>
The <a name="ref 873 pri 3"><strong>lathe</strong> is an object generated from rotating a two-dimensional curve about an axis. This curve is defined by a set of points which are connected by linear, quadratic or cubic spline curves. The syntax is:<p>
<listing>
  lathe {
    [ linear_spline | quadratic_spline | cubic_spline ]
    NUMBER_OF_POINTS,
    &lt;POINT_1&gt;, &lt;POINT_2&gt;, ..., &lt;POINT_n&gt;
    [ sturm ]
  }
</listing>
<p>
<a name="ref 963 pri 3"><a name="ref 169 pri 4"><a name="ref 1015 pri 4">The parameter <strong>NUMBER_OF_POINTS</strong> determines how many two-dimensional points are forming the curve. These points are connected by linear, quadratic or cubic splines as specified by an optional keyword (the default is <a name="ref 169 pri 6"><strong>linear_spline</strong>). Since the curve is not automatically closed, i. e. the first and last points are not automatically connected, you'll have to do this by your own if you want a closed curve. The curve thus defined is rotated about the y-axis to form the lathe object which is centered at the origin.<p>
The following examples creates a simple lathe object that looks like a <strong>thick</strong> cylinder, i. e. a cylinder with a thick wall:<p>
<listing>
  lathe {
    linear_spline
    5,
    &lt;2, 0&gt;, &lt;3, 0&gt;, &lt;3, 5&gt;, &lt;2, 5&gt;, &lt;2, 0&gt;
    pigment {Red}
  }
</listing>
<p>
<a name="ref 240 pri 10">The cylinder has an inner radius of 2 and an outer radius of 3, giving a wall width of 1. It's height is 5 and it's located at the origin pointing up, i. e. the rotation axis is the y-axis. Note that the first and last point are equal to get a closed curve.<p>
<a name="ref 1211 pri 10">The splines that are used by the lathe and prism objects are a little bit difficult to understand. The basic concept of splines is to draw a curve through a given set of points in a determined way. The linear spline is the simplest spline because it's nothing more than connecting consecutive points with a line. This means that the curve that is drawn between two points only depends on those two points. No additional information is taken into account. Quadratic and cubic splines are different in that they do not only take other points into account when connecting two points but they also look smoother and - in the case of the cubic spline - produce smoother transitions at each point.<p>
<a name="ref 1212 pri 10">Quadratic splines are made of quadratic curves. Each of them connects two consecutive points. Since those two points (call them second and third point) are not sufficient to describe a quadratic curve the predecessor of the second point is taken into account when the curve is drawn. Mathematically the relationship (their location on the 2-D plane) between the first and second point determines the slope of the curve at the second point. The slope of the curve at the third point is out of control. Thus quadratic splines look much <strong>smoother</strong> than linear splines but the transitions at each point are generally not smooth because the slopes on <strong>both sides</strong> of the point are different.<p>
<a name="ref 1213 pri 10">Cubic splines overcome the transition problem of quadratic splines because they also take the fourth point into account when drawing the curve between the second and third point. The slope at the fourth point is under control now and allows a smooth transition at each point. Thus cubic splines produce the most flexible and smooth curves.<p>
You should note that the number of spline segments, i. e. curves between two points, depends on the spline type used. For linear splines you get n-1 segments connecting the points P[i], i=1,...,n. A quadratic spline gives you n-2 segments because the last point is only used for determining the slope as explained above (thus you'll need at least three points to define a quadratic spline). The same holds for cubic splines where you get n-3 segments with the first and last point used only for slope calculations (thus needing at least four points).<p>
If you want to get a closed quadratic and cubic spline with smooth transitions at the end points you have to make sure that in the cubic case P[n-1] = P[2] (to get a closed curve), P[n] = P[3] and P[n-2] = P[1] (to smooth the transition). In the quadratic case P[n-1] = P[1] (to close the curve) and P[n] = P[2].<p>
<a name="ref 905 pri 13">The slower but more accurate Sturmian root solver may be used with the quadratic spline lathe if the shape does not render properly. Since a quadratic polynomial has to be solved for the linear spline lathe the Sturmian root solver is not needed. In case of cubic splines the Sturmian root solver is always used because a 6th order polynomial has to be solved.<hr>
<a name="ref 1214 pri 0"><a name="ref 1010 pri 2"><a name="ref 1010 pri 2"><center><h3><a name="section 7.5.2.8">
Section 7.5.2.8<br>Prism</h3></center>
The <a name="ref 1010 pri 3"><strong>prism</strong> is an object generated from sweeping one or more two-dimensional, closed curves along an axis. These curves are defined by a set of points which are connected by linear, quadratic or cubic splines.<p>
The syntax for the prism is:<p>
<listing>
  prism {
    [ linear_sweep | conic_sweep ]
    [ linear_spline | quadratic_spline | cubic_spline ]
    HEIGHT1,
    HEIGHT2,
    TOTAL_NUMBER_OF_POINTS,
    &lt;POINT_1&gt;, &lt;POINT_2&gt;, ..., &lt;POINT_n&gt;
    [ open ]
    [ sturm ]
  }
</listing>
<p>
The prism object allows you to use any number of sub-prisms inside one prism statement (they are of the same spline and sweep type). Wherever an even number of sub-prisms overlaps a hole appears.<p>
<a name="ref 169 pri 6">The syntax of the prism object depends on the type of spline curve used. Below the syntax of the linear spline prism is given.<p>
<listing>
  prism {
    linear_spline
    HEIGHT1,
    HEIGHT2,
    TOTAL_NUMBER_OF_POINTS,
    &lt;A_1&gt;, &lt;A_2&gt;, ..., &lt;A_na&gt;, &lt;A_1&gt;,
    &lt;B_1&gt;, &lt;B_2&gt;, ..., &lt;B_nb&gt;, &lt;B_1&gt;,
    &lt;C_1&gt;, &lt;C_2&gt;, ..., &lt;C_nc&gt;, &lt;C_1&gt;,
    ...
  }
</listing>
<p>
Each of the sub-prisms has to be closed by repeating the first point of a sub-prism at the end of the sub-prism's point sequence. If this is not the case a warning is issued and the prism is ignored (with linear splines automatic closing is used). This implies that all points of a prism are different (except the first and last of course). This applies to all spline types though the control points of the quadratic and cubic splines can be arbitrarily chosen.<p>
The last sub-prism of a linear spline prism is automatically closed - just like the last sub-polygon in the polygon statement - if the first and last point of the sub-polygon's point sequence are not the same. This make it very easy to convert between polygons and prisms. Quadratic and cubic splines are never automatically closed.<p>
<a name="ref 1015 pri 7">The syntax for quadratic spline prisms is:<p>
<listing>
  prism {
    quadratic_spline
    HEIGHT1,
    HEIGHT2,
    TOTAL_NUMBER_OF_POINTS,
    &lt;CL_A&gt;, &lt;A_1&gt;, &lt;A_2&gt;, ..., &lt;A_na&gt;, &lt;A_1&gt;,
    &lt;CL_B&gt;, &lt;B_1&gt;, &lt;B_2&gt;, ..., &lt;B_nb&gt;, &lt;B_1&gt;,
    &lt;CL_C&gt;, &lt;C_1&gt;, &lt;C_2&gt;, ..., &lt;C_nc&gt;, &lt;C_1&gt;,
    ...
  }
</listing>
<p>
Quadratic spline sub-prisms need an additional control point at the beginning of each sub-prisms' point sequence to determine the slope at the start of the curve.<p>
<a name="ref 963 pri 8">Last but not least the syntax for the cubic spline prism.<p>
<listing>
  prism {
    cubic_spline
    HEIGHT1,
    HEIGHT2,
    TOTAL_NUMBER_OF_POINTS,
    &lt;CL_A1&gt;, &lt;A_1&gt;, &lt;A_2&gt;, ..., &lt;A_na&gt;, &lt;A_1&gt;, &lt;CL_A2&gt;,
    &lt;CL_B1&gt;, &lt;B_1&gt;, &lt;B_2&gt;, ..., &lt;B_nb&gt;, &lt;B_1&gt;, &lt;CL_B2&gt;,
    &lt;CL_C1&gt;, &lt;C_1&gt;, &lt;C_2&gt;, ..., &lt;C_nc&gt;, &lt;C_1&gt;, &lt;CL_C2&gt;,
    ...
  }
</listing>
<p>
In addition to the closed point sequence each cubic spline sub-prism needs two control points to determine the slopes at the start and end of the curve.<p>
<a name="ref 880 pri 8"><a name="ref 940 pri 8">The parameter TOTAL_NUMBER_OF_POINTS determines how many two-dimensional points (lying in the x-z-plane) form the curves (this includes all control points needed for quadratic and cubic splines). The curves are swept along the y-axis from HEIGHT1 to HEIGHT2 to form the prism object. By default linear sweeping is used to create the prism, i. e. the prism's walls are perpendicular to the x-z-plane (the size of the curve does not change during the sweep). You can also use conic sweeping (<a name="ref 940 pri 9"><strong>conic_sweep</strong>) that leads to a prism with <strong>cone-like</strong> walls by scaling the curve down during the sweep.<p>
Like cylinders the prism is normally closed. You can remove the caps on the prism by using the <a name="ref 135 pri 14"><strong>open</strong> keyword. If you do so you shouldn't use it with CSG because the results may get wrong.<p>
The following example creates a simple prism object that looks like a piece of cake:<p>
<listing>
  prism {
    linear_sweep
    linear_spline
    0, 1,
    4,
    &lt;-1, 0&gt;, &lt;1, 0&gt;, &lt;0, 5&gt;, &lt;-1, 0&gt;
    pigment {Red}
  }
</listing>
<p>
For an explanation of the spline concept read the description of the lathe object.<p>
<a name="ref 905 pri 18">The slower but more accurate Sturmian root solver may be used with the cubic spline prisms if the shape does not render properly. The linear and quadratic spline prisms do not need the Sturmian root solver.<hr>

<center>
<a href="pov30021.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
