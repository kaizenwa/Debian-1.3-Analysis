<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 403 pri 0"><a name="ref 404 pri 0"><a name="ref 309 pri 1"><a name="ref 405 pri 1"><center><h3><a name="section 4.8.5.2.5">
Section 4.8.5.2.5<br>Using Frequency to Improve Realism</h3></center>
Another very good way of improving the realism of our explosion is to use a frequency value other than one. The way frequency works is explained in section <a href="pov30028.htm#ref 406 pri 0">&quot;Frequency Modifier&quot;</a> in the reference part.<p>
The rather mathematical explanation used there doesn't help much in understanding how this feature is used. It is quite simple though. The frequency value just tells the program how many times the color map will be repeated in the density range from 0 to 1. If a frequency of one (the default) is specified the color map will be visible once in the density field, e. g. the color at 0 will be used for density 0, color at 0.5 will be used for density 0.5 and the color at 1 will be used for density 1. Simple, isn't it?<p>
If we choose a frequency of two, the color at 0 will be used for density 0, the color at 0.5 will be used for density 0.25 and the color at 1 will be used for density 0.5. What about the densities above 0.5? Since there are no entries in the color map for values above 1 we just start at 0 again. Thus the color at 0.1 will be used for density 0.55 ((2*0.55) mod 1 = 1.1 mod 1 = 0.1), the color at 0.5 will be used for density 0.75 and the color at 1 will be used for density 1.<p>
If we are good at mathematics we'll note that the above example is not quite right because (1 * 2) mod 1 = 0 and not 1. We just think that we used a value slightly smaller than one and everything will be fine.<p>
We may have noticed that in order to avoid sudden changes in the halo color for frequencies larger than one we'll have to used a periodic color map, i.e. a color map whose entries at 0 and 1 are the same.<p>
We'll change our example by using a periodic color map and changing the frequency value to two.<p>
<listing>
  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      emitting
      spherical_mapping
      linear
      turbulence 1.5
      color_map {
        [ 0.0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 0.5 color rgbt &lt;1, 1, 0, -1&gt; ]
        [ 1.0 color rgbt &lt;1, 0, 0,  1&gt; ]
      }
      frequency 2
      samples 20
      scale 0.5
    }
    hollow
    scale 1.5
  }
</listing>
<p>
<center><img src="pov3001f.gif" border=0 width=320 height=240><br><cite>Using a periodic color map and a frequency of two gives a much nicer explosion.</cite></center><br> <p>
Looking at the result of (<b>halo05.pov</b>) we can be quite satisfied with the explosion we just have created, can't we?<p>
There's one thing left we should be aware of when increasing the frequency value. It is often necessary to increase the sample rate in (nearly) the same way as we change the frequency. If we don't do this we'll probably get some severe aliasing artifacts (like color jumps or strange bands of colors). If this happens just change the samples value according to the frequency value (twice sampling rate for a doubled frequency).<hr>
<a name="ref 407 pri 0"><a name="ref 408 pri 0"><center><h3><a name="section 4.8.5.2.6">
Section 4.8.5.2.6<br>Changing the Halo Color</h3></center>
We have a nice fiery explosion but we want to try to add some <strong>science fiction</strong> touch to it by using different colors. How about a nice green, less turbulent explosion that gets red at its borders?<p>
Nothing easier than that!<p>
<listing>
  sphere { 0, 1.5
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      emitting
      spherical_mapping
      linear
      turbulence 0.5
      color_map {
        [ 0 color rgbt &lt;0, 1, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, -1&gt; ]
      }
      samples 10
      scale 0.75
    }
    hollow
    scale 1.5
  }
</listing>
<p>
<center><img src="pov30020.gif" border=0 width=320 height=240><br><cite>Using red and green colors gives an unexpected result.</cite></center><br> <p>
This should do the trick. Looking at the result of <b>halo06.pov</b> we may be disappointed. Where is the red center of the explosion? The borders are green as expected but there is a lot of yellow in the center and only a little bit red. What is happening?<p>
We use an emitting halo in our example. According to the corresponding section in the halo reference chapter (see <a href="pov30028.htm#ref 380 pri 0">&quot;Emitting&quot;</a>) this type of halo uses very small particles that do not attenuate light passing through the halo. Especially particles near the viewer do not attenuate the light coming from particles far away from the viewer.<p>
During the calculation of the halo's color near the center of the container sphere, the ray steps through nearly all possible densities of the particle distribution. Thus we get red and green colors as we march on, depending on the current position in the halo. The sum of these colors is used which will gives as a yellow color (the sum of red and green is yellow). This is what is happening here.<p>
<a name="ref 409 pri 1"><a name="ref 410 pri 1">How can we still get what we want? The answer is to use a glowing halo instead of the emitting halo. The glowing halo is very similar to the emitting one except that it attenuates the light passing through. Thus the light of particles lying behind other particles will be attenuated by the particles in front.<p>
For the results of the glowing halo see <a href="pov3000e.htm#ref 411 pri 0">&quot;The Glowing Halo&quot;</a>.<hr>
<a name="ref 412 pri 0"><a name="ref 411 pri 0"><a name="ref 409 pri 2"><a name="ref 410 pri 3"><center><h3><a name="section 4.8.5.3">
Section 4.8.5.3<br>The Glowing Halo</h3></center>
We have mentioned the glowing halo in the section about the emitting halo as one way to avoid the color mixing that is happening with emitting halos.<p>
The glowing halo is very similar to the emitting halo except that it also absorbs light. We can view it as a combination of the emitting and the attenuating halo described in section <a href="pov3000e.htm#ref 413 pri 0">&quot;The Attenuating Halo&quot;</a>.<p>
By just replacing the <a name="ref 380 pri 7"><strong>emitting</strong> keyword in the example in section <a href="pov3000e.htm#ref 408 pri 0">&quot;Changing the Halo Color&quot;</a> with the <a name="ref 409 pri 10"><strong>glowing</strong> keyword we get the desired effect as shown in the example image (<b>halo11.pov</b>).<p>
<center><img src="pov30021.gif" border=0 width=320 height=240><br><cite>Using a glowing halo gives the expected result.</cite></center><br> <p>
Even though the red color of the high density areas is not very visible because the green colored, lower density areas lying in front absorb most of the red light, we don't get yellow color where we would have expected a red one.<p>
Due to its similarity with the emitting halo we have to make some experiments with this halo type. We just have to keep all those things we learned in the previous sections in mind to get some satisfying results.<hr>
<a name="ref 414 pri 0"><a name="ref 413 pri 0"><a name="ref 415 pri 1"><a name="ref 416 pri 1"><center><h3><a name="section 4.8.5.4">
Section 4.8.5.4<br>The Attenuating Halo</h3></center>
Another simple halo type is the attenuating halo that only absorbs light. It doesn't radiate on its own.<p>
A great difference between the attenuating halo and the other halo types is that the color of the attenuating halo is calculated from the halo's color map using the total particle density along a given ray. The other types calculated a (weighted) average of the colors calculated from the density at each sample.<hr>
<a name="ref 417 pri 0"><a name="ref 418 pri 0"><center><h3><a name="section 4.8.5.4.1">
Section 4.8.5.4.1<br>Making a Cloud</h3></center>
Attenuating halos are ideal to create clouds and smoke. In the following examples we will try to make a neat little cloud. We start again by using a unit-sized sphere that is filled with a basic attenuating halo (<b>halo21.pov</b>).<p>
<listing>
  camera {
    location &lt;0, 0, -2.5&gt;
    look_at &lt;0, 0, 0&gt;
  }

  light_source { &lt;10, 10, -10&gt; color rgb 1 shadowless }

  plane { z, 2
    pigment { checker color rgb 0, color rgb 1 }
    finish { ambient 1 diffuse 0 }
    scale 0.5
    hollow
  }

  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      attenuating
      spherical_mapping
      linear
      color_map {
        [ 0 color rgbt &lt;1, 0, 0, 1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, 0&gt; ]
      }
      samples 10
    }
    hollow
  }
</listing>
<p>
Even though clouds normally are not red but white or gray, we use the red color to make it more visible against the black/white checkerboard background.<p>
The color of an attenuating halo is calculated from the total accumulated density after a ray has marched through the complete particle field. This has to be kept in mind when creating the color map. We want the areas of the cloud with a low density to have a high translucency so we use a color of rgbt&lt;1,0,0,1&gt; and we want the high density areas to be opaque so we choose a color of rgbt&lt;1,0,0,0&gt;.<p>
<center><img src="pov30022.gif" border=0 width=320 height=240><br><cite>The basic attenuating halo used to create a cloud.</cite></center><br> <hr>
<a name="ref 419 pri 0"><a name="ref 420 pri 0"><center><h3><a name="section 4.8.5.4.2">
Section 4.8.5.4.2<br>Scaling the Halo Container</h3></center>
The cloud we have created so far doesn't look very realistic. It's just a red, partially translucent ball. In order to get a better result we use some of the methods we have already learned in the sections about emitting halos above. We add some turbulence to get a more realistic shape, we scale the halo to avoid the container object's surface to become visible and we decrease the translucency of the areas with a high particle density.<p>
<a name="ref 215 pri 6"><a name="ref 402 pri 7">Another idea is to scale the container object to get an ellipsoid shape that can be used to model a cloud pretty good. This is done by the <strong>scale &lt;1.5, 0.75, 1&gt;</strong> command at the end of the sphere. It scales both, the sphere and the halo inside.<p>
<listing>
  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      attenuating
      spherical_mapping
      linear
      turbulence 1
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, -1&gt; ]
      }
      samples 10
      scale 0.75
    }
    hollow
    scale &lt;1.5, 0.75, 1&gt;
  }
</listing>
<p>
Looking at the results of <b>halo22.pov</b> we see that this looks more like a real cloud (besides the color).<p>
<center><img src="pov30023.gif" border=0 width=320 height=240><br><cite>Scaling the halo container and adding some turbulence gives a better result.</cite></center><br> <hr>
<a name="ref 421 pri 0"><a name="ref 422 pri 0"><center><h3><a name="section 4.8.5.4.3">
Section 4.8.5.4.3<br>Adding Additional Halos</h3></center>
Another trick to get some more realism is to use multiple halos. If we look at cumulus clouds e. g. we notice that they often extend at the top while they are quite flat at the bottom.<p>
<a name="ref 423 pri 0">We want to model this appearance by adding two additional halos to our current container object (see section <a href="pov30027.htm#ref 424 pri 0">&quot;Multiple Halos&quot;</a> for more details). This is done in the following way:<p>
<listing>
  sphere { 0, 1.5
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      attenuating
      spherical_mapping
      linear
      turbulence 1
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, -1&gt; ]
      }
      samples 10
      scale &lt;0.75, 0.5, 1&gt;
      translate &lt;-0.4, 0, 0&gt;
    }
    halo {
      attenuating
      spherical_mapping
      linear
      turbulence 1
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, -1&gt; ]
      }
      samples 10
      scale &lt;0.75, 0.5, 1&gt;
      translate &lt;0.4, 0, 0&gt;
    }
    halo {
      attenuating
      spherical_mapping
      linear
      turbulence 1
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 0, 0, -1&gt; ]
      }
      samples 10
      scale 0.5
      translate &lt;0, 0.2, 0&gt;
    }
    hollow
  }
</listing>
<p>
The three halos used differ only in their location, i. e. in the translation vector we have used. The first two halos are used to form the base of the cloud while the last sits on top of the others. The sphere has a different radius than the previous ones because more space is needed for all three halos.<p>
The result of <b>halo23.pov</b> somewhat looks like a cloud, even though it may need some work.<p>
<center><img src="pov30024.gif" border=0 width=320 height=240><br><cite>Using multiple halos pretty much improves our cloud.</cite></center><br> <hr>
<a name="ref 425 pri 0"><a name="ref 426 pri 0"><a name="ref 427 pri 1"><a name="ref 428 pri 1"><center><h3><a name="section 4.8.5.5">
Section 4.8.5.5<br>The Dust Halo</h3></center>
The dust halo is a very complex halo type. It allows us to see the interaction of light coming from a light source with the particles in the halo. These particles absorb light in the same way as the attenuating halo. In addition they scatter the incoming light. This makes beams of light and shadows cast by objects onto the halo become visible.<hr>
<a name="ref 429 pri 0"><a name="ref 430 pri 0"><center><h3><a name="section 4.8.5.5.1">
Section 4.8.5.5.1<br>Starting With an Object Lit by a Spotlight</h3></center>
We start with a box shaped object that is lit by a spotlight. We don't use any halo at this moment because we want to see if the object is completely lit by the light (<b>halo31.pov</b>).<p>
<listing>
  camera {
    location &lt;0, 0, -2.5&gt;
    look_at &lt;0, 0, 0&gt;
  }

  background { color rgb &lt;0.2, 0.4, 0.8&gt; }

  light_source {
    &lt;2.5, 2.5, -2.5&gt;
    colour rgb &lt;1, 1, 1&gt;
    spotlight
    point_at &lt;0, 0, 0&gt;
    radius 12
    falloff 15
    tightness 1
  }

  difference {
    box { -1, 1 }
    box { &lt;-1.1, -0.8, -0.8&gt;, &lt;1.1, 0.8, 0.8&gt; }
    box { &lt;-0.8, -1.1, -0.8&gt;, &lt;0.8, 1.1, 0.8&gt; }
    box { &lt;-0.8, -0.8, -1.1&gt;, &lt;0.8, 0.8, 1.1&gt; }
    pigment { color rgb &lt;1, 0.2, 0.2&gt; }
    scale 0.5
    rotate 45*y
    rotate 45*x
  }
</listing>
<p>
<center><img src="pov30025.gif" border=0 width=320 height=240><br><cite>The object we want to use.</cite></center><br> <p>
As we see the whole object is lit by the light source. Now we can start to add some dust.<hr>
<a name="ref 431 pri 0"><a name="ref 432 pri 0"><center><h3><a name="section 4.8.5.5.2">
Section 4.8.5.5.2<br>Adding Some Dust</h3></center>
We use a box to contain the dust halo. Since we use a constant density function it doesn't matter what kind of density mapping we use. The density has the value specified by the <a name="ref 433 pri 0"><strong>max_value</strong> keyword everywhere inside the halo (the default value is one). The isotropic scattering is selected with <a name="ref 434 pri 0"><strong>dust_type</strong> .<p>
<listing>
  box { -1, 1
    pigment { colour rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      dust
      dust_type 1
      box_mapping
      constant
      colour_map {
        [ 0 color rgbt &lt;1, 1, 1, 1&gt; ]
        [ 1 color rgbt &lt;1, 1, 1, 0&gt; ]
      }
      samples 10
    }
    hollow
    scale 5
  }
</listing>
<p>
<center><img src="pov30026.gif" border=0 width=320 height=240><br><cite>This dust is too thick.</cite></center><br> <p>
The result of <b>halo32.pov</b> is too bright. The dust is too thick and we can only see some parts of the object and no background.<hr>
<a name="ref 435 pri 0"><a name="ref 436 pri 0"><center><h3><a name="section 4.8.5.5.3">
Section 4.8.5.5.3<br>Decreasing the Dust Density</h3></center>
The density inside the halo has the constant value one. This means that only the color map entry at position one is used to determine the density and color of the dust.<p>
We use a transmittance value of 0.7 to get a much thinner dust.<p>
<listing>
  box { -1, 1
    pigment { colour rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      dust
      dust_type 1
      box_mapping
      constant
      colour_map {
        [ 0 color rgbt &lt;1, 1, 1, 1.0&gt; ]
        [ 1 color rgbt &lt;1, 1, 1, 0.7&gt; ]
      }
      samples 10
    }
    hollow
    scale 5
  }
</listing>
<p>
<center><img src="pov30027.gif" border=0 width=320 height=240><br><cite>A thinner dust looks much better.</cite></center><br> <p>
Beside the ugly aliasing artifacts the image looks much better. We can see the whole object and even the background is slightly visible (<b>halo33.pov</b>).<hr>
<a name="ref 437 pri 0"><a name="ref 438 pri 0"><center><h3><a name="section 4.8.5.5.4">
Section 4.8.5.5.4<br>Making the Shadows Look Good</h3></center>
In order to reduce the aliasing artifacts we use three different techniques: jittering, super-sampling and an increased overall sampling rate.<p>
The jittering is used to add some randomness to the sampling points making the image look more noisy. This helps because regular aliasing artifacts are more annoying than noise. A low <a name="ref 251 pri 2"><strong>jitter</strong> value is a good choice.<p>
The super-sampling tries to detect fine features by taking additional samples in areas of high intensity changes. The threshold at which super-sampling is used and the maximum recursion level can be specified using the <a name="ref 439 pri 2"><strong>aa_threshold</strong> and <a name="ref 440 pri 2"><strong>aa_level</strong> keywords.<p>
The approach that always works is to increase the overall sampling rate. Since this is also the slowest method we should always try to use the other methods first. If they don't suffice we have to increase the sampling rate.<p>
We use the following halo to reduce the aliasing artifacts (<b>halo34.pov</b>).<p>
<listing>
  box { -1, 1
    pigment { colour rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      dust
      dust_type 1
      box_mapping
      constant
      colour_map {
        [ 0 color rgbt &lt;1, 1, 1, 1.0&gt; ]
        [ 1 color rgbt &lt;1, 1, 1, 0.7&gt; ]
      }
      samples 50
      aa_level 3
      aa_threshold 0.2
      jitter 0.1
    }
    hollow
    scale 5
  }
</listing>
<p>
<center><img src="pov30028.gif" border=0 width=320 height=240><br><cite>Different anti-aliasing methods help to get a satisfying result.</cite></center><br> <p>
The image looks much better now. There are hardly any aliasing artifacts left.<p>
The same parameters we have used are discussed in the section about the atmosphere feature (see <a href="pov30012.htm#ref 441 pri 0">&quot;The Atmosphere&quot;</a> for further explanations).<hr>
<a name="ref 442 pri 0"><a name="ref 443 pri 0"><center><h3><a name="section 4.8.5.5.5">
Section 4.8.5.5.5<br>Adding Turbulence</h3></center>
The major difference between the halo's dust and the atmosphere described in <a href="pov30012.htm#ref 441 pri 0">&quot;The Atmosphere&quot;</a> is the ability to choose a non-uniform particle distribution for the dust. This includes the fact that the halo is limited to a container object as well as the different density mappings and functions.<p>
Another interesting way of getting an irregular distribution is to add some turbulence to the dust. This is done with the <a name="ref 283 pri 7"><strong>turbulence</strong> keyword followed by the amount of turbulence to use, like the following example shows (<b>halo35.pov</b>).<p>
<listing>
  box { -1, 1
    pigment { colour rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      dust
      dust_type 1
      box_mapping
      linear
      turbulence 1
      colour_map {
        [ 0 color rgbt &lt;1, 1, 1, 1.0&gt; ]
        [ 1 color rgbt &lt;1, 1, 1, 0.5&gt; ]
      }
      samples 50
      aa_level 3
      aa_threshold 0.2
      jitter 0.1
    }
    hollow
    scale 5
  }
</listing>
<p>
<center><img src="pov30029.gif" border=0 width=320 height=240><br><cite>Adding turbulence to the dust makes it much more interesting.</cite></center><br> <p>
The image we now get looks much more interesting due to the shifts in the particle density.<p>
We should note that we use a linear density function instead of the previous constant one. This is necessary because with a constant density function the density has the same value everywhere. Adding turbulence would have no effect because wherever the points are moved the density will have this same value. Only a non-constant density distribution makes sense when turbulence is added.<p>
The fact that the turbulence value is actually a vector can be used to create effects like waterfalls by using a large turbulence value in one direction only (e.g. <strong>turbulence &lt;0.2, 1, 0.2&gt;</strong> ).<hr>

<center>
<a href="pov3000f.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
