<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 203 pri 0"><a name="ref 204 pri 0"><a name="ref 205 pri 1"><center><h3><a name="section 4.5">
Section 4.5<br>CSG Objects</h3></center>
<strong>Constructive Solid Geometry</strong>, <a name="ref 206 pri 1"><strong>CSG</strong>, is a powerful tool to combine primitive objects to create more complex objects as shown in the following sections.<hr>
<a name="ref 207 pri 0"><a name="ref 208 pri 0"><a name="ref 205 pri 2"><a name="ref 206 pri 3"><center><h3><a name="section 4.5.1">
Section 4.5.1<br>What is CSG?</h3></center>
<strong>CSG</strong> stands for <strong>Constructive Solid Geometry</strong>. POV-Ray allows us to construct complex solids by combining primitive shapes in four different ways. These are <strong>union</strong>, where two or more shapes are added together. <strong>Intersection</strong>, where two or more shapes are combined to make a new shape that consists of the area common to both shapes. <strong>Difference</strong>, where subsequent shapes are subtracted from the first shape. And last not least <strong>merge</strong>, which is like a union where the surfaces inside the union are removed (useful in transparent CSG objects). We will deal with each of these in detail in the next few sections.<p>
CSG objects can be extremely complex. They can be deeply nested. In other words there can be unions of differences or intersections of merges or differences of intersections or even unions of intersections of differences of merges... ad infinitum. CSG objects are (almost always) finite objects and thus respond to auto-bounding and can be transformed like any other POV primitive shape.<hr>
<a name="ref 209 pri 0"><a name="ref 210 pri 0"><a name="ref 211 pri 2"><center><h3><a name="section 4.5.2">
Section 4.5.2<br>CSG Union</h3></center>
Let's try making a simple union. Create a file called <b>csgdemo.pov</b> and edit it as follows:<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    location &lt;0, 1, -10&gt;
    look_at 0
    angle 36
  }

  light_source { &lt;500, 500, -1000&gt; White }

  plane { y, -1.5
    pigment { checker Green White }
  }
</listing>
<p>
Let's add two spheres each translated 0.5 units along the x-axis in each direction. We color one blue and the other red.<p>
<listing>
  sphere { &lt;0, 0, 0&gt;, 1
    pigment { Blue }
    translate -0.5*x
  }
  sphere { &lt;0, 0, 0&gt;, 1
    pigment { Red }
    translate 0.5*x
  }
</listing>
<p>
We trace this file at 200x150 <a name="ref 89 pri 9"><strong>-A</strong>. Now we place a union block around the two spheres. This will create a single CSG union out of the two objects.<p>
<listing>
  union{
    sphere { &lt;0, 0, 0&gt;, 1
      pigment { Blue }
      translate -0.5*x
    }
    sphere { &lt;0, 0, 0&gt;, 1
      pigment { Red }
      translate 0.5*x
    }
  }
</listing>
<p>
We trace the file again. The union will appear no different from what each sphere looked like on its own, but now we can give the entire union a single texture and transform it as a whole. Let's do that now.<p>
<listing>
  union{
    sphere { &lt;0, 0, 0&gt;, 1
      translate -0.5*x*
    }
    sphere { &lt;0, 0, 0&gt;, 1
      translate 0.5*x
    }
    pigment { Red }
    scale &lt;1, .25, 1&gt;
    rotate &lt;30, 0, 45&gt;
  }
</listing>
<p>
We trace the file again. As we can see, the object has changed dramatically. We experiment with different values of scale and rotate and try some different textures.<p>
There are many advantages of assigning only one texture to a CSG object instead of assigning the texture to each individual component. First, it is much easier to use one texture if our CSG object has a lot of components because changing the objects appearance involves changing only one single texture. Second, the file parses faster because the texture has to be parsed only once. This may be a great factor when doing large scenes or animations. Third, using only one texture saves memory because the texture is only stored once and referenced by all components of the CSG object. Assigning the texture to all n components means that it is stored n times.<hr>
<a name="ref 212 pri 0"><a name="ref 213 pri 0"><center><h3><a name="section 4.5.3">
Section 4.5.3<br>CSG Intersection</h3></center>
Now let's use these same spheres to illustrate the next kind of CSG object, the <strong>intersection</strong>. We change the word <a name="ref 211 pri 3"><strong>union</strong> to <a name="ref 214 pri 5"><strong>intersection</strong> and delete the <a name="ref 215 pri 6"><strong>scale</strong> and <a name="ref 216 pri 7"><strong>rotate</strong> statements:<p>
<listing>
  intersection {
    sphere { &lt;0, 0, 0&gt;, 1
      translate -0.5*x
    }
    sphere { &lt;0, 0, 0&gt;, 1
      translate 0.5*x
    }
    pigment { Red }
  }
</listing>
<p>
We trace the file and will see a lens-shaped object instead of the two spheres. This is because an intersection consists of the area shared by both shapes, in this case the lens-shaped area where the two spheres overlap. We like this lens-shaped object so we will use it to demonstrate differences.<hr>
<a name="ref 217 pri 0"><a name="ref 218 pri 0"><center><h3><a name="section 4.5.4">
Section 4.5.4<br>CSG Difference</h3></center>
We rotate the lens-shaped intersection about the y-axis so that the broad side is facing the camera.<p>
<listing>
  intersection{
    sphere { &lt;0, 0, 0&gt;, 1
      translate -0.5*x
    }
    sphere { &lt;0, 0, 0&gt;, 1
      translate 0.5*x
    }
    pigment { Red }
    rotate 90*y
  }
</listing>
<p>
Let's create a cylinder and stick it right in the middle of the lens.<p>
<listing>
  cylinder { &lt;0, 0, -1&gt; &lt;0, 0, 1&gt;, .35
    pigment { Blue }
  }
</listing>
<p>
We render the scene to see the position of the cylinder. We will place a <a name="ref 219 pri 2"><strong>difference</strong> block around both the lens-shaped intersection and the cylinder like this:<p>
<listing>
  difference {
    intersection {
      sphere { &lt;0, 0, 0&gt;, 1
        translate -0.5*x
      }
      sphere { &lt;0, 0, 0&gt;, 1
        translate 0.5*x
      }
      pigment { Red }
      rotate 90*y
    }
    cylinder { &lt;0, 0, -1&gt; &lt;0, 0, 1&gt;, .35
      pigment { Blue }
    }
  }
</listing>
<p>
We render the file again and see the lens-shaped intersection with a neat hole in the middle of it where the cylinder was. The cylinder has been <strong>subtracted</strong> from the intersection. Note that the pigment of the cylinder causes the surface of the hole to be colored blue. If we eliminate this pigment the surface of the hole will be red.<p>
OK, let's get a little wilder now. Let's declare our perforated lens object to give it a name. Let's also eliminate all textures in the declared object because we will want them to be in the final union instead.<p>
<listing>
  #declare Lens_With_Hole = difference {
    intersection {
      sphere { &lt;0, 0, 0&gt;, 1
        translate -0.5*x
      }
      sphere { &lt;0, 0, 0&gt;, 1
        translate 0.5*x
      }
      rotate 90*y
    }
    cylinder { &lt;0, 0, -1&gt; &lt;0, 0, 1&gt;, .35 }
  }
</listing>
<p>
Let's use a union to build a complex shape composed of copies of this object.<p>
<listing>
  union {
    object { Lens_With_Hole translate &lt;-.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;-.65, -.65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, -.65, 0&gt; }
    pigment { Red }
  }
</listing>
<p>
We render the scene. An interesting object to be sure. But let's try something more. Let's make it a partially-transparent object by adding some filter to the pigment block.<p>
<listing>
  union {
    object { Lens_With_Hole translate &lt;-.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;-.65, -.65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, -.65, 0&gt; }
    pigment { Red filter .5 }
  }
</listing>
<p>
We render the file again. This looks pretty good... only... we can see parts of each of the lens objects inside the union! This is not good.<hr>
<a name="ref 220 pri 0"><a name="ref 221 pri 0"><a name="ref 222 pri 2"><center><h3><a name="section 4.5.5">
Section 4.5.5<br>CSG Merge</h3></center>
This brings us to the fourth kind of CSG object, the <strong>merge</strong>. Merges are the same as unions, but the geometry of the objects in the CSG that is inside the merge is not traced. This should eliminate the problem with our object. Let's try it.<p>
<listing>
  merge {
    object { Lens_With_Hole translate &lt;-.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, .65, 0&gt; }
    object { Lens_With_Hole translate &lt;-.65, -.65, 0&gt; }
    object { Lens_With_Hole translate &lt;.65, -.65, 0&gt; }
    pigment { Red filter .5 }
  }
</listing>
<p>
Sure enough, it does!<hr>
<a name="ref 223 pri 0"><a name="ref 224 pri 0"><center><h3><a name="section 4.5.6">
Section 4.5.6<br>CSG Pitfalls</h3></center>
There is a severe pitfall in the CSG code that we have to be aware of.<hr>
<a name="ref 225 pri 0"><a name="ref 226 pri 0"><center><h3><a name="section 4.5.6.1">
Section 4.5.6.1<br>Coincidence Surfaces</h3></center>
POV-Ray uses inside/outside tests to determine the points at which a ray intersects a CSG object. A problem arises when the surfaces of two different shapes coincide because there is no way (due to numerical problems) to tell whether a point on the coincident surface belongs to one shape or the other.<p>
Look at the following example where a cylinder is used to cut a hole in a larger box.<p>
<listing>
  difference {
    box { -1, 1 pigment { Red } }
    cylinder { -z, z, 0.5 pigment { Green } }
  }
</listing>
<p>
If we trace this object we see red speckles where the hole is supposed to be. This is caused by the coincident surfaces of the cylinder and the box. One time the cylinder's surface is hit first by a viewing ray, resulting in the correct rendering of the hole, and another time the box is hit first, leading to a wrong result where the hole vanishes and red speckles appear.<p>
This problem can be avoided by increasing the size of the cylinder to get rid of the coincidence surfaces. This is done by:<p>
<listing>
  difference {
    box { -1, 1 pigment { Red } }
    cylinder { -1.001*z, 1.001*z, 0.5 pigment { Green } }
  }
</listing>
<p>
In general we have to make the subtracted object a little bit larger in a CSG difference. We just have to look for coincident surfaces and increase the subtracted object appropriately to get rid of those surfaces.<p>
The same problem occurs in CSG intersections and is also avoided by scaling some of the involved objects.<hr>
<a name="ref 227 pri 0"><a name="ref 228 pri 0"><center><h3><a name="section 4.6">
Section 4.6<br>The Light Source</h3></center>
In any ray-traced scene, the light needed to illuminate our objects and their surfaces must come from a light source. There are many kinds of light sources available in POV-Ray and careful use of the correct kind can yield very impressive results. Let's take a moment to explore some of the different kinds of light sources and their various parameters.<hr>
<a name="ref 229 pri 0"><a name="ref 230 pri 0"><center><h3><a name="section 4.6.1">
Section 4.6.1<br>The Ambient Light Source</h3></center>
The <a name="ref 231 pri 0"><strong>ambient light source</strong> is used to simulate the effect of inter-diffuse reflection. If there wasn't inter-diffuse reflection all areas not directly lit by a light source would be completely dark. POV-Ray uses the <a name="ref 232 pri 2"><strong>ambient</strong> keyword to determine how much light coming from the ambient light source is reflected by a surface.<p>
By default the ambient light source, which emits its light everywhere and in all directions, is pure white (<strong>rgb &lt;1,1,1&gt;</strong>). Changing its color can be used to create interesting effects. First of all the overall light level of the scene can be adjusted easily. Instead of changing all ambient values in every finish only the ambient light source is modified. By assigning different colors we can create nice effects like a moody reddish ambient lighting. For more details about the ambient light source see <a href="pov3002d.htm#ref 233 pri 0">&quot;Ambient Light&quot;</a>.<p>
Below is an example of a red ambient light source.<p>
<listing>
  global_settings { ambient_light rgb&lt;1, 0, 0&gt; }
</listing>
<hr>
<a name="ref 234 pri 0"><a name="ref 235 pri 0"><a name="ref 236 pri 0"><a name="ref 236 pri 1"><center><h3><a name="section 4.6.2">
Section 4.6.2<br>The Pointlight Source</h3></center>
Pointlights are exactly what the name indicates. A pointlight has no size, is invisible and illuminates everything in the scene equally no matter how far away from the light source it may be (this behavior can be changed). This is the simplest and most basic light source. There are only two important parameters, location and color. Let's design a simple scene and place a pointlight source in it.<p>
We create a new file and name it <b>litedemo.pov</b>. We edit it as follows:<p>
<listing>
  #include &quot;colors.inc&quot;
  #include &quot;textures.inc&quot;

  camera {
    location  &lt;-4, 3, -9&gt;
    look_at   &lt;0, 0, 0&gt;
    angle 48
  }
</listing>
<p>
We add the following simple objects:<p>
<listing>
  plane { y, -1
    texture {
      pigment {
        checker
        color rgb&lt;0.5, 0, 0&gt;
        color rgb&lt;0, 0.5, 0.5&gt;
      }
      finish {
        diffuse 0.4
        ambient 0.2
        phong 1
        phong_size 100
        reflection 0.25
      }
    }
  }

  torus { 1.5, 0.5
    texture { Brown_Agate }
    rotate &lt;90, 160, 0&gt;
    translate  &lt;-1, 1, 3&gt;
  }

  box { &lt;-1, -1, -1&gt;, &lt;1, 1, 1&gt;
    texture { DMFLightOak }
    translate  &lt;2, 0, 2.3&gt;
  }

  cone { &lt;0,1,0&gt;, 0, &lt;0,0,0&gt;, 1
    texture { PinkAlabaster }
    scale &lt;1, 3, 1&gt;
    translate  &lt;-2, -1, -1&gt;
  }

  sphere { &lt;0,0,0&gt;,1
    texture { Sapphire_Agate }
    translate  &lt;1.5, 0, -2&gt;
  }
</listing>
<p>
Now we add a pointlight:<p>
<listing>
  light_source {
    &lt;2, 10, -3&gt;
    color White
  }
</listing>
<p>
We render this at 200x150 <a name="ref 89 pri 9"><strong>-A</strong> and see that the objects are clearly visible with sharp shadows. The sides of curved objects nearest the light source are brightest in color with the areas that are facing away from the light source being darkest. We also note that the checkered plane is illuminated evenly all the way to the horizon. This allows us to see the plane, but it is not very realistic.<hr>
<a name="ref 237 pri 0"><a name="ref 238 pri 0"><a name="ref 239 pri 2"><a name="ref 239 pri 5"><center><h3><a name="section 4.6.3">
Section 4.6.3<br>The Spotlight Source</h3></center>
Spotlights are a very useful type of light source. They can be used to add highlights and illuminate features much as a photographer uses spots to do the same thing. There are a few more parameters with spotlights than with pointlights. These are <a name="ref 240 pri 5"><strong>radius</strong>, <a name="ref 241 pri 5"><strong>falloff</strong>, <a name="ref 242 pri 5"><strong>tightness</strong> and <a name="ref 243 pri 5"><strong>point_at</strong>. The radius parameter is the angle of the fully illuminated cone. The falloff parameter is the angle of the <strong>umbra</strong> cone where the light falls off to darkness. The tightness is a parameter that determines the rate of the light falloff. The point_at parameter is just what it says, the location where the spotlight is pointing to. Let's change the light in our scene as follows:<p>
<listing>
  light_source {
    &lt;0, 10, -3&gt;
    color White
    spotlight
    radius 15
    falloff 20
    tightness 10
    point_at &lt;0, 0, 0&gt;
  }
</listing>
<p>
We render this at 200x150 <a name="ref 89 pri 14"><strong>-A</strong> and see that only the objects are illuminated. The rest of the plane and the outer portions of the objects are now unlit. There is a broad falloff area but the shadows are still razor sharp. Let's try fiddling with some of these parameters to see what they do. We change the falloff value to 16 (it must always be larger than the radius value) and render again. Now the falloff is very narrow and the objects are either brightly lit or in total darkness. Now we change falloff back to 20 and change the tightness value to 100 (higher is tighter) and render again. The spotlight appears to have gotten much smaller but what has really happened is that the falloff has become so steep that the radius actually appears smaller.<p>
We decide that a tightness value of 10 (the default) and a falloff value of 18 are best for this spotlight and we now want to put a few spots around the scene for effect. Let's place a slightly narrower blue and a red one in addition to the white one we already have:<p>
<listing>
  light_source {
    &lt;10, 10, -1&gt;
    color Red
    spotlight
    radius 12
    falloff 14
    tightness 10
    point_at &lt;2, 0, 0&gt;
  }

  light_source {
    &lt;-12, 10, -1&gt;
    color Blue
    spotlight
    radius 12
    falloff 14
    tightness 10
    point_at &lt;-2, 0, 0&gt;
  }
</listing>
<p>
Rendering this we see that the scene now has a wonderfully mysterious air to it. The three spotlights all converge on the objects making them blue on one side and red on the other with enough white in the middle to provide a balance.<hr>
<a name="ref 244 pri 0"><a name="ref 245 pri 0"><a name="ref 246 pri 0"><center><h3><a name="section 4.6.4">
Section 4.6.4<br>The Cylindrical Light Source</h3></center>
Spotlights are cone shaped, meaning that their effect will change with distance. The farther away from the spotlight an object is, the larger the apparent radius will be. But we may want the radius and falloff to be a particular size no matter how far away the spotlight is. For this reason, cylindrical light sources are needed. A cylindrical light source is just like a spotlight, except that the radius and falloff regions are the same no matter how far from the light source our object is. The shape is therefore a cylinder rather than a cone. We can specify a cylindrical light source by replacing the <a name="ref 239 pri 4"><strong>spotlight</strong> keyword with the <a name="ref 138 pri 9"><strong>cylinder</strong> keyword. We try this now with our scene by replacing all three spotlights with cylinder lights and rendering again. We see that the scene is much dimmer. This is because the cylindrical constraints do not let the light spread out like in a spotlight. Larger radius and falloff values are needed to do the job. We try a radius of 20 and a falloff of 30 for all three lights. That's the ticket!<hr>

<center>
<a href="pov3000a.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
