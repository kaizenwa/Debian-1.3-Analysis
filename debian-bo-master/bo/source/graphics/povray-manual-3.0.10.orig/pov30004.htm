<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 127 pri 0"><a name="ref 128 pri 0"><center><h3><a name="section 4.3">
Section 4.3<br>Simple Shapes</h3></center>
So far we have just used the sphere shape. There are many other types of shapes that can be rendered by POV-Ray. The following sections will describe how to use some of the more simple objects as a replacement for the sphere used above.<hr>
<a name="ref 129 pri 0"><a name="ref 130 pri 0"><a name="ref 131 pri 3"><center><h3><a name="section 4.3.1">
Section 4.3.1<br>Box Object</h3></center>
The <a name="ref 131 pri 7"><strong>box</strong> is one of the most common objects used. We try this example in place of the sphere:<p>
<listing>
  box {
    &lt;-1, 0,   -1&gt;,  // Near lower left corner
    &lt; 1, 0.5,  3&gt;   // Far upper right corner

    texture {
      T_Stone25     // Pre-defined from stones.inc
      scale 4       // Scale by the same amount in all
                    // directions
    }

    rotate y*20     // Equivalent to &quot;rotate &lt;0,20,0&gt;&quot;
  }
</listing>
<p>
In the example we can see that a box is defined by specifying the 3D coordinates of its opposite corners. The first vector must be the minimum x-, y- and z-coordinates and the 2nd vector must be the maximum x-, y- and z-values. Box objects can only be defined parallel to the axes of the world coordinate system. We can later rotate them to any angle. Note that we can perform simple math on values and vectors. In the rotate parameter we multiplied the vector identifier <strong>y</strong> by 20. This is the same as &lt;0,1,0&gt;*20 or &lt;0,20,0&gt;.<hr>
<a name="ref 132 pri 0"><a name="ref 133 pri 0"><a name="ref 134 pri 3"><center><h3><a name="section 4.3.2">
Section 4.3.2<br>Cone Object</h3></center>
Here's another example showing how to use a <a name="ref 134 pri 7"><strong>cone</strong>:<p>
<listing>
  cone {
    &lt;0, 1, 0&gt;, 0.3    // Center and radius of one end
    &lt;1, 2, 3&gt;, 1.0    // Center and radius of other end

    texture { T_Stone25 scale 4 }
  }
</listing>
<p>
The cone shape is defined by the center and radius of each end. In this example one end is at location &lt;0,1,0&gt; and has a radius of 0.3 while the other end is centered at &lt;1,2,3&gt; with radius=1. If we want the cone to come to a sharp point we must use radius=0. The solid end caps are parallel to each other and perpendicular to the cone axis. If we want an open cone with no end caps we have to add the keyword <a name="ref 135 pri 7"><strong>open</strong> after the 2nd radius like this:<p>
<listing>
  cone {
    &lt;0, 1, 0&gt;, 0.3    // Center and radius of one end
    &lt;1, 2, 3&gt;, 1.0    // Center and radius of other end
    open              // Removes end caps

    texture { T_Stone25 scale 4 }
  }
</listing>
<hr>
<a name="ref 136 pri 0"><a name="ref 137 pri 0"><a name="ref 138 pri 3"><center><h3><a name="section 4.3.3">
Section 4.3.3<br>Cylinder Object</h3></center>
We may also define a <a name="ref 138 pri 7"><strong>cylinder</strong> like this:<p>
<listing>
  cylinder {
    &lt;0, 1, 0&gt;,     // Center of one end
    &lt;1, 2, 3&gt;,     // Center of other end
    0.5            // Radius
    open           // Remove end caps

    texture { T_Stone25 scale 4 }
  }
</listing>
<hr>
<a name="ref 139 pri 0"><a name="ref 140 pri 0"><a name="ref 141 pri 3"><a name="ref 141 pri 7"><center><h3><a name="section 4.3.4">
Section 4.3.4<br>Plane Object</h3></center>
Let's try out a computer graphics standard - <strong>The Checkered Floor</strong>. We add the following object to the first version of the <b>demo.pov</b> file, the one including the sphere.<p>
<listing>
  plane { &lt;0, 1, 0&gt;, -1
    pigment {
      checker color Red, color Blue
    }
  }
</listing>
<p>
The object defined here is an infinite plane. The vector &lt;0,1,0&gt; is the surface normal of the plane (i.e. if we were standing on the surface, the normal points straight up). The number afterward is the distance that the plane is displaced along the normal from the origin - in this case, the floor is placed at y=-1 so that the sphere at y=1, radius=2, is resting on it.<p>
We note that even though there is no <strong>texture</strong> statement there is an implied texture here. We might find that continually typing statements that are nested like <strong>texture {pigment</strong>} can get to be tiresome so POV-Ray let's us leave out the <strong>texture</strong> statement under many circumstances. In general we only need the texture block surrounding a texture identifier (like the <strong>T_Stone25</strong> example above), or when creating layered textures (which are covered later).<p>
This pigment uses the checker color pattern and specifies that the two colors red and blue should be used.<p>
Because the vectors &lt;1,0,0&gt;, &lt;0,1,0&gt; and &lt;0,0,1&gt; are used frequently, POV-Ray has three built-in vector identifiers <a name="ref 142 pri 7"><strong>x</strong>, <a name="ref 143 pri 7"><strong>y</strong> and <a name="ref 144 pri 7"><strong>z</strong> respectively that can be used as a shorthand. Thus the plane could be defined as:<p>
<listing>
  plane { y, -1
    pigment { ... }
  }
</listing>
<p>
Note that we do not use angle brackets around vector identifiers.<p>
Looking at the floor, we notice that the ball casts a shadow on the floor. Shadows are calculated very accurately by the ray-tracer, which creates precise, sharp shadows. In the real world, penumbral or &quot;soft&quot; shadows are often seen. Later we will learn how to use extended light sources to soften the shadows.<hr>
<a name="ref 145 pri 0"><a name="ref 146 pri 0"><a name="ref 103 pri 2"><center><h3><a name="section 4.3.5">
Section 4.3.5<br>Standard Include Objects</h3></center>
The standard include file <b>shapes.inc</b> contains some pre-defined shapes that are about the size of a sphere with a radius of one unit. We can invoke them like this:<p>
<listing>
  #include &quot;shapes.inc&quot;

  object {
    UnitBox
    texture { T_Stone25 scale 4 }
    scale 0.75
    rotate &lt;-20,25,0&gt;
    translate y
  }
</listing>
<hr>
<a name="ref 147 pri 0"><a name="ref 148 pri 0"><center><h3><a name="section 4.4">
Section 4.4<br>Advanced Shapes</h3></center>
After we have gained some experience with the simpler shapes available in POV-Ray it is time to go on to the more advanced, thrilling shapes.<p>
We should be aware that the shapes described below are not trivial to understand. We needn't be worried though if we do not know how to use them or how they work. We just try the examples and play with the features described in the reference chapter. There is nothing better than learning by doing.<hr>
<a name="ref 149 pri 0"><a name="ref 150 pri 0"><a name="ref 151 pri 1"><center><h3><a name="section 4.4.1">
Section 4.4.1<br>Bicubic Patch Object</h3></center>
Bicubic or <a name="ref 152 pri 1"><strong>Bezier patches</strong> are useful surface representations because they allow an easy definition of surfaces using only a few control points. The control points serve to determine the shape of the patch. Instead of defining the vertices of triangles, we simply give the coordinates of the control points. A single patch has 16 control points, four at each corner, and the rest positioned to divide the patch into smaller sections. For ray-tracing (or rendering) the patches are approximated using triangles. Bezier patches are almost always created using a third party modeller so for this tutorial, we will use <b>moray</b> (any other modeller that supports Bezier patches and POV-Ray can also be used). We will use <b>moray</b> only to create the patch itself, not the other elements of the scene.<p>
Bezier patches are actually very useful and, with a little practice, some pretty amazing things can be created with them. For our first tutorial, let's make a sort of a teepee/tent shape using a single sheet patch.<p>
First, we start <b>moray</b> and, from the main edit screen, we click on &quot;CREATE&quot;. We Name our object <strong>Teepee</strong>. The &quot;CREATE BEZIER PATCH&quot; dialogue box will appear. We have to make sure that &quot;SHEET&quot; is depressed. We click on &quot;OK, CREATE&quot;. At the bottom of the main edit screen, we click on &quot;EXTENDED EDIT&quot;.<p>
We hold the cursor over the &quot;TOP&quot; view and right click to make the pop-up menu appear. We click on &quot;MAXIMIZE&quot;. We [ALT]-drag to zoom in a little. We click on &quot;MARK ALL&quot;, and under the transformation mode box, &quot;UFRM SCL&quot;. We drag the mouse to scale the patch until it is approximately four units wide. We click on &quot;TRANSLATE&quot;, and move the patch so that its center is over the origin. We right click &quot;MINIMIZE&quot; and &quot;UNMARK ALL&quot;.<p>
We [SHIFT]-drag a box around the lower right control point to mark it. We [ALT]-zoom into the &quot;FRONT&quot; view so that we can see the patch better. In the &quot;FRONT&quot; view, we &quot;TRANSLATE&quot; that point 10 units along the negative z-axis (we note that in MORAY z is up). We &quot;UNMARK ALL&quot;. We repeat this procedure for each of the other three corner points. We make sure we remember to &quot;UNMARK ALL&quot; once each point has been translated. We should have a shape that looks as though it is standing on four pointed legs. We &quot;UNMARK ALL&quot;.<p>
Working once again in the &quot;TOP&quot; view, we [SHIFT]-drag a box around the four center control points to mark them. We right-click over the &quot;TOP&quot; view and &quot;MAXIMIZE&quot;. We click on &quot;UFRM SCL&quot; and drag the mouse to scale the four points close together. We [ALT]-drag to zoom closer and get them as close together as we can. We [ALT]-drag to zoom out, right click and &quot;MINIMIZE&quot;.<p>
In the &quot;FRONT&quot; view, we &quot;TRANSLATE&quot; the marked points 10 units along the positive z-axis. We &quot;UNMARK ALL&quot;. The resulting shape is quite interesting, was simple to model, and could not be produced using CSG primitives. Now let's use it in a scene.<p>
We click on &quot;DONE&quot; to return to the main edit screen. We note that U_STEPS and V_STEPS are both set to 3 and flatness is set to 0.01. We leave them alone for now. We click on &quot;FILES&quot; and then &quot;SAVE SEL&quot; (save selection). We name our new file <b>teepee1.mdl</b>. We press [F3] and open <b>teepee1.mdl</b>. There is no need to save the original file. When <b>teepee1</b> is open, we create a quick &quot;dummy&quot; texture (<b>moray</b> will not allow us to export data without a texture). We use white with default finish and name it <strong>TeePeeTex</strong>. We apply it to the object, save the file and press [CTRL-F9]. <b>moray</b> will create two files: <b>teepee1.inc</b> and <b>teepee1.pov</b>.<p>
We exit <b>moray</b> and copy <b>teepee1.inc</b> and <b>teepee1.pov</b> into our working directory where we are doing these tutorials. We create a new file called <b>bezdemo.pov</b> and edit it as follows:<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    location &lt;0, .1, -60&gt;
    look_at 0
    angle 40
  }

  background { color Gray25 }  //to make the patch easier to see

  light_source { &lt;300, 300, -700&gt; White }

  plane { y, -12
    texture {
      pigment {
        checker
        color Green
        color Yellow
      }
    }
  }
</listing>
<p>
Using a text editor, we create and declare a simple texture for our teepee object:<p>
<listing>
  #declare TeePeeTex = texture {
    pigment {
      color rgb &lt;1, 1, 1,&gt;
    }
    finish {
      ambient .2
      diffuse .6
    }
  }
</listing>
<p>
We paste in the bezier patch data from <b>teepee1.pov</b> (the additional object keywords added by <b>moray</b> were removed):<p>
<listing>
  bicubic_patch {
    type 1 flatness 0.0100 u_steps 3 v_steps 3,
    &lt;-5.174134, 5.528420, -13.211995&gt;,
    &lt;-1.769023, 5.528420, 0.000000&gt;,
    &lt;1.636088, 5.528420, 0.000000&gt;,
    &lt;5.041199, 5.528420, -13.003932&gt;,
    &lt;-5.174134, 1.862827, 0.000000&gt;,
    &lt;0.038471, 0.031270, 18.101474&gt;,
    &lt;0.036657, 0.031270, 18.101474&gt;,
    &lt;5.041199, 1.862827, 0.000000&gt;,
    &lt;-5.174134, -1.802766, 0.000000&gt;,
    &lt;0.038471, 0.028792, 18.101474&gt;,
    &lt;0.036657, 0.028792, 18.101474&gt;,
    &lt;5.041199, -1.802766, 0.000000&gt;,
    &lt;-5.174134, -5.468359, -13.070366&gt;,
    &lt;-1.769023, -5.468359, 0.000000&gt;,
    &lt;1.636088, -5.468359, 0.000000&gt;,
    &lt;4.974128, -5.468359, -12.801446&gt;
    texture {
      TeePeeTex
    }
    rotate -90*x  // to orient the object to LHC
    rotate 25*y   // to see the four &quot;legs&quot; better
  }
</listing>
<p>
We add the above rotations so that the patch is oriented to POV-Ray's left-handed coordinate system (remember the patch was made in <b>moray</b> in a right handed coordinate system), so we can see all four legs. Rendering this at 200x150 -a we see pretty much what we expect, a white <strong>teepee</strong> over a green and yellow checkered plane. Let's take a little closer look. We render it again, this time at 320x200.<p>
Now we see that something is amiss. There appears to be sharp angling, almost like faceting, especially near the top. This is indeed a kind of faceting and is due to the U_STEPS and V_STEPS parameters. Let's change these from 3 to 4 and see what happens.<p>
That's much better, but it took a little longer to render. This is an unavoidable tradeoff. If we want even finer detail, we must use a U_STEPS and V_STEPS value of 5 and set flatness to 0. But we must expect to use lots of memory and an even longer tracing time.<p>
Well, we can't just leave this scene without adding a few items just for interest. We declare the patch object and scatter a few of them around the scene:<p>
<listing>
  #declare TeePee = bicubic_patch {
    type 1 flatness 0.0100 u_steps 3 v_steps 3,
    &lt;-5.174134, 5.528420, -13.211995&gt;,
    &lt;-1.769023, 5.528420, 0.000000&gt;,
    &lt;1.636088, 5.528420, 0.000000&gt;,
    &lt;5.041199, 5.528420, -13.003932&gt;,
    &lt;-5.174134, 1.862827, 0.000000&gt;,
    &lt;0.038471, 0.031270, 18.101474&gt;,
    &lt;0.036657, 0.031270, 18.101474&gt;,
    &lt;5.041199, 1.862827, 0.000000&gt;,
    &lt;-5.174134, -1.802766, 0.000000&gt;,
    &lt;0.038471, 0.028792, 18.101474&gt;,
    &lt;0.036657, 0.028792, 18.101474&gt;,
    &lt;5.041199, -1.802766, 0.000000&gt;,
    &lt;-5.174134, -5.468359, -13.070366&gt;,
    &lt;-1.769023, -5.468359, 0.000000&gt;,
    &lt;1.636088, -5.468359, 0.000000&gt;,
    &lt;4.974128, -5.468359, -12.801446&gt;
    texture {
      TeePeeTex
     }
     rotate -90*x // to orient the object to LHC
     rotate 25*y  // to see the four &quot;legs&quot; better
  }

  object { TeePee }

  object { TeePee translate &lt;8, 0, 8&gt; }

  object { TeePee translate &lt;-9, 0, 9&gt; }

  object { TeePee translate &lt;18, 0, 24&gt; }

  object { TeePee translate &lt;-18, 0, 24&gt; }
</listing>
<p>
That looks good. Let's do something about that boring gray background. We delete the background declaration and replace it with:<p>
<listing>
  plane { y, 500
    texture {
      pigment { SkyBlue }
      finish { ambient 1 diffuse 0}
     }
     texture {
       pigment {
         bozo
         turbulence .5
         color_map {
           [0 White]
           [1 White filter 1]
         }
       }
       finish { ambient 1 diffuse 0 }
       scale &lt;1000, 250, 250&gt;
       rotate &lt;5, 45, 0&gt;
    }
  }
</listing>
<p>
This adds a pleasing cirrus-cloud filled sky. Now, let's change the checkered plane to rippled sand dunes:<p>
<listing>
  plane {y,-12
    texture {
      pigment {
        color &lt;.85, .5, .15&gt;
      }
      finish {
        ambient .25
        diffuse .6
        crand .5
      }
      normal {
        ripples .35
        turbulence .25
        frequency 5
      }
      scale 10
      translate 50*x
    }
  }
</listing>
<p>
We render this at 320x240 -a. Not bad! Let's just add one more element. Let's place a golden egg under each of the teepees. And since this is a bezier patch tutorial, let's make the eggs out of bezier patches.<p>
We return to <b>moray</b> and create another bezier patch. We name it <strong>Egg1</strong> and select &quot;CYLINDRICAL 2 - PATCH&quot; from the &quot;CREATE BEZIER PATCH&quot; dialogue box. We click on &quot;EXTENDED EDIT&quot;. We &quot;MARK ALL&quot; and rotate the patch so that the cylinder lays on its side. We &quot;UNMARK ALL&quot;. In the &quot;FRONT&quot; view, we [SHIFT]-drag a box around the four points on the right end to mark them. In the &quot;SIDE&quot; view, we right click and &quot;MAXIMIZE&quot;. We [ALT]-drag to zoom in a little closer. We &quot;UFRM SCL&quot; the points together as close as possible. We zoom in closer to get them nice and tight. We zoom out, right click and &quot;MINIMIZE&quot;.<p>
We click on &quot;TRANSLATE&quot; and drag the points to the left so that they are aligned on the z-axis with the next group of four points. This should create a blunt end to the patch. We repeat this procedure for the other end. We &quot;UNMARK ALL&quot;.<p>
In the &quot;FRONT&quot; view, the control grid should be a rectangle now and the patch should be an ellipsoid. We [SHIFT]-drag a box around the upper right corner of the control grid to mark those points. We then [SHIFT]-drag a box around the lower right corner to mark those points as well. In the &quot;SIDE&quot; view, we &quot;UFRM SCL&quot; the points apart a little to make that end of the egg a little wider than the other. We &quot;UNMARK ALL&quot;.<p>
The egg may need a little proportional adjustment. We should be able to &quot;MARK ALL&quot; and &quot;LOCAL SCL&quot; in the three views until we get it to look like an egg. When we are satisfied that it does, we &quot;UNMARK ALL&quot; and click on done. Learning from our teepee object, we now go ahead and change U_STEPS and V_STEPS to 4.<p>
We create a dummy texture, white with default finish, name it <strong>EggTex</strong> and apply it to the egg. From the FILES menu, we &quot;SAVE SEL&quot; to filename <b>egg1.mdl</b>. We load this file and export ([CTRL F9]). We exit <b>moray</b> and copy the files <b>egg1.inc</b> and <b>egg1.pov</b> into our working directory.<p>
Back in <b>bezdemo.pov</b>, we create a nice, shiny gold texture:<p>
<listing>
  #declare EggTex = texture {
    pigment { BrightGold }
    finish {
      ambient .1
      diffuse .4
      specular 1
      roughness 0.001
      reflection .5
      metallic
    }
  }
</listing>
<p>
And while we're at it, let's dandy up our <strong>TeePeeTex</strong> texture:<p>
<listing>
  #declare TeePeeTex = texture {
    pigment { Silver }
    finish {
      ambient .1
      diffuse .4
      specular 1
      roughness 0.001
      reflection .5
      metallic
    }
  }
</listing>
<p>
Now we paste in our egg patch data and declare our egg:<p>
<listing>
  #declare Egg = union { // Egg1
    bicubic_patch {
      type 1 flatness 0.0100 u_steps 4 v_steps 4,
      &lt;2.023314, 0.000000, 4.355987&gt;,
      &lt;2.023314, -0.000726, 4.355987&gt;,
      &lt;2.023312, -0.000726, 4.356867&gt;,
      &lt;2.023312, 0.000000, 4.356867&gt;,
      &lt;2.032037, 0.000000, 2.734598&gt;,
      &lt;2.032037, -1.758562, 2.734598&gt;,
      &lt;2.027431, -1.758562, 6.141971&gt;,
      &lt;2.027431, 0.000000, 6.141971&gt;,
      &lt;-1.045672, 0.000000, 3.281572&gt;,
      &lt;-1.045672, -1.758562, 3.281572&gt;,
      &lt;-1.050279, -1.758562, 5.414183&gt;,
      &lt;-1.050279, 0.000000, 5.414183&gt;,
      &lt;-1.044333, 0.000000, 4.341816&gt;,
      &lt;-1.044333, -0.002947, 4.341816&gt;,
      &lt;-1.044341, -0.002947, 4.345389&gt;,
      &lt;-1.044341, 0.000000, 4.345389&gt;
    }
    bicubic_patch {
      type 1 flatness 0.0100 u_steps 4 v_steps 4,
      &lt;2.023312, 0.000000, 4.356867&gt;,
      &lt;2.023312, 0.000726, 4.356867&gt;,
      &lt;2.023314, 0.000726, 4.355987&gt;,
      &lt;2.023314, 0.000000, 4.355987&gt;,
      &lt;2.027431, 0.000000, 6.141971&gt;,
      &lt;2.027431, 1.758562, 6.141971&gt;,
      &lt;2.032037, 1.758562, 2.734598&gt;,
      &lt;2.032037, 0.000000, 2.734598&gt;,
      &lt;-1.050279, 0.000000, 5.414183&gt;,
      &lt;-1.050279, 1.758562, 5.414183&gt;,
      &lt;-1.045672, 1.758562, 3.281572&gt;,
      &lt;-1.045672, 0.000000, 3.281572&gt;,
      &lt;-1.044341, 0.000000, 4.345389&gt;,
      &lt;-1.044341, 0.002947, 4.345389&gt;,
      &lt;-1.044333, 0.002947, 4.341816&gt;,
      &lt;-1.044333, 0.000000, 4.341816&gt;
    }
    texture { EggTex }
    translate &lt;0.5, 0, -5&gt;  // centers the egg around the origin
    translate -9.8*y        // places the egg on the ground
  }
</listing>
<p>
We now place a copy of the egg under each teepee. This should require only the x- and z-coordinates of each teepee to be changed:<p>
<listing>
  object { Egg }

  object { Egg translate &lt;8, 0, 8&gt; }

  object { Egg translate &lt;-9, 0, 9&gt; }

  object { Egg translate &lt;18, 0, 24&gt; }

  object { Egg translate &lt;-18, 0, 24&gt; }
</listing>
<p>
<center><img src="pov30002.gif" border=0 width=320 height=240><br><cite>Scene build with different Bezier patches.</cite></center><br> <p>
We render this at 320x240 <a name="ref 89 pri 2"><strong>-A</strong>. Everything looks good so we run it again at 640x480 <a name="ref 88 pri 4"><strong>+A</strong>. Now we see that there is still some faceting near the top of the teepees and on the eggs as well. The only solution is to raise U_STEPS and V_STEPS from 4 to 5 and set flatness to 0 for all our bezier objects. We make the changes and render it again at 640x480 <a name="ref 88 pri 7"><strong>+A</strong>.<hr>

<center>
<a href="pov30005.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
