<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 247 pri 0"><a name="ref 248 pri 0"><a name="ref 249 pri 0"><center><h3><a name="section 4.6.5">
Section 4.6.5<br>The Area Light Source</h3></center>
So far all of our light sources have one thing in common. They produce sharp shadows. This is because the actual light source is a point that is infinitely small. Objects are either in direct sight of the light, in which case they are fully illuminated, or they are not, in which case they are fully shaded. In real life, this kind of stark light and shadow situation exists only in outer space where the direct light of the sun pierces the total blackness of space. But here on Earth, light bends around objects, bounces off objects, and usually the source has some dimension, meaning that it can be partially hidden from sight (shadows are not sharp anymore). They have what is known as an <strong>umbra</strong>, or an area of fuzziness where there is neither total light or shade. In order to simulate these <strong>soft</strong> shadows, a ray-tracer must give its light sources dimension. POV-Ray accomplishes this with a feature known as an area light.<p>
Area lights have dimension in two axis'. These are specified by the first two vectors in the area light syntax. We must also specify how many lights are to be in the array. More will give us cleaner soft shadows but will take longer to render. Usually a 3*3 or a 5*5 array will suffice. We also have the option of specifying an adaptive value. The <a name="ref 250 pri 1"><strong>adaptive</strong> keyword tells the ray-tracer that it can adapt to the situation and send only the needed rays to determine the value of the pixel. If adaptive is not used, a separate ray will be sent for every light in the area light. This can really slow things down. The higher the adaptive value the cleaner the umbra will be but the longer the trace will take. Usually an adaptive value of 1 is sufficient. Finally, we probably should use the <a name="ref 251 pri 2"><strong>jitter</strong> keyword. This tells the ray-tracer to slightly move the position of each light in the area light so that the shadows appear truly soft instead of giving us an umbra consisting of closely banded shadows.<p>
OK, let's try one. We comment out the cylinder lights and add the following:<p>
<listing>
  light_source {
    &lt;2, 10, -3&gt;
    color White
    area_light &lt;5, 0, 0&gt;, &lt;0, 0, 5&gt;, 5, 5
    adaptive 1
    jitter
  }
</listing>
<p>
This is a white area light centered at &lt;2,10,-3&gt;. It is 5 units (along the x-axis) by 5 units (along the z-axis) in size and has 25 (5*5) lights in it. We have specified adaptive 1 and jitter. We render this at 200x150 <a name="ref 89 pri 12"><strong>-A</strong>.<p>
Right away we notice two things. The trace takes quite a bit longer than it did with a point or a spotlight and the shadows are no longer sharp! They all have nice soft umbrae around them. Wait, it gets better.<p>
Spotlights and cylinder lights can be area lights too! Remember those sharp shadows from the spotlights in our scene? It would not make much sense to use a 5*5 array for a spotlight, but a smaller array might do a good job of giving us just the right amount of umbra for a spotlight. Let's try it. We comment out the area light and change the cylinder lights so that they read as follows:<p>
<listing>
  light_source {
    &lt;2, 10, -3&gt;
    color White
    spotlight
    radius 15
    falloff 18
    tightness 10
    area_light &lt;1, 0, 0&gt;, &lt;0, 0, 1&gt;, 2, 2
    adaptive 1
    jitter
    point_at &lt;0, 0, 0&gt;
  }

  light_source {
    &lt;10, 10, -1&gt;
    color Red
    spotlight
    radius 12
    falloff 14
    tightness 10
    area_light &lt;1, 0, 0&gt;, &lt;0, 0, 1&gt;, 2, 2
    adaptive 1
    jitter
    point_at &lt;2, 0, 0&gt;
  }

  light_source {
    &lt;-12, 10, -1&gt;
    color Blue
    spotlight
    radius 12
    falloff 14
    tightness 10
    area_light &lt;1, 0, 0&gt;, &lt;0, 0, 1&gt;, 2, 2
    adaptive 1
    jitter
    point_at &lt;-2, 0, 0&gt;
  }
</listing>
<p>
We now have three area-spotlights, one unit square consisting of an array of four (2*2) lights, three different colors, all shining on our scene. We render this at 200x150 <a name="ref 89 pri 23"><strong>-A</strong>. It appears to work perfectly. All our shadows have small, tight umbrae, just the sort we would expect to find on an object under a real spotlight.<hr>
<a name="ref 252 pri 0"><a name="ref 253 pri 0"><center><h3><a name="section 4.6.6">
Section 4.6.6<br>Assigning an Object to a Light Source</h3></center>
Light sources are invisible. They are just a location where the light appears to be coming from. They have no true size or shape. If we want our light source to be a visible shape, we can use the <a name="ref 254 pri 1"><strong>looks_like</strong> keyword. We can specify that our light source can look like any object we choose. When we use <a name="ref 254 pri 3"><strong>looks_like</strong>, <a name="ref 255 pri 4"><strong>no_shadow</strong> is applied to the object automatically. This is done so that the object will not block any illumination from the light source. If we want some blocking to occur (as in a lampshade), it is better to simply use a union to do the same thing. Let's add such an object to our scene. Here is a light bulb we have made just for this purpose:<p>
<listing>
  #declare Lightbulb = union {
    merge {
      sphere { &lt;0,0,0&gt;,1 }
      cylinder { &lt;0,0,1&gt;, &lt;0,0,0&gt;, 1
        scale &lt;0.35, 0.35, 1.0&gt;
        translate  0.5*z
      }
      texture {
        pigment {color rgb &lt;1, 1, 1&gt;}
        finish {ambient .8 diffuse .6}
      }
    }
    cylinder { &lt;0,0,1&gt;, &lt;0,0,0&gt;, 1
      scale &lt;0.4, 0.4, 0.5&gt;
      texture { Brass_Texture }
      translate  1.5*z
    }
    rotate -90*x
    scale .5
  }
</listing>
<p>
Now we add the light source:<p>
<listing>
  light_source {
    &lt;0, 2, 0&gt;
    color White
    looks_like { Lightbulb }
  }
</listing>
<p>
Rendering this we see that a fairly believable light bulb now illuminates the scene. However, if we do not specify a high ambient value, the light bulb is not lit by the light source. On the plus side, all of the shadows fall away from the light bulb, just as they would in a real situation. The shadows are sharp, so let's make our bulb an area light:<p>
<listing>
  light_source {
    &lt;0, 2, 0&gt;
    color White
    area_light &lt;1, 0, 0&gt;, &lt;0, 1, 0&gt;, 2, 2
    adaptive 1
    jitter
    looks_like { Lightbulb }
  }
</listing>
<p>
We note that we have placed this area light in the x-y-plane instead of the x-z-plane. We also note that the actual appearance of the light bulb is not affected in any way by the light source. The bulb must be illuminated by some other light source or by, as in this case, a high ambient value. More interesting results might therefore be obtained in this case by using halos (see section <a href="pov3000d.htm#ref 256 pri 0">&quot;Halos&quot;</a>).<hr>
<a name="ref 257 pri 0"><a name="ref 258 pri 0"><center><h3><a name="section 4.6.7">
Section 4.6.7<br>Light Source Specials</h3></center>
<hr>
<a name="ref 259 pri 0"><a name="ref 260 pri 0"><center><h3><a name="section 4.6.7.1">
Section 4.6.7.1<br>Using Shadowless Lights</h3></center>
Light sources can be assigned the <a name="ref 261 pri 1"><strong>shadowless</strong> keyword and no shadows will be cast due to its presence in a scene. Sometimes, scenes are difficult to illuminate properly using the lights we have chosen to illuminate our objects. It is impractical and unrealistic to apply a higher ambient value to the texture of every object in the scene. So instead, we would place a couple of <strong>fill lights</strong> around the scene. Fill lights are simply dimmer lights with the <a name="ref 261 pri 3"><strong>shadowless</strong> keyword that act to boost the illumination of other areas of the scene that may not be lit well. Let's try using one in our scene.<p>
Remember the three colored area spotlights? We go back and un-comment them and comment out any other lights we have made. Now we add the following: <listing>
  light_source {
    &lt;0, 20, 0&gt;
    color Gray50
    shadowless
  }
</listing>
<p>
This is a fairly dim light 20 units over the center of the scene. It will give a dim illumination to all objects including the plane in the background. We render it and see.<hr>
<a name="ref 262 pri 0"><a name="ref 263 pri 0"><center><h3><a name="section 4.6.7.2">
Section 4.6.7.2<br>Using Light Fading</h3></center>
If it is realism we want, it is not realistic for the plane to be evenly illuminated off into the distance. In real life, light gets scattered as it travels so it diminishes its ability to illuminate objects the farther it gets from its source. To simulate this, POV-Ray allows us to use two keywords: <a name="ref 264 pri 1"><strong>fade_distance</strong>, which specifies the distance at which full illumination is achieved, and <a name="ref 265 pri 2"><strong>fade_power</strong>, an exponential value which determines the actual rate of attenuation. Let's apply these keywords to our fill light.<p>
First, we make the fill light a little brighter by changing <strong>Gray50</strong> to <strong>Gray75</strong>. Now we change that fill light as follows:<p>
<listing>
  light_source {
    &lt;0, 20, 0&gt;
    color Gray75
    fade_distance 5
    fade_power 1
    shadowless
  }
</listing>
<p>
This means that the full value of the fill light will be achieved at a distance of 5 units away from the light source. The fade power of 1 means that the falloff will be linear (the light falls of at a constant rate). We render this to see the result.<p>
That definitely worked! Now let's try a fade power of 2 and a fade distance of 10. Again, this works well. The falloff is much faster with a fade power of 2 so we had to raise the fade distance to 10.<hr>
<a name="ref 266 pri 0"><a name="ref 267 pri 0"><a name="ref 268 pri 1"><center><h3><a name="section 4.6.7.3">
Section 4.6.7.3<br>Light Sources and Atmosphere</h3></center>
By definition more than default, light sources are affected by atmosphere, i.e. their light is scattered by the atmosphere. This can be turned off by adding <strong>atmosphere off</strong> to the light source block. The light emitted by a light source can also be attenuated by the atmosphere (and also fog), that is it will be diminished as it travels through it, by adding <strong>atmospheric_attenuation on</strong>. The falloff is exponential and depends on the <a name="ref 269 pri 1"><strong>distance</strong> parameter of the atmosphere (or fog). We note that this feature only affects light coming directly from the light source. Reflected and refracted light is ignored.<p>
Let's experiment with these keywords. First we must add an atmosphere to our scene:<p>
<listing>
  #include &quot;atmos.inc&quot;

  atmosphere { Atmosphere2 }
</listing>
<p>
We comment out the three lines that turn each of the three spotlights into area lights. Otherwise the trace will take to long.<p>
<listing>
  //area_light &lt;1, 0, 0&gt;, &lt;0, 0, 1&gt;, 2, 2
  //adaptive 1
  //jitter
</listing>
<p>
Tracing the scene at 200x150 <a name="ref 89 pri 13"><strong>-A</strong> we see that indeed the spotlights are visible. We can see where the blue and red spots cross each other and where the white overhead light shines down through the center of the scene. We also notice that the spotlights appear to diminish in their intensity as the light descends from the light source to the objects. The red light is all but gone in the lower left part of the scene and the blue light all but gone in the lower right. This is due to the atmospheric attenuation and lends a further realism to the scene. The atmosphere-light source interaction gives our scene a smoky, mysterious appearance, but the trace took a long time. Making those spotlights area lights and it will take even longer. This is an inevitable trade-off - tracing speed for image quality.<hr>
<a name="ref 270 pri 0"><a name="ref 271 pri 0"><a name="ref 112 pri 2"><center><h3><a name="section 4.7">
Section 4.7<br>Simple Texture Options</h3></center>
The pictures rendered so far where somewhat boring regarding the appearance of the objects. Let's add some fancy features to the texture.<hr>
<a name="ref 272 pri 0"><a name="ref 273 pri 0"><center><h3><a name="section 4.7.1">
Section 4.7.1<br>Surface Finishes</h3></center>
One of the main features of a ray-tracer is its ability to do interesting things with surface finishes such as highlights and reflection. Let's add a nice little Phong highlight (shiny spot) to the sphere. To do this we need to add a <a name="ref 274 pri 1"><strong>finish</strong> keyword followed by a parameter. We change the definition of the sphere to this:<p>
<listing>
  sphere { &lt;0, 1, 2&gt;, 2
    texture {
      pigment { color Yellow } // Yellow is pre-defined in COLORS.INC
      finish { phong 1 }
    }
  }
</listing>
<p>
We render the scene. The <a name="ref 275 pri 2"><strong>phong</strong> keyword adds a highlight the same color of the light shining on the object. It adds a lot of credibility to the picture and makes the object look smooth and shiny. Lower values of phong will make the highlight less bright (values should be between 0 and 1).<hr>
<a name="ref 276 pri 0"><a name="ref 277 pri 0"><center><h3><a name="section 4.7.2">
Section 4.7.2<br>Adding Bumpiness</h3></center>
The highlight we have added illustrates how much of our perception depends on the reflective properties of an object. Ray-tracing can exploit this by playing tricks on our perception to make us see complex details that aren't really there.<p>
Suppose we wanted a very bumpy surface on the object. It would be very difficult to mathematically model lots of bumps. We can however simulate the way bumps look by altering the way light reflects off of the surface. Reflection calculations depend on a vector called <strong>surface normal</strong>. This is a vector which points away from the surface and is perpendicular to it. By artificially modifying (or perturbing) this normal vector we can simulate bumps. We change the scene to read as follows and render it:<p>
<listing>
  sphere { &lt;0, 1, 2&gt;, 2
    texture {
      pigment { color Yellow }
      normal { bumps 0.4 scale 0.2 }
      finish { phong 1}
    }
  }
</listing>
<p>
This tells POV-Ray to use a <a name="ref 278 pri 0"><strong>bump</strong> pattern to modify the surface normal. The value 0.4 controls the apparent depth of the bumps. Usually the bumps are about 1 unit wide which doesn't work very well with a sphere of radius 2. The scale makes the bumps 1/5th as wide but does not affect their depth.<hr>
<a name="ref 279 pri 0"><a name="ref 280 pri 0"><center><h3><a name="section 4.7.3">
Section 4.7.3<br>Creating Color Patterns</h3></center>
We can do more than assigning a solid color to an object. We can create complex patterns in the pigment block like in this example:<p>
<listing>
  sphere { &lt;0, 1, 2&gt;, 2
    texture {
      pigment {
        wood
        color_map {
          [0.0 color DarkTan]
          [0.9 color DarkBrown]
          [1.0 color VeryDarkBrown]
        }
        turbulence 0.05
        scale &lt;0.2, 0.3, 1&gt;
      }
      finish { phong 1 }
    }
  }
</listing>
<p>
The keyword <a name="ref 281 pri 2"><strong>wood</strong> specifies a pigment pattern of concentric rings like rings in wood. The <a name="ref 282 pri 3"><strong>color_map</strong> keyword specifies that the color of the wood should blend from <strong>DarkTan</strong> to <strong>DarkBrown</strong> over the first 90% of the vein and from <strong>DarkBrown</strong> to <strong>VeryDarkBrown</strong> over the remaining 10%. The <a name="ref 283 pri 5"><strong>turbulence</strong> keyword slightly stirs up the pattern so the veins aren't perfect circles and the <a name="ref 215 pri 7"><strong>scale</strong> keyword adjusts the size of the pattern.<p>
Most patterns are set up by default to give us one <strong>feature</strong> across a sphere of radius 1.0. A feature is very roughly defined as a color transition. For example, a wood texture would have one band on a sphere of radius 1.0. In this example we scale the pattern using the <a name="ref 215 pri 10"><strong>scale</strong> keyword followed by a vector. In this case we scaled 0.2 in the x direction, 0.3 in the y direction and the z direction is scaled by 1, which leaves it unchanged. Scale values larger than one will stretch an element. Scale values smaller than one will squish an element. A scale value of one will leave an element unchanged.<hr>
<a name="ref 284 pri 0"><a name="ref 285 pri 0"><a name="ref 286 pri 0"><a name="ref 112 pri 3"><center><h3><a name="section 4.7.4">
Section 4.7.4<br>Pre-defined Textures</h3></center>
POV-Ray has some very sophisticated textures pre-defined in the standard include files <b>glass.inc</b>, <b>metals.inc</b>, <b>stones.inc</b> and <b>woods.inc</b>. Some are entire textures with pigment, normal and/or finish parameters already defined. Some are just pigments or just finishes. We change the definition of our sphere to the following and then re-render it:<p>
<listing>
  sphere { &lt;0, 1, 2&gt;, 2
    texture {
      pigment {
        DMFWood4       // pre-defined in textures.inc
        scale 4        // scale by the same amount in all
                       // directions
      }
      finish { Shiny } // pre-defined in finish.inc
    }
  }
</listing>
<p>
The pigment identifier <strong>DMFWood4</strong> has already been scaled down quite small when it was defined. For this example we want to scale the pattern larger. Because we want to scale it uniformly we can put a single value after the scale keyword rather than a vector of x, y, z scale factors.<p>
We look through the file <b>textures.inc</b> to see what pigments and finishes are defined and try them out. We just insert the name of the new pigment where <strong>DMFWood4</strong> is now or try a different finish in place of <strong>Shiny</strong> and re-render our file.<p>
Here is an example of using a complete texture identifier rather than just the pieces.<p>
<listing>
  sphere { &lt;0, 1, 2&gt;, 2
    texture { PinkAlabaster }
  }
</listing>
<hr>

<center>
<a href="pov3000b.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
