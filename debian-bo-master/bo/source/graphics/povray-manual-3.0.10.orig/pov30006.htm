<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 170 pri 0"><a name="ref 171 pri 0"><center><h3><a name="section 4.4.4.1">
Section 4.4.4.1<br>Understanding The Concept of Splines</h3></center>
It would be helpful, in order to understand splines, if we had a sort of <strong>Spline Workshop</strong> where we could practice manipulating types and points of splines and see what the effects were like. So let's make one! Now that we know how to create a basic lathe, it will be easy (see file <b>lathdem2.pov</b>):<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    orthographic
    up &lt;0, 5, 0&gt;
    right &lt;5, 0, 0&gt;
    location &lt;2.5, 2.5, -100&gt;
    look_at &lt;2.5, 2.5, 0&gt;
  }

  /* set the control points to be used */

  #declare Red_Point    = &lt;1.00, 0.00, 0&gt;
  #declare Orange_Point = &lt;1.75, 1.00, 0&gt;
  #declare Yellow_Point = &lt;2.50, 2.00, 0&gt;
  #declare Green_Point  = &lt;2.00, 3.00, 0&gt;
  #declare Blue_Point   = &lt;1.50, 4.00, 0&gt;

  /* make the control points visible */

  cylinder { Red_Point, Red_Point - 20*z, .1
    pigment { Red }
    finish { ambient 1 }
  }

  cylinder { Orange_Point, Orange_Point - 20*z, .1
    pigment { Orange }
    finish { ambient 1 }
  }

  cylinder { Yellow_Point, Yellow_Point - 20*z, .1
    pigment { Yellow }
    finish { ambient 1 }
  }

  cylinder { Green_Point, Green_Point - 20*z, .1
    pigment { Green }
    finish { ambient 1 }
  }

  cylinder { Blue_Point, Blue_Point- 20*z, .1
    pigment { Blue }
    finish { ambient 1 }
  }

  /* something to make the curve show up */

  lathe {
    linear_spline
    5,
    Red_Point,
    Orange_Point,
    Yellow_Point,
    Green_Point,
    Blue_Point

    pigment { White }
    finish { ambient 1 }
  }
</listing>
<p>
<center><img src="pov30009.gif" border=0 width=320 height=240><br><cite>A simple &quot;Spline Workshop&quot;.</cite></center><br> <p>
Now, we take a deep breath. We know that all looks a bit weird, but with some simple explanations, we can easily see what all this does.<p>
First, we are using the orthographic camera. If we haven't read up on that yet, a quick summary is: it renders the scene <strong>flat</strong>, eliminating perspective distortion so that in a side view, the objects look like they were drawn on a piece of graph paper (like in the side view of a modeller or CAD package). There are several uses for this practical new type of camera, but here it is allowing us to see our lathe and cylinders <strong>edge on</strong>, so that what we see is almost like a cross section of the curve which makes the lathe, rather than the lathe itself. To further that effect, we eliminated shadowing with the <strong>ambient 1</strong> finish, which of course also eliminates the need for lighting. We have also positioned this particular side view so that &lt;0,0&gt; appears at the lower left of our scene.<p>
Next, we declared a set of points. We note that we used 3D vectors for these points rather than the 2D vectors we expect in a lathe. That's the exception we mentioned earlier. When we declare a 3D point, then use it in a lathe, the lathe only uses the first two components of the vector, and whatever is in the third component is simply ignored. This is handy here, since it makes this example possible.<p>
Next we do two things with the declared points. First we use them to place small diameter cylinders at the locations of the points with the circular caps facing the camera. Then we re-use those same vectors to determine the lathe. Since trying to declare a 2D vector can have some odd results, and isn't really what our cylinder declarations need anyway, we can take advantage of the lathe's tendancy to ignore the third component by just setting the z-coordinate in these 3D vectors to zero.<p>
The end result is: when we render this code, we see a white lathe against a black background showing us how the curve we've declared looks, and the circular ends of the cylinders show us where along the x-y-plane our control points are. In this case, it's very simple. The linear spline has been used so our <strong>curve</strong> is just straight lines zig-zagging between the points. We change the declarations of <strong>Red_Point</strong> and <strong>Blue_Point</strong> to read as follows (see file <b>lathdem3.pov</b>).<p>
<listing>
  #declare Red_Point  = &lt;2.00, 0.00, 0&gt;
  #declare Blue_Point = &lt;0.00, 4.00, 0&gt;
</listing>
<p>
<center><img src="pov3000a.gif" border=0 width=320 height=240><br><cite>Moving some points of the spline.</cite></center><br> <p>
We re-render and, as we can see, all that happens is that the straight line segments just move to accomodate the new position of the red and blue points. Linear splines are so simple, we could manipulate them in our sleep, no?<p>
Let's try something different. First, we change the points to the following (see file <b>lathdem4.pov</b>).<p>
<listing>
  #declare Red_Point    = &lt;1.00, 0.00, 0&gt;
  #declare Orange_Point = &lt;2.00, 1.00, 0&gt;
  #declare Yellow_Point = &lt;3.50, 2.00, 0&gt;
  #declare Green_Point  = &lt;2.00, 3.00, 0&gt;
  #declare Blue_Point   = &lt;1.50, 4.00, 0&gt;
</listing>
<p>
<center><img src="pov3000b.gif" border=0 width=320 height=240><br><cite>A quadratic spline lathe.</cite></center><br> <p>
We then go down to the lathe declaration and change <strong>linear_spline</strong> to <strong>quadratic_spline</strong>. We re-render and what do we have? Well, there's a couple of things worthy of note this time. First, we will see that instead of straight lines we have smooth arcs connecting the points. These arcs are made from quadratic curves, so our lathe looks much more interesting this time. Also, <strong>Red_Point</strong> is no longer connected to the curve. What happened?<p>
Well, while any two points can determine a straight line, it takes three to determine a quadratic curve. POV-Ray looks not only to the two points to be connected, but to the point immediately preceeding them to determine the formula of the quadratic curve that will be used to connect them. The problem comes in at the beginning of the curve. Beyond the first point in the curve there is no <strong>previous</strong> point. So we need to declare one. Therefore, when using a quadratic spline, we must remember that the first point we specify is only there so that POV-Ray can determine what curve to connect the first two points with. It will not show up as part of the actual curve.<p>
There's just one more thing about this lathe example. Even though our curve is now put together with smooth curving lines, the transitions between those lines is... well, kind of choppy, no? This curve looks like the lines between each individual point have been terribly mismatched. Depending on what we are trying to make, this could be acceptable, or, we might long for a more smoothly curving shape. Fortunately, if the latter is true, we have another option.<p>
The quadratic spline takes longer to render than a linear spline. The math is more complex. Still longer needs the cubic spline, yet, for a really smoothed out shape, this is the only way to go. We go back into our example, and simply replace <strong>quadratic_spline</strong> with <strong>cubic_spline</strong> (see file <b>lathdem5.pov</b>). We render one more time, and take a look at what we have.<p>
<center><img src="pov3000c.gif" border=0 width=320 height=240><br><cite>A cubic spline lathe.</cite></center><br> <p>
While a quadratic spline takes three points to determine the curve, a cubic needs four. So, as we might expect, <strong>Blue_Point</strong> has now dropped out of the curve, just as <strong>Red_Point</strong> did, as the first and last points of our curve are now only control points for shaping the curves between the remaining points. But look at the transition from <strong>Orange_Point</strong> to <strong>Yellow_Point</strong> and then back to <strong>Green_Point</strong>. Now, rather than looking mismatched, our curve segements look like one smoothly joined curve.<p>
The concept of splines is a handy and necessary one, which will be seen again in the prism and polygon objects. But with a little tinkering we can quickly get a feel for working with them.<hr>
<a name="ref 172 pri 0"><a name="ref 173 pri 0"><a name="ref 174 pri 3"><a name="ref 174 pri 7"><center><h3><a name="section 4.4.5">
Section 4.4.5<br>Mesh Object</h3></center>
Mesh objects are very useful because they allow us to create objects containing hundreds or thousands of triangles. Compared to a simple union of triangles the mesh object stores the triangles more efficiently. Copies of mesh objects need only a little additional memory because the triangles are stored only once.<p>
Almost every object can be approximated using triangles but we may need a lot of triangles to create more complex shapes. Thus we will only create a very simple mesh example. This example will show a very useful feature of the triangles meshes though: a different texture can be assigned to each triangle in the mesh.<p>
Now let's begin. We will create a simple box with differently colored sides. We create an empty file called <b>meshdemo.pov</b> and add the following lines.<p>
<listing>
  camera {
    location &lt;20, 20, -50&gt;
    look_at &lt;0, 5, 0&gt;
  }

  light_source { &lt;50, 50, -50&gt; color rgb&lt;1, 1, 1&gt; }

  #declare Red = texture {
    pigment { color rgb&lt;0.8, 0.2, 0.2&gt; }
    finish { ambient 0.2 diffuse 0.5 }
  }

  #declare Green = texture {
    pigment { color rgb&lt;0.2, 0.8, 0.2&gt; }
    finish { ambient 0.2 diffuse 0.5 }
  }

  #declare Blue = texture {
    pigment { color rgb&lt;0.2, 0.2, 0.8&gt; }
    finish { ambient 0.2 diffuse 0.5 }
  }
</listing>
<p>
We must declare all textures we want to use inside the mesh before the mesh is created. Textures cannot be specified inside the mesh due to the poor memory performance that would result.<p>
Now we add the mesh object. Three sides of the box will use individual textures while the other will use the <strong>global</strong> mesh texture.<p>
<listing>
  mesh {
    /* top side */
    triangle { &lt;-10, 10, -10&gt;, &lt;10, 10, -10&gt;, &lt;10, 10, 10&gt;
      texture { Red }
    }
    triangle { &lt;-10, 10, -10&gt;, &lt;-10, 10, 10&gt;, &lt;10, 10, 10&gt;
      texture { Red }
    }
    /* bottom side */
    triangle { &lt;-10, -10, -10&gt;, &lt;10, -10, -10&gt;, &lt;10, -10, 10&gt; }
    triangle { &lt;-10, -10, -10&gt;, &lt;-10, -10, 10&gt;, &lt;10, -10, 10&gt; }
    /* left side */
    triangle { &lt;-10, -10, -10&gt;, &lt;-10, -10, 10&gt;, &lt;-10, 10, 10&gt; }
    triangle { &lt;-10, -10, -10&gt;, &lt;-10, 10, -10&gt;, &lt;-10, 10, 10&gt; }
    /* right side */
    triangle { &lt;10, -10, -10&gt;, &lt;10, -10, 10&gt;, &lt;10, 10, 10&gt;
      texture { Green }
    }
    triangle { &lt;10, -10, -10&gt;, &lt;10, 10, -10&gt;, &lt;10, 10, 10&gt;
      texture { Green }
    }
    /* front side */
    triangle { &lt;-10, -10, -10&gt;, &lt;10, -10, -10&gt;, &lt;-10, 10, -10&gt;
      texture { Blue }
    }
    triangle { &lt;-10, 10, -10&gt;, &lt;10, 10, -10&gt;, &lt;10, -10, -10&gt;
      texture { Blue }
    }
    /* back side */
    triangle { &lt;-10, -10, 10&gt;, &lt;10, -10, 10&gt;, &lt;-10, 10, 10&gt; }
    triangle { &lt;-10, 10, 10&gt;, &lt;10, 10, 10&gt;, &lt;10, -10, 10&gt; }
    texture {
      pigment { color rgb&lt;0.9, 0.9, 0.9&gt; }
      finish { ambient 0.2 diffuse 0.7 }
    }
  }
</listing>
<p>
Tracing the scene at 320x240 we will see that the top, right and front side of the box have different textures. Though this is not a very impressive example it shows what we can do with mesh objects. More complex examples, also using smooth triangles, can be found under the scene directory as <b>chesmsh.pov</b> and <b>robotmsh.pov</b>.<hr>
<a name="ref 175 pri 0"><a name="ref 176 pri 0"><a name="ref 177 pri 3"><center><h3><a name="section 4.4.6">
Section 4.4.6<br>Polygon Object</h3></center>
The <a name="ref 177 pri 7"><strong>polygon</strong> object can be used to create any planar, n-sided shapes like squares, rectangles, pentagons, hexagons, octagons, etc.<p>
A polygon is defined by a number of points that describe its shape. Since polygons have to be closed the first point has to be repeated at the end of the point sequence.<p>
In the following example we will create the word <strong>POV</strong> using just one polygon statement.<p>
We start with thinking about the points we need to describe the desired shape. We want the letters to lie in the x-y-plane with the letter <strong>O</strong> being at the center. The letters extend from y=0 to y=1. Thus we get the following points for each letter (the z coordinate is automatically set to zero).<p>
<pre>
Letter P (outer polygon):
    &lt;-0.8, 0.0&gt;, &lt;-0.8, 1.0&gt;,
    &lt;-0.3, 1.0&gt;, &lt;-0.3, 0.5&gt;,
    &lt;-0.7, 0.5&gt;, &lt;-0.7, 0.0&gt;

Letter P (inner polygon):
    &lt;-0.7, 0.6&gt;, &lt;-0.7, 0.9&gt;,
    &lt;-0.4, 0.9&gt;, &lt;-0.4, 0.6&gt;

Letter O (outer polygon):
    &lt;-0.25, 0.0&gt;, &lt;-0.25, 1.0&gt;,
    &lt; 0.25, 1.0&gt;, &lt; 0.25, 0.0&gt;

Letter O (inner polygon):
    &lt;-0.15, 0.1&gt;, &lt;-0.15, 0.9&gt;,
    &lt; 0.15, 0.9&gt;, &lt; 0.15, 0.1&gt;

Letter V:
    &lt;0.45, 0.0&gt;, &lt;0.30, 1.0&gt;,
    &lt;0.40, 1.0&gt;, &lt;0.55, 0.1&gt;,
    &lt;0.70, 1.0&gt;, &lt;0.80, 1.0&gt;,
    &lt;0.65, 0.0&gt;
</pre>
<p>
Both letters <strong>P</strong> and <strong>O</strong> have a hole while the letter <strong>V</strong> consists of only one polygon. We'll start with the letter <strong>V</strong> because it is easier to define than the other two letters.<p>
We create a new file called <b>polygdem.pov</b> and add the following text.<p>
<listing>
  camera {
    orthographic
    location &lt;0, 0, -10&gt;
    right 1.3 * 4/3 * x
    up 1.3 * y
    look_at &lt;0, 0.5, 0&gt;
  }

  light_source { &lt;25, 25, -100&gt; color rgb 1 }

  polygon {
    8,

    &lt;0.45, 0.0&gt;, &lt;0.30, 1.0&gt;, // Letter &quot;V&quot;
    &lt;0.40, 1.0&gt;, &lt;0.55, 0.1&gt;,
    &lt;0.70, 1.0&gt;, &lt;0.80, 1.0&gt;,
    &lt;0.65, 0.0&gt;,
    &lt;0.45, 0.0&gt;

    pigment { color rgb &lt;1, 0, 0&gt; }
  }
</listing>
<p>
As noted above the polygon has to be closed by appending the first point to the point sequence. A closed polygon is always defined by a sequence of points that ends when a point is the same as the first point.<p>
After we have created the letter <strong>V</strong> we'll continue with the letter <strong>P</strong>. Since it has a hole we have to find a way of cutting this hole into the basic shape. This is quite easy. We just define the outer shape of the letter <strong>P</strong>, which is a closed polygon, and add the sequence of points that describes the hole, which is also a closed polygon. That's all we have to do. There'll be a hole where both polygons overlap.<p>
In general we will get holes whenever an even number of sub-polygons inside a single polygon statement overlap. A sub-polygon is defined by a closed sequence of points.<p>
The letter <strong>P</strong> consists of two sub-polygons, one for the outer shape and one for the hole. Since the hole polygon overlaps the outer shape polygon we'll get a hole.<p>
After we have understood how multiple sub-polygons in a single polygon statement work, it is quite easy to add the missing <strong>O</strong> letter.<p>
Finally, we get the complete word <strong>POV</strong>.<p>
<listing>
  polygon {
    30,

    &lt;-0.8, 0.0&gt;, &lt;-0.8, 1.0&gt;,    // Letter &quot;P&quot;
    &lt;-0.3, 1.0&gt;, &lt;-0.3, 0.5&gt;,    // outer shape
    &lt;-0.7, 0.5&gt;, &lt;-0.7, 0.0&gt;,
    &lt;-0.8, 0.0&gt;,

    &lt;-0.7, 0.6&gt;, &lt;-0.7, 0.9&gt;,    // whole
    &lt;-0.4, 0.9&gt;, &lt;-0.4, 0.6&gt;,
    &lt;-0.7, 0.6&gt;

    &lt;-0.25, 0.0&gt;, &lt;-0.25, 1.0&gt;,  // Letter &quot;O&quot;
    &lt; 0.25, 1.0&gt;, &lt; 0.25, 0.0&gt;,  // outer shape
    &lt;-0.25, 0.0&gt;,

    &lt;-0.15, 0.1&gt;, &lt;-0.15, 0.9&gt;,  // whole
    &lt; 0.15, 0.9&gt;, &lt; 0.15, 0.1&gt;,
    &lt;-0.15, 0.1&gt;,

    &lt;0.45, 0.0&gt;, &lt;0.30, 1.0&gt;,    // Letter &quot;V&quot;
    &lt;0.40, 1.0&gt;, &lt;0.55, 0.1&gt;,
    &lt;0.70, 1.0&gt;, &lt;0.80, 1.0&gt;,
    &lt;0.65, 0.0&gt;,
    &lt;0.45, 0.0&gt;

    pigment { color rgb &lt;1, 0, 0&gt; }
  }
</listing>
<p>
<center><img src="pov3000d.gif" border=0 width=320 height=240><br><cite>The word &quot;POV&quot; made with one polygon statement.</cite></center><br> <hr>
<a name="ref 178 pri 0"><a name="ref 179 pri 0"><center><h3><a name="section 4.4.7">
Section 4.4.7<br>Prism Object</h3></center>
The prism is essentially a polygon or closed curve which is swept along a linear path. We can imagine the shape so swept leaving a trail in space, and the surface of that trail is the surface of our prism. The curve or polygon making up a prism's face can be a composite of any number of sub-shapes, can use any kind of three different splines, and can either keep a constant width as it is swept, or slowly tapering off to a fine point on one end. But before this gets too confusing, let's start one step at a time with the simplest form of prism. We enter and render the following POV code (see file <b>prismdm1.pov</b>).<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    angle 20
    location &lt;2, 10, -30&gt;
    look_at &lt;0, 1, 0&gt;
  }

  light_source { &lt;20, 20, -20&gt; color White }

  prism {
    linear_sweep
    linear_spline
    0, // sweep the following shape from here ...
    1, // ... up through here
    7, // the number of points making up the shape ...

    &lt;3,5&gt;, &lt;-3,5&gt;, &lt;-5,0&gt;, &lt;-3,-5&gt;, &lt;3, -5&gt;, &lt;5,0&gt;, &lt;3,5&gt;

    pigment { Green }
  }
</listing>
<p>
<center><img src="pov3000e.gif" border=0 width=320 height=240><br><cite>A hexagonal prism shape.</cite></center><br> <p>
This produces a hexagonal polygon, which is then swept from y=0 through y=1. In other words, we now have an extruded hexagon. One point to note is that although this is a six sided figure, we have used a total of seven points. That is because the polygon is supposed to be a closed shape, which we do here by making the final point the same as the first. Technically, with linear polygons, if we didn't do this, POV-Ray would automatically join the two ends with a line to force it to close, although a warning would be issued. However, this only works with linear splines, so we mustn't get too casual about those warning messages!<hr>

<center>
<a href="pov30007.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
