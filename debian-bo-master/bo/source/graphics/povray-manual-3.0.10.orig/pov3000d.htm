<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 366 pri 0"><a name="ref 367 pri 0"><center><h3><a name="section 4.8.4.6.3">
Section 4.8.4.6.3<br>Caustics And Normals</h3></center>
POV-Ray makes use of surface normal perturbation in a way that is more unique than people generally stop to think. When we apply a surface normal in a texture we are actually not altering the surface at all, but rather telling POV-Ray to treat the surface <strong>as if</strong> it were altered, for purposes of computing the illumination falling on each individual spot. In short, it is a trick of the light and shadow which, supposing only that we don't see it at too sharp a viewing angle, effectively creates the illusion of distortions in the surface of an object.<p>
Caustics are also a synthetic trick, as we saw above, and sure enough, they have been designed to react to texture normal patterns as if those patterns were genuinely there. Remember the drinking glass experiment? If we found a glass with patterns etched into the surface we probably noted that the pattern showed up in the caustics cast by the glass too. When we have a transparent surface with a normal applied to it, it causes the caustics cast by that surface to mimick the normal pattern, so that it shows up in the shadows.<p>
Following is an example of what we mean: it is a simply meant to represent water in a swimming pool. We have distilled this down to a plane above to represent the water, one below to represent the floor of the pool, a camera just below the waterline, looking at the floor, and a light source high above (see <b>caustic2.pov</b>).<p>
<listing>
  #include &quot;colors.inc&quot;

  // Our camera is underwater, looking at the bottom of
  // the pool for the best view of the caustics produced

  camera {
    location &lt;0, -5, 0&gt;
    look_at  &lt;0, -10, -5&gt;
  }

  light_source { &lt;0, 100, 49.5&gt; color White }

  // the bottom of the pool...

  plane { y, -10
    texture {
      pigment { color rgb &lt;0.6, 0.7, 0.7&gt; }
      finish { ambient 0.1 diffuse 0.7 }
      scale 0.01
    }
  }

  // and the surface of the water

  plane { y, 0
    texture {
      pigment { rgbf &lt;0.6, 0.67, 0.72, 0.9&gt; }
      normal {
        bumps .6
        scale &lt;.75, .25, .25&gt;
        rotate &lt;0, 45, 0&gt;
      }
      finish { caustics .9 }
    }
  }
</listing>
<p>
The bumps we have given the water plane are meant to represent the small, random crests and troughs that form on a pool when a light breeze blows over it. We could have used ripples or waves as well, like something had recently splashed into it at some point, but the bumps will work well enough for an example.<p>
We notice that our view of the pool floor shows dozens of tiny caustic light spots, corresponding approximately to a random bump pattern. If we like we can try putting in ripples or waves and watch the pattern of the caustics change. Even though a flat plane itself would cast no caustics (we could try without the normal), POV-Ray's faked caustic generation knows that if the surface was really <strong>bumped</strong> like this normal is indicating, the refraction of the bumped surface would be just enough to concentrate light in caustics throughout the bottom of the pool.<p>
We see that just as with a curved surface, such as the sphere previously, normal patterns also trigger the appearance of caustics cast by an object. Interestingly enough, this alone would be proof that the caustics really are faked: our <strong>water</strong> hasn't even been given any refraction properties in its finish, yet the caustics are still there just the same!<hr>
<a name="ref 368 pri 0"><a name="ref 369 pri 0"><center><h3><a name="section 4.8.4.7">
Section 4.8.4.7<br>Using Iridescence</h3></center>
<strong>Iridescence</strong> is what we see on the surface of an oil slick when the sun shines on it. The rainbow effect is created by something called <strong>thin-film interference</strong> (read section <a href="pov30027.htm#ref 343 pri 1">&quot;Iridescence&quot;</a> for details). For now let's just try using it. Iridescence is specified by the <a name="ref 370 pri 1"><strong>irid</strong> keyword and three values: amount, <a name="ref 371 pri 2"><strong>thickness</strong> and <a name="ref 283 pri 6"><strong>turbulence</strong>. The amount is the contribution to the overall surface color. Usually 0.1 to 0.5 is sufficient here. The thickness affects the <strong>busyness</strong> of the effect. Keep this between 0.25 and 1 for best results. The turbulence is a little different from pigment or normal turbulence. We cannot set <a name="ref 312 pri 9"><strong>octaves</strong>, <a name="ref 311 pri 12"><strong>lambda</strong> or <a name="ref 310 pri 15"><strong>omega</strong> but we can specify an amount which will affect the thickness in a slightly different way from the thickness value. Values between 0.25 and 1 work best here too. Finally, iridescence will respond to the surface normal since it depends on the angle of incidence of the light rays striking the surface. With all of this in mind, let's add some iridescence to our glass sphere.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    pigment { White filter 1 }
      finish {
        ambient .1
        diffuse .1
        reflection .2
        refraction 1
        ior 1.5
        specular 1
        roughness .001
        fade_distance 5
        fade_power 1
        caustics 1
        irid {
          0.35
          thickness .5
          turbulence .5
        }
     }
  }
</listing>
<p>
We try to vary the values for amount, thickness and turbulence to see what changes they make. We also try to add a <a name="ref 324 pri 19"><strong>normal</strong> block to see what happens.<hr>
<a name="ref 372 pri 0"><a name="ref 256 pri 0"><center><h3><a name="section 4.8.5">
Section 4.8.5<br>Halos</h3></center>
<b>Important notice</b>: The halo feature in POV-Ray 3.0 is somewhat experimental. There is a high probability that the design and implementation of these features will be changed in future versions. We cannot guarantee that scenes using these features in 3.0 will render identically in future releases or that full backwards compatibility of language syntax can be maintained.<p>
<a name="ref 373 pri 1">Halos are a powerful feature that can be used to create a lot of different effects like clouds, fogs, fire, lasers, etc. The name actually comes from the ability to render halos with it, like the ones seen around the moon or the sun.<p>
Due to the complexity of the halo feature and the large amount of parameters provided it is very difficult to get satisfying results. The following sections will help to create a halo step by step, starting with the basic things and going to the more subtle stuff.<p>
It is also helpful to read the halo reference sections to get a better understanding of the halo feature. One should especially read the sections <a href="pov3001f.htm#ref 374 pri 0">&quot;Empty and Solid Objects&quot;</a> and <a href="pov30027.htm#ref 375 pri 0">&quot;Halo Mapping&quot;</a>  because they are essential for understanding halos.<hr>
<a name="ref 376 pri 0"><a name="ref 377 pri 0"><a name="ref 373 pri 2"><center><h3><a name="section 4.8.5.1">
Section 4.8.5.1<br>What are Halos?</h3></center>
Halos are a texture feature allowing us to fill the interior of an object with particles. The distribution of these particles can be modified using several density mappings and density functions. The particles can emit light to give fire- or laser-like effects or they can absorb light to create clouds or fog.<p>
A halo is attached to an object, the so called <strong>container object</strong>, just like a pigment, normal or finish. The container object is completely filled by the halo but we will not see anything if we do not make sure that the object is hollow and the surface is translucent. How this is accomplished will be shown in the next section.<p>
When working with halos we always have to keep in mind that the container object has to be hollow and translucent.<hr>
<a name="ref 378 pri 0"><a name="ref 379 pri 0"><a name="ref 380 pri 1"><a name="ref 381 pri 1"><center><h3><a name="section 4.8.5.2">
Section 4.8.5.2<br>The Emitting Halo</h3></center>
We start with one of the simpler types, the <strong>emitting halo</strong>. It uses particles that only emit light. There are no particles that absorb the light coming from other particles or light sources.<hr>
<a name="ref 382 pri 0"><a name="ref 383 pri 0"><center><h3><a name="section 4.8.5.2.1">
Section 4.8.5.2.1<br>Starting with a Basic Halo</h3></center>
A clever approach in designing a nice halo effect is to start with a simple, unit-sized shape that sits on the coordinate system's origin.<p>
In the first example (<b>halo01.pov</b>) we try to create a fiery explosion, which the sphere is best suited for. We start with a simple scene consisting of a camera, a light source (we don't care about shadows so we add the shadowless keyword), a checkered plane and a unit-sized sphere containing the halo.<p>
<listing>
  camera {
    location &lt;0, 0, -2.5&gt;
    look_at &lt;0, 0, 0&gt;
  }

  light_source { &lt;10, 10, -10&gt; color rgb 1 shadowless }

  plane { z, 2
    pigment { checker color rgb 0, color rgb 1 }
    finish { ambient 1 diffuse 0 }
    scale 0.5
    hollow
  }

  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      emitting
      spherical_mapping
      linear
      color_map {
        [ 0 color rgbt &lt;1, 0, 0, 1&gt; ]
        [ 1 color rgbt &lt;1, 1, 0, 0&gt; ]
      }
      samples 10
    }
    hollow
  }
</listing>
<p>
We note that the sphere is set to be hollow and has a translucent surface (the transmittance channel in the pigment's color is 1), just like it is required for halos. We also note that the plane has a <a name="ref 384 pri 2"><strong>hollow</strong> keyword even though it has no halo. Why is this necessary?<p>
<a name="ref 384 pri 5">The reason is quite simple. As described in section <a href="pov3001f.htm#ref 374 pri 0">&quot;Empty and Solid Objects&quot;</a> there can be no halo inside any other non-hollow object. Since the camera is <strong>inside</strong> the plane object, i. e. it is on the side of the plane that is considered to be inside, the halo will never be visible unless the plane is made hollow (or the <a name="ref 385 pri 5"><strong>negative</strong> keyword is added to bring the camera on the <strong>outside</strong> side of the plane).<p>
<a name="ref 380 pri 7"><a name="ref 381 pri 8">What do all those halo keywords and values mean? At the beginning of the halo the <a name="ref 380 pri 11"><strong>emitting</strong> keyword is used to specify what type of halo we want to use. The emitting halo emits light. That is what is best suited for our fiery explosion.<p>
<a name="ref 386 pri 12"><a name="ref 387 pri 12"><a name="ref 388 pri 12"><a name="ref 389 pri 12">The <a name="ref 388 pri 13"><strong>spherical_mapping</strong> and <a name="ref 386 pri 15"><strong>linear</strong> keywords need a more detailed explanation of how a halo works (this is also done in chapter <a href="pov30027.htm#ref 373 pri 0">&quot;Halo&quot;</a> in more detail).<p>
As noted above the halo is made up of lots of small particles. The distribution of these particles is described by a density function. In general, a density function tells us how much particles we'll find at a given location.<p>
Instead of using an explicitly, mathematical density function, halos rely on a given set of density mappings and density functions to model a variety of particle distributions.<p>
The first step in this model is the density mapping function that is used to map three-dimensional points onto a one-dimensional range of values. In our example we use a spherical mapping, i.e. we take the distance of a point from the center of the coordinate system. This is the reason why it is clever to start with a container object sitting on the coordinate system's center. Since all density mappings are made relative to this center we won't see anything if we start with an object sitting somewhere else. Moving the whole object (including textures and halos) to another location is the correct way of placing a container object.<p>
Now we have a single value in the range from 0 to 1. This value will be transformed using a density function to get density values instead of distance values. Just using this single value won't work because we want to have particle distributions were the density decreases as we move from the center of the container object to the outside.<p>
This is done by the density function. There are several alternatives available as described in the halo reference (see section <a href="pov30028.htm#ref 390 pri 0">&quot;Density Function&quot;</a>). We use the simple linear function that just maps values between 0 and 1 onto a 1 to 0 range. Thus we get a density value of 1 at the center of our sphere and a value of 0 at its surface.<p>
<a name="ref 391 pri 16">Now that we have a density function what do we do to see something? This is where the <a name="ref 391 pri 18"><strong>colour_map</strong> keyword comes into play. It is used to describe a color map that actually tells the program what colors are to be used for what density. The relation is quite simple: colors at the beginning of the color map (with small values) will be used for low density values and colors at the end of the map (high values) will be used for high densities. In our example the halo will be yellow at the center of the sphere where the density is greatest and it will blend to red at the surface of the sphere where the density approaches zero.<p>
The transmittance channel of the colors in the color map is used to model the translucency of the density field. A value of 0 represents no translucency, i. e. that areas with the corresponding density will be (almost) opaque, while a value of 1 means (almost) total translucency.<p>
In our example we use<p>
<listing>
  color_map {
    [ 0 color rgbt &lt;1, 0, 0, 1&gt; ]
    [ 1 color rgbt &lt;1, 1, 0, 0&gt; ]
  }
</listing>
<p>
which results in a halo with a very translucent, reddish outer area and a nearly opaque, yellowish inner areas as we can see after tracing the example image.<p>
<center><img src="pov3001b.gif" border=0 width=320 height=240><br><cite>The basic halo used in modelling a fiery explosion.</cite></center><br> <p>
<a name="ref 392 pri 18"><a name="ref 393 pri 18">There is one parameter that still needs to be explained: the <a name="ref 392 pri 19"><strong>samples</strong> keyword. This keyword tells POV-Ray how many samples have to be taken along any ray traveling through the halo to calculate its effect. Using a low value will result in a high tracing speed while a high value will lead to a low speed. The sample value has to be increased if the halo looks somewhat noisy, i. e. if some artifacts of the low sampling rate appear. For more details see section <a href="pov30028.htm#ref 394 pri 0">&quot;Halo Sampling&quot;</a>.<p>
A good starting value for the number of samples is 10.<hr>
<a name="ref 395 pri 0"><a name="ref 396 pri 0"><center><h3><a name="section 4.8.5.2.2">
Section 4.8.5.2.2<br>Increasing the Brightness</h3></center>
The colors of the halo in the above image are somewhat dim. There is too much of the background visible through the halo. That does not look much like fire, does it? An easy way to fix this is to decrease the transparency of the particles in the areas of high density. We do this by using use the following color map instead of the old one (the negative transmittance is correct).<p>
<listing>
  color_map {
    [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
    [ 1 color rgbt &lt;1, 1, 0, -1&gt; ]
  }
</listing>
<p>
Looking at the result of <b>halo02.pov</b> we see that the halo is indeed much brighter.<p>
<center><img src="pov3001c.gif" border=0 width=320 height=240><br><cite>The halo is much brighter now.</cite></center><br> <hr>
<a name="ref 397 pri 0"><a name="ref 398 pri 0"><center><h3><a name="section 4.8.5.2.3">
Section 4.8.5.2.3<br>Adding Some Turbulence</h3></center>
What we now have does not look like a fiery explosion. It's more a glowing ball than anything else. Somehow we have to make it look more <strong>chaotic</strong>, we have to add some turbulence to it.<p>
<a name="ref 283 pri 5"><a name="ref 399 pri 5">This is done by using the <a name="ref 283 pri 11"><strong>turbulence</strong> keyword together with the amount of turbulence we want to add. Just like in the following example.<p>
<listing>
  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      emitting
      spherical_mapping
      linear
      turbulence 1.5
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 1, 0, -1&gt; ]
      }
      samples 10
    }
    hollow
  }
</listing>
<p>
Adding turbulence to the halo moves all points inside the halo container in a pseudo-random manner. This results in a particle distribution that looks like there was some kind of <strong>flow</strong> in the halo (depending on the amount of turbulence we'll get a laminar or turbulent flow). The high turbulence value is used because an explosion is highly turbulent.<p>
Looking at the example image (<b>halo03.pov</b>) we'll see that this looks more like a fiery explosion than the glowing ball we got until now.<p>
<center><img src="pov3001d.gif" border=0 width=320 height=240><br><cite>Adding some turbulence makes the fiery explosion more realistic.</cite></center><br> <p>
We notice that the time it took to render the image increased after we added the turbulence. This is due to the fact that for every sample taken from the halo the slow turbulence function has to be evaluated.<hr>
<a name="ref 400 pri 0"><a name="ref 401 pri 0"><center><h3><a name="section 4.8.5.2.4">
Section 4.8.5.2.4<br>Resizing the Halo</h3></center>
There is one strange thing about our fiery explosion though. It still looks like a sphere. Why does this happen and what can we do to avoid it?<p>
As noted above adding turbulence moves the particles inside the halo container around. The problem is that some of the particles are actually moved out of the container object. This leads to high densities at the surface of the container object revealing the shape of the object (all particles outside the container are lost and will not visible resulting in a large, highly visible density change at the surface).<p>
An easy way of avoiding this is to make sure that the particles stay inside the container object even if we add some turbulence. This is done by scaling the halo to reduce its size. We do <b>not</b> scale the container object, just the halo.<p>
<a name="ref 215 pri 4"><a name="ref 402 pri 4">This is done by adding the <a name="ref 215 pri 9"><strong>scale</strong> keyword inside the halo statement.<p>
<listing>
  sphere { 0, 1
    pigment { color rgbt &lt;1, 1, 1, 1&gt; }
    halo {
      emitting
      spherical_mapping
      linear
      turbulence 1.5
      color_map {
        [ 0 color rgbt &lt;1, 0, 0,  1&gt; ]
        [ 1 color rgbt &lt;1, 1, 0, -1&gt; ]
      }
      samples 10
      scale 0.5
    }
    hollow
    scale 1.5
  }
</listing>
<p>
The <strong>scale 0.5</strong> command tells POV-Ray to scale all points inside the halo by this amount. This effectively scales the radius we get after the density mapping to a range of 0 to 0.5 instead of 0 to 1 (without turbulence). If we now add the turbulence the points are allowed to move half a unit in every direction without leaving the container object. That is exactly what we want.<p>
To compensate for the smaller halo we would get we scale the sphere (and the halo inside) by 1.5.<p>
Looking at the new example image (<b>halo04.pov</b>) we will no longer see any signs of the container sphere. We finally have a nice fiery explosion.<p>
<center><img src="pov3001e.gif" border=0 width=320 height=240><br><cite>Resizing the halo makes it look much better.</cite></center><br> <p>
The amount by which to scale the halo depends on the amount of turbulence we use. The higher the turbulence value the smaller the halo has to be scaled. That is something to experiment with.<p>
Another way to avoid that points move out of the sphere is to use a larger sphere, i. e. a sphere with a radius larger than one. It is important to re-size the sphere before the halo is added because otherwise the halo will also be scaled.<p>
We note that this only works for spherical and box mapping (and a non-constant density function). All other mapping types are (partially) infinite, i. e. the resulting particle distribution covers an infinite space (see also <a href="pov30027.htm#ref 375 pri 0">&quot;Halo Mapping&quot;</a>).<hr>

<center>
<a href="pov3000e.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
