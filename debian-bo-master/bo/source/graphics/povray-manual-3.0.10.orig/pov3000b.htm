<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 287 pri 0"><a name="ref 288 pri 0"><center><h3><a name="section 4.8">
Section 4.8<br>Advanced Texture Options</h3></center>
The extremely powerful texturing ability is one thing that really sets POV-Ray apart from other raytracers. So far we have not really tried anything too complex but by now we should be comfortable enough with the program's syntax to try some of the more advanced texture options.<p>
Obviously, we cannot try them all. It would take a tutorial a lot more pages to use every texturing option available in POV-Ray. For this limited tutorial, we will content ourselves to just trying a few of them to give an idea of how textures are created. With a little practice, we will soon be creating beautiful textures of our own.<hr>
<a name="ref 289 pri 0"><a name="ref 290 pri 0"><center><h3><a name="section 4.8.1">
Section 4.8.1<br>Pigment and Normal Patterns</h3></center>
Previous versions of POV-Ray made a distinction between pigment and normal patterns, i. e. patterns that could be used inside a <strong>normal</strong> or <strong>pigment</strong> statement. With POV-Ray 3.0 this restriction was removed so that all patterns listed in section <a href="pov30029.htm#ref 291 pri 0">&quot;Patterns&quot;</a> can be used as a pigment or normal pattern.<hr>
<a name="ref 292 pri 0"><a name="ref 293 pri 0"><a name="ref 294 pri 2"><center><h3><a name="section 4.8.2">
Section 4.8.2<br>Pigments</h3></center>
Every surface must have a color. In POV-Ray this color is called a <strong>pigment</strong>. It does not have to be a single color. It can be a color pattern, a color list or even an image map. Pigments can also be layered one on top of the next so long as the uppermost layers are at least partially transparent so the ones beneath can show through. Let's play around with some of these kinds of pigments.<p>
We create a file called <b>texdemo.pov</b> and edit it as follows:<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    location &lt;1, 1, -7&gt;
    look_at 0
    angle 36
  }

  light_source { &lt;1000, 1000, -1000&gt; White }

  plane { y, -1.5
    pigment { checker Green, White }
  }

  sphere { &lt;0,0,0&gt;, 1
    pigment { Red }
  }
</listing>
<p>
Giving this file a quick test render at 200x150 <a name="ref 89 pri 15"><strong>-A</strong> we see that it is a simple red sphere against a green and white checkered plane. We will be using the sphere for our textures.<hr>
<a name="ref 295 pri 0"><a name="ref 296 pri 0"><a name="ref 297 pri 2"><a name="ref 298 pri 4"><center><h3><a name="section 4.8.2.1">
Section 4.8.2.1<br>Using Color List Pigments</h3></center>
Before we begin we should note that we have already made one kind of pigment, the color list pigment. In the previous example we have used a checkered pattern on our plane. There are two other kinds of color list pigments, <a name="ref 297 pri 7"><strong>brick</strong> and <a name="ref 298 pri 10"><strong>hexagon</strong>. Let's quickly try each of these. First, we change the plane's pigment as follows:<p>
<listing>
  pigment { hexagon Green, White, Yellow }
</listing>
<p>
Rendering this we see a three-color hexagonal pattern. Note that this pattern requires three colors. Now we change the pigment to...<p>
<listing>
  pigment { brick Gray75, Red rotate -90*x scale .25 }
</listing>
<p>
Looking at the resulting image we see that the plane now has a brick pattern. We note that we had to rotate the pattern to make it appear correctly on the flat plane. This pattern normally is meant to be used on vertical surfaces. We also had to scale the pattern down a bit so we could see it more easily. We can play around with these color list pigments, change the colors, etc. until we get a <strong>floor</strong> that we like.<hr>
<a name="ref 299 pri 0"><a name="ref 300 pri 0"><center><h3><a name="section 4.8.2.2">
Section 4.8.2.2<br>Using Pigment and Patterns</h3></center>
Let's begin texturing our sphere by using a pattern and a color map consisting of three colors. wE replace the pigment block with the following.<p>
<listing>
  pigment {
    gradient x
    color_map {
      [0.00 color Red]
      [0.33 color Blue]
      [0.66 color Yellow]
      [1.00 color Red]
    }
  }
</listing>
<p>
Rendering this we see that it gives us an interesting pattern of vertical stripes. We change the gradient direction to y. The stripes are horizontal now. We change the gradient direction to z. The stripes are now more like concentric rings. This is because the gradient direction is directly away from the camera. We change the direction back to x and add the following to the pigment block.<p>
<listing>
  pigment {
    gradient x
    color_map {
      [0.00 color Red]
      [0.33 color Blue]
      [0.66 color Yellow]
      [1.00 color Red]
    }
    rotate -45*z          // &lt;- add this line
  }
</listing>
<p>
The vertical bars are now slanted at a 45 degree angle. All patterns can be rotated, scaled and translated in this manner. Let's now try some different types of patterns. One at a time, we substitute the following keywords for <strong>gradient x</strong> and render to see the result: <a name="ref 301 pri 2"><strong>bozo</strong>, <a name="ref 302 pri 4"><strong>marble</strong>, <a name="ref 303 pri 6"><strong>agate</strong>, <a name="ref 304 pri 8"><strong>granite</strong>, <a name="ref 305 pri 10"><strong>leopard</strong>, <a name="ref 306 pri 12"><strong>spotted</strong> and <a name="ref 281 pri 15"><strong>wood</strong> (if we like we can test all patterns listed in section <a href="pov30029.htm#ref 291 pri 0">&quot;Patterns&quot;</a>).<p>
Rendering these we see that each results in a slightly different pattern. But to get really good results each type of pattern requires the use of some pattern modifiers.<hr>
<a name="ref 307 pri 0"><a name="ref 308 pri 0"><center><h3><a name="section 4.8.2.3">
Section 4.8.2.3<br>Using Pattern Modifiers</h3></center>
Let's take a look at some pattern modifiers. First, we change the pattern type to bozo. Then we add the following change.<p>
<listing>
  pigment {
    bozo
    frequency 3            // &lt;- add this line
    color_map {
      [0.00 color Red]
      [0.33 color Blue]
      [0.66 color Yellow]
      [1.00 color Red]
    }
    rotate -45*z
  }
</listing>
<p>
The <a name="ref 309 pri 0"><strong>frequency</strong> modifier determines the number of times the color map repeats itself per unit of size. This change makes the <a name="ref 301 pri 3"><strong>bozo</strong> pattern we saw earlier have many more bands in it. Now we change the pattern type to <a name="ref 302 pri 6"><strong>marble</strong>. When we rendered this earlier, we saw a banded pattern similar to <strong>gradient y</strong> that really did not look much like marble at all. This is because marble really is a kind of gradient and it needs another pattern modifier to look like marble. This modifier is called <strong>turbulence</strong>. We change the line <strong>frequency 3</strong> to <strong>turbulence 1</strong> and render again. That's better! Now let's put <strong>frequency 3</strong> back in right after the turbulence and take another look. Even more interesting!<p>
But wait, it get's better! Turbulence itself has some modifiers of its own. We can adjust the turbulence several ways. First, the float that follows the <a name="ref 283 pri 9"><strong>turbulence</strong> keyword can be any value with higher values giving us more turbulence. Second, we can use the keywords <a name="ref 310 pri 11"><strong>omega</strong>, <a name="ref 311 pri 13"><strong>lambda</strong> and <a name="ref 312 pri 15"><strong>octaves</strong> to change the turbulence parameters. Let's try this now:<p>
<listing>
  pigment {
    marble
    turbulence 0.5
    lambda 1.5
    omega 0.8
    octaves 5
    frequency 3
    color_map {
      [0.00 color Red]
      [0.33 color Blue]
      [0.66 color Yellow]
      [1.00 color Red]
    }
    rotate 45*z
  }
</listing>
<p>
Rendering this we see that the turbulence has changed and the pattern looks different. We play around with the numerical values of turbulence, lambda, omega and octaves to see what they do.<hr>
<a name="ref 313 pri 0"><a name="ref 314 pri 0"><center><h3><a name="section 4.8.2.4">
Section 4.8.2.4<br>Using Transparent Pigments and Layered Textures</h3></center>
Pigments are described by numerical values that give the rgb value of the color to be used (like <strong>color rgb &lt;1, 0, 0&gt;</strong> giving us a red color). But this syntax will give us more than just the rgb values. We can specify filtering transparency by changing it as follows: <strong>color rgbf&lt;1, 0, 0, 1&gt;</strong>. The <strong>f</strong> stands for <a name="ref 315 pri 0"><strong>filter</strong>, POV-Ray's word for filtered transparency. A value of one means that the color is completely transparent, but still filters the light according to what the pigment is. In this case, the color will be a transparent red, like red cellophane.<p>
There is another kind of transparency in POV-Ray. It is called <strong>transmittance</strong> or non-filtering transparency (the keyword is <a name="ref 316 pri 0"><strong>transmit</strong>). It is different from <a name="ref 315 pri 1"><strong>filter</strong> in that it does not filter the light according to the pigment color. It instead allows all the light to pass through unchanged. It can be specified like this: <strong>rgbt &lt;1, 0, 0, 1&gt;</strong>.<p>
Let's use some transparent pigments to create another kind of texture, the layered texture. Returning to our previous example, declare the following texture.<p>
<listing>
  #declare LandArea = texture {
      pigment {
        agate
        turbulence 1
        lambda 1.5
        omega .8
        octaves 8
        color_map {
          [0.00 color rgb &lt;.5, .25, .15&gt;]
          [0.33 color rgb &lt;.1, .5, .4&gt;]
          [0.86 color rgb &lt;.6, .3, .1&gt;]
          [1.00 color rgb &lt;.5, .25, .15&gt;]
        }
      }
    }
  }
</listing>
<p>
This texture will be the <strong>land</strong> area. Now let's make the oceans by declaring the following.<p>
<listing>
  #declare OceanArea = texture {
    pigment {
      bozo
        turbulence .5
        lambda 2
        color_map {
          [0.00, 0.33 color rgb &lt;0, 0, 1&gt;
                      color rgb &lt;0, 0, 1&gt;]
          [0.33, 0.66 color rgbf &lt;1, 1, 1, 1&gt;
                      color rgbf &lt;1, 1, 1, 1&gt;]
          [0.66, 1.00 color rgb &lt;0, 0, 1&gt;
                      color rgb &lt;0, 0, 1&gt;]
        }
      }
    }
  }
</listing>
<p>
Note how the <strong>ocean</strong> is the opaque blue area and the <strong>land</strong> is the clear area which will allow the underlying texture to show through.<p>
Now, let's declare one more texture to simulate an atmosphere with swirling clouds.<p>
<listing>
  #declare CloudArea = texture {
    pigment {
      agate
      turbulence 1
      lambda 2
      frequency 2
      color_map {
        [0.0 color rgbf &lt;1, 1, 1, 1&gt;]
        [0.5 color rgbf &lt;1, 1, 1, .35&gt;]
        [1.0 color rgbf &lt;1, 1, 1, 1&gt;]
      }
    }
  }
</listing>
<p>
Now apply all of these to our sphere.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    texture { LandArea }
    texture { OceanArea }
    texture { CloudArea }
  }
</listing>
<p>
We render this and have a pretty good rendition of a little planetoid. But it could be better. We don't particularly like the appearance of the clouds. There is a way they could be done that would be much more realistic.<hr>
<a name="ref 317 pri 0"><a name="ref 318 pri 0"><a name="ref 319 pri 1"><center><h3><a name="section 4.8.2.5">
Section 4.8.2.5<br>Using Pigment Maps</h3></center>
Pigments may be blended together in the same way as the colors in a color map using the same pattern keywords that we can use for pigments. Let's just give it a try.<p>
We add the following declarations, making sure they appear before the other declarations in the file.<p>
<listing>
  #declare Clouds1 = pigment {
      bozo
      turbulence 1
      color_map {
        [0.0 color White filter 1]
        [0.5 color White]
        [1.0 color White filter 1]
      }
    }
  #declare Clouds2 = pigment {
    agate
    turbulence 1
    color_map {
      [0.0 color White filter 1]
      [0.5 color White]
      [1.0 color White filter 1]
      }
    }
  #declare Clouds3 = pigment {
    marble
    turbulence 1
    color_map {
      [0.0 color White filter 1]
      [0.5 color White]
      [1.0 color White filter 1]
    }
  }
  #declare Clouds4 = pigment {
    granite
    turbulence 1
    color_map {
      [0.0 color White filter 1]
      [0.5 color White]
      [1.0 color White filter 1]
    }
  }
</listing>
<p>
Now we use these declared pigments in our cloud layer on our planetoid. We replace the declared cloud layer with.<p>
<listing>
  #declare CloudArea = texture {
    pigment {
      gradient y
      pigment_map {
        [0.00 Clouds1]
        [0.25 Clouds2]
        [0.50 Clouds3]
        [0.75 Clouds4]
        [1.00 Clouds1]
      }
    }
  }
</listing>
<p>
We render this and see a remarkable pattern that looks very much like weather patterns on the planet earth. They are separated into bands, simulating the different weather types found at different latitudes.<hr>
<a name="ref 320 pri 0"><a name="ref 321 pri 0"><center><h3><a name="section 4.8.3">
Section 4.8.3<br>Normals</h3></center>
Objects in POV-Ray have very smooth surfaces. This is not very realistic so there are several ways to disturb the smoothness of an object by perturbing the surface normal. The surface normal is the vector that is perpendicular to the angle of the surface. By changing this normal the surface can be made to appear bumpy, wrinkled or any of the many patterns available. Let's try a couple of them.<hr>
<a name="ref 322 pri 0"><a name="ref 323 pri 0"><center><h3><a name="section 4.8.3.1">
Section 4.8.3.1<br>Using Basic Normal Modifiers</h3></center>
We comment out the planetoid sphere for now and, at the bottom of the file, create a new sphere with a simple, single color texture.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    pigment { Gray75 }
    normal { bumps 1 scale .2 }
  }
</listing>
<p>
Here we have added a <a name="ref 324 pri 2"><strong>normal</strong> block in addition to the <a name="ref 294 pri 5"><strong>pigment</strong> block (note that these do not have to be included in a <a name="ref 112 pri 9"><strong>texture</strong> block unless they need to be transformed together or need to be part of a layered texture). We render this to see what it looks like. Now, one at a time, we substitute for the keyword <a name="ref 325 pri 11"><strong>bumps</strong> the following keywords: <a name="ref 326 pri 13"><strong>dents</strong>, <a name="ref 327 pri 15"><strong>wrinkles</strong>, <a name="ref 328 pri 17"><strong>ripples</strong> and <a name="ref 329 pri 19"><strong>waves</strong> (we can also use any of the patterns listed in <a href="pov30029.htm#ref 291 pri 0">&quot;Patterns&quot;</a>). We render each to see what they look like. We play around with the float value that follows the keyword. We also experiment with the scale value.<p>
For added interest, we change the plane texture to a single color with a normal as follows.<p>
<listing>
  plane { y, -1.5
    pigment { color rgb &lt;.65, .45, .35&gt; }
    normal { dents .75 scale .25 }
  }
</listing>
<hr>
<a name="ref 330 pri 0"><a name="ref 331 pri 0"><center><h3><a name="section 4.8.3.2">
Section 4.8.3.2<br>Blending Normals</h3></center>
Normals can be layered similar to pigments but the results can be unexpected. Let's try that now by editing the sphere as follows.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    pigment { Gray75 }
      normal { radial frequency 10 }
      normal { gradient y scale .2 }
  }
</listing>
<p>
As we can see, the resulting pattern is neither a radial nor a gradient. It is instead the result of first calculating a radial pattern and then calculating a gradient pattern. The results are simply additive. This can be difficult to control so POV-Ray gives the user other ways to blend normals.<p>
One way is to use normal maps. A normal map works the same way as the pigment map we used earlier. Let's change our sphere texture as follows.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    pigment { Gray75 }
    normal {
      gradient y
      frequency 3
      turbulence .5
      normal_map {
        [0.00 granite]
        [0.25 spotted turbulence .35]
        [0.50 marble turbulence .5]
        [0.75 bozo turbulence .25]
        [1.00 granite]
      }
    }
  }
</listing>
<p>
Rendering this we see that the sphere now has a very irregular bumpy surface. The gradient pattern type separates the normals into bands but they are turbulated, giving the surface a chaotic appearance. But this give us an idea.<p>
Suppose we use the same pattern for a normal map that we used to create the oceans on our planetoid and applied it to the land areas. Does it follow that if we use the same pattern and modifiers on a sphere the same size that the shape of the pattern would be the same? Wouldn't that make the land areas bumpy while leaving the oceans smooth? Let's try it. First, let's render the two spheres side-by-side so we can see if the pattern is indeed the same. We un-comment the planetoid sphere and make the following changes.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    texture { LandArea }
    texture { OceanArea }
    //texture { CloudArea }  // &lt;-comment this out
    translate -x             // &lt;- add this transformation
  }
</listing>
<p>
Now we change the gray sphere as follows.<p>
<listing>
  sphere { &lt;0,0,0&gt;, 1
    pigment { Gray75 }
    normal {
      bozo
      turbulence .5
      lambda 2
      normal_map {
        [0.4 dents .15 scale .01]
        [0.6 agate turbulence 1]
        [1.0 dents .15 scale .01]
      }
    }
    translate x // &lt;- add this transformation
  }
</listing>
<p>
We render this to see if the pattern is the same. We see that indeed it is. So let's comment out the gray sphere and add the <a name="ref 324 pri 3"><strong>normal</strong> block it contains to the land area texture of our planetoid. We remove the transformations so that the planetoid is centered in the scene again.<p>
<listing>
  #declare LandArea = texture {
    pigment {
      agate
      turbulence 1
      lambda 1.5
      omega .8
      octaves 8
      color_map {
        [0.00 color rgb &lt;.5, .25, .15&gt;]
        [0.33 color rgb &lt;.1, .5, .4&gt;]
        [0.86 color rgb &lt;.6, .3, .1&gt;]
        [1.00 color rgb &lt;.5, .25, .15&gt;]
      }
    }
    normal {
      bozo
      turbulence .5
      lambda 2
      normal_map {
        [0.4 dents .15 scale .01]
        [0.6 agate turbulence 1]
        [1.0 dents .15 scale .01]
      }
    }
  }
</listing>
<p>
Looking at the resulting image we see that indeed our idea works! The land areas are bumpy while the oceans are smooth. We add the cloud layer back in and our planetoid is complete.<p>
There is much more that we did not cover here due to space constraints. On our own, we should take the time to explore slope maps, average and bump maps.<hr>

<center>
<a href="pov3000c.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
