<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 1347 pri 0"><a name="ref 415 pri 0"><a name="ref 416 pri 1"><a name="ref 415 pri 4"><center><h3><a name="section 7.6.4.3.1">
Section 7.6.4.3.1<br>Attenuating</h3></center>
The attenuating halo that only absorbs light passing through it is rendered by accumulating the particle density along a ray. The total halo color is determined from the total, accumulated density and the specified color map (see section <a href="pov30028.htm#ref 1348 pri 0">&quot;Halo Color Map&quot;</a> for details about the color map). The background light, i. e. the light passing through the halo, is attenuated by the total density and added to the total halo color to get the final color of the halo.<p>
This model is suited to render particle distributions with a high <strong>albedo</strong> because the final color does not depend on the transparency of single volume elements but only on the total transparency along the ray. The <a name="ref 1349 pri 4"><strong>albedo</strong> of a particle is given by the amount of light scattered by this particle in all directions in relation to the amount of incoming light. If the particle doesn't absorb any light the albedo is one.<p>
Clouds and steams are two of the effects that can be rendered quite realistic by adding enough turbulence.<hr>
<a name="ref 1350 pri 0"><a name="ref 427 pri 0"><a name="ref 428 pri 1"><a name="ref 1351 pri 1"><a name="ref 1352 pri 1"><a name="ref 427 pri 3"><a name="ref 434 pri 4"><a name="ref 994 pri 4"><center><h3><a name="section 7.6.4.3.2">
Section 7.6.4.3.2<br>Dust</h3></center>
The dust halo consists of particles that do not emit any light. They only reflect and absorb incoming light. Its syntax is:<p>
<listing>
  halo {
    dust
    [ dust_type DUST_TYPE ]
    [ eccentricity ECCENTRICITY ]
  }
</listing>
<p>
As the ray marches through the dust all light coming from any light sources is accumulated and scattered according to the dust type and the current dust density. Since this light accumulation includes a test for occlusion, other objects may cast shadows <strong>into</strong> the dust.<p>
The same scattering types that are used with the atmosphere in section <a href="pov3002c.htm#ref 268 pri 0">&quot;Atmosphere&quot;</a> can be used with the dust (the default type is isotropic scattering). They are:<p>
<listing>
  #declare ISOTROPIC_SCATTERING         = 1
  #declare MIE_HAZY_SCATTERING          = 2
  #declare MIE_MURKY_SCATTERING         = 3
  #declare RAYLEIGH_SCATTERING          = 4
  #declare HENYEY_GREENSTEIN_SCATTERING = 5
</listing>
<p>
The Henyey-Greenstein function needs the additional parameter <a name="ref 994 pri 5"><strong>eccentricity</strong> that is described in the section about atmosphere. This keyword only applies to dust type 5, the Henyey-Greenstein scattering.<hr>
<a name="ref 1353 pri 0"><a name="ref 380 pri 0"><a name="ref 381 pri 2"><a name="ref 380 pri 7"><center><h3><a name="section 7.6.4.3.3">
Section 7.6.4.3.3<br>Emitting</h3></center>
Emitting halos only emit light. Every particle is a small light source that emits some light. This light is not attenuated by the other particles because they are assumed to be very small.<p>
As the ray travels through the density field of an emitting halo the color of the particles in each volume element and their differential transparency is determined from the color map. These intensities are accumulated to get the total color of the density field. This total intensity is added to the light passing through the halo. The background light is attenuated by the total density of the halo.<p>
Since the emitted light is not attenuated it can be used to model effects like fire, explosions, light beams, etc. By choosing a well suited color map those effects can be rendered with a high degree of realism.<p>
Fire is best modeled using planar mapping. Spherical mapping and high turbulence values can be used to create explosions (it's best to use a periodic color map and frequencies larger than one).<p>
Emitting halos do not cast any light on other objects like light sources do, even though they are made up of small, light-emitting particles. In order to make them actually emit light hundreds or thousands of small light sources would have to be used. This would slow down tracing by a degree that would make it useless.<hr>
<a name="ref 1354 pri 0"><a name="ref 409 pri 0"><a name="ref 410 pri 2"><a name="ref 409 pri 6"><center><h3><a name="section 7.6.4.3.4">
Section 7.6.4.3.4<br>Glowing</h3></center>
The glowing halo is similar to the emitting halo. The difference is that the light emitted by the particles is attenuated by the other particles. This can be seen as a combination of the attenuating and the emitting model.<hr>
<a name="ref 1355 pri 0"><a name="ref 1356 pri 0"><center><h3><a name="section 7.6.4.4">
Section 7.6.4.4<br>Density Mapping</h3></center>
The density mapping is used to map points in space onto a linear, one-dimensional interval between 0.0 and 1.0, thus describing the appearance of the three-dimensional particle distribution. The different mapping types are specified by:<p>
<listing>
  halo {
    planar_mapping | spherical_mapping |
    cylindrical_mapping | box_mapping
  }
</listing>
<p>
The default mapping type is planar mapping.<p>
Since the mapping takes place in relation to the origin of the world coordinate system the following rule must always be kept in mind: <strong>Halo container objects ought to be unit sized objects centered at the origin</strong>. They can be transformed later to suit the individuals needs.<p>
The different mapping types are explained in more detail in the following sections.<hr>
<a name="ref 1357 pri 0"><a name="ref 1358 pri 0"><a name="ref 1359 pri 0"><a name="ref 877 pri 0"><center><h3><a name="section 7.6.4.4.1">
Section 7.6.4.4.1<br>Box Mapping</h3></center>
The box mapping can be used to create a box-shaped particle distribution. The mapping is calculated by getting the maximum of the absolute values of each coordinate as given by the formula:<p>
<listing>
  r(x, y, z) = max(abs(x), abs(y), abs(z))
</listing>
<p>
Values larger than one are clipped to one.<hr>
<a name="ref 1360 pri 0"><a name="ref 1361 pri 0"><a name="ref 1362 pri 0"><a name="ref 967 pri 0"><center><h3><a name="section 7.6.4.4.2">
Section 7.6.4.4.2<br>Cylindrical Mapping</h3></center>
The distance r(x,y,z) from the y-axis given by<p>
<listing>
  r(x, y, z) = sqrt(x*x + z*z)
</listing>
<p>
is used to get the interval values. Values larger than one are clipped to one.<hr>
<a name="ref 1363 pri 0"><a name="ref 1364 pri 0"><a name="ref 1365 pri 0"><a name="ref 987 pri 0"><center><h3><a name="section 7.6.4.4.3">
Section 7.6.4.4.3<br>Planar Mapping</h3></center>
The distance r(x,y,z) from the x-z-plane given by<p>
<listing>
  r(x, y, z) = abs(y)
</listing>
<p>
is used to get the interval values. Values larger than one are clipped to one.<hr>
<a name="ref 1366 pri 0"><a name="ref 1367 pri 0"><a name="ref 389 pri 1"><a name="ref 388 pri 3"><center><h3><a name="section 7.6.4.4.4">
Section 7.6.4.4.4<br>Spherical Mapping</h3></center>
The distance r(x,y,z) from the origin given by<p>
<listing>
  r(x, y, z) = sqrt(x*x + y*y + z*z)
</listing>
<p>
is used to get the interval values. Values larger than one are clipped to one.<hr>
<a name="ref 1368 pri 0"><a name="ref 390 pri 0"><a name="ref 1369 pri 0"><a name="ref 433 pri 1"><center><h3><a name="section 7.6.4.5">
Section 7.6.4.5<br>Density Function</h3></center>
The density function determines how the actual density values are calculated from the linear, one-dimensional interval that resulted from the density mapping.<p>
The density function is specified by the following keywords:<p>
<listing>
  halo {
    [ constant | linear | cubic | poly ]
    [ max_value MAX_VALUE ]
    [ exponent EXPONENT ]
  }
</listing>
<p>
The <a name="ref 1012 pri 1"><strong>exponent</strong> keyword is only used together with the <a name="ref 995 pri 3"><strong>poly</strong> density function.<p>
The individual functions f(r) are described in the following sections. They all map the value r(x,y,z) calculated by the density mapping onto a suitable density range between 0 and MAX_VALUE (specified with the keyword <a name="ref 433 pri 5"><strong>max_value</strong>).<hr>
<a name="ref 1370 pri 0"><a name="ref 462 pri 0"><a name="ref 1371 pri 0"><a name="ref 462 pri 2"><center><h3><a name="section 7.6.4.5.1">
Section 7.6.4.5.1<br>Constant</h3></center>
The constant function gives the constant value MAX_VALUE regardless of the interval value and the type of density mapping. It is calculated by the trivial formula <listing>
  f(r) = MAX_VALUE.
</listing>
<p>
<center><img src="pov30051.gif" border=0 width=320 height=240><br><cite>The constant density function.</cite></center><br> <p>
The constant density function can be used to create a constant particle distribution that is only constrained by the container object.<hr>
<a name="ref 1372 pri 0"><a name="ref 386 pri 0"><a name="ref 387 pri 1"><a name="ref 386 pri 4"><center><h3><a name="section 7.6.4.5.2">
Section 7.6.4.5.2<br>Linear</h3></center>
A linear falloff from MAX_VALUE at r=0 to zero at r=1 is created with the linear density function. It is given by:<p>
<listing>
  f(r) = MAX_VALUE * (1 - r)
</listing>
<p>
<center><img src="pov30052.gif" border=0 width=320 height=240><br><cite>The linear density function.</cite></center><br> <hr>
<a name="ref 1373 pri 0"><a name="ref 961 pri 1"><a name="ref 1374 pri 1"><a name="ref 961 pri 3"><center><h3><a name="section 7.6.4.5.3">
Section 7.6.4.5.3<br>Cubic</h3></center>
The cubic function gives a smooth blend between the maximum value MAX_VALUE at r=0 and 0 at r=1. It is given by:<p>
<listing>
  f(r) = MAX_VALUE * (2 * r  - 3) * r * r + 1
</listing>
<p>
<center><img src="pov30053.gif" border=0 width=320 height=240><br><cite>The cubic density function.</cite></center><br> <p>
This is actually a cubic spline.<hr>
<a name="ref 1375 pri 0"><a name="ref 995 pri 1"><a name="ref 1376 pri 1"><a name="ref 1377 pri 1"><a name="ref 995 pri 4"><a name="ref 1012 pri 5"><center><h3><a name="section 7.6.4.5.4">
Section 7.6.4.5.4<br>Poly</h3></center>
A polynomial function can be used to get a large variety of density functions. All have the maximum value MAX_VALUE at r=0 and the minimum value 0 at r=1. It is given by:<p>
<listing>
  f(r) = MAX_VALUE * (1 - r) ^ EXPONENT
</listing>
<p>
<center><img src="pov30054.gif" border=0 width=320 height=240><br><cite>The polynomial density function for different exponent values.</cite></center><br> <p>
The exponent is given by the <a name="ref 1012 pri 7"><strong>exponent</strong> keyword. In case of EXPONENT=0 you'll get a linear falloff.<hr>
<a name="ref 1378 pri 0"><a name="ref 1348 pri 0"><a name="ref 1379 pri 0"><a name="ref 391 pri 3"><center><h3><a name="section 7.6.4.6">
Section 7.6.4.6<br>Halo Color Map</h3></center>
The density f(r), which ranges from 0 to MAX_VALUE, is mapped onto the color map to get the color and differential translucency for each volume element as the ray marches through the density field (the final color of attenuating halos is calculated from the total density; see section <a href="pov30027.htm#ref 375 pri 0">&quot;Halo Mapping&quot;</a> and section <a href="pov30028.htm#ref 415 pri 0">&quot;Attenuating&quot;</a>). The differential translucency determines for each value of f(r) how much the total opacity has to be increased (or decreased).<p>
The color map is specified by:<p>
<listing>
  halo {
    [ colour_map COLOUR_MAP ]
  }
</listing>
<p>
The differential translucency is stored in the transmittance channel of the map's color entries. A simple example is given by<p>
<listing>
  colour_map {
    [0 rgbt&lt;1, 1, 1, 1&gt;]
    [1 rgbt&lt;1, 1, 1, 0&gt;]
  }
</listing>
<p>
In this example areas with a low density (small f(r)) will be translucent (large differential translucency of 1=100%) and areas with a high density (large f(r)) will be opaque (small differential translucency of 0=0%). You should note that negative transmittance values can be used to create very dense fields.<p>
In the case of the dust halo the filter channels of the colors in the color map are used to specify the amount of light that will be filtered by the corresponding color map entry. For all other halo types the filter value is ignored.<p>
There is no default color map.<hr>
<a name="ref 1380 pri 0"><a name="ref 394 pri 0"><center><h3><a name="section 7.6.4.7">
Section 7.6.4.7<br>Halo Sampling</h3></center>
The halo effects are calculated by marching through the density field along a ray. At discrete steps samples are taken from the density field and evaluated according to the color map and all other parameters. The effects of all volume elements are accumulated to get the total effect.<p>
The following parameters are used to tune the sampling process:<p>
<listing>
  halo {
    [ samples SAMPLES ]
    [ aa_level AA_LEVEL ]
    [ aa_threshold AA_THRESHOLD ]
    [ jitter JITTER ]
  }
</listing>
<p>
The individual sampling parameters are described in the sections below.<hr>
<a name="ref 1381 pri 0"><a name="ref 1382 pri 0"><a name="ref 393 pri 1"><a name="ref 392 pri 4"><center><h3><a name="section 7.6.4.7.1">
Section 7.6.4.7.1<br>Number of Samples</h3></center>
The number of samples that are taken along the ray inside the halo container object is specified by the <a name="ref 392 pri 8"><strong>samples</strong> keyword. The greater the number of samples the more denser the density field is sampled and the more accurate but slower the result will be.<p>
The default number of samples is 10. This is sufficient for simple density fields that don't use turbulence.<p>
High turbulence values and dust halos normally need a large number of samples to avoid aliasing artifacts.<hr>
<a name="ref 1383 pri 0"><a name="ref 1384 pri 0"><a name="ref 1385 pri 0"><a name="ref 1386 pri 0"><a name="ref 1387 pri 0"><center><h3><a name="section 7.6.4.7.2">
Section 7.6.4.7.2<br>Super-Sampling</h3></center>
The sampling is prone to alias (like the atmosphere sampling in section <a href="pov3002c.htm#ref 268 pri 0">&quot;Atmosphere&quot;</a>). One way to reduce possible aliasing artifacts is to use super-sampling. If two neighboring samples differ too much an additional sampling is taken in-between. This process recurses until the values of the samples are close too each other or the maximum recursion level given by <a name="ref 440 pri 3"><strong>aa_level</strong> is reached. The threshold to kick super-sampling in is given by <a name="ref 439 pri 6"><strong>aa_threshold</strong>.<p>
By default super-sampling is not used. The default values for <a name="ref 439 pri 10"><strong>aa_threshold</strong> and <a name="ref 440 pri 14"><strong>aa_level</strong> are 0.3 and 3 respectively.<hr>
<a name="ref 1388 pri 0"><a name="ref 251 pri 0"><a name="ref 1389 pri 0"><a name="ref 251 pri 8"><center><h3><a name="section 7.6.4.7.3">
Section 7.6.4.7.3<br>Jitter</h3></center>
Jitter can be used to introduce some noise to the sampling locations. This may help to reduce aliasing artifacts at the cost of an increased noise level in the image. Since the human visual system is much more forgiving to noise than it is to regular patterns this is not much of a problem.<p>
By default jittering is not used. The values should be smaller than 1.0.<p>
Note that jittering is used even if super-sampling is not used.<hr>
<a name="ref 1390 pri 0"><a name="ref 1391 pri 0"><center><h3><a name="section 7.6.4.8">
Section 7.6.4.8<br>Halo Modifiers</h3></center>
This section covers all general halo modifiers. They are:<p>
<listing>
  halo {
    [ turbulence &lt;TURBULENCE&gt; ]
    [ octaves OCTAVES ]
    [ omega OMEGA ]
    [ lambda LAMBDA ]
    [ frequency FREQUENCY ]
    [ phase PHASE ]
    [ scale &lt;VECTOR&gt; ]
    [ rotate &lt;VECTOR&gt; ]
    [ translate &lt;VECTOR&gt; ]
  }
</listing>
<hr>
<a name="ref 1392 pri 0"><a name="ref 406 pri 0"><a name="ref 405 pri 1"><a name="ref 309 pri 3"><center><h3><a name="section 7.6.4.8.1">
Section 7.6.4.8.1<br>Frequency Modifier</h3></center>
The <a name="ref 309 pri 6"><strong>frequency</strong> parameter adjusts the number of times the density interval is mapped onto itself, i. e. the range from 0.0 to 1.0, before it is mapped onto the color map. The formula doing this is:<p>
<listing>
  f_new(r) = (f(r) * FREQUENCY + PHASE) modulo 1.0
</listing>
<p>
Thus the halo color map will be repeated by the specified frequency.<hr>
<a name="ref 1393 pri 0"><a name="ref 1394 pri 0"><a name="ref 1395 pri 0"><a name="ref 576 pri 2"><center><h3><a name="section 7.6.4.8.2">
Section 7.6.4.8.2<br>Phase Modifier</h3></center>
The phase parameter determines the offset at which the mapping of the density field onto itself starts. See the formula in the previous section for how the pahse is used.<p>
Thus the color entry for density f(r)=0 can be moved to phase mod 1.<hr>
<a name="ref 1396 pri 0"><a name="ref 1397 pri 0"><center><h3><a name="section 7.6.4.8.3">
Section 7.6.4.8.3<br>Transformation Modifiers</h3></center>
Halos can be transformed using the rotate, scale and translate keywords. You have to be careful that you don't move the density field out of the container object though.<hr>
<a name="ref 1398 pri 0"><a name="ref 1399 pri 0"><center><h3><a name="section 7.6.5">
Section 7.6.5<br>Special Textures</h3></center>
Special textures are complex textures made up of multiple textures. The component textures may be plain textures or may be made up of special textures. A plain texture has just one pigment, normal and finish statement (and maby some halo statements). Even a pigment with a pigment map is still one pigment and thus considered a plain texture as are normals with normal map statements.<p>
Special textures use either a <a name="ref 934 pri 2"><strong>texture_map</strong> keyword to specify a blend or pattern of textures or they use a bitmap similar to an image map called a <strong>material map</strong> (specified with the <a name="ref 901 pri 5"><strong>material_map</strong> keyword).<p>
There are restrictions on using special textures. A special texture may not be used as a default texture (see section <a href="pov3001c.htm#ref 1127 pri 0">&quot;Default Directive&quot;</a>). A special texture cannot be used as a layer in a layered texture however you may use layered textures as any of the textures contained within a special texture.<hr>
<a name="ref 1400 pri 0"><a name="ref 1286 pri 0"><a name="ref 1401 pri 0"><center><h3><a name="section 7.6.5.1">
Section 7.6.5.1<br>Texture Maps</h3></center>
In addition to specifying blended color with a color map or a pigment map you may create a blend of textures using <a name="ref 934 pri 0"><strong>texture_map</strong>. The syntax for a texture map is identical to the pigment map except you specify a texture in each map entry.<p>
A texture map is specified by...<p>
<listing>
  texture{
    PATTERN_TYPE
    texture_map {
      [ NUM_1 TEXTURE_BODY_1]
      [ NUM_2 TEXTURE_BODY_2]
      [ NUM_3 TEXTURE_BODY_3]
       ...
    }
    TEXTURE_MODIFIERS...
  }
</listing>
<p>
Where NUM_1, NUM_2, ... are float values between 0.0 and 1.0 inclusive. A TEXTURE_BODY is anything that would normally appear inside a <strong>texture</strong> statement but the texture keyword and <strong>{</strong>} braces are not needed. Note that the <a name="ref 1282 pri 4"><strong>[]</strong> brackets are part of the actual statement. They are not notational symbols denoting optional parts. The brackets surround each entry in the map. There may be from 2 to 256 entries in the map.<p>
For example:<p>
<listing>
  texture {
    gradient x       //this is the PATTERN_TYPE
    texture_map {
      [0.3  pigment{Red} finish{phong 1}]
      [0.3  T_Wood11]    //this is a texture identifier
      [0.6  T_Wood11]
      [0.9  pigment{DMFWood4} finish{Shiny}]
    }
  }
</listing>
<p>
When the <strong>gradient x</strong> function returns values from 0.0 to 0.3 the red highlighted texture is used. From 0.3 to 0.6 the texture identifier <strong>T_Wood11</strong> is used. From 0.6 up to 0.9 a blend of <strong>T_Wood11</strong> and a shiny <strong>DMFWood4</strong> is used. From 0.9 on up only the shiny wood is used.<p>
Texture maps may be nested to any level of complexity you desire. The textures in a map may have color maps or texture maps or any type of texture you want.<p>
The blended area of a texture map works by fully calculating both contributing textures in their entirety and then linearly interpolating the apparent colors. This means that reflection, refraction and lighting calculations are done twice for every point. This is in contrast to using a pigment map and a normal map in a plain texture, where the pigment is computed, then the normal, then reflection, refraction and lighting are calculated once for that point.<p>
Entire textures may also be used with the block patterns such as checker, hexagon and brick. For example...<p>
<listing>
  texture {
    checker
      texture { T_Wood12 scale .8 }
      texture {
        pigment { White_Marble }
        finish { Shiny }
        scale .5
      }
    }
  }
</listing>
<p>
Note that in the case of block patterns the <strong>texture</strong> wrapping is required around the texture information. Also note that this syntax prohibits the use of a layered texture however you can work around this by declaring a texture identifier for the layered texture and referencing the identifier.<p>
A texture map is also used with the <a name="ref 864 pri 9"><strong>average</strong> pattern type. See <a href="pov30029.htm#ref 864 pri 2">&quot;Average&quot;</a> for details.<hr>

<center>
<a href="pov30029.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
