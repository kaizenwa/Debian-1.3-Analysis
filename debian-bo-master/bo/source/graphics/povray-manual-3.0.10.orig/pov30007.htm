<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 180 pri 0"><a name="ref 181 pri 0"><center><h3><a name="section 4.4.7.1">
Section 4.4.7.1<br>Teaching An Old Spline New Tricks</h3></center>
If we followed the section on splines covered under the lathe tutorial (see section <a href="pov30006.htm#ref 171 pri 0">&quot;Understanding The Concept of Splines&quot;</a>), we know that there are two additional kinds of splines besides linear: the quadratic and the cubic spline. Sure enough, we can use these with prisms to make a more free form, smoothly curving type of prism.<p>
There is just one catch, and we should read this section carefully to keep from tearing our hair out over mysterious <strong>too few points in  prism</strong> messages which keep our prism from rendering. We can probably guess where this is heading: how to close a non-linear spline. Unlike the linear spline, which simply draws a line between the last and first points if we forget to make the last point equal to the first, quadratic and cubic splines are a little more fussy.<p>
First of all, we remember that quadratic splines determine the equation of the curve which connects any two points based on those two points and the previous point, so the first point in any quadratic spline is just a <strong>control point</strong> and won't actually be part of the curve. What this means is: when we make our shape out of a quadratic spline, we must match the second point to the last, since the first point is not on the curve - it's just a control point needed for computational purposes.<p>
Likewise, cubic splines need both the first and last points to be control points, therefore, to close a shape made with a cubic spline, we must match the second point to the second from last point. If we don't match the correct points on a quadratic or cubic shape, that's when we will get the <strong>too few points in prism</strong> error. POV-Ray is still waiting for us to close the shape, and when it runs out of points without seeing the closure, an error is issued.<p>
Confused? Okay, how about an example? We replace the prism in our last bit of code with this one (see file <b>prismdm2.pov</b>).<p>
<listing>
  prism {
    cubic_spline
    0, // sweep the following shape from here ...
    1, // ... up through here
    6, // the number of points making up the shape ...

    &lt; 3, -5&gt;, // point#1 (control point... not on curve)
    &lt; 3,  5&gt;, // point#2  ... THIS POINT ...
    &lt;-5,  0&gt;, // point#3
    &lt; 3, -5&gt;, // point#4
    &lt; 3,  5&gt;, // point#5 ... MUST MATCH THIS POINT
    &lt;-5,  0&gt;  // point#6 (control point... not on curve)

    pigment { Green }
  }
</listing>
<p>
<center><img src="pov3000f.gif" border=0 width=320 height=240><br><cite>A cubic, triangular prism shape.</cite></center><br> <p>
This simple prism produces what looks like an extruded triangle with its corners sanded smoothly off. Points two, three and four are the corners of the triangle and point five closes the shape by returning to the location of point two. As for points one and six, they are our control points, and aren't part of the shape - they're just there to help compute what curves to use between the other points.<hr>
<a name="ref 182 pri 0"><a name="ref 183 pri 0"><center><h3><a name="section 4.4.7.2">
Section 4.4.7.2<br>Smooth Transitions</h3></center>
Now a handy thing to note is that we have made point one equal point four, and also point six equals point three. Yes, this is important. Although this prism would still be legally closed if the control points were not what we've made them, the curve transitions between points would not be as smooth. We change points one and six to &lt;4,6&gt; and &lt;0,7&gt; respectively and re-render to see how the back edge of the shape is altered (see file <b>prismdm3.pov</b>).<p>
To put this more generally, if we want a smooth closure on a cubic spline, we make the first control point equal to the third from last point, and the last control point equal to the third point. On a quadratic spline, the trick is similar, but since only the first point is a control point, make that equal to the second from last point.<hr>
<a name="ref 184 pri 0"><a name="ref 185 pri 0"><center><h3><a name="section 4.4.7.3">
Section 4.4.7.3<br>Multiple Sub-Shapes</h3></center>
Just as with the polygon object (see section <a href="pov30006.htm#ref 176 pri 0">&quot;Polygon Object&quot;</a>) the prism is very flexible, and allows us to make one prism out of several sub-prisms. To do this, all we need to do is keep listing points after we have already closed the first shape. The second shape can be simply an add on going off in another direction from the first, but one of the more interesting features is that if any even number of sub-shapes overlap, that region where they overlap behaves as though it has been cut away from both sub-shapes. Let's look at another example. Once again, same basic code as before for camera, light and so forth, but we substitute this complex prism (see file <b>prismdm4.pov</b>).<p>
<listing>
  prism {
    linear_sweep
    cubic_spline
    0,  // sweep the following shape from here ...
    1,  // ... up through here
    18, // the number of points making up the shape ...

    &lt;3,-5&gt;, &lt;3,5&gt;, &lt;-5,0&gt;, &lt;3, -5&gt;, &lt;3,5&gt;, &lt;-5,0&gt;, // sub-shape #1
    &lt;2,-4&gt;, &lt;2,4&gt;, &lt;-4,0&gt;, &lt;2,-4&gt;, &lt;2,4&gt;, &lt;-4,0&gt;,  // sub-shape #2
    &lt;1,-3&gt;, &lt;1,3&gt;, &lt;-3,0&gt;, &lt;1, -3&gt;, &lt;1,3&gt;, &lt;-3,0&gt;  // sub-shape #3

    pigment { Green }
  }
</listing>
<p>
<center><img src="pov30010.gif" border=0 width=320 height=240><br><cite>Using sub-shapes to create a more complex shape.</cite></center><br> <p>
For readability purposes, we have started a new line every time we moved on to a new sub-shape, but the ray-tracer of course tells where each shape ends based on whether the shape has been closed (as described earlier). We render this new prism, and look what we've got. It's the same familiar shape, but it now looks like a smaller version of the shape has been carved out of the center, then the carved piece was sanded down even smaller and set back in the hole.<p>
Simply, the outer rim is where only sub-shape one exists, then the carved out part is where sub-shapes one and two overlap. In the extreme center, the object reappears because sub-shapes one, two, and three overlap, returning us to an odd number of overlapping pieces. Using this technique we could make any number of extremely complex prism shapes!<hr>
<a name="ref 186 pri 0"><a name="ref 187 pri 0"><center><h3><a name="section 4.4.7.4">
Section 4.4.7.4<br>Conic Sweeps And The Tapering Effect</h3></center>
In our original prism, the keyword <strong>linear_sweep</strong> is actually optional. This is the default sweep assumed for a prism if no type of sweep is specified. But there is another, extremely useful kind of sweep: the conic sweep. The basic idea is like the original prism, except that while we are sweeping the shape from the first height through the second height, we are constantly expanding it from a single point until, at the second height, the shape has expanded to the original points we made it from. To give a small idea of what such effects are good for, we replace our existing prism with this (see file <b>prismdm5.pov</b>):<p>
<listing>
  prism {
    conic_sweep
    linear_spline
    0, // height 1
    1, // height 2
    5, // the number of points making up the shape...

    &lt;4,4&gt;,&lt;-4,4&gt;,&lt;-4,-4&gt;,&lt;4,-4&gt;,&lt;4,4&gt;

    rotate &lt;180, 0, 0&gt;
    translate &lt;0, 1, 0&gt;
    scale &lt;1, 4, 1&gt;
    pigment { gradient y scale .2 }
  }
</listing>
<p>
<center><img src="pov30011.gif" border=0 width=320 height=240><br><cite>Creating a pyramid using conic sweeping.</cite></center><br> <p>
The gradient pigment was selected to give some definition to our object without having to fix the lights and the camera angle right at this moment, but when we render it, we what we've created? A horizontally striped pyramid! By now we can recognize the linear spline connecting the four points of a square, and the familiar final point which is there to close the spline.<p>
Notice all the transformations in the object declaration. That's going to take a little explanation. The rotate and translate are easy. Normally, a conic sweep starts full sized at the top, and tapers to a point at y=0, but of course that would be upside down if we're making a pyramid. So we flip the shape around the x-axis to put it rightside up, then since we actually orbitted around the point, we translate back up to put it in the same position it was in when we started.<p>
The scale is to put the proportions right for this example. The base is eight units by eight units, but the height (from y=1 to y=0) is only one unit, so we've stretched it out a little. At this point, we're probably thinking, &quot;why not just sweep up from y=0 to y=4 and avoid this whole scaling thing?&quot;<p>
That is a very important gotcha! with conic sweeps. To see what's wrong with that, let's try and put it into practice (see file <b>prismdm6.pov</b>). We must make sure to remove the scale statement, and then replace the line which reads<p>
<listing>
  1, // height 2
</listing>
 with<p>
<listing>
  1, // height 2
</listing>
<p>
This sets the second height at y=4, so let's re-render and see if the effect is the same.<p>
<center><img src="pov30012.gif" border=0 width=320 height=240><br><cite>Choosing a second height larger than one for the conic sweep.</cite></center><br> <p>
Whoa! Our height is correct, but our pyramid's base is now huge! What went wrong here? Simple. The base, as we described it with the points we used actually occurs at y=1 no matter what we set the second height for. But if we do set the second height higher than one, once the sweep passes y=1, it keeps expanding outward along the same lines as it followed to our original base, making the actual base bigger and bigger as it goes.<p>
To avoid losing control of a conic sweep prism, it is usually best to let the second height stay at y=1, and use a scale statement to adjust the height from its unit size. This way we can always be sure the base's corners remain where we think they are.<p>
That leads to one more interesting thing about conic sweeps. What if we for some reason don't want them to taper all the way to a point? What if instead of a complete pyramid, we want more of a ziggurat step? Easily done. After putting the second height back to one, and replacing our scale statment, we change the line which reads<p>
<listing>
  0, // height 1
</listing>
 to<p>
<listing>
  0, // height 1
</listing>
<p>
<center><img src="pov30013.gif" border=0 width=320 height=240><br><cite>Increasing the first height for the conic sweep.</cite></center><br> <p>
When we re-render, we see that the sweep stops short of going all the way to its point, giving us a pyramid without a cap. Exactly how much of the cap is cut off depends on how close the first height is to the second height.<hr>
<a name="ref 188 pri 0"><a name="ref 189 pri 0"><a name="ref 190 pri 1"><center><h3><a name="section 4.4.8">
Section 4.4.8<br>Superquadric Ellipsoid Object</h3></center>
Sometimes we want to make an object that does not have perfectly sharp edges like a box does. Then, the <a name="ref 191 pri 3"><strong>superquadric ellipsoid</strong> is a useful object. It is described by the simple syntax:<p>
<listing>
  superellipsoid { &lt;r, n&gt; }
</listing>
<p>
Where r and n are float values greater than zero and less than or equal to one. Let's make a superellipsoid and experiment with the values of r and n to see what kind of shapes we can make.<p>
We create a file called <b>supellps.pov</b> and edit it as follows:<p>
<listing>
  #include &quot;colors.inc&quot;

  camera {
    location &lt;10, 5, -20&gt;
    look_at 0
    angle 15
  }

  background { color rgb &lt;.5, .5, .5&gt; }

  light_source { &lt;10, 50, -100&gt; White }
</listing>
<p>
The addition of a gray background makes it a little easier to see our object. We now type:<p>
<listing>
  superellipsoid { &lt;.25, .25&gt;
    pigment { Red }
  }
</listing>
<p>
We save the file and trace it at 200x150 <a name="ref 89 pri 6"><strong>-A</strong> to see the shape. It will look like a box, but the edges will be rounded off. Now let's experiment with different values of r and n. For the next trace, try &lt;1, 0.2&gt;. The shape now looks like a cylinder, but the top edges are rounded. Now try &lt;0.1, 1&gt;. This shape is an odd one! We don't know exactly what to call it, but it is interesting. Finally, lets try &lt;1, 1&gt;. Well, this is more familiar... a sphere!<p>
There are a couple of facts about superellipsoids we should know. First, we should not use a value of 0 for either r nor n. This will cause POV-Ray to incorrectly make a black box instead of our desired shape. Second, very small values of r and n may yield strange results so they should be avoided. Finally, the Sturmian root solver will not work with superellipsoids.<p>
Superellipsoids are finite objects so they respond to auto-bounding and can be used in CSG.<p>
Now let's use the superellipsoid to make something that would be useful in a scene. We will make a tiled floor and place a couple of superellipsoid objects hovering over it. We can start with the file we have already made.<p>
We rename it to <b>tiles.pov</b> and edit it so that it reads as follows:<p>
<listing>
  #include &quot;colors.inc&quot;
  #include &quot;textures.inc&quot;

  camera {
    location &lt;10, 5, -20&gt;
    look_at 0
    angle 15
  }
  background { color rgb &lt;.5, .5, .5&gt; }

  light_source{ &lt;10, 50, -100&gt; White }
</listing>
<p>
Note that we have added <strong>#include &quot;textures.inc&quot;</strong> so we can use pre-defined textures. Now we want to define the superellipsoid which will be our tile.<p>
<listing>
  #declare Tile = superellipsoid { &lt;0.5, 0.1&gt;
    scale &lt;1, .05, 1&gt;
  }
</listing>
<p>
Superellipsoids are roughly 2*2*2 units unless we scale them otherwise. If we wish to lay a bunch of our tiles side by side, they will have to be offset from each other so they don't overlap. We should select an offset value that is slightly more than 2 so that we have some space between the tiles to fill with grout. So we now add this:<p>
<listing>
  #declare Offset = 2.1
</listing>
<p>
We now want to lay down a row of tiles. Each tile will be offset from the original by an ever-increasing amount in both the +z and -z directions. We refer to our offset and multiply by the tile's rank to determine the position of each tile in the row. We also union these tiles into a single object called <strong>Row</strong> like this:<p>
<listing>
  #declare Row = union {
    object { Tile }
    object { Tile translate z*Offset }
    object { Tile translate z*Offset*2 }
    object { Tile translate z*Offset*3 }
    object { Tile translate z*Offset*4 }
    object { Tile translate z*Offset*5 }
    object { Tile translate z*Offset*6 }
    object { Tile translate z*Offset*7 }
    object { Tile translate z*Offset*8 }
    object { Tile translate z*Offset*9 }
    object { Tile translate z*Offset*10 }
    object { Tile translate -z*Offset }
    object { Tile translate -z*Offset*2 }
    object { Tile translate -z*Offset*3 }
    object { Tile translate -z*Offset*4 }
    object { Tile translate -z*Offset*5 }
    object { Tile translate -z*Offset*6 }
  }
</listing>
<p>
This gives us a single row of 17 tiles, more than enough to fill the screen. Now we must make copies of the <strong>Row</strong> and translate them, again by the offset value, in both the +x and -x directions in ever increasing amounts in the same manner.<p>
<listing>
  object { Row }
  object { Row translate x*Offset }
  object { Row translate x*Offset*2 }
  object { Row translate x*Offset*3 }
  object { Row translate x*Offset*4 }
  object { Row translate x*Offset*5 }
  object { Row translate x*Offset*6 }
  object { Row translate x*Offset*7 }
  object { Row translate -x*Offset }
  object { Row translate -x*Offset*2 }
  object { Row translate -x*Offset*3 }
  object { Row translate -x*Offset*4 }
  object { Row translate -x*Offset*5 }
  object { Row translate -x*Offset*6 }
  object { Row translate -x*Offset*7 }
</listing>
<p>
Finally, our tiles are complete. But we need a texture for them. To do this we union all of the <strong>Rows</strong> together and apply a <strong>White Marble</strong> pigment and a somewhat shiny reflective surface to it:<p>
<listing>
  union{
    object { Row }
    object { Row translate x*Offset }
    object { Row translate x*Offset*2 }
    object { Row translate x*Offset*3 }
    object { Row translate x*Offset*4 }
    object { Row translate x*Offset*5 }
    object { Row translate x*Offset*6 }
    object { Row translate x*Offset*7 }
    object { Row translate -x*Offset }
    object { Row translate -x*Offset*2 }
    object { Row translate -x*Offset*3 }
    object { Row translate -x*Offset*4 }
    object { Row translate -x*Offset*5 }
    object { Row translate -x*Offset*6 }
    object { Row translate -x*Offset*7 }
    pigment { White_Marble }
    finish { phong 1 phong_size 50 reflection .35 }
  }
</listing>
<p>
We now need to add the <strong>grout</strong>. This can simply be a white plane. We have stepped up the ambient here a little so it looks whiter.<p>
<listing>
  plane { y, 0  //this is the grout
    pigment { color White }
    finish { ambient .4 diffuse .7 }
  }
</listing>
<p>
To complete our scene, let's add five different superellipsoids, each a different color, so that they hover over our tiles and are reflected in them.<p>
<listing>
  superellipsoid {
    &lt;0.1, 1&gt;
    pigment { Red }
    translate &lt;5, 3, 0&gt;
    scale .45
  }

  superellipsoid {
    &lt;1, 0.25&gt;
    pigment { Blue }
    translate &lt;-5, 3, 0&gt;
    scale .45
  }

  superellipsoid {
    &lt;0.2, 0.6&gt;
    pigment { Green }
    translate &lt;0, 3, 5&gt;
    scale .45
  }

  superellipsoid {
    &lt;0.25, 0.25&gt;
    pigment { Yellow }
    translate &lt;0, 3, -5&gt;
    scale .45
  }

  superellipsoid {
    &lt;1, 1&gt;
    pigment { Pink }
    translate y*3
    scale .45
  }
</listing>
<p>
<center><img src="pov30014.gif" border=0 width=320 height=240><br><cite>Some superellipsoids hovering above a tiled floor.</cite></center><br> <p>
We trace the scene at 320x200 <a name="ref 89 pri 10"><strong>-A</strong> to see the result. If we are happy with that, we do a final trace at 640x480 <a name="ref 192 pri 10"><strong>+A0.2</strong>.<hr>

<center>
<a href="pov30008.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
