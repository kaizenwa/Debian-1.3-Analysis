<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 90 pri 0"><a name="ref 77 pri 0"><center><h3><a name="section 3.2.5">
Section 3.2.5<br>Display Types</h3></center>
You have already seen how to turn on graphics preview using <a name="ref 74 pri 1"><strong>+D1</strong>. Here are details on other variations of the <a name="ref 69 pri 3"><strong>+D</strong> switch. Use <a name="ref 70 pri 4"><strong>-D</strong> to turn the display off. If you use <a name="ref 70 pri 6"><strong>-D</strong> then you will probably want to add the <a name="ref 91 pri 6"><strong>+V</strong> switch to turn on verbose status messages so you can monitor the progress of the rendering while in progress.<p>
The number &quot;1&quot; after the <a name="ref 69 pri 9"><strong>+D</strong> tells it what kind of video hardware to use. If you use <a name="ref 69 pri 13"><strong>+D</strong> alone or <a name="ref 92 pri 13"><strong>+D0</strong> then POV-Ray will attempt to auto detect your hardware type. Use <a name="ref 93 pri 13"><strong>+D?</strong> to see a message about what type of hardware POV-Ray found.<p>
You may also explicitly tell POV-Ray what hardware to use. The following chart lists all of the supported types.<p>
<center><table border><tr><td valign=top>+D0</td><td valign=top>Auto detect (S)VGA type (Default)</td></tr>
<tr><td valign=top>+D1</td><td valign=top>Standard VGA 320x200</td></tr>
<tr><td valign=top>+D2</td><td valign=top>Standard VGA 360 x 480</td></tr>
<tr><td valign=top>+D3</td><td valign=top>Tseng Labs 3000 SVGA 640x480</td></tr>
<tr><td valign=top>+D4</td><td valign=top>Tseng Labs 4000 SVGA</td></tr>
<tr><td valign=top>+D5</td><td valign=top>AT&amp;T VDC600 SVGA 640x400</td></tr>
<tr><td valign=top>+D6</td><td valign=top>Oak Technologies SVGA 640x480</td></tr>
<tr><td valign=top>+D7</td><td valign=top>Video 7 SVGA 640x480</td></tr>
<tr><td valign=top>+D8</td><td valign=top>Video 7 Vega (Cirrus) VGA 360x480</td></tr>
<tr><td valign=top>+D9</td><td valign=top>Paradise SVGA 640x480</td></tr>
<tr><td valign=top>+DA</td><td valign=top>Ahead Systems Ver. A SVGA 640x480</td></tr>
<tr><td valign=top>+DB</td><td valign=top>Ahead Systems Ver. B SVGA 640x480</td></tr>
<tr><td valign=top>+DC</td><td valign=top>Chips &amp; Technologies SVGA 640x480</td></tr>
<tr><td valign=top>+DD</td><td valign=top>ATI SGVA 640x480</td></tr>
<tr><td valign=top>+DE</td><td valign=top>Everex SVGA 640x480</td></tr>
<tr><td valign=top>+DF</td><td valign=top>Trident SVGA 640x480</td></tr>
<tr><td valign=top>+DG</td><td valign=top>VESA Standard SVGA Adapter</td></tr>
<tr><td valign=top>+DH</td><td valign=top>ATI XL display card</td></tr>
<tr><td valign=top>+DI</td><td valign=top>Diamond Computer Systems SpeedSTAR 24X</td></tr>

</td></tr></table></center>

<p>
The most common type is a VESA standard card which uses <a name="ref 73 pri 14"><strong>+DG</strong>. VESA is a standard software interface that works on a wide variety of cards. Those cards which do not have VESA support directly built-in, generally have a video driver that you can load to provide VESA support. The program <b>UniVBE</b> is a high quality universal VESA driver that may work for you. It can be found at <b>http://www.povray.org</b> or possibly other POV-Ray sites.<p>
The options listed above had been tested worked under earlier versions of POV-Ray but there have been many changes in the program and we cannot guarantee these all still work. If you can use VESA then do so. It has been well tested and will give you the most flexibility.<p>
After the <a name="ref 69 pri 19"><strong>+D</strong> and the type, you may specify a 3rd character that specifies the palette type.<p>
<center><table border><tr><td valign=top>+D?3</td><td valign=top>Use 332 palette with dithering (default and best for VGA systems). This is a fixed palette of 256 colors with each color consisting 3-bits of red data, 3-bits green and 2-bits blue.</td></tr>
<tr><td valign=top>+D?0</td><td valign=top>Use HSV palette option for VGA display. This is a fixed palette of 256 colors where colors are matched according to hue, saturation and intensity rather than the amount of red, green and blue.</td></tr>
<tr><td valign=top>+D?G</td><td valign=top>Use fixed gray scale palette option for VGA display.</td></tr>
<tr><td valign=top>+D?H</td><td valign=top>Use HiColor option. Displays more than 32,000 colors with dithering. Supported on VESA, SpeedSTAR 24X, ATI XL HiColor and Tseng 4000 based cards with high color 15 or 16 bit options.</td></tr>
<tr><td valign=top>+D?T</td><td valign=top>For Truecolor 24 bit cards. Use 24 bit color. Supported on the Diamond SpeedSTAR 24X and cards with 24-bit VESA support only.</td></tr>

</td></tr></table></center>

<p>
Here are some examples:<p>
<pre>
   +D0H Auto detect the VGA display type and display the image to the
        screen as it's being worked on. Use the 15-bit HiColor chip and
        dithering to display more than 32,000 colors on screen.
   +D4  Display to a TSENG 4000 chipset VGA using the 332 palette option.
   +D4H Display to a TSENG 4000 chipset VGA using the HiColor option.
   +DG0 Display to a VESA VGA adapter and use the HSV palette option.
   +DG3 Display to a VESA VGA adapter and use the 332 palette option.
   +DGH Display to a VESA VGA adapter and use the HiColor option for
        over 32,000 colors.
   +DGT Display to a VESA VGA adapter and use the TrueColor option for
        over 16 million colors.
</pre>
<p>
Note that your VESA BIOS must support these options in order for you to use them. Some cards may support HiColor and/or TrueColor at the hardware level but not through their VESA BIOS.<hr>
<a name="ref 94 pri 0"><a name="ref 4 pri 0"><center><h3><a name="section 4">
Section 4<br>Beginning Tutorial</h3></center>
The beginning tutorial explains step by step how to use POV-Ray's scene description language to create own scenes. The use of almost every feature of POV-Ray's language is explained in detail. We will learn basic things like placing cameras and light sources. We will also learn how to create a large variety of objects and how to assign different textures to them. The more sophisticated features like radiosity, halos and atmospheric effects will be explained in detail.<p>
The following sections explain the features in roughly the same order as they are described in the reference guide.<hr>
<a name="ref 95 pri 0"><a name="ref 96 pri 0"><center><h3><a name="section 4.1">
Section 4.1<br>Our First Image</h3></center>
We will create the scene file for a simple picture. Since ray-tracers thrive on spheres, that is what we will render first.<hr>
<a name="ref 97 pri 0"><a name="ref 98 pri 0"><center><h3><a name="section 4.1.1">
Section 4.1.1<br>Understanding POV-Ray's Coordinate System</h3></center>
First, we have to tell POV-Ray where our camera is and where it is looking. To do this, we use 3D coordinates. The usual coordinate system for POV-Ray has the positive y-axis pointing up, the positive x-axis pointing to the right, and the positive z-axis pointing into the screen as follows:<p>
 <center><img src="pov30000.gif" border=0 width=320 height=240><br><cite>The left-handed coordinate system (the z-axis is pointing away).</cite></center><br> <p>
This kind of coordinate system is called a left-handed coordinate system. If we use our left hand's fingers we can easily see why it is called left-handed. We just point our thumb in the direction of the positive x-axis, the index finger in the direction of the positive y-axis and the middle finger in the positive z-axis direction. We can only do this with our left hand. If we had used our right hand we would not have been able to point the middle finger in the correct direction.<p>
The left hand can also be used to determine rotation directions. To do this we must perform the famous <strong>Computer Graphics Aerobics</strong> exercise. We hold up our left hand and point our thumb in the positive direction of the axis of rotation. Our fingers will curl in the positive direction of rotation. Similarly if we point our thumb in the negative direction of the axis our fingers will curl in the negative direction of rotation.<p>
 <center><img src="pov30001.gif" border=0 width=320 height=240><br><cite>&quot;Computer Graphics Aerobics&quot; to determine the rotation direction.</cite></center><br> <p>
In the above illustration, the left hand is curling around the x-axis. The thumb points in the positive x direction and the fingers curl over in the positive rotation direction.<p>
If we want to use a right-handed system, as some CAD systems and modellers do, the <a name="ref 99 pri 1"><strong>right</strong> vector in the camera specification needs to be changed. See the detailed description in <a href="pov3001e.htm#ref 100 pri 0">&quot;Handedness&quot;</a>. In a right-handed system we use our right hand for the <strong>Aerobics</strong>.<p>
There is some controversy over whether POV-Ray's method of doing a right-handed system is really proper. To avoid problems we stick with the left-handed system which is not in dispute.<hr>
<a name="ref 101 pri 0"><a name="ref 102 pri 0"><a name="ref 103 pri 1"><center><h3><a name="section 4.1.2">
Section 4.1.2<br>Adding Standard Include Files</h3></center>
Using our personal favorite text editor, we create a file called <b>demo.pov</b>. We then type in the following text. The input is case sensitive, so we have to be sure to get capital and lowercase letters correct.<p>
<listing>
  #include &quot;colors.inc&quot;    // The include files contain
  #include &quot;shapes.inc&quot;    // pre-defined scene elements
  #include &quot;finish.inc&quot;
  #include &quot;glass.inc&quot;
  #include &quot;metals.inc&quot;
  #include &quot;stones.inc&quot;
  #include &quot;woods.inc&quot;
</listing>
<p>
The first include statement reads in definitions for various useful colors. The second include statement reads in some useful shapes. The next read pre-defined finishes, glass, metal, stone and wood textures. It is a good idea to have a look through them to see but a few of the many possible shapes and textures available.<p>
We should only include files we really need in our scene. Some of the include files coming with POV-Ray are quite large and we should better save the parsing time and memory if we don't need them. In the following examples we will only use the <b>colors.inc</b>, <b>finish.inc</b> and <b>stones.inc</b> include files so we will better remove the appropriate lines from our scene file.<p>
We may have as many include files as needed in a scene file. Include files may themselves contain include files, but we are limited to declaring includes nested only ten levels deep.<p>
Filenames specified in the include statements will be searched for in the current directory first and, if not found, will then be searched for in directories specified by any <a name="ref 82 pri 4"><strong>+L</strong> or <a name="ref 104 pri 4"><strong>Library_Path</strong> options active. This would facilitate keeping all our &quot;include&quot; (<b>.inc</b>) files such as <b>shapes.inc</b>, <b>colors.inc</b> and <b>textures.inc</b> in an &quot;include&quot; subdirectory, and giving an <a name="ref 82 pri 8"><strong>+L</strong> switch on the command line to where our library of include files are.<hr>
<a name="ref 105 pri 0"><a name="ref 106 pri 0"><center><h3><a name="section 4.1.3">
Section 4.1.3<br>Adding a Camera</h3></center>
The <a name="ref 107 pri 1"><strong>camera</strong> declaration describes where and how the <a name="ref 107 pri 3"><strong>camera</strong> sees the scene. It gives x-, y- and z-coordinates to indicate the position of the camera and what part of the scene it is pointing at. We describe the coordinates using a three-part <strong>vector</strong>. A vector is specified by putting three numeric values between a pair of angle brackets and separating the values with commas.<p>
We add the following camera statement to the scene.<p>
<listing>
  camera {
    location &lt;0, 2, -3&gt;
    look_at  &lt;0, 1,  2&gt;
  }
</listing>
<p>
Briefly, <strong>location &lt;0,2,-3&gt;</strong> places the camera up two units and back three units from the center of the ray-tracing universe which is at &lt;0,0,0&gt;. By default +z is into the screen and -z is back out of the screen.<p>
Also <strong>look_at &lt;0,1,2&gt;</strong> rotates the camera to point at the coordinates &lt;0,1,2&gt;. A point 5 units in front of and 1 unit lower than the camera. The <strong>look_at</strong> point should be the center of attention of our image.<hr>
<a name="ref 108 pri 0"><a name="ref 109 pri 0"><center><h3><a name="section 4.1.4">
Section 4.1.4<br>Describing an Object</h3></center>
Now that the camera is set up to record the scene, let's place a yellow sphere into the scene. We add the following to our scene file:<p>
<listing>
  sphere {
    &lt;0, 1, 2&gt;, 2
    texture {
      pigment { color Yellow }
    }
  }
</listing>
<p>
The first vector specifies the center of the sphere. In this example the x coordinate is zero so it is centered left and right. It is also at y=1 or one unit up from the origin. The z coordinate is 2 which is five units in front of the camera, which is at z=-3. After the center vector is a comma followed by the radius which in this case is two units. Since the radius is half the width of a sphere, the sphere is four units wide.<hr>
<a name="ref 110 pri 0"><a name="ref 111 pri 0"><a name="ref 112 pri 1"><center><h3><a name="section 4.1.5">
Section 4.1.5<br>Adding Texture to an Object</h3></center>
After we have defined the location and size of the sphere, we need to describe the appearance of the surface. The <strong>texture</strong> block specifies these parameters. Texture blocks describe the color, bumpiness and finish properties of an object. In this example we will specify the color only. This is the minimum we must do. All other texture options except color will use default values.<p>
The color we define is the way we want an object to look if fully illuminated. If we were painting a picture of a sphere we would use dark shades of a color to indicate the shadowed side and bright shades on the illuminated side. However ray-tracing takes care of that. We pick the basic color inherent in the object and POV-Ray brightens or darkens it depending on the lighting in the scene. Because we are defining the basic color the object actually <strong>has</strong> rather than how it <strong>looks</strong> the parameter is called <strong>pigment</strong>.<p>
Many types of color patterns are available for use in a <strong>pigment</strong> statement. The keyword <a name="ref 113 pri 1"><strong>color</strong> specifies that the whole object is to be one solid color rather than some pattern of colors. We can use one of the color identifiers previously defined in the standard include file <b>colors.inc</b>.<p>
If no standard color is available for our needs, we may define our own color by using the color keyword followed by <a name="ref 114 pri 1"><strong>red</strong>, <a name="ref 115 pri 1"><strong>green</strong> and <a name="ref 116 pri 1"><strong>blue</strong> keywords specifying the amount of red, green and blue to be mixed. For example a nice shade of pink can be specified by:<p>
<listing>
  color red 1.0 green 0.8 blue 0.8
</listing>
<p>
The values after each keyword should be in the range from 0.0 to 1.0. Any of the three components not specified will default to 0. A shortcut notation may also be used. The following produces the same shade of pink:<p>
<listing>
  color rgb &lt;1.0, 0.8, 0.8&gt;
</listing>
<p>
Colors are explained in more detail in section <a href="pov3001a.htm#ref 117 pri 0">&quot;Specifying Colors&quot;</a>.<hr>
<a name="ref 118 pri 0"><a name="ref 119 pri 0"><center><h3><a name="section 4.1.6">
Section 4.1.6<br>Defining a Light Source</h3></center>
One more detail is needed for our scene. We need a <a name="ref 120 pri 1"><strong>light source</strong>. Until we create one, there is no light in this virtual world. Thus we add the line<p>
<listing>
  light_source { &lt;2, 4, -3&gt; color White}
</listing>
<p>
to the scene file to get our first complete POV-Ray scene file as shown below.<p>
<listing>
  #include &quot;colors.inc&quot;

  background { color Cyan }

  camera {
    location &lt;0, 2, -3&gt;
    look_at  &lt;0, 1,  2&gt;
  }

  sphere {
    &lt;0, 1, 2&gt;, 2
    texture {
      pigment { color Yellow }
    }
  }

  light_source { &lt;2, 4, -3&gt; color White}
</listing>
<p>
The vector in the <a name="ref 121 pri 2"><strong>light_source</strong> statement specifies the location of the light as two units to our right, four units above the origin and three units back from the origin. The light source is invisible, it only casts light, so no texture is needed.<p>
That's it! We close the file and render a small picture of it using the command<p>
<pre>
  povray +w160 +h120 +p +x +d0 -v -idemo.pov
</pre>
<p>
If our computer does not use the command line, we have to read the platform specific docs for the correct command to render the scene.<p>
We may also set any other command line options we like. The scene is written to the image file <b>demo.tga</b> (or some suffix other than <b>.tga</b> if our computer uses a different default file format).<p>
The scene we just traced isn't quite state of the art but we will have to start with the basics before we soon get to much more fascinating features and scenes.<hr>
<a name="ref 122 pri 0"><a name="ref 123 pri 0"><center><h3><a name="section 4.2">
Section 4.2<br>Using the Camera</h3></center>
<hr>
<a name="ref 124 pri 0"><a name="ref 125 pri 0"><center><h3><a name="section 4.2.1">
Section 4.2.1<br>Using Focal Blur</h3></center>
Let's construct a simple scene to illustrate the use of focal blur. For this example we will use a pink sphere, a green box and a blue cylinder with the sphere placed in the foreground, the box in the center and the cylinder in the background. A checkered floor for perspective and a couple of light sources will complete the scene.<p>
We create a new file called <b>focaldem.pov</b> and enter the following text<p>
<listing>
  #include &quot;colors.inc&quot;
  #include &quot;shapes.inc&quot;
  #include &quot;textures.inc&quot;

  #version 3.0

  global_settings {
    assumed_gamma 2.2 // for most PC monitors
    max_trace_level 5
  }

  sphere { &lt;1, 0, -6&gt;, 0.5
    finish {
      ambient 0.1
      diffuse 0.6
    }
    pigment { NeonPink }
  }

  box { &lt;-1, -1, -1&gt;, &lt; 1,  1,  1&gt;
    rotate &lt;0, -20, 0&gt;
    finish {
      ambient 0.1
      diffuse 0.6
    }
    pigment { Green }
  }

  cylinder { &lt;-6, 6, 30&gt;, &lt;-6, -1, 30&gt;, 3
    finish {
      ambient 0.1
      diffuse 0.6
    }
    pigment {NeonBlue}
  }

  plane { y, -1.0
    pigment {
      checker color Gray65 color Gray30
    }
  }

  light_source { &lt;5, 30, -30&gt; color White }

  light_source { &lt;-5, 30, -30&gt; color White }
</listing>
<p>
Now we can proceed to place our focal blur camera to an appropriate viewing position. Straight back from our three objects will yield a nice view. Adjusting the focal point will move the point of focus anywhere in the scene. We just add the following lines to the file:<p>
<listing>
  camera {
    location &lt;0.0, 1.0, -10.0&gt;
    look_at  &lt;0.0, 1.0,  0.0&gt;

  //  focal_point &lt;-6, 1, 30&gt;    // blue cylinder in focus
  //  focal_point &lt; 0, 1,  0&gt;    // green box in focus
    focal_point &lt; 1, 1, -6&gt;    // pink sphere in focus

    aperture 0.4     // a nice compromise
  //  aperture 0.05    // almost everything is in focus
  //  aperture 1.5     // much blurring

  //  blur_samples 4       // fewer samples, faster to render
    blur_samples 20      // more samples, higher quality image
  }
</listing>
<p>
The focal point is simply the point at which the focus of the camera is at its sharpest. We position this point in our scene and assign a value to the aperture to adjust how close or how far away we want the focal blur to occur from the focused area.<p>
The aperture setting can be considered an <strong>area of focus</strong>. Opening up the aperture has the effect of making the area of focus smaller while giving the aperture a smaller value makes the area of focus larger. This is how we control where focal blur begins to occur around the focal point.<p>
The blur samples setting determines how many rays are used to sample each pixel. Basically, the more rays that are used the higher the quality of the resultant image, but consequently the longer it takes to render. Each scene is different so we have to experiment. This tutorial has examples of 4 and 20 samples but we can use more for high resolution images. We should not use more samples than is necessary to achieve the desired quality - more samples take more time to render. The confidence and variance settings are covered in section <a href="pov3001e.htm#ref 126 pri 0">&quot;Focal Blur&quot;</a>.<p>
We experiment with the focal point, aperture, and blur sample settings. The scene has lines with other values that we can try by commenting out the default line with double slash marks and un-commenting the line we wish to try out. We make only one change at a time to see the effect on the scene.<p>
Two final points when tracing a scene using a focal blur camera. We needn't specify anti-aliasing (the \Clo{+A} switch) because the focal blur code uses its one sampling method that automatically takes care of anti-aliasing. Focal blur can only be used with the perspective camera.<hr>

<center>
<a href="pov30004.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
