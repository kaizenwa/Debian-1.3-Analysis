<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 1263 pri 0"><a name="ref 544 pri 0"><a name="ref 268 pri 4"><center><h3><a name="section 7.5.6.8">
Section 7.5.6.8<br>Atmosphere Interaction</h3></center>
By default light sources will interact with an atmosphere added to the scene. This behaviour can be switched off by using the <a name="ref 268 pri 9"><strong>atmosphere</strong> keyword inside the light source statement.<p>
<listing>
  light_source {
    ...
    atmosphere off
  }
</listing>
<hr>
<a name="ref 1264 pri 0"><a name="ref 1265 pri 1"><a name="ref 527 pri 1"><center><h3><a name="section 7.5.6.9">
Section 7.5.6.9<br>Atmospheric Attenuation</h3></center>
Normally light coming from light sources is not influenced by fog or atmosphere. This can be changed by turning the <a name="ref 1265 pri 1"><strong>atmospheric attenuation</strong> for a given light source on. All light coming from this light source will now be diminished as it travels through the fog or atmosphere. This results in an distance-based, exponential intensity falloff ruled by the used fog or atmosphere. If there is no fog or atmosphere no change will be seen.<hr>
<a name="ref 1266 pri 0"><a name="ref 1267 pri 0"><center><h3><a name="section 7.5.7">
Section 7.5.7<br>Object Modifiers</h3></center>
A variety of modifiers may be attached to objects. Transformations such as translate, rotate and scale have already been discussed. Textures are in a section of their own below. Here are three other important modifiers: <a name="ref 919 pri 4"><strong>clipped_by</strong>, <a name="ref 874 pri 5"><strong>bounded_by</strong> and <a name="ref 255 pri 9"><strong>no_shadow</strong>. Although the examples below use object statements and object identifiers, these modifiers may be used on any type of object such as sphere, box etc.<hr>
<a name="ref 1268 pri 0"><a name="ref 919 pri 0"><center><h3><a name="section 7.5.7.1">
Section 7.5.7.1<br>Clipped_By</h3></center>
The <a name="ref 919 pri 5"><strong>clipped_by</strong> statement is technically an object modifier but it provides a type of CSG similar to CSG intersection. You attach a clipping object like this:<p>
<listing>
  object {
    My_Thing
    clipped_by{plane{y,0}}
  }
</listing>
<p>
Every part of the object <strong>My_Thing</strong> that is inside the plane is retained while the remaining part is clipped off and discarded. In an intersection object the hole is closed off. With <a name="ref 919 pri 11"><strong>clipped_by</strong> it leaves an opening. For example the following figure shows object A being clipped by object B.<p>
 <center><img src="pov30050.gif" border=0 width=320 height=240><br><cite>An object clipped by another object.</cite></center><br> <p>
<a name="ref 919 pri 18"><strong>clipped_by</strong> may be used to slice off portions of any shape. In many cases it will also result in faster rendering times than other methods of altering a shape.<p>
Often you will want to use the <a name="ref 919 pri 26"><strong>clipped_by</strong> and <a name="ref 874 pri 28"><strong>bounded_by</strong> options with the same object. The following shortcut saves typing and uses less memory.<p>
<listing>
  object {
    My_Thing
    bounded_by { box { &lt;0,0,0&gt;, &lt;1,1,1&gt; } }
    clipped_by { bounded_by }
  }
</listing>
<p>
This tells POV-Ray to use the same box as a clip that was used as a bounds.<hr>
<a name="ref 1269 pri 0"><a name="ref 874 pri 0"><center><h3><a name="section 7.5.7.2">
Section 7.5.7.2<br>Bounded_By</h3></center>
The calculations necessary to test if a ray hits an object can be quite time consuming. Each ray has to be tested against every object in the scene. POV-Ray attempts so speed up the process by building a set of invisible boxes, called bounding boxes, which cluster the objects together. This way a ray that travels in one part of the scene doesn't have to be tested against objects in another, far away part of the scene. When large a number of objects are present the boxes are nested inside each other. POV-Ray can use bounding boxes on any finite object and even some clipped or bounded quadrics. However infinite objects (such as a planes, quartic, cubic and poly) cannot be automatically bound. CSG objects are automatically bound if they contain finite (and in some cases even infinite) objects. This works by applying the CSG set operations to the bounding boxes of all objects used inside the CSG object. For difference and intersection operations this will hardly ever lead to an optimal bounding box. It's sometimes better (depending on the complexity of the CSG object) to use a <a name="ref 874 pri 3"><strong>bounded_by</strong> statement with such shapes.<p>
Normally bounding shapes are not necessary but there are cases where they can be used to speed up the rendering of complex objects. Bounding shapes tell the ray-tracer that the object is totally enclosed by a simple shape. When tracing rays, the ray is first tested against the simple bounding shape. If it strikes the bounding shape the ray is further tested against the more complicated object inside. Otherwise the entire complex shape is skipped, which greatly speeds rendering.<p>
To use bounding shapes, simply include the following lines in the declaration of your object:<p>
<listing>
  bounded_by {
    object { ... }
  }
</listing>
<p>
An example of a bounding shape:<p>
<listing>
  intersection {
    sphere { &lt;0,0,0&gt;, 2 }
    plane  { &lt;0,1,0&gt;, 0 }
    plane  { &lt;1,0,0&gt;, 0 }
    bounded_by { sphere { &lt;0,0,0&gt;, 2 } }
  }
</listing>
<p>
The best bounding shape is a sphere or a box since these shapes are highly optimized, although, any shape may be used. If the bounding shape is itself a finite shape which responds to bounding slabs then the object which it encloses will also be used in the slab system.<p>
CSG shapes can benefit from bounding slabs without a <a name="ref 874 pri 7"><strong>bounded_by</strong> statement however they may do so inefficiently in intersection, difference and merge. In these three CSG types the automatic bound used covers all of the component objects in their entirety. However the result of these intersections may result in a smaller object. Compare the sizes of the illustrations for union and intersection in the CSG section above. It is possible to draw a much smaller box around the intersection of A and B than the union of A and B yet the automatic bounds are the size of the union of A and B regardless of the kind of CSG specified.<p>
While it is almost always a good idea to manually add a <a name="ref 874 pri 12"><strong>bounded_by</strong> to intersection, difference and merge, it is often best to <b>not</b> bound a union. If a union has no <a name="ref 874 pri 18"><strong>bounded_by</strong> and no <a name="ref 919 pri 27"><strong>clipped_by</strong> POV-Ray can internally split apart the components of a union and apply automatic bounding slabs to any of its finite parts. Note that some utilities such as <b>raw2pov</b> may be able to generate bounds more efficiently than POV-Ray's current system. However most unions you create yourself can be easily bounded by the automatic system. For technical reasons POV-Ray cannot split a merge object. It is probably best to hand bound a merge, especially if it is very complex.<p>
Note that if bounding shape is too small or positioned incorrectly it may clip the object in undefined ways or the object may not appear at all. To do true clipping, use <a name="ref 919 pri 37"><strong>clipped_by</strong> as explained above. Often you will want to use the <a name="ref 919 pri 48"><strong>clipped_by</strong> and <a name="ref 874 pri 55"><strong>bounded_by</strong> options with the same object. The following shortcut saves typing and uses less memory.<p>
<listing>
  object {
    My_Thing
    clipped_by{ box { &lt;0,0,0&gt;,&lt;1,1,1 &gt; }}
    bounded_by{ clipped_by }
  }
</listing>
<p>
This tells POV-Ray to use the same box as a bounds that was used as a clip.<hr>
<a name="ref 1270 pri 0"><a name="ref 384 pri 1"><center><h3><a name="section 7.5.7.3">
Section 7.5.7.3<br>Hollow</h3></center>
POV-Ray by default assumes that objects are made of a solid material that completely fills the interior of an object. By adding the <a name="ref 384 pri 1"><strong>hollow</strong> keyword to the object you can make it hollow. That is very useful if you want atmospheric effects to exist inside an object. It is even required for objects containing a halo (see <a href="pov30027.htm#ref 373 pri 0">&quot;Halo&quot;</a> for details).<p>
In order to get a hollow CSG object you just have to make the top level object hollow. All children will assume the same <strong>hollow</strong> state except their state is explicitly set. The following example will set both spheres inside the union hollow<p>
<listing>
  union {
    sphere { -0.5*x, 1 }
    sphere {  0.5*x, 1 }
    hollow
  }
</listing>
<p>
while the next example will only set the second sphere hollow because the first sphere was explicitly set to be not hollow.<p>
<listing>
  union {
    sphere { -0.5*x, 1 hollow off }
    sphere {  0.5*x, 1 }
    hollow
  }
</listing>
<hr>
<a name="ref 1271 pri 0"><a name="ref 255 pri 0"><center><h3><a name="section 7.5.7.4">
Section 7.5.7.4<br>No_Shadow</h3></center>
You may specify the <a name="ref 255 pri 5"><strong>no_shadow</strong> keyword in an object to make that object cast no shadow. This is useful for special effects and for creating the illusion that a light source actually is visible. This keyword was necessary in earlier versions of POV-Ray which did not have the <a name="ref 254 pri 10"><strong>looks_like</strong> statement. Now it is useful for creating things like laser beams or other unreal effects.<p>
Simply attach the keyword as follows:<p>
<listing>
  object {
    My_Thing
    no_shadow
  }
</listing>
<hr>
<a name="ref 1272 pri 0"><a name="ref 905 pri 0"><center><h3><a name="section 7.5.7.5">
Section 7.5.7.5<br>Sturm</h3></center>
Some of POV-Ray's objects allow you to choose between a fast but sometimes inaccurate root solver and a slower but more accurate one. This is the case for all objects that involve the solution of a cubic or quartic polynomial. There are analytic mathematical solutions for those polynomials that can be used.<p>
Lower order polynomials are trivial to solve while higher order polynomials require iterative algorithms to solve them. One of those algorithms is the Sturmian root solver.<p>
The following list shows all objects for which the Sturmian root solver can be used.<p>
<pre>
  blob
  cubic
  lathe    (only with quadratic splines)
  poly
  prism    (only with cubic splines)
  quartic
  sor
</pre>
<hr>
<a name="ref 1273 pri 0"><a name="ref 1274 pri 0"><center><h3><a name="section 7.6">
Section 7.6<br>Textures</h3></center>
The <a name="ref 112 pri 0"><strong>texture</strong> describes what the object looks like, i. e. its material. Textures are combinations of pigments, normals, finishes and halos. Pigment is the color or pattern of colors inherent in the material. Normal is a method of simulating various patterns of bumps, dents, ripples or waves by modifying the surface normal vector. Finish describes the reflective and refractive properties of a material. Halo simulates effects like clouds, fog, fire etc. by using a density field defined inside the object.<p>
A <strong>plain texture</strong> consists of a single pigment, an optional normal, a single finish and optionally one or more halos. A <strong>special  texture</strong> combines two or more textures using a pattern or blending function. Special textures may be made quite complex by nesting patterns within patterns. At the innermost levels however, they are made up from plain textures. Note that although we call a plain texture <strong>plain</strong> it may be a very complex texture. The term <strong>plain</strong> only means that it has a single pigment, normal, finish and halo.<p>
The most complete form for defining a plain texture is as follows:<p>
<listing>
  texture {
    TEXTURE_IDENTIFIER
    pigment {...}
    normal {...}
    finish {...}
    halo {...}
    TRANSFORMATIONS
  }
</listing>
<p>
Each of the items in a texture are optional but if they are present the identifier must be first and the transformations must be last. The pigment, normal and finish parameters modify any pigment, normal and finish already specified in the TEXTURE_IDENTIFIER. Any halos are added to the already existing halos. If no texture identifier is specified the pigment, normal and finish statements modify the current default values and any halo is added to the default halo, if any. TRANSFORMATIONs are translate, rotate, scale and matrix statements. They should be specified last.<p>
The sections below describe all of the options available in pigments, normals, finishes and halos. Special textures are covered later.<hr>
<a name="ref 1275 pri 0"><a name="ref 294 pri 1"><center><h3><a name="section 7.6.1">
Section 7.6.1<br>Pigment</h3></center>
The color or pattern of colors for an object is defined by a <a name="ref 294 pri 1"><strong>pigment</strong> statement. All plain textures must have a pigment. If you do not specify one the default pigment is used. A pigment statement is part of a texture specification. However it can be tedious to use a <strong>texture</strong> statement just to add a color to an object. Therefore you may attach a pigment directly to an object without explicitly specifying that it as part of a texture. For example:<p>
<listing>
  //this...                //can be shortened to this...

  object {                 object {
    My_Object                My_Object
    texture {                pigment {color Red}
      pigment {color Red}  }
    }
  }
</listing>
<p>
The color you define is the way you want the object to look if fully illuminated. You pick the basic color inherent in the object and POV-Ray brightens or darkens it depending on the lighting in the scene. The parameter is called <strong>pigment</strong> because we are defining the basic color the object actually is rather than how it looks.<p>
The most complete form for defining a pigment is as follows:<p>
<listing>
  pigment {
    PIGMENT_IDENTIFIER
    PATTERN_TYPE
    PIGMENT_MODIFIERS...
  }
</listing>
<p>
Each of the items in a pigment are optional but if they are present, they should be in the order shown above to insure that the results are as expected. Any items after the PIGMENT_IDENTIFIER modify or override settings given in the identifier. If no identifier is specified then the items modify the pigment values in the current default texture. Valid PIGMENT_MODIFIERS are <a name="ref 282 pri 3"><strong>color_map</strong>, <a name="ref 319 pri 5"><strong>pigment_map</strong>, <a name="ref 852 pri 6"><strong>image_map</strong> and <a name="ref 1024 pri 7"><strong>quick_color</strong> statements as well as any of the generic PATTERN_MODIFIERS such as <a name="ref 954 pri 15"><strong>translate</strong>, <a name="ref 216 pri 26"><strong>rotate</strong>, <a name="ref 215 pri 42"><strong>scale</strong>, <a name="ref 283 pri 52"><strong>turbulence</strong>, wave shape and warp statements. Such modifiers apply only to the pigment and not to other parts of the texture. Modifiers should be specified last.<p>
The various pattern types fall into roughly four categories. Each category is discussed below. They are solid color, color list patterns, color mapped patterns and image maps.<hr>
<a name="ref 1276 pri 0"><a name="ref 1277 pri 0"><a name="ref 113 pri 6"><a name="ref 926 pri 7"><center><h3><a name="section 7.6.1.1">
Section 7.6.1.1<br>Solid Color Pigments</h3></center>
The simplest type of pigment is a solid color. To specify a solid color you simply put a color specification inside a pigment. For example:<p>
<listing>
  pigment {color Orange}
</listing>
<p>
A color specification consists of the option keyword <a name="ref 113 pri 14"><strong>color</strong> followed by a color identifier or by a specification of the amount of red, green, blue, filtered and unfiltered transparency in the surface. See section <a href="pov3001a.htm#ref 117 pri 0">&quot;Specifying Colors&quot;</a> for more details about colors. Any pattern modifiers used with a solid color are ignored because there is no pattern to modify.<hr>
<a name="ref 1278 pri 0"><a name="ref 1279 pri 0"><center><h3><a name="section 7.6.1.2">
Section 7.6.1.2<br>Color List Pigments</h3></center>
There are three color list patterns: <a name="ref 915 pri 2"><strong>checker</strong>, <a name="ref 298 pri 6"><strong>hexagon</strong> and <a name="ref 297 pri 10"><strong>brick</strong>. The result is a pattern of solid colors with distinct edges rather than a blending of colors as with color mapped patterns. Each of these patterns is covered in more detail in a later section. The syntax for each is:<p>
<listing>
  pigment { brick COLOR1, COLOR2 MODIFIERS ... }
  pigment { checker COLOR1, COLOR2 MODIFIERS ... }
  pigment { hexagon COLOR1, COLOR2, COLOR3 MODIFIERS ... }
</listing>
<p>
Each COLORn is any valid color specification. There should be a comma between each color or the <a name="ref 113 pri 18"><strong>color</strong> keyword should be used as a separator so that POV-Ray can determine where each color specification starts and ends.<hr>
<a name="ref 1280 pri 0"><a name="ref 1281 pri 0"><a name="ref 282 pri 0"><center><h3><a name="section 7.6.1.3">
Section 7.6.1.3<br>Color Maps</h3></center>
Most of the color patterns do not use abrupt color changes of just two or three colors like those in the brick, checker or hexagon patterns. They instead use smooth transitions of many colors that gradually change from one point to the next. The colors are defined in a pigment modifier called a <strong>color map</strong> that describes how the pattern blends from one color to the next.<p>
Each of the various pattern types available is in fact a mathematical function that takes any x, y, z location and turns it into a number between 0.0 and 1.0 inclusive. That number is used to specify what mix of colors to use from the color map.<p>
A color map is specified by...<p>
<listing>
  pigment{
    PATTERN_TYPE
    color_map {
      [ NUM_1 COLOR_1]
      [ NUM_2 COLOR_2]
      [ NUM_3 COLOR_3]
       ...
    }
    PIGMENT_MODIFIERS...
  }
</listing>
<p>
Where NUM_1, NUM_2, ... are float values between 0.0 and 1.0 inclusive. COLOR_1, COLOR_2, ... are color specifications. Note that the <a name="ref 1282 pri 0"><strong>[]</strong> brackets are part of the actual statement. They are not notational symbols denoting optional parts. The brackets surround each entry in the color map. There may be from 2 to 256 entries in the map. The alternate spelling <a name="ref 391 pri 0"><strong>colour_map</strong> may be used.<p>
For example<p>
<listing>
  sphere {
    &lt;0,1,2&gt;, 2
    pigment {
      gradient x       //this is the PATTERN_TYPE
      color_map {
        [0.1  color Red]
        [0.3  color Yellow]
        [0.6  color Blue]
        [0.6  color Green]
        [0.8  color Cyan]
      }
    }
  }
</listing>
<p>
The pattern function is evaluated and the result is a value from 0.0 to 1.0. If the value is less than the first entry (in this case 0.1) then the first color (red) is used. Values from 0.1 to 0.3 use a blend of red and yellow using linear interpolation of the two colors. Similarly values from 0.3 to 0.6 blend from yellow to blue. Note that the 3rd and 4th entries both have values of 0.6. This causes an immediate abrupt shift of color from blue to green. Specifically a value that is less than 0.6 will be blue but exactly equal to 0.6 will be green. Moving along, values from 0.6 to 0.8 will be a blend of green and cyan. Finally any value greater than or equal to 0.8 will be cyan.<p>
If you want areas of unchanging color you simply specify the same color for two adjacent entries. For example:<p>
<listing>
  color_map {
    [0.1  color Red]
    [0.3  color Yellow]
    [0.6  color Yellow]
    [0.8  color Green]
  }
</listing>
<p>
In this case any value from 0.3 to 0.6 will be pure yellow.<p>
The <a name="ref 282 pri 3"><strong>color_map</strong> keyword may be used with any pattern except <a name="ref 297 pri 8"><strong>brick</strong>, <a name="ref 915 pri 11"><strong>checker</strong>, <a name="ref 298 pri 16"><strong>hexagon</strong> and <a name="ref 852 pri 18"><strong>image_map</strong>. You may declare and use <a name="ref 282 pri 22"><strong>color_map</strong> identifiers. For example:<p>
<listing>
  #declare Rainbow_Colors=
    color_map {
      [0.0   color Magenta]
      [0.33  color Yellow]
      [0.67  color Cyan]
      [1.0   color Magenta]
    }

  object{My_Object
    pigment{
      gradient x
      color_map{Rainbow_Colors}
    }
  }
</listing>
<hr>

<center>
<a href="pov30025.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
