<html>
<body text="#000000" bgcolor="#C0C0C0" background="backgrnd.gif">
<a name="ref 1227 pri 0"><a name="ref 177 pri 2"><a name="ref 177 pri 2"><a name="ref 177 pri 3"><center><h3><a name="section 7.5.3.4">
Section 7.5.3.4<br>Polygon</h3></center>
Polygons are useful for creating rectangles, squares and other planar shapes with more than three edges. Their syntax is:<p>
<listing>
  polygon {
    TOTAL_NUMBER_OF_POINTS,
    &lt;A_1&gt;, &lt;A_2&gt;, ..., &lt;A_na&gt;, &lt;A_1&gt;,
    &lt;B_1&gt;, &lt;B_2&gt;, ..., &lt;B_nb&gt;, &lt;B_1&gt;,
    &lt;C_1&gt;, &lt;C_2&gt;, ..., &lt;C_nc&gt;, &lt;C_1&gt;,
    ...
  }
</listing>
<p>
The points &lt;A_1&gt; through &lt;A_na&gt; describe the first sub-polygon, the points &lt;B_1&gt; through &lt;B_nb&gt; describe the second sub-polygon, and so on. A polygon can contain any number of sub-polygons, either overlapping or not. In places where an even number of polygons overlaps a hole appears. You only have to be sure that each of these polygons is closed. This is insured by repeating the first point of a sub-polygon at the end of the sub-polygon's point sequence. This implies that all points of a sub-polygon are different.<p>
If the (last) sub-polygon is not closed a warning is issued and the program automatically closes the polygon. This is useful because polygons imported from other programs may not be closed, i. e. their first and last point are not the same.<p>
All points of a polygon are three-dimensional vectors that have to lay on one plane. If this is not the case an error occurs. You can also use two-dimensional vectors to describe the polygon. POV-Ray assumes that the z value is zero in this case.<p>
A square polygon that matches the default planar imagemap is simply:<p>
<listing>
  polygon {
    4,
    &lt;0, 0&gt;, &lt;0, 1&gt;, &lt;1, 1&gt;, &lt;1, 0&gt;
    texture {
      finish { ambient 1 diffuse 0 }
      pigment { image_map { gif &quot;test.gif&quot;  } }
    }
    //scale and rotate as needed here
  }
</listing>
<p>
The sub-polygon feature can be used to generate complex shapes like the letter &quot;P&quot;, where a hole is cut into another polygon:<p>
<listing>
  #declare P = polygon {
    12,
    &lt;0, 0&gt;, &lt;0, 6&gt;, &lt;4, 6&gt;, &lt;4, 3&gt;, &lt;1, 3&gt;, &lt;1, 0&gt;, &lt;0, 0&gt;,
    &lt;1, 4&gt;, &lt;1, 5&gt;, &lt;3, 5&gt;, &lt;3, 4&gt;, &lt;1, 4&gt;
  }
</listing>
<p>
The first sub-polygon (on the first line) describes the outer shape of the letter &quot;P&quot;. The second sub-polygon (on the second line) describes the rectangular hole that is cut in the top of the letter &quot;P&quot;. Both rectangles are closed, i. e. their first and last points are the same.<p>
The feature of cutting holes into a polygon is based on the polygon inside/outside test used. A point is considered to be inside a polygon if a straight line drawn from this point in an arbitrary direction crosses an odd number of edges (this is known as <strong>Jordan's curve  theorem</strong>).<p>
Another very complex example showing one large triangle with three small holes and three separate, small triangles is given below:<p>
<listing>
  polygon {
    28,
    &lt;0, 0&gt; &lt;1, 0&gt; &lt;0, 1&gt; &lt;0, 0&gt;          // large outer triangle
    &lt;.3, .7&gt; &lt;.4, .7&gt; &lt;.3, .8&gt; &lt;.3, .7&gt;  // small outer triangle #1
    &lt;.5, .5&gt; &lt;.6, .5&gt; &lt;.5, .6&gt; &lt;.5, .5&gt;  // small outer triangle #2
    &lt;.7, .3&gt; &lt;.8, .3&gt; &lt;.7, .4&gt; &lt;.7, .3&gt;  // small outer triangle #3
    &lt;.5, .2&gt; &lt;.6, .2&gt; &lt;.5, .3&gt; &lt;.5, .2&gt;  // inner triangle #1
    &lt;.2, .5&gt; &lt;.3, .5&gt; &lt;.2, .6&gt; &lt;.2, .5&gt;  // inner triangle #2
    &lt;.1, .1&gt; &lt;.2, .1&gt; &lt;.1, .2&gt; &lt;.1, .1&gt;  // inner triangle #3
  }
</listing>
<hr>
<a name="ref 1228 pri 0"><a name="ref 1229 pri 0"><a name="ref 957 pri 0"><center><h3><a name="section 7.5.3.5">
Section 7.5.3.5<br>Triangle and Smooth Triangle</h3></center>
The <a name="ref 957 pri 1"><strong>triangle</strong> primitive is available in order to make more complex objects than the built-in shapes will permit. Triangles are usually not created by hand but are converted from other files or generated by utilities. A triangle is defined by<p>
<listing>
  triangle {
    &lt;CORNER1&gt;, &lt;CORNER2&gt;, &lt;CORNER3&gt;
  }
</listing>
<p>
where &lt;CORNERn&gt; is a vector defining the x, y, z coordinates of each corner of the triangle.<p>
Because triangles are perfectly flat surfaces it would require extremely large numbers of very small triangles to approximate a smooth, curved surface. However much of our perception of smooth surfaces is dependent upon the way light and shading is done. By artificially modifying the surface normals we can simulate as smooth surface and hide the sharp-edged seams between individual triangles.<p>
<a name="ref 868 pri 1">The <a name="ref 1230 pri 1"><strong>smooth triangle</strong> primitive is used for just such purposes. The smooth triangles use a formula called Phong normal interpolation to calculate the surface normal for any point on the triangle based on normal vectors which you define for the three corners. This makes the triangle appear to be a smooth curved surface. A smooth triangle is defined by<p>
<listing>
  smooth_triangle {
    &lt;CORNER1&gt;, &lt;NORMAL1&gt;,
    &lt;CORNER2&gt;, &lt;NORMAL2&gt;,
    &lt;CORNER3&gt;, &lt;NORMAL3&gt;
  }
</listing>
<p>
where the corners are defined as in regular triangles and &lt; NORMALn&gt; is a vector describing the direction of the surface normal at each corner.<p>
These normal vectors are prohibitively difficult to compute by hand. Therefore smooth triangles are almost always generated by utility programs. To achieve smooth results, any triangles which share a common vertex should have the same normal vector at that vertex. Generally the smoothed normal should be the average of all the actual normals of the triangles which share that point.<hr>
<a name="ref 1231 pri 0"><a name="ref 1232 pri 0"><center><h3><a name="section 7.5.4">
Section 7.5.4<br>Infinite Solid Primitives</h3></center>
There are five polynomial primitive shapes that are possibly infinite and do not respond to automatic bounding. They are plane, cubic, poly, quadric and quartic. They do have a well defined inside and may be used in CSG and inside a <a name="ref 919 pri 2"><strong>clipped_by</strong> statement. As with all shapes they can be translated, rotated and scaled..<hr>
<a name="ref 1233 pri 0"><a name="ref 141 pri 2"><a name="ref 141 pri 2"><center><h3><a name="section 7.5.4.1">
Section 7.5.4.1<br>Plane</h3></center>
The <a name="ref 141 pri 3"><strong>plane</strong> primitive is a simple way to define an infinite flat surface. The plane is specified as follows:<p>
<listing>
  plane { &lt;NORMAL&gt;, DISTANCE }
</listing>
<p>
The &lt;NORMAL&gt; vector defines the surface normal of the plane. A surface normal is a vector which points up from the surface at a 90 degree angle. This is followed by a float value that gives the distance along the normal that the plane is from the origin (that is only true if the normal vector has unit length; see below). For example:<p>
<listing>
  plane { &lt;0, 1, 0&gt;, 4 }
</listing>
<p>
This is a plane where <strong>straight up</strong> is defined in the positive y-direction. The plane is 4 units in that direction away from the origin. Because most planes are defined with surface normals in the direction of an axis you will often see planes defined using the <a name="ref 142 pri 8"><strong>x</strong>, <a name="ref 143 pri 13"><strong>y</strong> or <a name="ref 144 pri 18"><strong>z</strong> built-in vector identifiers. The example above could be specified as:<p>
<listing>
  plane { y, 4 }
</listing>
<p>
The plane extends infinitely in the x- and z-directions. It effectively divides the world into two pieces. By definition the normal vector points to the outside of the plane while any points away from the vector are defined as inside. This inside/outside distinction is only important when using planes in CSG and <a name="ref 919 pri 21"><strong>clipped_by</strong>.<p>
A plane is called a <strong>polynomial</strong> shape because it is defined by a first order polynomial equation. Given a plane:<p>
<listing>
  plane { &lt;A, B, C&gt;, D }
</listing>
<p>
it can be represented by the equation<p>
<listing>
  A*x + B*y + C*z - D*sqrt(A^2 + B^2 + C^2) = 0.
</listing>
<p>
Therefore our example <strong>plane { y,4 </strong>} is actually the polynomial equation y=4. You can think of this as a set of all x, y, z points where all have y values equal to 4, regardless of the x or z values.<p>
This equation is a <strong>first order</strong> polynomial because each term contains only single powers of x, y or z. A second order equation has terms like x^2, y^2, z^2, xy, xz and yz. Another name for a 2nd order equation is a quadric equation. Third order polys are called cubics. A 4th order equation is a quartic. Such shapes are described in the sections below.<hr>
<a name="ref 1234 pri 0"><a name="ref 1235 pri 0"><a name="ref 995 pri 0"><center><h3><a name="section 7.5.4.2">
Section 7.5.4.2<br>Poly, Cubic and Quartic</h3></center>
Higher order polynomial surfaces may be defined by the use of a poly shape. The syntax is<p>
<listing>
  poly { ORDER, &lt;T1, T2, T3, .... Tm&gt; }
</listing>
<p>
where ORDER is an integer number from 2 to 7 inclusively that specifies the order of the equation. T1, T2, ... Tm are float values for the coefficients of the equation. There are m such terms where<p>
<listing>
  m = ((ORDER+1)*(ORDER+2)*(ORDER+3))/6.
</listing>
<p>
<a name="ref 961 pri 0">An alternate way to specify 3rd order polys is:<p>
<listing>
  cubic { &lt;T1, T2,... T20&gt; }
</listing>
<p>
<a name="ref 1019 pri 0">Also 4th order equations may be specified with:<p>
<listing>
  quartic { &lt;T1, T2,... T35&gt; }
</listing>
<p>
Here's a more mathematical description of quartics for those who are interested. Quartic surfaces are 4th order surfaces and can be used to describe a large class of shapes including the torus, the lemniscate, etc. The general equation for a quartic equation in three variables is (hold onto your hat):<p>
<pre>
  a00 x^4 + a01 x^3 y + a02 x^3 z+ a03 x^3 + a04 x^2 y^2+
  a05 x^2 y z+ a06 x^2 y + a07 x^2 z^2+a08 x^2 z+a09 x^2+
  a10 x y^3+a11 x y^2 z+ a12 x y^2+a13 x y z^2+a14 x y z+
  a15 x y + a16 x z^3 + a17 x z^2 + a18 x z + a19 x+
  a20 y^4 + a21 y^3 z + a22 y^3+ a23 y^2 z^2 +a24 y^2 z+
  a25 y^2 + a26 y z^3 + a27 y z^2 + a28 y z + a29 y+
  a30 z^4 + a31 z^3 + a32 z^2 + a33 z + a34 = 0
</pre>
<p>
To declare a quartic surface requires that each of the coefficients (a0 ... a34) be placed in order into a single long vector of 35 terms.<p>
As an example let's define a torus the hard way. A Torus can be represented by the equation:<p>
<pre>
 x^4 + y^4 + z^4 + 2 x^2 y^2 + 2 x^2 z^2 + 2 y^2 z^2 -
 2 (r_0^2 + r_1^2) x^2 + 2 (r_0^2 - r_1^2) y^2 -
 2 (r_0^2 + r_1^2) z^2 + (r_0^2 - r_1^2)^2 = 0
</pre>
<p>
<a name="ref 240 pri 8">Where r_0 is the <strong>major</strong> radius of the torus, the distance from the hole of the donut to the middle of the ring of the donut, and r_1 is the <strong>minor</strong> radius of the torus, the distance from the middle of the ring of the donut to the outer surface. The following object declaration is for a torus having major radius 6.3 minor radius 3.5 (Making the maximum width just under 20).<p>
<listing>
  // Torus having major radius sqrt(40), minor radius sqrt(12)

  quartic {
    &lt; 1,   0,   0,   0,   2,   0,   0,   2,   0,
   -104,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   1,   0,   0,   2,   0,  56,   0,
      0,   0,   0,   1,   0, -104,  0, 784 &gt;
    sturm
    bounded_by { // bounded_by speeds up the render,
                 // see bounded_by
                 // explanation later
                 // in docs for more info.
     sphere { &lt;0, 0, 0&gt;, 10 }
    }
  }
</listing>
<p>
Poly, cubic and quartics are just like quadrics in that you don't have to understand what one is to use one. The file <b>shapesq.inc</b> has plenty of pre-defined quartics for you to play with. The syntax for using a pre-defined quartic is:<p>
<listing>
  object { Quartic_Name }
</listing>
<p>
<a name="ref 905 pri 16">Polys use highly complex computations and will not always render perfectly. If the surface is not smooth, has dropouts, or extra random pixels, try using the optional keyword <a name="ref 905 pri 25"><strong>sturm</strong> in the definition. This will cause a slower but more accurate calculation method to be used. Usually, but not always, this will solve the problem. If sturm doesn't work, try rotating or translating the shape by some small amount. See the sub-directory <b>math</b> in the scene files directory for examples of polys in scenes.<p>
There are really so many different quartic shapes, we can't even begin to list or describe them all. If you are interested and mathematically inclined, an excellent reference book for curves and surfaces where you'll find more quartic shape formulas is:<p>
<pre>
  &quot;The CRC Handbook of Mathematical Curves and Surfaces&quot;
  David von Seggern
  CRC Press, 1990
</pre>
<hr>
<a name="ref 1236 pri 0"><a name="ref 1017 pri 1"><a name="ref 1017 pri 1"><center><h3><a name="section 7.5.4.3">
Section 7.5.4.3<br>Quadric</h3></center>
Quadric surfaces can produce shapes like ellipsoids, spheres, cones, cylinders, paraboloids (dish shapes) and hyperboloids (saddle or hourglass shapes). Note that you do not confuse <strong>quaDRic</strong> with <strong>quaRTic</strong>. A quadric is a 2nd order polynomial while a quartic is 4th order. Quadrics render much faster and are less error-prone.<p>
A quadric is defined in POV-Ray by<p>
<listing>
  quadric { &lt;A,B,C&gt;, &lt;D,E,F&gt;, &lt;G,H,I&gt;, J }
</listing>
<p>
where A through J are float expressions that define a surface of x, y, z points which satisfy the equation<p>
<pre>
  A x^2   + B y^2   + C z^2 +
  D xy    + E xz    + F yz +
  G x     + H y     + I z    + J = 0
</pre>
<p>
Different values of A, B, C, ... J will give different shapes. If you take any three dimensional point and use its x, y and z coordinates in the above equation the answer will be 0 if the point is on the surface of the object. The answer will be negative if the point is inside the object and positive if the point is outside the object. Here are some examples:<p>
<pre>
  X^2 + Y^2 + Z^2 - 1 = 0  Sphere
  X^2 + Y^2 - 1 = 0        Infinite cylinder along the Z axis
  X^2 + Y^2 - Z^2 = 0      Infinite cone along the Z axis
</pre>
<p>
The easiest way to use these shapes is to include the standard file <b>shapes.inc</b> into your program. It contains several pre-defined quadrics and you can transform these pre-defined shapes (using translate, rotate and scale) into the ones you want. You can invoke them by using the syntax:<p>
<listing>
  object { Quadric_Name }
</listing>
<p>
The pre-defined quadrics are centered about the origin &lt; 0,0,0&gt; and have a radius of 1. Don't confuse radius with width. The radius is half the diameter or width making the standard quadrics 2 units wide.<p>
Some of the pre-defined quadrics are,<p>
<pre>
  Ellipsoid
  Cylinder_X, Cylinder_Y, Cylinder_Z
  QCone_X, QCone_Y, QCone_Z
  Paraboloid_X, Paraboloid_Y, Paraboloid_Z
</pre>
<p>
For a complete list, see the file <b>shapes.inc</b>.<hr>
<a name="ref 1237 pri 0"><a name="ref 205 pri 0"><center><h3><a name="section 7.5.5">
Section 7.5.5<br>Constructive Solid Geometry</h3></center>
POV-Ray supports <strong>Constructive Solid Geometry</strong> (CSG) with five different operations: difference, intersection, merge, union and negation (inversion). While the first four operations represent binary operators, i. e. they need two arguments, the negation is a unary operator, it takes only one argument.<hr>
<a name="ref 1238 pri 0"><a name="ref 1239 pri 0"><center><h3><a name="section 7.5.5.1">
Section 7.5.5.1<br>About CSG</h3></center>
Constructive Solid Geometry is a technique for combining two or more objects to create a new object using the three boolean set operators <a name="ref 211 pri 4"><strong>union</strong>, <a name="ref 214 pri 7"><strong>intersection</strong>, and <a name="ref 1240 pri 7"><strong>negation</strong>. It only works with solid objects, i. e. objects that have a well-defined interior. This is the case for all objects described in the sections <a href="pov3001f.htm#ref 1202 pri 0">&quot;Finite Solid Primitives&quot;</a> and <a href="pov30022.htm#ref 1232 pri 0">&quot;Infinite Solid Primitives&quot;</a>.<p>
CSG shapes may be used anywhere a standard shape can be used, even inside other CSG shapes. They can be translated, rotated or scaled in the same way as any other shape. The shapes making up the CSG shape may be individually translated, rotated and scaled as well.<hr>
<a name="ref 1241 pri 0"><a name="ref 1242 pri 0"><center><h3><a name="section 7.5.5.2">
Section 7.5.5.2<br>Inside and Outside</h3></center>
Most shape primitives, like spheres, boxes and blobs divide the world into two regions. One region is inside the object and one is outside.<p>
Given any point in space you can say it's either inside or outside any particular primitive object. Well, it could be exactly on the surface but this case is rather hard to determine due to numerical problems.<p>
Even planes have an inside and an outside. By definition, the surface normal of the plane points towards the outside of the plane. You should note that triangles and triangle-based shapes cannot be used as solid objects in CSG since they have no well defined inside and outside.<p>
CSG uses the concepts of inside and outside to combine shapes together as explained in the following sections.<p>
Imagine you have to objects that partially overlap like shown in the figure below. Four different areas of points can be distinguished: points that are neither in object A nor in object B, points that are in object A but not in object B, points that are not in object A but in object B and last not least points that are in object A and object B.<p>
 <center><img src="pov30044.gif" border=0 width=320 height=240><br><cite>Two overlapping objects.</cite></center><br> <p>
Keeping this in mind it will be quite easy to understand how the CSG operations work.<hr>

<center>
<a href="pov30023.htm">Next Section</a><br>
<a href="povray.htm#Table of Contents">Table Of Contents</a><br>
</center>
</body>
</html>
