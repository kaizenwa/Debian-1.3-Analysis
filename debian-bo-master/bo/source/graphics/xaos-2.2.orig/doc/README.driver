This is small document about writing new driver for XaoS.



DRIVER API
==========


Ugly interface is designed to make writing of new drivers as easy as possible.
You need to write just few functions to fill following table:
(use file ui_template for starting of writing new driver from scrath*/

struct ui_driver {
  char *name;
  int (*init)(void);		/*initializing function. returns 0 if fail*/
  void (*getsize)(int *,int *);	/*get current size..in full-screen versions
  				  i.e svga and dos asks user for it*/
  void (*processevents)(int,int *,int *,int *,int *);
  				/*processevents..calls ui_resize,ui_key
				  also returns positions of mouse..
				  waits for event if first parameter is
				  1*/
  void (*getmouse)(int *,int *,int *);
  				/*returns current mouse positions*/
  void (*uninit)();
  				/*called before exit*/
  int (*set_color)(int,int,int,int);
  				/*sets palette color and returns number*/
  void (*print)(int,int,char *);	/*prints text*/
  void (*display)();		/*displays bitmap*/
  int (*alloc_buffers)(char **buffer1,char **buffer2);/*makes buffers*/
  void (*free_buffers)(char *buffer1,char *buffer2);/*frees buffers*/
  void (*flip_buffers)();	/*prints text*/
  void (*rotate_palette) (int);       /*rotates palette for n steps*/
  int maxsize;			/*maximal size of palette*/
  int textheight;		/*width of text*/
  char **help;			/*help text*/
  int helpsize;			/*size of help in lines*/
  struct params *params;	/*command line parameters*/
  int flags;
  float width,height;
  int maxwidth,maxheight;
};


FUNCTIONS
=========

Ui uses following functions to communicate with driver:

init
====
  function that initializes driver and returns 1 if success and 0 if fail

getsize(int *width,int *height)
==============================
  returns size of screen(window) x and y

processevents(int wait, int *x,int *y, int *buttonmask, int &keys)
==================================================================
  gets new keyboard/mouse events. parameters:
    wait - if 1 function can wait for next event otherwise just lookup if 
           something comed. This is usefull on multitasked os where xaos
	   does not eats unnecesaru cpi.
    *x,*y - here returns current positions of mouse
    *b - returns mask of BUTTON1,BUTTON2,BUTTON3 for mouse buttons
    *k - returns mask for cursor keys- 1=left,2=right,4=up,8=down
    function also calls ui_key(ASCII character) and ui_resize if required

    note in case of problems freeing/allocating inside processevents you may 
    call ui_call_resize that calls resize later outside this function

uninit
======
 Unitialises driver - called before exit.

set_color(int r,int g,int b,int init)
=====================================
  allocates color in palette and returns index. -1 if fail
    parameters:
    r , g , b = rgb values in range 0-255
    init = if set forget old palette and restart allocating from beggining

print(int x,int y, char *text)
==============================
  prints text to screen at possition x/y

display
=======
  displays current buffer to screen

alloc_buffers(char **buffer1,char **buffer2)
============================================
  allocs two buffers that can hold screen size bitmap. 
  Also sets current buffer to buffer1. Since version 2.1 returns scanline 
  size in bytes(usually width) and 0 if fail. This is usefull on systems, that
  allocated bitmap bigger than window/screen(dividable by 4 or so)

free_buffers(char *buffer1,char *buffer2)
=========================================
  frees allocated buffers

flip_buffer
===========
  flips buffers = sets current buffer to other one

rotate_palette(int dirrection)
==============================
  function used for palette rotating. It is not required. Set to NULL if
  it is unimplemented in your driver. 

  When rotating is on this function is periodicaly called with direction 
  attribute. It must rotate all colors 1-number_of_allocated direction steps 
  forward except first one.   This should be implemented also using cmap array 
  in zoom_context that contains correct rgb values. 
  
  So you may use ui_getcontext to get zoom_context and then
  set context->numcolors colors in array cmap.

OTHER INFORMATION
=================
Also some additional variables are use to inform ui about driver.
All this values can be changed by init functions in case they are unknown
before.

maxsize
=======

  maximal size of palette(unused for now)


textheight
==========
  height of your font


>>>>FOLLOWING PART IS NOT REQUIRED TO MAKE FIRST VERSION OF DRIVER WORKING<<<<<
so you may skip to REGISTERING DRIVER for first read and return here later.


help
====
  help text. This text is displayed at the end of ui' help. So you can put
  your copyright there and additional informations about driver.


helpsize
========
  number of lines of help


params
======
  Using this you may define command line options for you driver.

  They are defined using params structure like:
  static struct params params[]={
    {"-mode",P_NUMBER,&defmode,"Select graphics mode(same number as in interactive menu)"},
    {NULL,0,NULL,NULL}  /*this is MUST be last option field*/
  };

  every line is one parameters. List ends with {NULL,0,NULL,NULL}.
  First filed is option name.
  Second field is type of parameter:
    P_SWITCH - no parameter - variable is just set to 1 if option
    P_NUMBER - integer number
    P_STRING - string
    P_FLOAT - floating point number (variable is float)
  Third is pointer to variable that is changed if option is set. 
  It is for example int* for P_NUMBER or P_SWITCH and so on..
  Last one is help text. Displayed by ui -h


width,height
============
  see FLAGS. May be set to 0.0,0.0 for the begining

maxwidth,maxheight
==================
  see FLAGS. May be set to 0,0 for the begining

FLAGS
=====
  This variable says more about your driver. You may start with value 0.
  But for final version it is recomeded to read following section curefully.

  Flags are uppercase constants and should be set by following way:

  ASYNC_PALETTE | PALETTE_ROTATION

  following switches are supported:

  RANDOM_PALETTE_SIZE
  ===================
    random size of palette. This is used in X where palette is shared between
    programs. By default xaos allocates all available colors up to 256. This
    is not very nice to other aplications in X. So randomsize causes that
    just some random number of colors(between 8-256) are allocated. 
  
    Also when this variable is off XaoS expects that allways same number of
    colors is available.
  Palette rotation options:
  =========================
    Palette rotation should be implemented by various ways.
    You may define following values to let xaos know about features/limitations
    of your implementetion:
    PALETTE_ROTATION
    ================
     define in case palette rotation is supported

    ASYNC_PALETTE
    =============
     enables asynchronous calling of rotating function(this makes problems on
     most platforms..you may try your luck..)
    ROTATE_INSIDE_CALCULATION
    =========================
     call rotate routing inside calculation loop too?  
     (vbuff should include incorrect data)
    PALETTE_REDISPLAYS
    ==================
     If you rotate_palette function displays buffers(like in
     truecolor modes. Set this to 1 and ui will handle this more
     effectivly)


  UPDATE_AFTER_PALETTE
  ====================
    recalculate after palette changing?
  UPDATE_AFTER_RESIZE
  ===================
    recalculate and redraw screen even if its size is not changed.
    In case that resize precodure destruys data in buffers

  Screen/window size informations
  ===============================
    Xaos needs to know exact size of displayed images. This is required
    for random dot stereograms and also for keeping fractals in their shape
    (do not make them wide on 640x200 resolution etc.)
    So minimally one of the following values should be defined.
    (they are sorted in order I preffer them)

    SCREENSIZE
    ==========
     values width/height specifies exact size of screen/window in centimeters
    PIXELSIZE
    =========
     values width/height specifies exact size of one pixel in centimeters
     This is better for windowed enviroments where window size is often changed
    FULLSCREEN
    ==========
     driver runs fullscreen. XaoS automatically uses default screen size
     (29.0cm x 21.5cm)
    RESOLUTION
    ==========
     driver does not know exact screen size. But knows resolution used.
     (it is in variables width/height) XaoS automatically calculates
     pixel width using:29.0cm/maxwidth
     and height: 21.5/maxheight

   Of course default width and height can be changed by command line options.
   You may also use combinations like:
   
   SCREENSIZE | FULLSCREEN (the best for fullscreen drivers)
   PIXELSIZE|RESOLUTION (the best for windowed drivers)
   FULLSCREEN (for fullscreen drivers than have no idea about screen size..
               normal pc drivers)
   nothing (for windowed drivers than have no idea about maximal resolution..
               very strange..at least. Not recomended)

   do not forget to sed width,height,maxwidth,maxheight fields if required.



REGISTERING DRIVER
==================

Than just register driver to driver.c and you may compile :)
You may use ui_template.c as driver template..

Please let me know if you want to start code some driver.
