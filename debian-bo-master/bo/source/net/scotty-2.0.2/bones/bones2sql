#! /usr/local/bin/scotty -nf
## -*- tcl -*-
##
## Create a relational model for the bones database. We simply write
## the SQL create table statements to stdout, each statement seperated
## by an empty line. This makes things quite portable.
##
## Copyright (c) 1995
##
## J. Schoenwaelder
## TU Braunschweig, Germany
## Institute for Operating Systems and Computer Networks
##
## Permission to use, copy, modify, and distribute this
## software and its documentation for any purpose and without
## fee is hereby granted, provided that this copyright
## notice appears in all copies.  The University of Braunschweig
## makes no representations about the suitability of this
## software for any purpose.  It is provided "as is" without
## express or implied warranty.
##

proc bones { query } { puts "$query \\g" }

##
## Below are all the table creation statements.
##

bones {
    create table Person (
			 id		int primary key,
			 name		char(80) not null, 
			 address	int,
			 privphone	char(40),
			 email		char(40),
			 phone		char(40),
			 position	char(20),
			 department	int
			 )
}

bones {
    create table Department (
			     id	 	int primary key,
			     name	char(80) not null,
			     address	int not null,
			     head	int
			     )
}

bones {
    create table Project (
			  id	int primary key,
			  name	char(80) not null,
			  descr	char(255),
			  start	int,
			  end	int
			  )
}

bones {
    create table ProjectMember (
				id	int,
				project	int,
				type	char(20),
				start	int,
				end	int
				)
}

bones {
    create table Location (
			   city		char(80) not null,
			   street	char(80) not null,
			   house	char(80) not null,
			   room		char(80)
			   )
}

##
## Here starts the account section. This is modeled very closely
## like the UNIX way of doing things. Perhaps we need future add ons
## to model other operating systems.
##

bones {
    create table Login (
			id	int not null primary key,
			name	char(16) not null,
			passwd	char(16) not null,
			home	char(255) not null,
			shell	char(80) not null,
			group	int not null,
			owner	int
			)
}

bones {
    create table Group (
			id	int not null primary key,
			name	char(16) not null
			)
}
    
bones {
    create table GroupMember (
			      uid	int not null,
			      gid	int not null
			      )
}

##
## The hardware and software section contains tables to model 
## hardware and software information plus the software installation
## and their maintainers.
##

bones {
    create table Hardware (
			   id		int not null primary key,
			   inventNo	int not null,
			   serialNo	int not null,
			   description	char(255) not null,
			   price	int,
			   date		int,
			   type		char(20)
			  )
}

bones {
    create table Software (
			   id		int not null primary key,
			   name		char(40) not null,
			   version	char(40),
			   description	char(255),
			   license	char(80),
			   type		char(20)
			  )
}

bones {
    create table SoftwareInstalled (
				    id		int not null primary key,
				    software	int not null,
				    machines	int,
				    contact	int not null,
				    owner	int
				   )
}

##
## The device section contains definitions for devices like hosts,
## printer disks etc. 
##

bones {
    create table Device (
			 id		int not null primary key,
			 name		char(40) not null,
			 type		char(20),
			 hardware	int,
			 os		char(40),
			 location	int
			)
}

##
## Filesystems, Partitions etc. are of special interest. So we model
## them using the following classes.
##

bones {
    create table Partition (
			    id		int not null primary key,
			    name	char(40),
			    device	int,
			    cylinder	int,
			    sector	int,
			    sectorSize	int,
			    filesystem	int
			   )
}

bones {
    create table Filesystem (
			     id		int not null primary key,
			     name	char(40),
			     type	char(20),
			     readOnly   int,
			     access	char(256),
			     rootAccess	char(256),
			     anonymous	char(20)
			    )
}

##
## Tables used to store network information.
##


bones {
    create table Network (
			  id		int not null primary key,
			  layer		int,
			  name		char(40),
			  type		char(20),
			  speed		int,
			  address	char(40),
			  mask		char(40)
			 )
}

bones {
    create table Interface (
			    id		int not null primary key,
			    name	char(40),
			    address	char(40),
			    device	int,
			    network	int
			   )
}

bones {
    create table Service (
			  id		int not null primary key,
			  name		char(40),
			  protocol	char(20),
			  port		int
			 )
}

exit 0

##
## Some stuff that is currently not part of the model.
##

IPDomain OBJECT CLASS
    SUBCLASS of Audit
    KEY { name }
    MUST CONTAIN {
	name		:: string,
	master		:: device,
	servers		:: device,
	xchangers	:: device,
	devices		:: device[]
    }

-- Netgroups (not to confuse with YP netgroups) are used to define
-- sets of objects to allow very flexible and short configuration
-- descriptions.

Netgroup OBJECT CLASS
    SUBCLASS of Audit
    KEY { name }
    MUST CONTAIN {
	name	:: string,
	devices	:: device[],
	hosts	:: iPInterface[],
	ethers	:: ethernetInterface[],
	groups	:: group[],
	logins	:: login[]
    }
    MAY CONTAIN {
	services	:: iPService[]
    }
