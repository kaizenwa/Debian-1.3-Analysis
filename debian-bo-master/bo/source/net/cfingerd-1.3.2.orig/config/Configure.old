#!/usr/bin/perl
#
# Configuration script for CFINGERD
# Version 2.2.1 by Ken Hollis
#
# Do not modify this script unless you absolutely know what you're doing!
#
# Update log:
#	07/29/96: Decided to make an update log :)  Added commenting to the
#		  configuration script.

# Set version

$VERSION = "1.3.0";

# Clear the screen

system("clear");

# Check whether or not we're superuser.  If not, die and display the message
# below.

$> && die <<"EOT";

In order to complete the configuration process, you must change to root
by becoming superuser (su) or logging in as root on another virtual terminal.

Please consult the FAQ, or read the \"README\" file for more information 
on how to begin installing cfingerd.

EOT

# Unbuffered screen output mode

$| = 1;

# Remove the configuration files that may have been generated from a
# previous installation.

system("rm -f config.h ; rm -f userlist/config.h");

print <<"EOT";
This is CFINGERD $VERSION
Configuration Script by Ken Hollis <khollis\@bitgate.com>
EOT

# Check if a previous Makefile already exists.
if (-e "./Makefile") {
    $clean = 0;
    open(IF, "Makefile") || die "Makefile: $!\n";

    # Is this the original makefile generated by "make clean" ?

    while(<IF>) {
	chop;
	if (/totally clean installation/) {
	    $clean = 1;
	    last;
	}
    }
    close(IF);

    # If not, then we need to ask the user if they wish to re-install the
    # version of cfingerd that they have, or if they want to stop.

    if (!$clean) {
	print <<"EOT";

You already have a previously created Makefile, meaning you have run this 
configuration script once before.  If you want to go ahead and re-run the 
configuration script, simply reply with \"Y\" to continue and re-make the 
makefile.  Otherwise, reply with \"N\" and type \"make clean\" manually 
before running the Configuration script again.

EOT
	print "Go ahead? ";
	$GA = <STDIN>;
	chop($GA);
	$GA =~ tr/a-z/A-Z/;
	if ($GA ne 'Y') {
	    print "\n";
	    exit;
	}
    }
}

# Now, request the user's fully qualified domain name (or FQDN.)  This is
# for use in the program for internal checking.

print <<"EOT";

FQDN:
This is your fully qualified domain name.  You should enter the entire 
name here of your system (for example, netcom23.netcom.com, or 
whatever).  Sometimes the getlocalhost routine that cfingerd uses doesn't 
quite return the correct information for your system for whatever 
reasons...

If the name in parenthesis is correct, please just hit return.

EOT

# Get the host name

$FOUND_FQDN = `hostname`;
chop($FOUND_FQDN);
$FOUND_FQDN = $FOUND_FQDN . ".";

$ukd = 0;

# And the domain name for which the host belongs.

if (-e "/bin/dnsdomainname") {
    $FOUND_FQDN = $FOUND_FQDN . `/bin/dnsdomainname`;
    chop($FOUND_FQDN);
} elsif (-e "/bin/domainname") {
    $FOUND_FQDN = $FOUND_FQDN . `/bin/domainname`;
    chop($FOUND_FQDN);
} else {
    $FOUND_FQDN = $FOUND_FQDN . "unknown.domain";
    $ukd = 1;
}

# Now, prompt the user to make sure the hostname that is specified is 
# correct.  Some installations of Linux like to make double ".com" entries
# or skewed data for hostname data.  This is here for a safety check.  We
# can NEVER assume anything.

print "FQDN ($FOUND_FQDN): ";
$FQDN = <STDIN>;
chop($FQDN);

# Double check to make sure that we didn't specify a new domain name, or
# the one already there was accepted.  Also, make sure that the domain
# specified is NOT unknown.

if (($FQDN eq "") && ($ukd == 1)) {
    print "\n";
    print "You need to specify an FQDN entry.  Installation cancelled.\n\n";
    exit;
} elsif ($FQDN ne "") {
    $FOUND_FQDN = $FQDN;
} else {
    $FQDN = $FOUND_FQDN;
}

# Now, clear the screen and begin autodetection of the system operating
# system and some other fun stuff.

system("clear");
print "Beginning autodetection sequence...\n\n";

# Get the name of the OS they're running, and chop off the \n

$uname = `uname`;
chop($uname);

$has_lastlog = 0;

# Eeegads - I need to change this.

if ($uname ne "Linux") {
    print "It appears you're running BSD/OS or some variant thereof.\n";
    $make = "gmake";
} else {
    # Probably not, but what the hell.
    print "Looks like we've got a Linux user!\n";
    $make = "make";
}

# Check the location of lastlog.  On various versions of Unix, this can
# exist in various places.  If there's no lastlog file, we can only use
# the /var/adm/wtmp file for lastlog, since there's no other alternative.

if (-e "/var/log/lastlog") {
    $has_lastlog = 1;
    print "/var/log/lastlog will be used instead of /var/adm/wtmp.\n";
    $lastlog_file = "/var/log/lastlog";
} elsif (-e "/var/adm/lastlog") {
    $has_lastlog = 1;
    print "/var/adm/lastlog will be used instead of /var/adm/wtmp.\n";
    $lastlog_file = "/var/adm/lastlog";
} else {
    print "/var/adm/wtmp will be used.  Caution - large files can make cfingerd slow!\n";
    $lastlog_file = "/var/adm/wtmp";
}

# Now, find the NOBODY ID.  Don't assume that "id nobody" will return the
# correct data.  (Although this is true in newer utilities, we can't assume
# that the user has the newer utilities.)

open(PW, "grep nobody /etc/passwd|");
while(<PW>) {
    chop;
    ($un,$pw,$uid,$gid,$gecos,$dir) = split(/:/);
}
close(PW);

# Now, check to make sure that we have a Nobody UID/GID pair that was in the
# configuration file.  We need to make sure that there is one.  If the
# numbers are negative, then we cannot continue.

if (($uid ne "") && ($gid ne "")) {
    print "Your nobody user ID and group ID are $uid, and $gid respectively.\n";
} elsif (($uid < 0) || ($gid < 0)) {
    print "Oops - your nobody user ID or group ID contains a negative number.\n";
    print "This will cause a problem with cfingerd (and possibly other programs.)\n";
    print "\nYou will probably want to change the nobody UID/GID to something\n";
    print "like 65535 and 65535.\n";
    exit;
} else {
    print "You need to create a nobody GID.  Error.\n";
    exit;
}

# Check for shadow passwords.

if (-e "/etc/shadow") {
    print "Ah, good.  You have Shadow passwords.\n";
    $has_shadow = 1;
} else {
    print "Bummer - no shadow passwords.  Will compensate.\n";
    $has_shadow = 0;
}
$has_shadow = 0;

print "\n";

if ($uname eq "Linux") {
    $make = "make";
}

# Now create the configuration header file.

print "Creating src/config.h...\n";

$dateandtime = `date`;
chop($dateandtime);

$define_bsd = "\n#ifndef BSD\n#define BSD 1\n#endif\n";
open(CF, "src/config.h.in");
open(CFO, ">src/config.h");
while(<CF>) {
    chop;
    s/\$0//;
#    s/\$0/#define\tACTUAL_HOSTNAME\t\"$FQDN\"/;
    s/\$1/#define\tNOBODY_UID\t\t$uid/;
    s/\$2/#define\tNOBODY_GID\t\t$gid/;
    s/\$3/#define\tCOMPILE_DT\t\t\"$dateandtime\"/;
    s/\$4/#define\tWTMPFILE\t\t"$lastlog_file"/;

    if ($has_lastlog eq "0") {
	s/\$5/#undef\tUSE_LASTLOG/;
    } else {
	s/\$5/#define\tUSE_LASTLOG\t\t$has_lastlog/;
    }

    if ($has_shadow eq "0") {
	s/\$6/#undef\tHAS_SHADOW/;
    } else {
	s/\$6/#define\tHAS_SHADOW\t\t$has_shadow/;
    }

    print CFO "$_\n";
}

# And now, create the userlist configuration file.

print CFO $define_bsd if $make eq "gmake";
close(CFO);
close(CF);

print "Creating userlist/config.h...\n";

open(CFF, "userlist/config.h.in");
open(CFFO, ">userlist/config.h");
while(<CFF>) {
    chop;
#    s/\$0/#define\tLOCAL_NAME\t\"$FQDN\"/;
    s/\$0//;
    print CFFO "$_\n";
}

print CFFO $define_bsd if $make eq "gmake";
close(CFFO);
close(CFF);

# And the makefile.

print "Creating Makefile...\n";

open(MF, "Makefile.in");
open(MFO, ">Makefile");
while(<MF>) {
    chop;
    s/\$0/$make/;
    print MFO "$_\n";
}
close(MF);
close(MFO);

# Okay, tell the user we've accomplished our goal.  Now all that needs to be
# done is the start of the compile.  If the user wants to automagically
# start compiling cfingerd, we can allow that here.

print <<"EOT";

Now, edit src/config.h, and userlist/config.h and make any changes you need.
After you're done with that, become superuser, and type \"make all\".

If you don't wish to use the FQDN you specified, simply remove the define 
from the src/config.h and userlist/config.h files so that localhost will 
be used in its place.

If you don't want to edit those, you may respond with \"Y\" to 
automatically let the Configuration program compile everything for you.

EOT

# Start compiling now?

print "Shall I start compilation? ";
$start = <STDIN>;
chop($start);
print "\n";

# if so, let's begin!

$start =~ tr/a-z/A-Z/;
if ($start eq "Y") {
    system("make all");
} else {
    exit;
}
