Index: nis/ypclients/Makeconfig
diff -u nis/ypclients/Makeconfig:1.1.1.1 nis/ypclients/Makeconfig:1.3
--- nis/ypclients/Makeconfig:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/Makeconfig	Sat Jan 25 23:18:02 1997
@@ -8,6 +8,10 @@
 #MAKE=make
 I486FLAGS=-m486
 
+# Comment two lines below for glibc 2.
+# LIBS=-lnsl
+# CRYPTLIB=-lcrypt
+
 USRSBINDIR=${DEBDIR}/usr/sbin
 USRBINDIR=${DEBDIR}/usr/bin
 BINDIR=${DEBDIR}/bin
@@ -19,6 +23,7 @@
 SRCDIR:=$(shell pwd)
 
 WFLAGS=-Wall -ansi -pedantic -Wtraditional -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wnested-externs
+WFLAGS=-Wall -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wnested-externs
 
 MKDIR=mkdir -p
 
@@ -26,7 +31,7 @@
 
 CC	= gcc $(I486FLAGS)
 
-XCFLAGS = -D_GNU_SOURCE -D_BSD_SOURCE -D_POSIX_SOURCE -Dlinux
+XCFLAGS = -D_GNU_SOURCE -D_BSD_SOURCE -D_POSIX_SOURCE -Dlinux -D_XOPEN_SOURCE
 
 MINUS_G=
 XTRAFLAGS=$(XCFLAGS)
Index: nis/ypclients/README.new
diff -u /dev/null nis/ypclients/README.new:1.2
--- /dev/null	Mon Jan 27 07:52:54 1997
+++ nis/ypclients/README.new	Mon Jan 27 07:49:40 1997
@@ -0,0 +1,11 @@
+This is the new ypclients for glibc 2.0 and libc 5.4.21 or above.
+You should uncomment two lines in Makeconfig:
+
+LIBS=-lnsl
+CRYPTLIB=-lcrypt
+
+for glibc 2.0.
+
+H.J.
+hjl@gnu.ai.mit.edu
+01/26/97
Index: nis/ypclients/xdr_yp.h
diff -u nis/ypclients/xdr_yp.h:1.1.1.1 nis/ypclients/xdr_yp.h:1.2
--- nis/ypclients/xdr_yp.h:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/xdr_yp.h	Sat Jan 25 21:22:42 1997
@@ -7,7 +7,9 @@
  * Added RCS keywords.
  *
  */
-
+#if 1
+#include <rpcsvc/yp_prot.h>
+#else
 extern bool_t xdr_domainname (XDR *, char *);
 extern bool_t xdr_peername (XDR *, char *);
 extern bool_t xdr_datum (XDR *, datum *);
@@ -27,3 +29,4 @@
 extern bool_t xdr_ypmaplist (XDR *, struct ypmaplist *);
 extern bool_t xdr_ypresp_maplist (XDR *, struct ypresp_maplist *);
 extern bool_t xdr_ypresp_order (XDR *, struct ypresp_order *);
+#endif
Index: nis/ypclients/ypbind/Makefile
diff -u nis/ypclients/ypbind/Makefile:1.1.1.1 nis/ypclients/ypbind/Makefile:1.2
--- nis/ypclients/ypbind/Makefile:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/Makefile	Sat Jan 25 23:18:03 1997
@@ -1,6 +1,6 @@
-#include ../Makeconfig
+include ../Makeconfig
 #
-#include ../Makerules
+include ../Makerules
 
 CC = gcc -m486 -ansi -pedantic # -fbounds-checking
 
Index: nis/ypclients/ypbind/TODO
diff -u nis/ypclients/ypbind/TODO:1.1.1.1 nis/ypclients/ypbind/TODO:1.2
--- nis/ypclients/ypbind/TODO:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/TODO	Sat Jan 25 21:22:42 1997
@@ -1,3 +1 @@
-Accept a list of servers for a domain, circulate between entries (or use 
-fallback entries if a server fails).
-Make use of mmap() or SysV-IPC command-line options.
+Test binding to multiple NIS domains.
Index: nis/ypclients/ypbind/daemon.c
diff -u nis/ypclients/ypbind/daemon.c:1.1.1.1 nis/ypclients/ypbind/daemon.c:1.2
--- nis/ypclients/ypbind/daemon.c:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/daemon.c	Sat Jan 25 21:22:42 1997
@@ -1,6 +1,12 @@
 /* 
  * $Log: daemon.c,v $
- * Revision 1.1  1995/07/25 14:27:34  swen
+ * Revision 1.1.1.1  1997/01/23 20:48:30  hjl
+ * Import ypbind 3.0.
+ *
+ * Revision 1.2  1996/10/08 09:36:13  swen
+ * Reordered include files.
+ *
+ * Revision 1.1  1995/07/25  14:27:34  swen
  * ypbind version 2.0.
  *
  * Revision 2.3  1995/01/24  12:24:20  swen
@@ -8,20 +14,22 @@
  *
  */
 
-static char rcsid[] = "$Id: daemon.c,v 1.1 1995/07/25 14:27:34 swen Exp $" ;
+static char rcsid[] = "$Id: daemon.c,v 1.1.1.1 1997/01/23 20:48:30 hjl Exp $" ;
 
 /*
  * Initialize a daemon process.
  */
 
-#include	<stdio.h>
-#include	<signal.h>
 #include	<sys/param.h>
-#include	<errno.h>
-#include    <unistd.h>
 #include	<sys/file.h>
 #include	<sys/ioctl.h>
+#include	<sys/types.h>
 #include    <sys/stat.h>
+#include	<stdio.h>
+#include	<signal.h>
+#include    <unistd.h>
+#include    <fcntl.h>
+#include	<errno.h>
 #include	"ourhdr.h"
 
 extern int	errno;
Index: nis/ypclients/ypbind/daemon.h
diff -u nis/ypclients/ypbind/daemon.h:1.1.1.1 nis/ypclients/ypbind/daemon.h:1.2
--- nis/ypclients/ypbind/daemon.h:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/daemon.h	Sat Jan 25 21:22:42 1997
@@ -1,5 +1,8 @@
 /* 
  * $Log: daemon.h,v $
+ * Revision 1.1.1.1  1997/01/23 20:48:30  hjl
+ * Import ypbind 3.0.
+ *
  * Revision 1.1  1995/07/25 14:27:37  swen
  * ypbind version 2.0.
  *
Index: nis/ypclients/ypbind/patchlevel.h
diff -u nis/ypclients/ypbind/patchlevel.h:1.1.1.1 nis/ypclients/ypbind/patchlevel.h:1.2
--- nis/ypclients/ypbind/patchlevel.h:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/patchlevel.h	Sat Jan 25 21:22:42 1997
@@ -1 +1 @@
-#define YPBIND_VERSION "2.1"
+#define YPBIND_VERSION "3.0"
Index: nis/ypclients/ypbind/readn.c
diff -u nis/ypclients/ypbind/readn.c:1.1.1.1 nis/ypclients/ypbind/readn.c:1.2
--- nis/ypclients/ypbind/readn.c:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/readn.c	Sat Jan 25 21:22:42 1997
@@ -3,8 +3,8 @@
 ssize_t						/* Read "n" bytes from a descriptor. */
 readn(int fd, void *vptr, size_t n)
 {
-	ssize_t	nleft;
-	size_t	nread;
+	size_t	nleft;
+	ssize_t	nread;
 	char	*ptr;
 
 	ptr = vptr;
Index: nis/ypclients/ypbind/slave.c
diff -u nis/ypclients/ypbind/slave.c:1.1.1.1 nis/ypclients/ypbind/slave.c:1.2
--- nis/ypclients/ypbind/slave.c:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/slave.c	Sat Jan 25 21:22:42 1997
@@ -25,27 +25,27 @@
 #include <rpc/pmap_clnt.h> /* for pmap_unset */
 #include "ourhdr.h"
 #include "ypbind.h"
-#if USE_IPC
 #include <sys/ipc.h>
 #include <sys/sem.h>
 #include <sys/shm.h>
-#endif
 
+#if 0
 extern int putenv(const char *);
+#endif
 
 extern SVCXPRT *udptransp;
 extern domainname mydomain;
 extern int broken_server;
-extern int debug;
+extern int debug, use_ipc, use_mmap;
 extern char **Argv;
 extern int Argc;
 
+extern CLIENT * clntudp_create(struct sockaddr_in *, u_long, u_long,
+                               struct timeval, int *);
+
 struct binding *ypbindlist;
-#if USE_IPC
 int semid = -1;
-#else
 int lockfd;
-#endif
 domainname askdomain;
 volatile int hangup;
 
@@ -72,17 +72,17 @@
   if (0 != sigaction(SIGHUP, &sact, NULL))
     log_ret("Could not install signal handler for SIGHUP");
   
-  for(;;)
-  {
-    hangup = 0;
-    init_binding();
-  
-    for(;!hangup;)
-      {
-        check_binding();
-        sleep(PING_INTERVAL);
-      }
-  }
+  for (;;)
+    {
+      hangup = 0;
+      init_binding();
+      
+      while (!hangup)
+        {
+          check_binding();
+          sleep(PING_INTERVAL);
+        }
+    }
 }
 
 void
@@ -91,20 +91,23 @@
   struct binding ypdb;
 
   write_lock_binding();
-  bzero(ypbindlist, sizeof(struct binding) * _MAXDOMAIN);
-#if !MMAP_SHARED_OK
-  lseek(lockfd, 0, SEEK_SET);
-  writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN);
-#endif
+  memset(ypbindlist, 0, sizeof(struct binding) * _MAXDOMAIN);
+  if (!use_mmap)
+    {
+      lseek(lockfd, 0, SEEK_SET);
+      if (writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN) <= 0)
+        log_sys("cannot write ypbindlist");
+    }
   un_lock_write_binding();
 
   memset((void *)&ypdb, 0, sizeof(struct binding));
   strncpy(ypdb.domain, mydomain, YPMAXDOMAIN);
   ypdb.is_bound = TRUE; /* always bind to our NIS domain */
+  ypdb.active = 0;
   ypdb.lockfd = -1;
-  ypdb.client_handle = NULL;
+  ypdb.server[0].client_handle = NULL;
   ypdb.is_alive = FALSE;
-  ypdb.use_broadcast = TRUE; /* default is using broadcast */
+  ypdb.server[0].use_broadcast = TRUE; /* default is using broadcast */
   update_entry(&ypdb);
   parse_config_file(_PATH_YPCONF);
   return;
@@ -115,8 +118,8 @@
 {
   struct binding ypdb;
   time_t t;
-  int i;
-
+  int i, j;
+  
   time(&t);
   for (i = 0; i < _MAXDOMAIN; i++)
     {
@@ -125,28 +128,40 @@
       un_lock_read_binding();
       if (ypdb.is_bound)
         {
-          if (ypdb.is_alive && ypdb.next_check > t)
+          if (ypdb.is_alive)
             {
-              if (debug)
-                  log_msg("pinging server %s, port %d",
-                          inet_ntoa(ypdb.server_addr),
-                          ntohs(ypdb.server_port));
-              ping_server(&ypdb);
+              int active;
+              for (j = 0; j < _MAXSERVER; j++)
+                {
+                  active = (ypdb.active + j) % _MAXSERVER;
+                  if (!ypdb.server[active].filled) continue;
+                  if (debug)
+                    log_msg("pinging server %s, port %d",
+                            inet_ntoa(ypdb.server[active].server_addr),
+                            ntohs(ypdb.server[active].server_port));
+                  ypdb.is_alive = FALSE;
+                  ping_server(&ypdb, active);
+                  if (ypdb.is_alive) break;
+                }
+              if (active != ypdb.active && ypdb.server[active].filled)
+                {
+                  ypdb.active=active;
+                  update_entry(&ypdb); 
+                }
             }
-          
-          if (!ypdb.is_alive || ypdb.next_check <= t)
+          if (!ypdb.is_alive)
             {
-              if (ypdb.use_broadcast)
+              if (ypdb.server[ypdb.active].use_broadcast)
                 {
                   if (debug)
-                      log_msg("broadcasting for domain %s", ypdb.domain);
+                    log_msg("broadcasting for domain %s", ypdb.domain);
                   broadcast(&ypdb);
                 }
               else
                 {
                   if (debug)
-                    log_msg("rebinding to server %s", ypdb.host->h_name);
-                  bindto_server(ypdb.domain, ypdb.host);
+                    log_msg("binding to server %s", ypdb.server[ypdb.active].host);
+                  bindto_server(ypdb.domain, ypdb.server[ypdb.active].host);
                 }
               continue;
             }
@@ -155,7 +170,8 @@
 }
 
 void
-add_server(char *dom, struct sockaddr_in *raddrp, CLIENT *clnt_handlep, struct hostent *host, bool_t use_broadcast)
+add_server(char *dom, struct sockaddr_in *raddrp, CLIENT *clnt_handlep,
+           const char *host, bool_t use_broadcast)
 {
   struct binding entry;
 #if USE_BINDINGDIR
@@ -163,19 +179,33 @@
   struct ypbind_resp ybr;
   pid_t lockpid;
   char path[MAXPATHLEN];
-  int fd, len, status;
+  int fd, len, status, active;
 #endif
   
   if (NULL == dom || (0 != get_entry(dom, &entry)))
     return;
-  
+
   if (!entry.is_bound)
     {
-      strncpy(entry.domain, dom, YPMAXDOMAIN);
+      entry.active = 0;
       entry.lockfd = -1;
-      entry.client_handle = NULL;
-      entry.is_bound = TRUE;
+      memset((void *)&entry.server, 0, sizeof(struct bound_server));
+      entry.is_alive = FALSE;
     }
+
+  /* find empty slot */
+  for (active = 0; active < _MAXSERVER; active++)
+
+    if (!entry.server[active].filled) break;
+  
+  active = active % _MAXSERVER;
+  if (use_broadcast) active =  _MAXSERVER - 1;
+
+  if (debug)
+    log_msg("add_server() domain: %s, host: %s, %sbroadcast, slot: %d",
+            dom, host ? host : "unknown", use_broadcast ? "" : "no",
+            active);
+  
   if (NULL != raddrp)
     {
       if (!broken_server &&
@@ -185,18 +215,23 @@
 	  log_msg("Answer from %s on illegal port", inet_ntoa(raddrp->sin_addr));
 	  return;
 	}
-      memcpy(&entry.server_addr, &raddrp->sin_addr, sizeof entry.server_addr);
-      entry.server_port = raddrp->sin_port;
+      memcpy(&entry.server[active].server_addr, &raddrp->sin_addr,
+             sizeof entry.server[active].server_addr);
+      entry.server[active].server_port = raddrp->sin_port;
       entry.is_alive = TRUE;
     }
-  if (NULL != entry.client_handle)
-    clnt_destroy(entry.client_handle);
-  entry.client_handle = clnt_handlep;
+  if (NULL != entry.server[active].client_handle)
+    clnt_destroy(entry.server[active].client_handle);
+  entry.server[active].client_handle = clnt_handlep;
   if (NULL != host)
-    entry.host = host;
-  entry.next_check = time(NULL) + REBIND_INTERVAL;
-  entry.version = YPVERS;
-  entry.use_broadcast = use_broadcast;
+    {
+      if (entry.server[active].host) free(entry.server[active].host);
+      entry.server[active].host = strdup(host);
+    }
+  entry.server[active].version = YPVERS;
+  entry.server[active].use_broadcast = use_broadcast;
+  entry.server[active].filled = TRUE;
+  entry.active = active;
   
 #if USE_BINDINGDIR
   if (NULL != raddrp)
@@ -204,7 +239,7 @@
       if (-1 != entry.lockfd)
         close(entry.lockfd);
       sprintf(path, "%s/%s.%ld", BINDINGDIR,
-              entry.domain, entry.version);
+              entry.domain, entry.server[active].version);
       if ((fd = open(path, O_CREAT | O_RDWR | O_TRUNC, FILE_MODE )) == -1)
         {
           if (-1 == mkdir(BINDINGDIR, DIR_MODE))
@@ -222,10 +257,10 @@
         log_sys("set lock");
       
       
-          /*
-           * ok, if BINDINGDIR exists, and we can create the binding file, then
-           * write to it..
-           */
+      /*
+       * ok, if BINDINGDIR exists, and we can create the binding file, then
+       * write to it..
+       */
       entry.lockfd = fd;
       
       iov[0].iov_base = (caddr_t) &(udptransp->xp_port);
@@ -233,7 +268,7 @@
       iov[1].iov_base = (caddr_t) &ybr;
       iov[1].iov_len = sizeof ybr;
       
-      bzero(&ybr, sizeof ybr);
+      memset(&ybr, 0, sizeof ybr);
       ybr.ypbind_status = YPBIND_SUCC_VAL;
       ybr.ypbind_respbody.ypbind_bindinfo.ypbind_binding_addr = raddrp->sin_addr;
       ybr.ypbind_respbody.ypbind_bindinfo.ypbind_binding_port = raddrp->sin_port;
@@ -253,7 +288,7 @@
 }
 
 void
-bindto_server(char *ypdomain, struct hostent *host)
+bindto_server(char *ypdomain, char *server)
 {
   struct sockaddr_in server_addr;
   int sock;
@@ -263,10 +298,50 @@
   CLIENT *clnt_handlep = NULL;
   int i = 0;
   
+  struct hostent *host;
+  static char *order = NULL;
+  int result;
+
   if (debug)
-    log_msg("bindto_server: domain %s, host %s", ypdomain, host->h_name);
+    log_msg("bindto_server: domain %s, host %s", ypdomain, server);
+  
+  /*
+   * FIXME: gethostbyname may in turn ask ypbind (entry in 
+   * /etc/host.conf)!!! 
+   * so much for shooting yourself in the foot.
+   * Using RESOLV_SERV_ORDER is a kludge, should use gethostent()
+   */
+  
+  if (!order)
+    order = strdup("RESOLV_SERV_ORDER=hosts");
+  result = putenv(order);
+  if (0 != result)
+    log_ret("putenv failed");
+  host = gethostbyname(server);
+  if (NULL == host)
+    {
+      switch (h_errno)
+        {
+        case HOST_NOT_FOUND:
+          log_msg("Unknown host: %s", server);
+          break;
+        case TRY_AGAIN:
+          log_msg("Host name lookup failure");
+          break;
+        case NO_DATA:
+          log_msg("No address associated with name: %s", server);
+          break;
+        case NO_RECOVERY:
+          log_msg("Unknown server error");
+          break;
+        default:
+          log_ret("gethostbyname: Unknown error");
+          break;
+        }
+      return;
+    }
   
-  bzero((char *)&server_addr, sizeof server_addr);
+  memset((char *)&server_addr, 0, sizeof server_addr);
   server_addr.sin_family = host->h_addrtype;
   server_addr.sin_port = htons(0);
   sock = RPC_ANYSOCK;
@@ -280,10 +355,10 @@
       clnt_handlep = clntudp_create(&server_addr, YPPROG, YPVERS,
                                     timeout, &sock);
       if (NULL != clnt_handlep)
-          break;
+        break;
       i++;
     }
-
+  
   if (NULL == clnt_handlep)
     {
       log_msg("clnt_create for server %s failed", host->h_name);
@@ -293,7 +368,7 @@
   timeout.tv_sec = 5;
   timeout.tv_usec = 0;
   status = clnt_call(clnt_handlep, YPPROC_DOMAIN,
-                     (xdrproc_t) xdr_domainname, ypdomain,
+                     (xdrproc_t) xdr_domainname, &ypdomain,
                      (xdrproc_t) xdr_bool, &out,
                      timeout);
   if (RPC_SUCCESS != status)
@@ -307,37 +382,41 @@
       clnt_destroy(clnt_handlep);
     }
   else
-    add_server(ypdomain, &server_addr, clnt_handlep, host, FALSE);
-
+    add_server(ypdomain, &server_addr, clnt_handlep, host->h_name, FALSE);
+  
   return;
 }
 
 void
-ping_server(struct binding *ypdb)
+ping_server(struct binding *ypdb, int active)
 {
   int status;
+  bool_t out;
   struct timeval timeout;
-  char *nothing;
   
-  if (NULL != ypdb->client_handle)
+  if (NULL != ypdb->server[active].client_handle)
     {
-      bzero((char *)&nothing, sizeof nothing);
+      char *domainname = ypdb->domain;
       timeout.tv_sec = 2;
       timeout.tv_usec = 0;
-      status = clnt_call(ypdb->client_handle, YPPROC_NULL,
-                         (xdrproc_t) xdr_void, nothing,
-                         (xdrproc_t) xdr_void, &nothing,
+      status = clnt_call(ypdb->server[active].client_handle, YPPROC_DOMAIN,
+                         (xdrproc_t) xdr_domainname, &domainname,
+                         (xdrproc_t) xdr_bool, &out,
                          timeout);
       
-      if (RPC_SUCCESS != status)
+      if ((RPC_SUCCESS != status) || (TRUE != out))
         {
-          log_msg(clnt_sperror(ypdb->client_handle, ypdb->host->h_name));
-	  clnt_destroy(ypdb->client_handle);
-          ypdb->client_handle = NULL;
+          RPC_SUCCESS != status
+	    ? log_msg(clnt_sperror(ypdb->server[active].client_handle,
+	                           ypdb->server[active].host ? ypdb->server[active].host : "unknown"))
+            : log_msg("domain %s not served by %s",
+                      ypdb->domain, ypdb->server[active].host ? ypdb->server[active].host : "unknown") ;
+          clnt_destroy(ypdb->server[active].client_handle);
+          ypdb->server[active].client_handle = NULL;
           ypdb->is_alive = FALSE;
-          ypdb->next_check = time(NULL);
-          update_entry(ypdb);
         }
+      else
+        ypdb->is_alive=TRUE;
     }
   return;
 }
@@ -384,7 +463,7 @@
       /* update global variable for eachresult */
   askdomain = ypdb->domain;
   status = clnt_broadcast(YPPROG, YPVERS, YPPROC_DOMAIN_NONACK,
-                          (xdrproc_t) xdr_domainname, askdomain,
+                          (xdrproc_t) xdr_domainname, (void *) &askdomain,
                           (xdrproc_t) xdr_bool, (void *)&out,
                           (resultproc_t) eachresult);
   if (RPC_SUCCESS != status)
@@ -395,7 +474,7 @@
           close(ypdb->lockfd);
           ypdb->lockfd = -1;
           sprintf(path, "%s/%s.%ld", BINDINGDIR,
-                  ypdb->domain, ypdb->version);
+                  ypdb->domain, ypdb->server[ypdb->active].version);
           unlink(path);
         }
 #endif
@@ -443,7 +522,7 @@
         {
           if (debug)
             log_msg("parsed domain %s server %s", tmpdomain, tmpserver);
-          check_config_entry(tmpdomain, tmpserver);
+          bindto_server(tmpdomain, tmpserver);
           continue;
         }
       count = sscanf(cp, "domain %s broadcast", tmpdomain);
@@ -459,7 +538,7 @@
         {
           if (debug)
             log_msg("parsed ypserver %s", tmpserver);
-          check_config_entry(mydomain, tmpserver);
+          bindto_server(mydomain, tmpserver);
           continue;
         }
     }
@@ -468,114 +547,75 @@
 }
 
 void
-check_config_entry(char *ypdomain, const char *ypserver)
-{
-  struct hostent *host;
-  static char *order = NULL;
-  int result;
-
-      /*
-       * FIXME: gethostbyname may in turn ask ypbind (entry in 
-       * /etc/host.conf)!!! 
-       * so much for shooting yourself in the foot.
-       * Using RESOLV_SERV_ORDER is a kludge, should use gethostent()
-       */
-
-  if (!order)
-    order = strdup("RESOLV_SERV_ORDER=hosts");
-  result = putenv(order);
-  if (0 != result)
-    log_ret("putenv failed");
-  if (debug)
-    log_msg("getenv: %s", getenv("RESOLV_SERV_ORDER"));
-  host = gethostbyname(ypserver);
-  if (NULL == host)
-    {
-      switch (h_errno)
-        {
-        case HOST_NOT_FOUND:
-          log_msg("Unknown host: %s", ypserver);
-          break;
-        case TRY_AGAIN:
-          log_msg("Host name lookup failure");
-          break;
-        case NO_DATA:
-          log_msg("No address associated with name: %s", ypserver);
-          break;
-        case NO_RECOVERY:
-          log_msg("Unknown server error");
-          break;
-        default:
-          log_ret("gethostbyname: Unknown error");
-          break;
-        }
-    }
-  else
-    bindto_server(ypdomain, host);
-
-  return;
-}
-
-void
 init_master_slave_communication(void)
 {
-#if USE_IPC
   int shmid;
   struct shmid_ds dummy;
-  ushort empty[2] = {0,0};
-
-  if ((semid = semget(IPC_PRIVATE, 2, IPC_CREAT|SHM_R|SHM_W)) < 0)
-    log_sys("cannot create semaphore");
-
-
-  if ((shmid = shmget(IPC_PRIVATE, 
-                      sizeof(struct binding) * _MAXDOMAIN,
-                      IPC_CREAT|SHM_R|SHM_W)) < 0)
-    log_sys("cannot create shared memory segment");
-
-  ypbindlist = (struct binding *)shmat(shmid, NULL, 0);
-
-  /* mark it for deletion just in case we are not able to
-     handle it on our own. handles case of failed attachment
-     as well */
-  (void)shmctl(shmid, IPC_RMID, &dummy);  
-
-  if (!ypbindlist)
-    log_sys("cannot attach to shared memory segment");
-
-  memset(ypbindlist, 0, sizeof(struct binding) * _MAXDOMAIN);
-
-  semctl(semid, 0, SETALL, empty);
+  ushort empty [2] = {0,0};
+  union semun semarg;
 
-#else
-
-  lockfd = open_lockfile();
-#if MMAP_SHARED_OK  
-  ypbindlist = (struct binding *) mmap(0, sizeof(struct binding) * _MAXDOMAIN,
-                                       (PROT_READ | PROT_WRITE), 
+  if (use_ipc)
+    {
+      if ((semid = semget(IPC_PRIVATE, 2, IPC_CREAT|SHM_R|SHM_W)) < 0)
+        log_sys("cannot create semaphore");
+      
+      
+      if ((shmid = shmget(IPC_PRIVATE, 
+                          sizeof(struct binding) * _MAXDOMAIN,
+                          IPC_CREAT|SHM_R|SHM_W)) < 0)
+        log_sys("cannot create shared memory segment");
+      
+      ypbindlist = (struct binding *)shmat(shmid, NULL, 0);
+      
+      /* mark it for deletion just in case we are not able to
+         handle it on our own. handles case of failed attachment
+         as well */
+      (void)shmctl(shmid, IPC_RMID, &dummy);  
+      
+      if (!ypbindlist)
+        log_sys("cannot attach to shared memory segment");
+      
+      memset(ypbindlist, 0, sizeof(struct binding) * _MAXDOMAIN);
+      
+      semarg.array = empty;
+      semctl(semid, 0, SETALL, semarg);
+    }
+  else
+    {
+      lockfd = open_lockfile();
+      if (use_mmap)
+        {
+          ypbindlist = (struct binding *) mmap(0,
+                                               sizeof(struct binding) * _MAXDOMAIN,
+                                               (PROT_READ | PROT_WRITE), 
 #if MMAP_SHARED_ANON_OK
-                                       (MAP_ANON | MAP_SHARED), -1, 0);
+                                               (MAP_ANON | MAP_SHARED), -1,
 #else  
-                                       MAP_SHARED, lockfd, 0);
+                                               MAP_SHARED, lockfd,
 #endif /* MMAP_SHARED_ANON_OK */
-  if ((caddr_t) -1 == (caddr_t) ypbindlist)
-    log_sys("cannot create shared region");
-#else
-  ypbindlist = (struct binding *) calloc(_MAXDOMAIN, sizeof(struct binding));
-  if (NULL == ypbindlist)
-    log_sys("cannot create shared region");
-  writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN);
-#endif /* MMAP_SHARED_OK */
-#endif
+                                               0);
+          if ((caddr_t) -1 == (caddr_t) ypbindlist)
+            log_sys("cannot create shared region");
+        }
+      else
+        {
+          ypbindlist = (struct binding *) calloc(_MAXDOMAIN, sizeof(struct binding));
+          if (NULL == ypbindlist)
+            log_sys("cannot create shared region");
+          if (writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN) <= 0)
+            log_sys("cannot write shared region");
+        }
+    }
 }
 
-#if USE_IPC
 void
 terminate_master_slave_communication(void)
 {
   if(semid != -1)
   {
-    (void)semctl(semid, 0, IPC_RMID, NULL);
+    union semun dummy;
+
+    (void)semctl(semid, 0, IPC_RMID, dummy);
     semid = -1;
   }
 }
@@ -586,92 +626,134 @@
 read_lock_binding(void)
 {
   struct sembuf sops[2];
-  int i;
-
-  sops[0].sem_num = 1; /* check if write semaphore is clear */
-  sops[0].sem_op = 0;
-  sops[0].sem_flg = IPC_NOWAIT;
-  sops[1].sem_num = 0; /* then signal reading */
-  sops[1].sem_op = 1;
-  sops[1].sem_flg = SEM_UNDO|IPC_NOWAIT;
-
-  for(i=0; i<IPC_LOCK_RETRY; i++)
-  {
-    if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
-      break;
-    sleep(1);
-  }
-  if(i==IPC_LOCK_RETRY)
-    log_sys("cannot create read lock");
+  int i, status;
+  
+  if (use_ipc)
+    {
+      sops[0].sem_num = 1; /* check if write semaphore is clear */
+      sops[0].sem_op = 0;
+      sops[0].sem_flg = IPC_NOWAIT;
+      sops[1].sem_num = 0; /* then signal reading */
+      sops[1].sem_op = 1;
+      sops[1].sem_flg = SEM_UNDO|IPC_NOWAIT;
+      
+      for(i=0; i<IPC_LOCK_RETRY; i++)
+        {
+          if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
+            break;
+          sleep(1);
+        }
+      if(i==IPC_LOCK_RETRY)
+        log_sys("cannot create read lock");
+    }
+  else
+    {
+      status = lock_reg(lockfd, F_SETLKW, F_RDLCK, 0, SEEK_SET, 0);
+      if (0 != status) 
+        log_sys("set read lock");
+      if (!use_mmap)
+        {
+          lseek(lockfd, 0, SEEK_SET);
+          if (readn(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN) < 0)
+            log_sys("cannot read ypbindlist");
+        }
+    }
+  return;
 }
 
 void 
 write_lock_binding(void)
 {
   struct sembuf sops[3];
-  int i;
-
-  sops[0].sem_num = 0; /* check if read semaphore is clear */
-  sops[0].sem_op = 0;
-  sops[0].sem_flg = IPC_NOWAIT;
-  sops[1].sem_num = 1; /* check if write semaphore is clear */
-  sops[1].sem_op = 0;
-  sops[1].sem_flg = IPC_NOWAIT;
-  sops[2].sem_num = 1; /* then signal writing */
-  sops[2].sem_op = 1;
-  sops[2].sem_flg = SEM_UNDO|IPC_NOWAIT;
-
-  for(i=0; i<IPC_LOCK_RETRY; i++)
-  {
-    if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
-      break;
-    sleep(1);
-  }
-  if(i==IPC_LOCK_RETRY)
-    log_sys("cannot create write lock");
+  int i, status;
+      
+  if (use_ipc)
+    {
+      sops[0].sem_num = 0; /* check if read semaphore is clear */
+      sops[0].sem_op = 0;
+      sops[0].sem_flg = IPC_NOWAIT;
+      sops[1].sem_num = 1; /* check if write semaphore is clear */
+      sops[1].sem_op = 0;
+      sops[1].sem_flg = IPC_NOWAIT;
+      sops[2].sem_num = 1; /* then signal writing */
+      sops[2].sem_op = 1;
+      sops[2].sem_flg = SEM_UNDO|IPC_NOWAIT;
+      
+      for(i=0; i<IPC_LOCK_RETRY; i++)
+        {
+          if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
+            break;
+          sleep(1);
+        }
+      if(i==IPC_LOCK_RETRY)
+        log_sys("cannot create write lock");
+    }
+  else
+    {
+      status = lock_reg(lockfd, F_SETLKW, F_WRLCK, 0, SEEK_SET, 0); 
+      if (0 != status) 
+        log_sys("set write lock");
+    }
+  return;
 }
 
-void 
+
+void
 un_lock_read_binding(void)
 {
   struct sembuf sops[1];
   int i;
-
-  sops[0].sem_num = 0; /* clear read semaphore */
-  sops[0].sem_op = -1;
-  sops[0].sem_flg = SEM_UNDO|IPC_NOWAIT;
-
-  for(i=0; i<IPC_LOCK_RETRY; i++)
-  {
-    if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
-      break;
-    sleep(1);
-  }
-  if(i==IPC_LOCK_RETRY)
-    log_sys("error unlocking");
+  
+  if (use_ipc)
+    {
+      sops[0].sem_num = 0; /* clear read semaphore */
+      sops[0].sem_op = -1;
+      sops[0].sem_flg = SEM_UNDO|IPC_NOWAIT;
+      
+      for(i=0; i<IPC_LOCK_RETRY; i++)
+        {
+          if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
+            break;
+          sleep(1);
+        }
+      if(i==IPC_LOCK_RETRY)
+        log_sys("error unlocking");
+    }
+  else
+    un_lock_write_binding();
+  return;
 }
 
 void 
 un_lock_write_binding(void)
 {
   struct sembuf sops[1];
-  int i;
-
-  sops[0].sem_num = 1; /* clear write semaphore */
-  sops[0].sem_op = -1;
-  sops[0].sem_flg = SEM_UNDO|IPC_NOWAIT;
-
-  for(i=0; i<IPC_LOCK_RETRY; i++)
-  {
-    if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
-      break;
-    sleep(1);
-  }
-  if(i==IPC_LOCK_RETRY)
-    log_sys("error unlocking");
+  int i, status;
+  
+  if (use_ipc)
+    {
+      sops[0].sem_num = 1; /* clear write semaphore */
+      sops[0].sem_op = -1;
+      sops[0].sem_flg = SEM_UNDO|IPC_NOWAIT;
+      
+      for(i=0; i<IPC_LOCK_RETRY; i++)
+        {
+          if (!semop(semid, sops, sizeof(sops)/sizeof(struct sembuf)))
+            break;
+          sleep(1);
+        }
+      if(i==IPC_LOCK_RETRY)
+        log_sys("error unlocking");
+    }
+  else
+    {
+      status = lock_reg(lockfd, F_SETLKW, F_UNLCK, 0, SEEK_SET, 0);
+      if (0 != status)
+        log_sys("unlock");
+    }
+  return;
 }
 
-#else
 
 int
 open_lockfile(void)
@@ -696,50 +778,6 @@
   return fd;
 }
 
-void 
-read_lock_binding(void)
-{
-  int status;
-
-  status = lock_reg(lockfd, F_SETLKW, F_RDLCK, 0, SEEK_SET, 0);
-  if (0 != status) 
-    log_sys("set read lock");
-#if !MMAP_SHARED_OK
-  lseek(lockfd, 0, SEEK_SET);
-  readn(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN);
-#endif
-  return;
-}
-
-void
-write_lock_binding(void)
-{
-  int status;
-
-  status = lock_reg(lockfd, F_SETLKW, F_WRLCK, 0, SEEK_SET, 0); 
-  if (0 != status) 
-    log_sys("set write lock");
-  return;
-}
-
-void 
-un_lock_read_binding(void)
-{
-  un_lock_write_binding();
-}
-
-void 
-un_lock_write_binding(void)
-{
-  int status;
-  
-  status = lock_reg(lockfd, F_SETLKW, F_UNLCK, 0, SEEK_SET, 0);
-  if (0 != status)
-    log_sys("unlock");
-  return;
-}
-#endif
-
 int
 get_entry(char *dom, struct binding *entry)
 {
@@ -765,15 +803,18 @@
     return;
   write_lock_binding();
   memcpy(ypdb, entry, sizeof (struct binding));
-#if !MMAP_SHARED_OK  
-  lseek(lockfd, 0, SEEK_SET);
-  writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN);
-#endif
+  if (!use_mmap)
+    {
+      lseek(lockfd, 0, SEEK_SET);
+      if (writen(lockfd, ypbindlist, sizeof(struct binding) * _MAXDOMAIN) <= 0)
+        log_sys("cannot write ypbindlist");
+    }
   un_lock_write_binding();
   if (debug)
     log_msg("%s entry for domain %s: server %s, port %d",
             entry->is_alive ? "updated" : "cleared", entry->domain,
-            inet_ntoa(entry->server_addr), ntohs(entry->server_port));
+            inet_ntoa(entry->server[entry->active].server_addr),
+            ntohs(entry->server[entry->active].server_port));
   return;
 }
 
Index: nis/ypclients/ypbind/ypbind.c
diff -u nis/ypclients/ypbind/ypbind.c:1.1.1.1 nis/ypclients/ypbind/ypbind.c:1.2
--- nis/ypclients/ypbind/ypbind.c:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/ypbind.c	Sat Jan 25 21:22:42 1997
@@ -1,5 +1,11 @@
 /* 
  * $Log: ypbind.c,v $
+ * Revision 1.1.1.1  1997/01/23 20:48:30  hjl
+ * Import ypbind 3.0.
+ *
+ * Revision 1.5  1996/10/08 09:55:11  swen
+ * Made ipc and mmap runtime options. Updated for release 3.0
+ *
  * Revision 1.4  1995/11/15 10:06:25  swen
  * Added SYSV-IPC (from Michael Rausch <mrausch@ernie.mi.uni-koeln.de>)
  * Make mmap (not MAP_ANON) work again with latest kernels.
@@ -19,7 +25,7 @@
  *
  */
 
-static char rcsid[] = "$Id: ypbind.c,v 1.4 1995/11/15 10:06:25 swen Exp $" ;
+static char rcsid[] = "$Id: ypbind.c,v 1.1.1.1 1997/01/23 20:48:30 hjl Exp $" ;
 
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -45,39 +51,49 @@
 #include <arpa/inet.h>
 #include <rpcsvc/yp_prot.h>
 #include <rpcsvc/ypclnt.h>
+#ifdef __sun__
+#include <rpc/svc_soc.h>
+#endif
 #include <rpc/pmap_clnt.h> /* for pmap_unset */
 #include "ourhdr.h"
 #include "ypbind.h"
 #include "patchlevel.h"
 
+extern SVCXPRT * svcudp_create(int);
+extern SVCXPRT * svctcp_create(int, u_int, u_int);
+#if 0
+extern svc_register(SVCXPRT *, u_long, u_long,
+                    void (*)(struct svc_req *, SVCXPRT *), u_long);
+#endif
+
 char **Argv = NULL;
 int Argc = 0;
 
 extern int use_broadcast;
 SVCXPRT *udptransp, *tcptransp;
-domainname mydomain;
+domainname mydomain = NULL;
 int ypsetmode = YPSET_NO;
 pid_t childpid;
-int broken_server;
+int broken_server, use_ipc, use_mmap;
 volatile int debug;
 
 void *
-ypbindproc_null_2_svc(struct svc_req *rqstp)
+ypbindproc_null_2_svc(void *argp, struct svc_req *rqstp)
 {
   static char * result;
-  bzero((char *)&result, sizeof(result));
+  memset((char *)&result, 0, sizeof(result));
   return((void *) &result);
 }
 
 struct ypbind_resp *
-ypbindproc_domain_2_svc(domainname arg1, struct svc_req *rqstp)
+ypbindproc_domain_2_svc(domainname *arg1, struct svc_req *rqstp)
 {
   static struct ypbind_resp  result;
   struct binding *ypdb;
   
-  bzero((char *) &result, sizeof(result));
+  memset((char *) &result, 0, sizeof(result));
   result.ypbind_status = YPBIND_FAIL_VAL;
-  ypdb = find_entry(arg1);
+  ypdb = find_entry(*arg1);
   
   read_lock_binding();
 
@@ -90,12 +106,14 @@
     {
       result.ypbind_status = YPBIND_SUCC_VAL;
       memcpy(&result.ypbind_respbody.ypbind_bindinfo.ypbind_binding_addr.s_addr,
-             &ypdb->server_addr, sizeof ypdb->server_addr);
+             &ypdb->server[ypdb->active].server_addr,
+             sizeof ypdb->server[ypdb->active].server_addr);
       result.ypbind_respbody.ypbind_bindinfo.ypbind_binding_port =
-        ypdb->server_port;
+        ypdb->server[ypdb->active].server_port;
       if (debug)
-          log_msg("YPBINDPROC_DOMAIN_2: server %s, port %d",
-                  inet_ntoa(ypdb->server_addr), ntohs(ypdb->server_port));
+        log_msg("YPBINDPROC_DOMAIN_2: server %s, port %d",
+                inet_ntoa(ypdb->server[ypdb->active].server_addr),
+                ntohs(ypdb->server[ypdb->active].server_port));
     }
   
   un_lock_read_binding();
@@ -103,14 +121,18 @@
 }
 
 void *
-ypbindproc_setdom_2_svc(struct ypbind_setdom arg1, struct svc_req *rqstp)
+ypbindproc_setdom_2_svc(struct ypbind_setdom *arg1, struct svc_req *rqstp)
 {
   static char *result;
   struct sockaddr_in *fromsin, bindsin;
   
-  bzero((char *)&result, sizeof(result));
+#ifdef SOLARIS
+  fromsin = (rqstp->rq_xprt)->xp_raddr;
+#else
   fromsin = svc_getcaller(rqstp->rq_xprt);
+#endif
   
+  memset((char *)&result, 0, sizeof(result));
   switch (ypsetmode)
     {
     case YPSET_LOCAL:
@@ -127,24 +149,24 @@
   if (ntohs(fromsin->sin_port) >= IPPORT_RESERVED)
     return (void *) &result;
   
-  if (YPVERS != arg1.ypsetdom_vers)
+  if (YPVERS != arg1->ypsetdom_vers)
     return (void *) &result;
-  bzero((char *) &bindsin, sizeof bindsin);
+  memset((char *) &bindsin, 0, sizeof bindsin);
   bindsin.sin_family = AF_INET;
-  bindsin.sin_addr.s_addr = arg1.ypsetdom_addr.s_addr;
-  bindsin.sin_port = arg1.ypsetdom_port;
-  add_server(arg1.ypsetdom_domain, &bindsin, NULL, NULL, 1);
+  bindsin.sin_addr.s_addr = arg1->ypsetdom_addr.s_addr;
+  bindsin.sin_port = arg1->ypsetdom_port;
+  add_server(arg1->ypsetdom_domain, &bindsin, NULL, NULL, 1);
   return((void *) &result);
 }
 
 void *
 _ypbindproc_null_2(void  *argp, struct svc_req *rqstp)
 {
-  return (ypbindproc_null_2_svc(rqstp));
+  return (ypbindproc_null_2_svc(argp, rqstp));
 }
 
 struct ypbind_resp *
-_ypbindproc_domain_2(domainname argp, struct svc_req *rqstp)
+_ypbindproc_domain_2(domainname *argp, struct svc_req *rqstp)
 {
   return (ypbindproc_domain_2_svc(argp, rqstp));
 }
@@ -152,7 +174,7 @@
 void *
 _ypbindproc_setdom_2(struct ypbind_setdom  *argp, struct svc_req *rqstp)
 {
-  return (ypbindproc_setdom_2_svc(*argp, rqstp));
+  return (ypbindproc_setdom_2_svc(argp, rqstp));
 }
 
 void
@@ -206,7 +228,7 @@
       svcerr_noproc(transp);
       return;
     }
-  bzero((char *)&argument, sizeof (argument));
+  memset((char *)&argument, 0, sizeof (argument));
   if (!svc_getargs(transp, xdr_argument, (caddr_t) &argument))
     {
       svcerr_decode(transp);
@@ -232,8 +254,7 @@
   Argv = argv;
   Argc = argc;
 
-  debug = 0;
-  broken_server = 0;
+  debug = broken_server = use_ipc = use_mmap = 0;
 
   for (i = 1; i < argc; i++)
     {
@@ -248,13 +269,17 @@
         ypsetmode = YPSET_LOCAL;
       else if (0 == strcmp("-debug", argv[i]))
         debug = 1;
+      else if (0 == strcmp("-ipc", argv[i]))
+        use_ipc = 1;
+      else if (0 == strcmp("-mmap", argv[i]))
+        use_mmap = 1;
       else if (0 == strcmp("-broken_server", argv[i]))
         broken_server = 1;
     }
 
   log_open("ypbind", (LOG_PID | LOG_CONS), LOG_DAEMON);
   yp_get_default_domain(&mydomain);
-  if ('\0' == mydomain[0])
+  if (NULL == mydomain || '\0' == mydomain[0])
     log_quit("domainname not set. Aborting.\n");
   
   if (0 != getuid())
@@ -362,9 +387,8 @@
       if ( 0 != sigaction(sig, &sact, NULL))
         log_quit("Could not uninstall signal handler for signal %d.", sig);
       kill(childpid, sig);
-#if USE_IPC
-      terminate_master_slave_communication();
-#endif
+      if (use_ipc)
+        terminate_master_slave_communication();
       unlink(_PATH_YPPIDFILE);
       raise(sig);
       exit(0); /* just in case */
@@ -377,9 +401,8 @@
   unlink(_PATH_YPPIDFILE);
   if (0 != childpid)
     kill(childpid, SIGTERM);
-#if USE_IPC
-  terminate_master_slave_communication();
-#endif
+  if (use_ipc)
+    terminate_master_slave_communication();
   pmap_unset(YPBINDPROG, YPBINDVERS);
 }
 
@@ -388,6 +411,7 @@
 void
 inststr(char *dst[], int argc, const char *src)
 {
+#ifdef __linux__
   if (strlen(src) <= strlen(dst[0]))
     {
       char *ptr;
@@ -421,6 +445,7 @@
         }
       strncpy(dst[0], src, count);
     }
+#endif /* __linux__ */
 }
 
 void
@@ -439,6 +464,7 @@
   if (0 != write_lock(fd, 0, SEEK_SET, 0))
     log_sys("cannot lock pidfile");
   sprintf(pbuf, "%6d\n", getpid());
-  writen(fd, pbuf, strlen(pbuf));
+  if (writen(fd, pbuf, strlen(pbuf)) <= 0)
+    log_sys("cannot write pidfile");
   return;
 }
Index: nis/ypclients/ypbind/ypbind.h
diff -u nis/ypclients/ypbind/ypbind.h:1.1.1.1 nis/ypclients/ypbind/ypbind.h:1.3
--- nis/ypclients/ypbind/ypbind.h:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/ypbind.h	Mon Jan 27 07:48:47 1997
@@ -1,5 +1,11 @@
 /*
  * $Log: ypbind.h,v $
+ * Revision 1.1.1.1  1997/01/23 20:48:30  hjl
+ * Import ypbind 3.0.
+ *
+ * Revision 1.3  1996/10/08 09:58:31  swen
+ * Updated for release 3.0
+ *
  * Revision 1.2  1995/11/15 10:06:31  swen
  * Added SYSV-IPC (from Michael Rausch <mrausch@ernie.mi.uni-koeln.de>)
  * Make mmap (not MAP_ANON) work again with latest kernels.
@@ -19,54 +25,54 @@
 #ifndef _PATH_YPCONF
 #define _PATH_YPCONF "/etc/yp.conf"
 #endif
+#ifndef _PATH_VARRUN
+#ifdef SOLARIS
+#define _PATH_VARRUN "/var/yp/binding/"
+#else
+#define _PATH_VARRUN "/var/run/"
+#endif
+#endif
 #define _PATH_YPPIDFILE _PATH_VARRUN"ypbind.pid"
 #define _MAXDOMAIN  8
-#define REBIND_INTERVAL 1800 /* rebind every 30 minutes */
-#define PING_INTERVAL     60 /* check binding every minute */
+#define _MAXSERVER  3
+#define PING_INTERVAL     10 /* check binding every 10 seconds */
 #define YPSET_NO	0
 #define YPSET_LOCAL	1
 #define YPSET_ALL	2
 
-#define USE_IPC 1		  /* use SysV IPC for sharing the bindings */
-
-#define MMAP_SHARED_OK 0          /* does shared mapping of files work? */
-                                  /* (it does in 1.3.12                 */
-#define MMAP_SHARED_ANON_OK 0     /* can we share anonymous regions? (not yet in 1.3.40) */
-
-#if USE_IPC
-#undef MMAP_SHARED_OK
-#define MMAP_SHARED_OK 1	  /* SysV IPC is handled the same way ... */
-#endif
+#define MMAP_SHARED_ANON_OK 0     /* can we share anonymous regions? (not yet in 2.0.21) */
 
-struct binding
+struct bound_server
 {
-  struct hostent *host;
+  char *host;
   struct in_addr server_addr;
-  long int version;
   unsigned short int server_port;
-  char domain[YPMAXDOMAIN];
-  int lockfd;
+  long int version;
+  bool_t use_broadcast;
   CLIENT *client_handle;
+  bool_t filled;
+};
+
+struct binding
+{
+  char domain[YPMAXDOMAIN];
   bool_t is_bound;
   bool_t is_alive;
-  bool_t use_broadcast;
-  time_t next_check;
+  int lockfd;
+  int active; /* index into server */
+  struct bound_server server[_MAXSERVER];
 };
 
 typedef char *domainname;
 
-extern void *ypbindproc_null_2_svc(struct svc_req *);
-extern struct ypbind_resp *ypbindproc_domain_2_svc(domainname, struct svc_req *);
-extern void *ypbindproc_setdom_2_svc(struct ypbind_setdom, struct svc_req *);
 extern struct ypservers *ypconf_read(const char *);
 
-extern bool_t xdr_domainname(XDR *, char *);
+extern bool_t xdr_domainname_ypbind(XDR *, char *);
 
 bool_t eachresult(bool_t *, struct sockaddr_in *);
 void parse_config_file(const char *);
-void check_config_entry(char *, const char *);
 void broadcast(struct binding *);
-void add_server(char *, struct sockaddr_in *, CLIENT *, struct hostent *, bool_t);
+void add_server(char *, struct sockaddr_in *, CLIENT *, const char *, bool_t);
 void sighandler(int);
 void toggle_debug(int);
 void handle_hangup(int);
@@ -76,8 +82,8 @@
 int open_lockfile(void);
 struct binding *find_entry(char *dom);
 pid_t start_slave (void);
-void bindto_server (char *, struct hostent *);
-void ping_server(struct binding *);
+void bindto_server (char *, char *);
+void ping_server(struct binding *, int);
 void write_lock_binding(void);
 void read_lock_binding(void);
 void un_lock_read_binding(void);
@@ -87,6 +93,4 @@
 void check_binding(void);
 void create_pidfile(void);
 void init_master_slave_communication(void);
-#if USE_IPC
 void terminate_master_slave_communication(void);
-#endif
Index: nis/ypclients/ypbind/ypbind.man
diff -u nis/ypclients/ypbind/ypbind.man:1.1.1.1 nis/ypclients/ypbind/ypbind.man:1.2
--- nis/ypclients/ypbind/ypbind.man:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypbind/ypbind.man	Sat Jan 25 21:22:43 1997
@@ -1,5 +1,5 @@
 .\" -*- nroff -*-
-.TH ypbind 8 "November 1995" "ypbind Version 2.2"
+.TH ypbind 8 "October 1996" "ypbind Version 3.0"
 .SH NAME
 ypbind - NIS binding process
 .SH SYNOPSIS
@@ -8,6 +8,10 @@
 [
 .B \-debug
 ] [
+.B \-ipc
+] [
+.B \-mmap
+] [
 .B \-broken_server
 ] [
 .B \-ypset
@@ -99,6 +103,18 @@
 .B ypbind
 will not put itself into background, and error messages and debug
 output are written to standard error.
+
+.IP \-ipc
+lets
+.B ypbind
+use IPC for the master-slave communication. It requires a kernel with IPC
+enabled. You must use this, if your root-Filesystem is on NFS.
+
+.IP \-mmap
+lets
+.B ypbind
+use mmap for the master-slave communication. This may fail with some older
+kernels.
 
 .IP \-broken_server
 lets
Index: nis/ypclients/ypcat/Makefile
diff -u nis/ypclients/ypcat/Makefile:1.1.1.1 nis/ypclients/ypcat/Makefile:1.2
--- nis/ypclients/ypcat/Makefile:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypcat/Makefile	Sat Jan 25 23:18:03 1997
@@ -2,8 +2,6 @@
 
 include ../Makerules
 
-LIBS=
-
 ifndef OPTFLAGS
 OPTFLAGS= -O2
 endif
Index: nis/ypclients/ypmatch/Makefile
diff -u nis/ypclients/ypmatch/Makefile:1.1.1.1 nis/ypclients/ypmatch/Makefile:1.2
--- nis/ypclients/ypmatch/Makefile:1.1.1.1	Thu Jan 23 16:20:20 1997
+++ nis/ypclients/ypmatch/Makefile	Sat Jan 25 23:18:04 1997
@@ -2,8 +2,6 @@
 
 include ../Makerules
 
-LIBS=
-
 ifndef OPTFLAGS
 OPTFLAGS= -O2
 endif
Index: nis/ypclients/yppasswd/Makefile
diff -u nis/ypclients/yppasswd/Makefile:1.1.1.1 nis/ypclients/yppasswd/Makefile:1.2
--- nis/ypclients/yppasswd/Makefile:1.1.1.1	Thu Jan 23 16:20:21 1997
+++ nis/ypclients/yppasswd/Makefile	Sat Jan 25 23:18:04 1997
@@ -17,7 +17,7 @@
 all: $(PROG)
 
 yppasswd: $(OBJS)
-	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(CRYPTLIB)
 
 clean:
 	$(RM) -f core *.o *.a *~ tmp_make foo $(PROG)
Index: nis/ypclients/yppoll/Makefile
diff -u nis/ypclients/yppoll/Makefile:1.1.1.1 nis/ypclients/yppoll/Makefile:1.2
--- nis/ypclients/yppoll/Makefile:1.1.1.1	Thu Jan 23 16:20:21 1997
+++ nis/ypclients/yppoll/Makefile	Sat Jan 25 23:18:04 1997
@@ -2,8 +2,6 @@
 
 include ../Makerules
 
-LIBS=
-
 ifndef OPTFLAGS
 OPTFLAGS= -O2
 endif
Index: nis/ypclients/ypset/Makefile
diff -u nis/ypclients/ypset/Makefile:1.1.1.1 nis/ypclients/ypset/Makefile:1.2
--- nis/ypclients/ypset/Makefile:1.1.1.1	Thu Jan 23 16:20:21 1997
+++ nis/ypclients/ypset/Makefile	Sat Jan 25 23:18:05 1997
@@ -2,8 +2,6 @@
 
 include ../Makerules
 
-LIBS=
-
 ifndef OPTFLAGS
 OPTFLAGS= -O2
 endif
Index: nis/ypclients/ypwhich/Makefile
diff -u nis/ypclients/ypwhich/Makefile:1.1.1.1 nis/ypclients/ypwhich/Makefile:1.3
--- nis/ypclients/ypwhich/Makefile:1.1.1.1	Thu Jan 23 16:20:21 1997
+++ nis/ypclients/ypwhich/Makefile	Sat Jan 25 23:18:05 1997
@@ -2,8 +2,6 @@
 
 include ../Makerules
 
-LIBS=
-
 ifndef OPTFLAGS
 OPTFLAGS= -O2
 endif
@@ -11,7 +9,7 @@
 CFLAGS = $(WFLAGS) $(OPTFLAGS) $(INC) $(XCFLAGS)
 INC= -I. -I..
 
-OBJS  =ypwhich.o xdrfix.o
+OBJS  =ypwhich.o #xdrfix.o
 PROG=ypwhich
 
 all: $(PROG)
Index: nis/ypclients/ypwhich/ypwhich.c
diff -u nis/ypclients/ypwhich/ypwhich.c:1.1.1.1 nis/ypclients/ypwhich/ypwhich.c:1.3
--- nis/ypclients/ypwhich/ypwhich.c:1.1.1.1	Thu Jan 23 16:20:21 1997
+++ nis/ypclients/ypwhich/ypwhich.c	Sun Jan 26 09:58:07 1997
@@ -112,7 +112,7 @@
   tv.tv_sec = 5;
   tv.tv_usec = 0;
   r = clnt_call(client, YPBINDPROC_DOMAIN,
-                (xdrproc_t)xdr_domainname, dom,
+                (xdrproc_t)xdr_domainname, &dom,
                 (xdrproc_t)xdr_ypbind_resp, &ypbr,
                 tv);
   if( r != RPC_SUCCESS)
@@ -276,7 +276,7 @@
   tv.tv_sec = 5;
   tv.tv_usec = 0;
   r = clnt_call(client, YPPROC_MAPLIST,
-		(xdrproc_t)xdr_domainname, domainname,
+		(xdrproc_t)xdr_domainname, &domainname,
 		(xdrproc_t)xdr_ypresp_maplist, &ypml,
 		tv);
 
