#! /bin/sh
#
# tiny news server
# implements only a subset of NNTP in a somewhat crude manner
# talk to the terminal 
# 
# copyright 1996 Egil Kvaleberg, egilk@sn.no
# the GNU General Public License applies
#

SPOOL="/var/spool/news"
NEWS="/usr/lib/news"

TMP="/tmp/tinynews.$$"
TMP2="/tmp/tinynews2.$$"
group=""
article=""
first=""
last=""

# arg1: article number
# arg2: ID of OK
show_article () {
    if article_ok "$1" ; then
	if stat_article "$1" $2; then
	    cat $1
	    echo "."
	else
	    echo 423 "Can't find number $1"
	fi
    fi
}

# arg1: argument
arg_article () {
    if test "X$1" != "X"; then
	# BUG: ARTICLE <msgid>
	echo "$1"
    else 
	echo "$article"
    fi
}

# arg1: article number
# returns OK status
article_ok () {
    if test "X$group" = "X"; then
	echo 412 "Select group first"
	return 1
    fi
    if ! expr $article + 1 >/dev/null 2>/dev/null; then
	echo 420 "An article must be selected"
	return 1
    fi
    return 0
}

# produce stat-line
# arg1: article number
# arg2: ID of OK
# returns OK status 
stat_article () {
    if test -f "$article"; then
	# BUG: retrieve $msgid...
	msgid=`cat $1 | grep -s -i "^message-id: " | colrm 1 12 | head -n 1`
	echo $2 $1 $msgid selected
	return 0
    else
	return 1
    fi
}

# end and clean up
clean_up () {
    @rm -f $TMP $TMP2
    exit 0
}

trap "clean_up" 1 2 3 15
echo 200 "Tiny news server, pleased to meet you"
while read cmd arg more ; do
    case $cmd in
    ARTICLE | article )
	article=`arg_article "$arg"`
	show_article "$article" 220
	;;
    STAT | stat )
	article=`arg_article "$arg"`
	if article_ok "$article"; then
	    if ! stat_article "$article" 223; then
		echo 423 "Can't find number $article"
		article=""
	    fi
	fi
	;;
    NEXT | next )
	if article_ok "$article"; then
	    if test `expr $article "<" $first` = 1; then
		article=`expr $first - 1`
	    fi
	    while true; do
		if test `expr $article ">=" $last` = 1; then
		    echo 421 "No more articles"
		    break
		fi
		article=`expr $article + 1`
		if stat_article "$article" 223; then
		    break
		fi
	    done
	fi
	;;
    LAST | last )
	if article_ok "$article"; then
	    if test `expr $article ">" $last` = 1; then
		article=`expr $last + 1`
	    fi
	    while true; do
		if test `expr $article "<=" $first` = 1; then
		    echo 422 "Already at first article"
		    break
		fi
		article=`expr $article - 1`
		if stat_article "$article" 223; then
		    break
		fi
	    done
	fi
	;;
    GROUP | group )
	group="$arg"
	article=""
	group_d=`echo "$group" | sed -e "s:\\.:/:g"`
	if test -d "$SPOOL/$group_d"; then
	    cd "$SPOOL/$group_d"
	    # BUG: vvvvery slow
	    rm -f $TMP
	    touch $TMP
	    ls -f [0-9]* 2>/dev/null | sort -n >$TMP
	    if test -s "$TMP"; then
		first=`head -n 1 $TMP`
		last=`tail -n 1 $TMP`
		count=`expr $last + 1 - $first`
		article=$first
		echo 211 "$count $first $last $group selected"
	    else 
		# BUG: this is WRONG
		echo 411 "Group $group is empty"
	    fi
	else
	    echo 411 "Sorry, we don't carry $group"
	    group=""
	fi
	;;
    HELP | help )
	echo 100 "This is what I can offer:"
	echo "ARTICLE argnum"
	echo "GROUP name"
	echo "-> 211 count first last"
	echo "LIST"
	echo "HELP"
	echo "LAST"
	echo "NEXT"
	echo "STAT argnum"
	echo "QUIT"
	echo "."
	;;
    LIST | list )
	echo 215 "The groups I know about are:"
	cat $NEWS/active
	echo "."
	;;
    POST | post )
	echo 340 "Show me the article, end with a single '.'"
	rm -f $TMP
	while read line ; do
	    if test "X$line" = "X." ; then
		break
	    else
		echo $line >>$TMP
	    fi
	done
	if test -s "$TMP"; then
	    if inews <$TMP 2>$TMP2 ; then
		echo 240 "Article posted OK"
	    else
		echo 441 "Posting failed"
	    fi
	else
	    echo 441 "You sent an empty article"
	fi
	;;
    SLAVE | slave )
	echo 202 "I'm your obedient servant"
	;;
    IHAVE | ihave )
	echo 435 "I'm not permitted to handle $cmd"
	;;
    BODY | body |\
    HEAD | head |\
    NEWGROUPS | newgroups |\
    NEWNEWS | newnews )
	echo 500 "I've heard about $cmd, but can't do it. Sorry"
	;;
    QUIT | quit )
	echo 205 "Goodbye"
	clean_up
	;;
    * )
	echo 500 "Sorry, don't know what you mean by $cmd"
    esac
done
