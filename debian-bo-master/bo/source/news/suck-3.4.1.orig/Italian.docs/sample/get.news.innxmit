#!/bin/sh

#PRIMA DELL'USO - controllare per assicurarsi che tutti i path definiti in basso siano corretti!!

#NOTA: questo script probabilmente va avviato da root.  Molti sistemi non
# lasceranno avviare ctlinnd ad un user normale

REMOTE_HOST=news.flashnet.it
LOCAL_HOST=localhost

SPOOLDIR=/usr/spool/news		# directory di base per gli article da rpostare
NEWSDIR=/usr/lib/news			# directory di base per i binari delle news
BASEDIR=/usr/spool/news/suck		# directory di base per gli script e i file di dati

LOCALPOST=${NEWSDIR}/bin/innxmit	# collocazione del binario
CTLINND=${NEWSDIR}/bin/ctlinnd		# collocazione del binario

TMPDIR=${BASEDIR}			# collocazione per i file suck.*
MSGDIR=${BASEDIR}/Msgs			# dove mettere i messaggi MultiFile quando li si prende
BATCHFILE=${TMPDIR}/batch		# Nome del batchfile da generare per rnews o innxmit
SITE=flashnet				# nome del sito dal file newsfeeds
OUTGOING=${SPOOLDIR}/out.going/${SITE}	# collocazione della lista degli article da mandare
OUTGOINGNEW=${OUTGOING}.new		# file per contenere temporaneamente la lista
OUTGOINGFAIL=${OUTGOINGNEW}.fail	# file con i trasferimenti falliti
SCRIPT=${BASEDIR}/put.news		# mio filtro per rpost
OUTFILE=/tmp/tmp$$			# usato da rpost come article dopo che viene filtrato
LOCKFILE=${BASEDIR}/getnews.lock	# lock file per prevenire istanze multiple dello script
PHRASES_FILE=phrases.ital		# file contenente le frasi, passato al parametro -l
NEWSGROUP=news				# gruppo che possiede il file in out.going, tipicamente news o uucp.

TESTHOST=testhost
RPOST=rpost
SUCK=suck

# se stiamo già runnando, usciamo
if [ -f ${LOCKFILE} ]; then
	echo "Già in esecuzione, impossibile avviarne due alla volta"
	exit
else
	touch ${LOCKFILE}
fi

# il local host è up e running in modo che possiamo postare i messaggi che scarichiamo?
${TESTHOST} ${LOCAL_HOST} -s -l ${PHRASES_FILE}
LOCAL_RESULT=$?
if [ ${LOCAL_RESULT} -ne 0 ]; then
	echo "L'Host Locale non risponde"
fi

# il remote host è up e running in modo che possiamo scaricare i messaggi?
${TESTHOST} ${REMOTE_HOST} -s -l ${PHRASES_FILE}
REMOTE_RESULT=$?

if [ ${REMOTE_RESULT} -ne 0 ]; then
	echo "L'Host Remoto non risponde"
fi

if [ ${REMOTE_RESULT} -eq 0 -a ${LOCAL_RESULT} -eq 0 ]; then
	
	# download dei messaggi
	${SUCK} ${REMOTE_HOST} -c -bi ${BATCHFILE} -dt ${TMPDIR} -dm ${MSGDIR} -dd ${BASEDIR} -l ${PHRASES_FILE}
	SUCK_STATUS=$?

	if [ ${SUCK_STATUS} -eq 0 ]; then
		echo "Article Downloadati"
	elif [ ${SUCK_STATUS} -eq 1 ]; then
		echo "Nessun article da downloadare"
	elif [ ${SUCK_STATUS} -eq 2 ]; then
		echo "Risposta inaspettata dal server remoto ad un comando emesso"
	elif [ ${SUCK_STATUS} -eq 4 ]; then
		echo "Impossibile fare l'autorizzazione NNTP"
	elif [ ${SUCK_STATUS} -eq -1 ]; then
		echo "Errore generale"
	fi

	# adesso mandiamo i messaggi
	if [ -s ${OUTGOING}  -o -s ${OUTGOINGNEW} ]; then

		${TESTHOST} ${REMOTE_HOST} -s -l ${PHRASES_FILE}

		if [ $? -ne 0 ]; then
			echo "L'Host di posting remoto non risponde"
		else
			# INND ha bisogno di questo così che il file outgoing verrà
			# flushato propriamente e avremo un nuovo file vuoto con
			# cui lavorare quando avremo finito
			# Prima mv quello corrente ad un nuovo nome di file
			# Siccome innd ha già il file aperto, non si preoccuperà
			# del rinominamento.
			# Il flush assicurerà che tutti i messaggi da postare siano
			# stati scritti, chiuderà il vecchio (già rinominato) e ne
			# creerà uno nuovo.

			# se l'outgoingnew già esiste, significa che l'ultima volta
			# abbiamo abortito, quindi non proviamo a farlo di nuovo
			if [ ! -s ${OUTGOINGNEW} ]; then
				mv ${OUTGOING} ${OUTGOINGNEW}
				${CTLINND} flush ${SITE}
			fi

			# messaggi outgoing da postare
			${RPOST} ${REMOTE_HOST} -d -b ${OUTGOINGNEW} -p ${SPOOLDIR} -l ${PHRASES_FILE} -f \$\$o=${OUTFILE} ${SCRIPT} \$\$i ${OUTFILE}

			ERRLEV=$?
			if [ ${ERRLEV} -eq 0 ]; then
				echo "Article postati in remoto"
				rm ${OUTFILE}
			elif [ ${ERRLEV} -eq 1 ]; then
				echo "Errore postando un messaggio"
			elif [ ${ERRLEV} -eq 2 ]; then
				echo "Incapace di fare l'autorizzazione NNTP con il server remoto"
			elif [ ${ERRLEV} -eq 3 ]; then
				echo "Risposta inaspettata dal server remoto ad un comando mentre si faceva l'autorizzazione NNTP"
			elif [ ${ERRLEV} -eq -1 ]; then
				echo "Errore fatale"
			fi

			if [ -f ${OUTGOINGFAIL} ]; then
				mv ${OUTGOINGFAIL} ${OUTGOINGNEW}	# così possiamo rifarlo
				chown news.${NEWSGROUP} ${OUTGOINGNEW}
				chmod 664 ${OUTGOINGNEW}
			fi
		fi
	fi	
	
	echo "Adesso si può terminare il collegamento del modem"

	if [ ${SUCK_STATUS} -eq 0 ]; then	
		# locally post articles
		${LOCALPOST} ${LOCAL_HOST} ${BATCHFILE}
		
		if [ $? -eq 0 ]; then
			echo "Article Postati In Locale"
			rm -rf ${MSGDIR}
		fi	
	fi	
fi

rm -f ${LOCKFILE}
