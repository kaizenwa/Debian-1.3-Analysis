head	1.8;
access;
symbols;
locks; strict;
comment	@# @;


1.8
date	96.08.11.22.21.23;	author steveg;	state Exp;
branches;
next	1.7;

1.7
date	96.04.28.23.48.14;	author steveg;	state Exp;
branches;
next	1.6;

1.6
date	96.01.28.22.38.30;	author steveg;	state Exp;
branches;
next	1.5;

1.5
date	95.07.20.05.23.14;	author tedhajek;	state Exp;
branches;
next	1.4;

1.4
date	95.05.04.06.17.50;	author tedhajek;	state Exp;
branches;
next	1.3;

1.3
date	95.02.21.05.18.04;	author tedhajek;	state Exp;
branches;
next	1.2;

1.2
date	95.02.05.20.03.35;	author tedhajek;	state Exp;
branches;
next	1.1;

1.1
date	95.02.02.05.40.03;	author tedhajek;	state Exp;
branches;
next	1.0;

1.0
date	94.10.17.02.01.14;	author tedhajek;	state Exp;
branches;
next	0.14;

0.14
date	94.10.17.01.25.56;	author tedhajek;	state Exp;
branches;
next	0.13;

0.13
date	94.10.16.23.27.52;	author tedhajek;	state Exp;
branches;
next	0.12;

0.12
date	94.10.16.23.05.29;	author tedhajek;	state Exp;
branches;
next	0.11;

0.11
date	94.10.16.23.01.11;	author tedhajek;	state Exp;
branches;
next	0.10;

0.10
date	94.10.16.22.54.47;	author tedhajek;	state Exp;
branches;
next	0.9;

0.9
date	94.10.16.21.51.47;	author tedhajek;	state Exp;
branches
	0.9.1.1;
next	0.8;

0.8
date	94.10.16.19.27.59;	author tedhajek;	state Exp;
branches;
next	;

0.9.1.1
date	94.10.16.21.56.21;	author tedhajek;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Don't place Welcome.html if [Ii]ndex.html exists.
Don't offer to delete old log files if they don't exist.
@
text
@#!/usr/bin/perl
#
# 	$Id: httpdconfig,v 1.7 1996/04/28 23:48:14 steveg Exp steveg $	

#########################
# httpdconfig - configuration script for Debian GNU/Linux httpd package
#
# Written by Ted Hajek <tedhajek@@boombox.micro.umn.edu>
#  29 Aug 1994 to 16 Oct 1994 (how's that for productivity?)
#
# This script was originally the postinstallation script for the httpd
# package.  However, because of a problem in the dpkg installation utility,
# I've opted to install this script so that it can be run at any time.
#
# This script only performs very simple configuration of the httpd server;
# in particular, it only will set up a standalone server.  Perhaps later,
# I'll set this up so that it can also configure a server running under inetd.
# It also avoids setting up things like proxy servers.  These functions
# are left for the advanced user (in other words, more advanced than me).
#
# The script sets the following options:
#
#   Port              The port at which httpd accepts connections
#   AccessLog         Should server access be logged?
#   ErrorLog          Should errors be logged?
# NOTE: in the current version, those are set to the default, and the user must
#       edit the file to change them.
#
#   UserDir           Should users have public html directories under their homes?
#                     If so, what should the directories be named?
#   Pass /*           Default directory for html documents.
#                     Directory is created if nonexistent.
#                     A sample Welcome.html file is generated in the directory if
#                       one doesn't already exist
#                     The user has the opportunity to set up a group to maintain the
#                       hierarchy; the directory is made SGID that group if the user
#                       chooses so chooses.
#
#
# Here's the deal:  The httpd package won't install a configuration file.
# If one already exists, we won't do anything unless we're given the
# option `--force'.
#
# Then, the script will ask the user about the above variables and
# create a configuration file.
#
# If the user forced replacement of an existing script, the existing
# script will be saved as `httpd.conf.old'.  If `httpd.conf.old' exists,
# the existing script will be saved as `httpd.conf.old-#', where # is the
# PID of the httpdconfig process.
#
# It also mentions:
#      Exec         The location of scripts executed by the server.
#      DOCS         How to obtain the documentation for the server.
#
# It then warns the user that they are running a server that allows remote
# access to documents on their machine (no, really?) and, upon confirmation,
# puts a stanza in rc.misc to start the server.
##############################

# flush after every write or print.  Clears up bug number 415.
$| = 1;

#######################################################
# GLOBAL CONSTANTS (not really constants, actually...)
#                  (but I won't touch 'em, really!)
#######################################################

$conf_file = "/etc/cern-httpd.conf";	# Where is the config file?
$default_port = 80;		# Default port on which to run 
# $default_nogroup_gid = 65534;	# Need this when getting new GID's
# $default_access_logging = "no";	# Should we log access?
# $default_error_logging = "no";	# should we log errors?
$default_user_dir = "public_html"; # Where should users' docs be stored?
$default_doc_location = "/home/httpd-data"; # Where should docs be stored
$default_use_doc_maint_group = "yes"; # Should we use a doc maint. group?
$default_doc_maint_group = "www-data"; # What should we name it?
$default_dir_mode = 755;	# Use this mode when we're making directories


########################################
# Housekeeping...
#######################################

##
## Better make sure that EUID = 0...
##
die "You must be root to run this script." if ($> != 0);

#####################################
# process command line args
####################################

$force = 0;			# don't force update of existing config file

$no_of_args = $#ARGV + 1;
if ($no_of_args > 1) {
    &usage;
    exit;
} elsif ($no_of_args == 1) {
    if ($ARGV[0] eq "--version") {
	&version;
	exit;
    } elsif ($ARGV[0] eq "--force") {
	$force = 1;
    } else {
	&usage;
	exit;
    }
}

#################################
# look for existing configuration file
################################
##  Check for existing /etc/cern-httpd.conf file.
##    - if one doesn't exist, we go ahead.
##    - if one exists and user hasn't specified --force, we bail out.
if (-f "${conf_file}") {
    if ($force) {
	if (-f "${conf_file}.old") {
	    $backup_file = "${conf_file}.old-$$";
	} else {
	    $backup_file = "${conf_file}.old";
	}
	print "Moving existing `${conf_file}' to `$backup_file'... ";
	rename ("${conf_file}", $backup_file);
	print "Done.\n";
    } else {
	print "You have an existing `${conf_file}' file.\n";
	print "  (no action taken)\n";
	print "Use `httpdconfig --force' to backup and replace it.\n";
	exit (0);
    }
}

#####################
## make sure the server is dead
#####################
system("start-stop-daemon --stop --quiet --oknodo --exec /usr/sbin/cern-httpd");

###############################################################
## if we've made it this far, /etc/cern-httpd.conf is safe to modify.
## Gather some information...
###############################################################

# welcome the user
&welcome;
&pause;
# get the port number
$port = &get_port;
# check whether or not user wants access and error logging enabled
##
## now, user gets logging whether or not they want it :-)
##
# $access_logging = &check_access_logging;
# $error_logging = &check_error_logging;
# check whether or not users should have a public html directory.
# if so, what should it be called?
$user_dir = &get_user_dir;
# find out the root of the tree of served files
$doc_location = &get_and_create_doc_location;
# Ask user if they want to use an HTML document maintenance group
$use_doc_maint_group = &check_doc_maint_group;

# OK.  We have all the necessary information.  Here it is:
#   $port                  port at which httpd will listen
#   $user_dir              users' public html directories (or "none")
#   $doc_location          the root directory for served documents.
#   $use_doc_maint_group   should change ownership of the WWW tree to this group?
#
# Furthermore, we're sure that the group for document maintenance exists, provided
# the user wants one.  Good.  

#################################
# CONFIGURE HTTPD
#################################

# Now, we must:
#    - Create the /etc/cern-httpd.conf file to reflect the changes
#    - change group ownership of the $doc_location directory
#    - Set the GID bit on the $doc_location directory
#    - put a sample Welcome.html file in the $doc_location directory
#      if one doesn't already exist
#    - put stanza in /etc/rc.misc to start daemon
#    - set up things to cycle logfiles
# Also, we'll tell the user how to get docs on the server and tell them
# where server scripts can be found.


##
## Configuration file:
##
# First, we'll hack the configuration file.
print "Creating configuration file...";

# write the default configuration to "/tmp/cern-httd.conf"
# NOTE -- since this script contains the full text of the configuration file,
#   if the format is superceded in future versions of httpd, we'll have
#   to change the script to reflect such changes.
&seed_tmp_with_default_config;
open (SEED, "/tmp/cern-httpd.conf");

# open the new configuration file for writing:
open (CONFIG, ">${conf_file}");

# Tell where this came from
print CONFIG "# This file was automatically generated by the postinstallation script.\n";
print CONFIG "#\n";

# loop through the original conf file
while (<SEED>) {
    if (/^Port/) {
	print CONFIG "Port\t$port\n";
    } elsif (/^UserDir/) {
	if ($user_dir eq "none") {
	    print CONFIG "# UserDir\t$default_user_dir\n";
	} else {
	    print CONFIG "UserDir\t$user_dir\n";
	}
    } elsif (/^Pass/) {
	print CONFIG "Pass\t/*\t$doc_location/*\n";
    } else {
	print CONFIG $_;
    }
}

close SEED;
close CONFIG;

print "Done.\n";

##
## add sample Welcome file
##
# we only want to do this if there already doesn't exist a Welcome.html file.
if (! (-f "$doc_location/Welcome.html" or -f "$doc_location/index.html"
       or -f "$doc_location/Index.html")) {
    print "Putting sample Welcome.html file in `$doc_location'... ";
    &insert_sample_welcome_file;
    print "Done.\n";
}


##
## deal with document maintainance group
##
if ($use_doc_maint_group eq "yes") {
    print "Changing ownership and mode of things in $doc_location...";
    ($name, $passwd, $gid, $members) = getgrnam($default_doc_maint_group);

    # do this for the files and directories in $doc_location
    open (FIND, "find $doc_location -print |") || die "Couldn't run find: $!\n";

    while ($filename = <FIND>) {
	chop $filename;
	chown (0, $gid, $filename);
	if (-d $filename) {
	    chmod (02775, $filename); # directories should be SGID
	} else {
	    chmod (0664, $filename); # files should be group-writeable
	}
    }

    close (FIND);

    print "Done.\n";
}


##
## link the startup and shutdown script into the
## appropriate directories
##
system("update-rc.d cern-httpd defaults >/dev/null");

# start the server
system("start-stop-daemon --start --quiet --oknodo --exec /usr/sbin/cern-httpd");

##
## Check for the remnants of pre rev-5 log files
##
&clean_up_old;

##
## Say goodbye, now...
##
&exit_message;
&pause;

exit (0);


####################################################
####################################################
# END MAIN PROGRAM -- BEGIN SUBROUTINES
####################################################
####################################################
# These are in alphabetical order


##########################################
## check_access_logging
##########################################
# See if user wants access logging enabled
#
sub check_access_logging {
    local ($answer);

    &print_heading ("Access Logging");

    print "Do you want the server to log all server access?  If so, \n";
    print "a line will be generated in the log each time anyone accesses\n";
    print "a file from your server.\n";
    print "\n";
    print "If you choose 'no', the server can still log errors; you will\n";
    print "be asked about that momentarily.\n";
    print "\n";
    print "By default, the server will not log access.  If you type anything\n";
    print "beginning with a 'y' below, the server *will* log access.\n";
    print "\n";

    &print_prompt("Access logging", $default_access_logging);
    chop ($answer = <STDIN>);

    if ($answer =~ /^[Yy]/) {
	$answer = "yes";
    } else {
	$answer = $default_access_logging;
    }

    return $answer;
}




#####################################
## check_doc_maint_group
#####################################
# Find out if the user wants to use the 'www-data' group to give users
# the appropriate permissions to edit the served document tree.
sub check_doc_maint_group {
    local ($answer);
    local ($name, $passwd, $gid, $members);
    local ($doc_maint_group_num);

    &print_heading ("Use a group for WWW document tree maintainers");

    # check for the group 'www-data'
    ($name, $passwd, $gid, $members) = getgrnam($default_doc_maint_group);

    if ($name) {		# The group already exists.
	print "I noticed that you already have a group called $default_doc_maint_group.\n";
	print "Would you like me to change the group ownership of the WWW document tree\n";
	print "to this group and flag the tree so that any subdirectories created under\n";
	print "it belong to the group?\n";
	print "\n";
	print "The directory and any future subdirectories will also, by default, be\n";
	print "writeable by this group.\n";
	print "\n";
	print "You can change membership in the group by editing the file '/etc/group'\n";
	print "or by using the command 'adduser user www-data', where 'user' is the \n";
	print "name of an existing user.\n";
	print "\n";

	&print_prompt ("Use document maintenance group?", $default_use_doc_maint_group);
	chop ($answer = <STDIN>);

	if ($answer =~ /^[Yy]/) {
	    $answer = "yes";
	} elsif (! $answer) {
	    $answer = $default_use_doc_maint_group;
	} else {
	    $answer = "no";
	}
    } else {			# The group doesn't exist
	print "Would you like to create a group called $default_doc_maint_group?\n";
	print "After I create the group, I will change the ownership of the WWW\n";
	print "document tree to this group and flag the root of the tree so that any\n";
	print "subdirectories created under the tree will be automatically owned\n";
	print "by the group.\n";
	print "\n";
	print "Furthermore, the group will be given write permission to the WWW\n";
	print "document tree.\n";
	print "\n";

	&print_prompt ("Create document maintenance group?", $default_use_doc_maint_group);
	chop ($answer = <STDIN>);

	if ($answer =~ /^[Yy]/) {
	    $answer = "yes";
	} elsif (! $answer) {
	    $answer = $default_use_doc_maint_group;
	} else {
	    $answer = "no";
	}
	
	# create group if user wants to set things up this way:
	if ($answer eq "yes") {
	    print "Creating group $default_doc_maint_group... ";
	    system ("addgroup --quiet --force-badname $default_doc_maint_group");
	    print "done.\n";
	}
    }

    return ($answer);
}


#################################
## check_error_logging
#################################
# See if user wants access logging enabled
#
sub check_error_logging {
    local ($answer);

    &print_heading ("Error Logging");

    print "Do you want the server to log errors?\n";
    print "\n";
    print "By default, the server will not log errors.  If you type anything\n";
    print "beginning with a 'y' below, the server *will* log errors.\n";
    print "\n";

    &print_prompt("Error logging", $default_error_logging);
    chop ($answer = <STDIN>);

    if ($answer =~ /^[Yy]/) {
	$answer = "yes";
    } else {
	$answer = $default_error_logging;
    }

    return $answer;
}

#####################################
## clean_up_old
#####################################
# offer to clean up old log files
#
sub clean_up_old {

    opendir(LOGDIR, "/var/log");
    while ( $fname = readdir(LOGDIR) ) {
	if ( $fname =~ /^httpd.*\.log.*/ ) {
	    @@flist = (@@flist, "/var/log/" . $fname);
	}
    }
    closedir(LOGDIR);

    opendir(RUNDIR, "/var/run");
    while ( $fname = readdir(RUNDIR) ) {
	if ( $fname =~ /^httpd.pid/ ) {
	    @@flist = (@@flist, "/var/run/".$fname);
	}
    }
    closedir(RUNDIR);

    if ( defined(@@flist)) {
	printf "The following files are probably the remnants of an old\n";
	printf "version of cern-httpd that did not properly clean up after\n";
	printf "itself:\n\n";
	foreach (@@flist) {printf "$_\n"}
	printf "\nRemove them now? [Y]: ";
	chop ($answer = <STDIN>) ;
	if ($answer =~ /^[Yy]/) {
	    $rmnow = "yes";
	} elsif (! $answer) {
	    $rmnow = "yes";
	} else {
	    $rmnow = "no";
	}

	if ("$rmnow" eq "yes") {
	    printf "Removing files\n";
	    unlink(@@flist) ;
	}
    }
}

	
#####################################
## exit_message
#####################################
# say goodbye, tell the user what we've done
sub exit_message {
    print <<DONE1


------ Configuration complete. -------

Your http daemon is ready-to-go; the server has been restarted.
At that point, anyone will be able to retrieve documents from your
machine.  As such, you should review the setup and make sure that it
works with your overall security strategy.
DONE1
    ;
    if ( -f "$doc_location/Welcome.html" ) {
	print <<DONE2
There is a sample file called `Welcome.html' in your document
directory that will serve as a `home page' for your server until you
get a chance to edit your own.  It contains a link to the httpd docs
and to Debian GNU/Linux bug reports.  Please populate the Web with
lots of groovy things.
DONE2
;
    }
}


######################################
## get_and_create_doc_location
######################################
# Get the directory name that represents the root
# of the tree of served files.
#
# This also creates the directory in question.
#
sub get_and_create_doc_location {
    local ($answer, $dir_create);

    &print_heading ("Root of Document Tree");

    print "Please specify the complete name of the directory in which\n";
    print "all the body of documents served will reside.\n";
    print "\n";
    print "If the directory you specify does not exist, it will be created\n";
    print "for you.  The default directory is \"$default_doc_location\".\n";
    print "\n";

    # LOOP:
    # get directory name from user.
    #
    # if the user leaves this one blank, make sure the default directory
    # exists and return it.
    #
    # make sure the answer begins with a slash and doesn't contain
    # double-dots.
    #
    # then, check if the directory exists.  If so, we're fine.  Return
    # the directory.
    #
    # finally, try to create the directory.  If it works, return it.
    # otherwise, try again.
    while (1) {
	&print_prompt ("Document directory", $default_doc_location);
	chop ($answer = <STDIN>);	# get answer from user
	$answer =~ s/\s+//g;	# strip spaces

	# if it's blank, create the default; immediately return.
	if (! $answer) {
	    &mktree ($default_doc_location) if (! -d $default_doc_location);
	    if (-d $default_doc_location) {
		return ($default_doc_location);
	    } else {
		die "Yipes! I couldn't create the default directory.";
	    }
	}
	
	if (! ($answer =~ m%^/%)) {
	    print "The document directory must be specified by an absolute path.\n";
	    print "In other words, it must begin with a slash.\n";
	    next;
	} elsif ($answer =~ /\.\./) {
	    print "You shouldn't have double-dots (..) in your path.\n";
	    next;
	}

	# chop trailing slash if it exists:
	chop ($answer) if ($answer =~ m%/$%);

	# if directory exists, it's OK.  Return the answer.
	return ($answer) if (-d $answer);

	# otherwise, we'll try to create the directory.
	# use another subroutine; this might be useful elsewhere.
	&mktree ($answer);
	if (-d $answer) {
	    return $answer;
	} else {
	    print "I couldn't create that directory.  Try again...\n";
	}
    }
}



########################################
## get_new_group_num
########################################
# Subroutine to generate a unique, unused group number.
# we'll add one to the largest group number, unless the largest number
# is that used for "nogroup" (65534).
#
# in that case, we'll add one to the second-largest group number.
#
sub get_new_group_num {
    local ($new_num, $largest, $second_largest);
    local ($name, $passwd, $gid, $members);
    local (@@gid_list);

    $largest = 0;
    $second_largest = 0;

    # reset iteration through the group file
    setgrent;

    # now iterate through the thing.
    # put each GID into an array entry
    while (($name, $passwd, $gid, $members) = getgrent) {
	push (@@gid_list, $gid);
    }

    # OK, we're done looking through the group file.
    endgrent;

    # sort the gid's numerically and find the largest:
    # we want the second largest as well in case the largest == GID(nogroup).
    sub numerically { $a <=> $b; }
    foreach $gid (sort numerically @@gid_list) {
	if ($gid > $largest) {
	    $second_largest = $largest;
	    $largest = $gid;
	}
    }

    # now, generate the GID for the new group.
    if ($largest == $default_nogroup_gid) {
	$new_num = $second_largest + 1;
    } else {
	$new_num = $largest + 1;
    }

    return ($new_num);
}
	    


####################################
## get_num
####################################
# get a number from the user
#
sub get_num {
    local ($prompt, $default) = @@_;
    local ($num);

    # loop until we have a valid number
    while (1) {
	&print_prompt ($prompt, $default);
	chop ($num = <STDIN>);

	# if they hit enter, use default
	if ($num eq "") {
	    $num = $default;
	    last;
	}

	# check if num consists of all digits
	if ($num =~ /^\d+$/) {
	    last;
	}

	print "Hmm... that doesn't look like a number.\n";
	print "Please try again...\n\n";
    }

    return ($num);
}


#################################
## get_port
#################################
# Get the port number
#
sub get_port {
    local ($answer);

    &print_heading ("Port Selection");
    
    print "Please choose a port on which httpd will listen for requests.\n";
    print "The default port, 80, is the standard location for HTTP daemons.\n";
    print "You can, however, choose another port if you wish.\n";
    print "\n";
    print "If you choose a port number lower than 1024, you need to be root\n";
    print "to start the server.  This is the normal mode of operation.\n";
    print "\n";
    print "This option can be overridden on the command line.\n";
    print "\n\n";
    
    $answer = &get_num ("Port", $default_port);

    return ($answer);
}
    


######################################
## get_user_dir
######################################
# Get the directory name for user's public html files
#
sub get_user_dir {
    local ($answer, $good_dir);

    &print_heading ("Users' Public HTML Directories");

    print "Httpd affords each user the opportunity to create a subdirectory\n";
    print "of their home directory in which they can place HTML files.\n";
    print "Then, when someone tries to grab the URL\n";
    print "  http://your.machine/~user/file.html\n";
    print "They get the file 'file.html' from the public HTML directory of 'user'.\n";
    print "\n";
    print "Here, you specify the name of the subdirectory in which users can place\n";
    print "HTML files they wish to share with the world.  By default, this will be:\n";
    print "  public_html\n";
    print "However, you can make it whatever you wish.  It's a good idea to restrict\n";
    print "yourself to letters of the alphabet and dashes or underscores, but I'm\n";
    print "not going to force you to follow this guideline.\n";
    print "\n";
    print "If you don't want users to be able to share HTML files with the world,\n";
    print "specify 'none' as the directory name.\n";
    print "\n";

    &print_prompt("Users' public HTML directory", $default_user_dir);
    chop ($answer = <STDIN>);	# get value from user
    $answer =~ s/\s+//g;	# strip spaces

    return $answer if ($answer eq "none");
    return $default_user_dir if (! $answer);

    # make sure that there are no slashes
    # and that we can create such a directory:
    #
    # perhaps this is a particularly ugly way to do this...
    #
    # we try to create the directory under /tmp after making sure
    # that there are no slashes or double-dots in the path.
    # loop until we have a good directory.
    while (1) {
	print "Trying to create directory /tmp/$answer ... \n";
	if ($answer =~ m#/# || $answer =~ /\.\./) {
	    print "You shouldn't have slashes or double-dots in the users' subdirectory.\n";
	    $good_dir = 0;
	} else {
	    mkdir ("/tmp/$answer", 0644);
	    if (-d "/tmp/$answer") {
		$good_dir = 1;
		rmdir ("/tmp/$answer");	# clean up after ourselves...
	    } else {
		$good_dir = 0;
	    }
	}

	if ($good_dir) {
	    print "OK.\n";
	    last;
	} 
	print "failed.\n";
	print "Try again... Remember, this is the name of a subdirectory.\n";
	&print_prompt("Users' public HTML directory", $default_user_dir);
	chop ($answer = <STDIN>);	# get value from user
	$answer =~ s/\s+//g;	# strip spaces


	return $answer if ($answer eq "none");
	return $default_user_dir if (! $answer);
    }

    return $answer;
}
    


#####################################
# insert_sample_welcome_file
#####################################
# put a sample Welcome.html file in $doc_location
#
sub insert_sample_welcome_file {
    open (WELCOME, ">$doc_location/Welcome.html");
    print WELCOME <<END_WELCOME;
<HTML>
<HEAD>
<TITLE>Debian GNU/Linux System</TITLE>
</HEAD>

<BODY>

<H1>Howdy!</H1>

Here are a couple of interesting things you should check out:

<H2>CERN Hypertext Daemon Manual</H2>

The <A HREF="http://www.w3.org/hypertext/WWW/Daemon/Status.html">CERN HTTPD Installation and
Administration Manual</A> contains instructions for the care and feeding of 
httpd. 
       
<H2>Debian GNU/Linux Information</H2>

The <A HREF="http://www.debian.org/">
Debian GNU/Linux</A> WWW site has a great deal of information, including
hypertext versions of the manual and info pages for Debian.

<H2>Debian GNU/Linux Bug Report Logs</H2>

Think you've found a bug?  Check one of these locations to see if
someone else has already discovered it:

<UL>
  <LI> Debian bugs at the
       <A HREF="http://www.cl.cam.ac.uk/users/iwj10/debian-bugs/">
       University of Cambridge</A>.
  <LI> US Mirror of 
       <A HREF="http://www.debian.org/Bugs/">
       Debian Bugs</A>.
</UL>

Enjoy browsing!
</BODY>
</HTML>
END_WELCOME
    
    close (WELCOME);
}



#####################################
## mktree
#####################################
# given a path, create the directory specified, creating all leading
# directories if necessary.  If successful, return 1, otherwise, return 0.
sub mktree {
    local ($requested_path) = @@_;
    local (@@path);
    local ($done, $attempt);

    # chop off any trailing slash.
    chop ($requested_path) if ($requested_path =~ m%/$%);
    # get rid of leading slash
    $requested_path =~ s@@^/(.+)$@@$1@@;

    # split the path elements into an array
    @@path = split(/\//, $requested_path);

    # this'll hold the parts of the path that have already been
    # created.  For example, if we are creating
    #   /usr/local/lib/httpd_data
    # the variable $done will hold
    #   /usr/local
    # after we're sure that /usr and /usr/local exist.
    $done = "";

    # while there are still path elements, create the next.
    while (@@path) {
	$attempt = shift(@@path);
	mkdir("$done/$attempt", $default_dir_mode);
	if (-d "$done/$attempt") {
	    $done = "$done/$attempt";
	} else {
	    return 0;
	}
    }

    return 1;
}


###########################################
## pause
###########################################
sub pause {
    local ($discard);
   
    print "Press [enter] to continue: ";
    $discard = <STDIN>;
}



#########################################
## print_heading
#########################################
# print a simple heading
#
sub print_heading {
    local ($head) = @@_;

    print "\n";
    print "                 ------ $head ------\n";
    print "\n";
}



####################################
## print_prompt
####################################
# print a simple prompt
#
sub print_prompt {
    local ($prompt, $default) = @@_;

    print "$prompt [$default]: ";
}


##############################################
## seed_tmp_with_default_config
##############################################
# creates file /tmp/cern-httpd.conf, which will be
# munged into /etc/cern-httpd.conf by this script.
sub seed_tmp_with_default_config {
    open (SEED, ">/tmp/cern-httpd.conf") || die "Couldn't open temp file: $!";

    print SEED <<END_SEED;
#
#	Sample configuration file for cern_httpd for running it
#	as a normal HTTP server.
#
# See:
#	<http://www.w3.org/hypertext/WWW/Daemon/User/Config/Overview.html>
#
# for more information.
#
# Written by:
#	Ari Luotonen  April 1994  <luotonen\@@dxcern.cern.ch>
#
# Minimally Hacked for Debian GNU/Linux by:
#	Ted Hajek    Aprli 1995    <tedhajek\@@boombox.micro.umn.edu>

#
#	Set this to point to the directory where you unpacked this
#	distribution, or wherever you want httpd to have its "home"
#
ServerRoot	/usr/lib/cern-httpd

#
#	The default port for HTTP is 80; if you are not root you have
#	to use a port above 1024; good defaults are 8000, 8001, 8080
#
Port	80

#
#	General setup; on some systems, like HP, nobody is defined so
#	that setuid() fails; in those cases use a different user id.
#
UserId	nobody
GroupId	nogroup

#
#	Logging; if you want logging uncomment these lines and specify
#	locations for your access and error logs
#
AccessLog	/var/log/cern-httpd.log
ErrorLog	/var/log/cern-httpd-error.log
LogFormat	Common
LogTime		LocalTime

#
#	User-supported directories under ~/(UserDir)
#
UserDir	public_html

#
#	Scripts; URLs starting with /cgi-bin/ will be understood as
#	script calls in the directory /your/script/directory
#
Exec	/cgi-bin/*	/usr/lib/cern-httpd/cgi-bin/*

#
#	URL translation rules; default location of documents.
#
Pass	/*	/home/httpd-data/*
END_SEED

    close (SEED);
}



############################################
## usage
############################################
# prints usage message
#
sub usage {
    print STDERR "httpdconfig - http daemon configuration script\n";
    print STDERR "\n";
    print STDERR "usage: httpdconfig [option]\n";
    print STDERR "\n";
    print STDERR "valid options:\n";
    print STDERR "  --force      Force httpdconfig to replace existing httpd.conf file\n";
    print STDERR "  --help       Display this message\n";
    print STDERR "  --version    Display version and copyright information\n";
}



############################################
## version
############################################
# prints version and copyright information
#
sub version {
    print STDERR "httpdconfig - http daemon configuration script\n";
    print STDERR " version $Id: httpdconfig,v 1.7 1996/04/28 23:48:14 steveg Exp steveg $	\n"; # this should grab RCS version number?
    print STDERR "\n";
    print STDERR "Copyright (C) 1994 by Ted Hajek <tedhajek\@@boombox.micro.umn.edu>\n";
    print STDERR "\n";
    print STDERR "This program is free software; you can redistribute it and/or modify\n";
    print STDERR "it under the terms of the GNU General Public License as published by\n";
    print STDERR "the Free Software Foundation; either version 2 of the License, or\n";
    print STDERR "(at your option) any later version.\n";
    print STDERR "\n";
    print STDERR "This program is distributed in the hope that it will be useful,\n";
    print STDERR "but WITHOUT ANY WARRANTY; without even the implied warranty of\n";
    print STDERR "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n";
    print STDERR "GNU General Public License in the file `/usr/doc/copyright/GPL'.\n";
}



#######################################
## welcome
#######################################
# Welcome the nice user
#
sub welcome {
    &print_heading ("cern-httpd configuration");
    print "\n";
    print "Welcome to post-installation configuration of the CERN httpd.\n";
    print "Answering these questions will allow you to configure the daemon\n";
    print "to provide simple HTTP service on a port of your choice. You may\n";
    print "change the resulting configuration by running /usr/sbin/httpdconfig,\n";
    print "or by editing /etc/cern-httpd.conf\n";

    print "\n";
    print "The CERN httpd can provide much more complex service than that initiated by\n";
    print "this script.  If you are interested, look at the sample configuration files\n";
    print "in the directory:\n";
    print "  /usr/doc/examples\n";
    print "\n";
    print "Actually, you should probably look at the documentation regardless of\n";
    print "the complexity of your HTTP service.  After all, by running this server,\n";
    print "you're allowing others to anonymously access files on your machine.\n";
    print "\n";
    print "The documentation for the CERN httpd is available, surprisingly enough,\n";
    print "on the Web.  Point your favorite WWW client to the following URL:\n";
    print "  http://www.w3.org/httpd/\n";
    print "\n";
}



@


1.7
log
@Changes to bring up to rev 5. Mostly default
filenames, and the routine to clean up old files.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.6 1996/01/28 22:38:30 steveg Exp steveg $	
d236 2
a237 1
if (! -f "$doc_location/Welcome.html") {
d461 1
a461 1
    if ( length (@@flist) > 0) {
d489 1
a489 1
    print <<DONE
d498 4
a501 1

d507 3
a509 1
DONE
d1012 1
a1012 1
    print STDERR " version $Id: httpdconfig,v 1.6 1996/01/28 22:38:30 steveg Exp steveg $	\n"; # this should grab RCS version number?
@


1.6
log
@Changed default user directory to public_html, changed cern reference, changed
print_prompt to use [] instead of ()
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.5 1995/07/20 05:23:14 tedhajek Exp steveg $	
d26 3
d69 1
a69 1
$conf_file = "/etc/httpd.conf";	# Where is the config file?
d115 1
a115 1
##  Check for existing /etc/httpd.conf file.
d118 1
a118 1
if (-f "/etc/httpd.conf") {
d120 2
a121 2
	if (-f "/etc/httpd.conf.old") {
	    $backup_file = "/etc/httpd.conf.old-$$";
d123 1
a123 1
	    $backup_file = "/etc/httpd.conf.old";
d125 2
a126 2
	print "Moving existing `/etc/httpd.conf' to `$backup_file'... ";
	rename ("/etc/httpd.conf", $backup_file);
d129 1
a129 1
	print "You have an existing `/etc/httpd.conf' file.\n";
d139 1
a139 1
system("start-stop-daemon --stop --quiet --oknodo --exec /usr/sbin/httpd");
d142 1
a142 1
## if we've made it this far, /etc/httpd.conf is safe to modify.
d179 1
a179 1
#    - Create the /etc/httpd.conf file to reflect the changes
d196 1
a196 1
# write the default configuration to "/tmp/httd.conf"
d201 1
a201 1
open (SEED, "/tmp/httpd.conf");
d204 1
a204 1
open (CONFIG, ">/etc/httpd.conf");
a213 12
#    } elsif (/^. AccessLog/) {
#	if ($access_logging eq "no") {
#	    print CONFIG $_;
#	} else {
#	    print CONFIG "AccessLog\t/var/adm/httpd-access.log\n";
#	}
#    } elsif (/^. ErrorLog/) {
#	if ($error_logging eq "no") {
#	    print CONFIG $_;
#	} else {
#	    print CONFIG "ErrorLog\t/var/adm/httpd-error.log\n";
#	}
d268 1
d270 2
a271 1
## put file in rc.misc to start server
d273 1
a273 24
#print "Adding file /etc/rc.misc/httpd to automatically start server...";
#if (-f "/etc/rc.misc/httpd") {
#    print "\nMoving existing /etc/rc.misc/httpd to /etc/httpd-start.disabled...\n";
#    rename ("/etc/rc.misc/httpd", "/etc/httpd-start.disabled");
#}
#open (STARTUP, ">/etc/rc.misc/httpd");
#print STARTUP <<END_STARTUP;
##!/bin/sh
##
## Start the CERN http daemon.
#if [ -x /usr/sbin/httpd ]; then
#    echo "Starting httpd..."
#    /usr/sbin/httpd &
#fi
#END_STARTUP
#close (STARTUP);

#chmod (0755, "/etc/rc.misc/httpd");
#print "Done.\n";


# link the startup and shutdown script into the
# appropriate directories
system("update-rc.d httpd defaults >/dev/null");
d276 6
a281 1
system("start-stop-daemon --start --quiet --oknodo --exec /usr/sbin/httpd");
d436 46
d910 2
a911 2
# creates file /tmp/httpd.config, which will be
# munged into /etc/httpd.config by this script.
d913 1
a913 1
    open (SEED, ">/tmp/httpd.conf") || die "Couldn't open temp file: $!";
d954 2
a955 2
AccessLog	/var/log/httpd.log
ErrorLog	/var/log/httpd-error.log
d1006 1
a1006 1
    print STDERR " version $Id: httpdconfig,v 1.5 1995/07/20 05:23:14 tedhajek Exp steveg $	\n"; # this should grab RCS version number?
d1029 1
a1029 1
    &print_heading ("httpd configuration");
d1033 4
a1036 1
    print "to provide simple HTTP service on a port of your choice.\n";
@


1.5
log
@Fixed pointers to other pages in default Welcome.html.

Made sure "www-data" is name of group.

Made sure daemon is killed before making changes and restarted after
changes take place.

Made sure that "update-rc.d" is run to ensure that httpd is started on
system startup.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.4 1995/05/04 06:17:50 tedhajek Exp tedhajek $	
d71 1
a71 1
$default_user_dir = "public-html"; # Where should users' docs be stored?
d203 1
a203 1
# loop through the original conf file
d207 1
d225 1
a225 1
	    print CONFIG "# UserDir\tpublic_html\n";
d791 3
a793 6
  <LI> Debian bugs at
       <A HREF="http://www.cps.cmich.edu/~streeter/debian-bugs/">
       Central Michigan University</A>.
  <LI> Debian bugs at the
       <A HREF="http://www.engr.wisc.edu/~streeter/debian-bugs/">
       University of Wisconsin</A>.
d882 1
a882 1
    print "$prompt ($default): ";
d900 1
a900 1
#	<http://info.cern.ch/hypertext/WWW/Daemon/User/Config/Overview.html>
d941 1
a941 1
UserDir	public-html
d952 1
a952 1
Pass	/*	/home/http-data/*
d985 1
a985 1
    print STDERR " version $Id: httpdconfig,v 1.4 1995/05/04 06:17:50 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
d1025 1
a1025 1
    print "  http://info.cern.ch/httpd/\n";
@


1.4
log
@- changed a bunch of things.  See the file "debian.ChangeLog" in this
directory.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.3 1995/02/21 05:18:04 tedhajek Exp tedhajek $	
d71 2
a72 2
$default_user_dir = "public_html"; # Where should users' docs be stored?
$default_doc_location = "/home/httpd_data"; # Where should docs be stored
d133 5
d300 7
d363 1
a363 1
# Find out if the user wants to use the 'www-maint' group to give users
d372 1
a372 1
    # check for the group 'www-maint'
d385 1
a385 1
	print "or by using the command 'adduser user www-maint', where 'user' is the \n";
d424 1
a424 1
	    system ("addgroup --quiet $default_doc_maint_group");
d471 1
a471 1
Your http daemon is ready-to-go; the server will be started shortly.
d771 1
a771 1
The <A HREF="http://info.cern.ch/httpd/">CERN HTTPD Installation and
d775 1
a775 1
<H2>The Debian GNU/Linux FAQ</H2>
d777 3
a779 3
The <A HREF="http://www.wi.leidenuniv.nl/~jdassen/debian-faq_toc.html">
frequently asked questions</A> list for Debian GNU/Linux is a valuable 
resource.
d910 1
a910 1
#	Ted Hajek    Autust 1994    <tedhajek\@@boombox.micro.umn.edu>
d935 2
a936 2
AccessLog	/var/adm/httpd.log
ErrorLog	/var/adm/httpd-error.log
d943 1
a943 1
UserDir	public_html
d987 1
a987 1
    print STDERR " version $Id: httpdconfig,v 1.3 1995/02/21 05:18:04 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


1.3
log
@Added "$| = 1;" line at beginning of script to command-buffer output.
This repairs debian bug number 415.

Still need to figure out what to do with respect to adding group.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.2 1995/02/05 20:03:35 tedhajek Exp tedhajek $	
d68 3
a70 3
$default_nogroup_gid = 65534;	# Need this when getting new GID's
$default_access_logging = "no";	# Should we log access?
$default_error_logging = "no";	# should we log errors?
d144 5
a148 2
$access_logging = &check_access_logging;
$error_logging = &check_error_logging;
a158 2
#   $access_logging        should accesses be logged?
#   $error_logging         should errors be logged?
d205 12
a216 12
    } elsif (/^. AccessLog/) {
	if ($access_logging eq "no") {
	    print CONFIG $_;
	} else {
	    print CONFIG "AccessLog\t/var/adm/httpd-access.log\n";
	}
    } elsif (/^. ErrorLog/) {
	if ($error_logging eq "no") {
	    print CONFIG $_;
	} else {
	    print CONFIG "ErrorLog\t/var/adm/httpd-error.log\n";
	}
d274 16
a289 16
print "Adding file /etc/rc.misc/httpd to automatically start server...";
if (-f "/etc/rc.misc/httpd") {
    print "\nMoving existing /etc/rc.misc/httpd to /etc/httpd-start.disabled...\n";
    rename ("/etc/rc.misc/httpd", "/etc/httpd-start.disabled");
}
open (STARTUP, ">/etc/rc.misc/httpd");
print STARTUP <<END_STARTUP;
#!/bin/sh
#
# Start the CERN http daemon.
if [ -x /usr/sbin/httpd ]; then
    echo "Starting httpd..."
    /usr/sbin/httpd &
fi
END_STARTUP
close (STARTUP);
d291 2
a292 2
chmod (0755, "/etc/rc.misc/httpd");
print "Done.\n";
d372 3
a374 1
	print "You can change membership in the group by editing the file '/etc/group'.\n";
d412 1
a412 4
	    $group_num = &get_new_group_num;
	    open(GROUP, ">>/etc/group") || die "Yipes, couldn't append to /etc/group";
	    print GROUP $default_doc_maint_group . "::" . $group_num . ":\n";
	    close(GROUP);
d459 2
a460 4
Your http daemon is ready-to-go; the next time you restart the system,
a stanza of code in `/etc/rc.misc/httpd' will start the server.  If
you can't wait 'till then, type `httpd &' at your shell prompt.  At
that point, anyone will be able to retrieve documents from your
d746 1
d749 1
d757 17
d775 9
a783 5
  <LI> <A HREF="http://info.cern.ch/httpd/">
       The CERN Hypertext Daemon</A> Installation
       and Administration Manual
  <LI> <A HREF="http://www.cl.cam.ac.uk/users/iwj10/debian-bugs/">
       Existing bugs</A> in Debian GNU/Linux
d787 2
d923 2
a924 2
# AccessLog	/var/adm/httpd.log
# ErrorLog	/var/adm/httpd-error.log
d937 1
a937 1
Exec	/cgi-bin/*	/usr/lib/httpd/cgi-bin/*
d975 1
a975 1
    print STDERR " version $Id: httpdconfig,v 1.2 1995/02/05 20:03:35 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


1.2
log
@- changed ServerRoot to /usr/lib/cern-httpd rather than /usr/lib/httpd
in seed configuration file.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.1 1995/02/02 05:40:03 tedhajek Exp tedhajek $	
d58 2
d952 1
a952 1
    print STDERR " version $Id: httpdconfig,v 1.1 1995/02/02 05:40:03 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


1.1
log
@- escaped "@@" symbols in strings so script works with perl 5.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 1.0 1994/10/17 02:01:14 tedhajek Exp tedhajek $	
d879 1
a879 1
ServerRoot	/usr/lib/httpd
d950 1
a950 1
    print STDERR " version $Id: httpdconfig,v 1.0 1994/10/17 02:01:14 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


1.0
log
@Alphabetized subroutines (that took a while!).

Added message to be displayed after configuration is complete.

Added some comments to poorly-explained code.

Removed code used to cycle logfiles -- I found out that httpd
automatically cycles them on a monthly basis.

Added "goodbye" message -- told users to review the setup to make sure
that it jives with their overall security strategy
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.14 1994/10/17 01:25:56 tedhajek Exp tedhajek $	
d870 1
a870 1
#	Ari Luotonen  April 1994  <luotonen@@dxcern.cern.ch>
d873 1
a873 1
#	Ted Hajek    Autust 1994    <tedhajek@@boombox.micro.umn.edu>
d950 1
a950 1
    print STDERR " version $Id: httpdconfig,v 0.14 1994/10/17 01:25:56 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
d952 1
a952 1
    print STDERR "Copyright (C) 1994 by Ted Hajek <tedhajek@@boombox.micro.umn.edu>\n";
@


0.14
log
@Added Welcome.html page in $doc_location

Made generated /etc/cron.weekly/httpd file executable.

Stripped out some unused code.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.13 1994/10/16 23:27:52 tedhajek Exp tedhajek $	
d291 1
d293 1
a293 1
## Code to cycle logfiles
d295 2
a296 35
if (($access_logging eq "yes" || $error_logging eq "yes")) {
    print "Adding file /etc/cron.weekly/httpd to cycle logfiles...";
    if (-f "/etc/cron.weekly/httpd") {
	print "\nMoving existing /etc/cron.weekly/httpd to /etc/httpd-cycle.disabled...\n";
	rename ("/etc/cron.weekly/httpd", "/etc/httpd-cycle.disabled");
    }
    open (CYCLE, ">/etc/cron.weekly/httpd");
    print CYCLE "#/bin/sh\n";
    print CYCLE "#\n";
    print CYCLE "# cron script to rotate httpd log files.\n";
    print CYCLE "#\n";
    print CYCLE "# Adapted from system log rotation script written by\n";
    print CYCLE "# Ian A. Murdock <imurdock@@gnu.ai.mit.edu> by\n";
    print CYCLE "# Ted Hajek <tedhajek@@boombox.micro.umn.edu>\n";
    print CYCLE "cd /var/adm\n";
    print CYCLE "echo 'Rotating httpd log files:'\n";
    print CYCLE "\n";
    print CYCLE "for LOG in ";
    print CYCLE "/var/adm/httpd-access.log " if ($access_logging eq "yes");
    print CYCLE "/var/adm/httpd-error.log " if ($error_logging eq "yes");
    print CYCLE "\n";
    print CYCLE "do\n";
    print CYCLE "   if [ -f $LOG ]; then\n";
    print CYCLE "      savelog -g adm -m 644 -u root -c 4 $LOG\n";
    print CYCLE "   fi\n";
    print CYCLE "done\n";
    print CYCLE "\n";
    print CYCLE "echo\n";
    print CYCLE "# Restart httpd.\n";
    print CYCLE "httpd -restart\n";
    print CYCLE "echo 'Restarted httpd.'\n";
    close (CYCLE);
    chmod (0755, "/etc/cron.weekly/httpd");
    print "Done.\n";
}
d298 1
d308 5
a312 5
####################################################
##  has_file_been_changed
####################################################
# find out if the configuration file /etc/httpd.conf differs from
# the one installed by dpkg-util.deb.
d314 4
a317 2
sub has_file_been_changed {
    local ($md5_hash_default, $md5_hash_installed);
d319 18
a336 7
    # read the existing md5 hash of the default config file
    if (-f "$md5_hash_file") {
	open(DEFAULT, "$md5_hash_file");
	chop($md5_hash_default = <DEFAULT>);
	close(DEFAULT);
    } else {			# This is an ugly hack
	$md5_hash_default = $orig_config_hash;
d339 3
a341 12
    # compute the md5 hash of the existing config file
    open(INSTALLED, "md5sum $conf_file |") || die "Couldn't run md5sum: $!";
    chop($md5_hash_installed = <INSTALLED>);
    close(INSTALLED);

    # actually, each of the "hashes" above consist of the actual
    # hash, two spaces and the filename.  We need to trim out 
    # everything but the hash.
    #
    # I hope that md5 hashes don't contain spaces...
    $md5_hash_default =~ s/^(\S+)\s.*$/$1/;
    $md5_hash_installed =~ s/^(\S+)\s.*$/$1/;
a342 7
    #print "Default MD5: $md5_hash_default\n";
    #print "Installed MD5: $md5_hash_installed\n";
    
    # If the two aren't equal, the conf file has been changed.
    # therefore, we return true.
    # 
    # similarly, if they're equal, we return false.
a343 2
    return ("$md5_hash_default" ne "$md5_hash_installed");
}
d360 1
a360 1
    if ($name) {
d373 1
a373 1
	chop ($answer = <>);
d382 1
a382 1
    } else {
d394 1
a394 1
	chop ($answer = <>);
d418 5
a422 6
########################################
## get_new_group_num
########################################
# Subroutine to generate a unique, unused group number.
# we'll add one to the largest group number, unless the largest number
# is that used for "nogroup" (65534).
d424 2
a425 6
# in that case, we'll add one to the second-largest group number.
#
sub get_new_group_num {
    local ($new_num, $largest, $second_largest);
    local ($name, $passwd, $gid, $members);
    local (@@gid_list);
d427 1
a427 2
    $largest = 0;
    $second_largest = 0;
d429 5
a433 2
    # reset iteration through the group file
    setgrent;
d435 2
a436 4
    # now iterate through the thing.
    while (($name, $passwd, $gid, $members) = getgrent) {
	push (@@gid_list, $gid);
    }
d438 2
a439 15
    # sort them gid's numerically and find the largest:
    sub numerically { $a <=> $b; }
    foreach $gid (sort numerically @@gid_list) {
	if ($gid > $largest) {
	    $second_largest = $largest;
	    $largest = $gid;
	}
    }

    # OK, we're done looking through the group file.
    endgrent;

    # now, generate the GID for the new group.
    if ($largest == $default_nogroup_gid) {
	$new_num = $second_largest + 1;
d441 1
a441 1
	$new_num = $largest + 1;
d444 26
a469 1
    return ($new_num);
d471 1
a471 1
	    
d509 1
a509 1
	chop ($answer = <>);	# get answer from user
a547 9
#####################################
## mktree
#####################################
# given a path, create the directory specified, creating all leading
# directories if necessary.  If successful, return 1, otherwise, return 0.
sub mktree {
    local ($requested_path) = @@_;
    local (@@path);
    local ($done, $attempt);
a548 4
    # chop off any trailing slash.
    chop ($requested_path) if ($requested_path =~ m%/$%);
    # get rid of leading slash
    $requested_path =~ s@@^/(.+)$@@$1@@;
d550 64
a613 1
    @@path = split(/\//, $requested_path);
d615 5
a619 1
    $done = "";
d621 3
a623 7
    while (@@path) {
	$attempt = shift(@@path);
	mkdir("$done/$attempt", $default_dir_mode);
	if (-d "$done/$attempt") {
	    $done = "$done/$attempt";
	} else {
	    return 0;
d625 3
d630 27
a656 1
    return 1;
d658 2
d689 1
a689 1
    chop ($answer = <>);	# get value from user
d699 3
a701 1

d725 1
a725 1
	chop ($answer = <>);	# get value from user
d737 5
a741 4
##########################################
## check_access_logging
##########################################
# See if user wants access logging enabled
d743 5
a747 2
sub check_access_logging {
    local ($answer);
d749 1
a749 1
    &print_heading ("Access Logging");
d751 1
a751 10
    print "Do you want the server to log all server access?  If so, \n";
    print "a line will be generated in the log each time anyone accesses\n";
    print "a file from your server.\n";
    print "\n";
    print "If you choose 'no', the server can still log errors; you will\n";
    print "be asked about that momentarily.\n";
    print "\n";
    print "By default, the server will not log access.  If you type anything\n";
    print "beginning with a 'y' below, the server *will* log access.\n";
    print "\n";
d753 1
a753 2
    &print_prompt("Access logging", $default_access_logging);
    chop ($answer = <>);
d755 7
a761 5
    if ($answer =~ /^[Yy]/) {
	$answer = "yes";
    } else {
	$answer = $default_access_logging;
    }
d763 4
a766 1
    return $answer;
a769 7
#################################
## check_error_logging
#################################
# See if user wants access logging enabled
#
sub check_error_logging {
    local ($answer);
d771 9
a779 1
    &print_heading ("Error Logging");
d781 4
a784 5
    print "Do you want the server to log errors?\n";
    print "\n";
    print "By default, the server will not log errors.  If you type anything\n";
    print "beginning with a 'y' below, the server *will* log errors.\n";
    print "\n";
d786 2
a787 2
    &print_prompt("Error logging", $default_error_logging);
    chop ($answer = <>);
d789 7
a795 5
    if ($answer =~ /^[Yy]/) {
	$answer = "yes";
    } else {
	$answer = $default_error_logging;
    }
d797 8
a804 96
    return $answer;
}
	
       
###################################
## ensure_user_and_group
###################################
# Make sure that nobody and nogroup exist.
#
sub ensure_user_and_group {
    local ($name, $passwd, $uid, $gid, $quota, $comment,$gcos, $dir, $shell);
    local ($members);
    local ($nobody_gid);

    &print_heading ("Checking for User and Group 'nobody' and 'nogroup'");

    print "After the httpd process binds to the port you just selected,\n";
    print "any children it forks off usually have a different user\n";
    print "and group ID (especially if you execute the server as root).\n";
    print "\n";
    print "By default, the server will run as the user 'nobody' with group\n";
    print "'nogroup'.  This user and group customarily don't own files.\n";
    print "\n";

    print "Checking for group 'nogroup' ... ";
    ($name, $passwd, $gid, $members) = getgrnam("nogroup");
    print "done.\n";

    if ($name) {
	$nobody_gid = $gid;
    } else {
	print "Didn't find group 'nogroup'.  Creating ... ";
	open(GROUP, ">>/etc/group") || die "Yipes, couldn't append to /etc/group";
	print GROUP "nogroup:*:" . $default_nogroup_gid . ":\n";
	close(GROUP);
	print "done.\n";
    }

    print "\nChecking for user 'nobody' ... ";
    ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwnam("nobody");
    print "done.\n";

    if (! $name) {
	print "Didn't find user 'nobody'.  Creating ... ";
	$nobody_gid = $default_nogroup_gid if (! $nobody_gid);
	open(PASSWD, ">>/etc/passwd") || die "Yipes, couldn't append to /etc/passwd";
	print PASSWD "nobody:*:" . $default_nobody_uid . ":" . $nobody_gid . "::/:\n";
	close(PASSWD);
	print "done.\n";
    }
    &pause;
}

#################################
## get_port
#################################
# Get the port number
#
sub get_port {
    local ($answer);

    &print_heading ("Port Selection");
    
    print "Please choose a port on which httpd will listen for requests.\n";
    print "The default port, 80, is the standard location for HTTP daemons.\n";
    print "You can, however, choose another port if you wish.\n";
    print "\n";
    print "If you choose a port number lower than 1024, you need to be root\n";
    print "to start the server.  This is the normal mode of operation.\n";
    print "\n";
    print "This option can be overridden on the command line.\n";
    print "\n\n";
    
    $answer = &get_num ("Port", $default_port);

    return ($answer);
}
    
####################################
## get_num
####################################
# get a number from the user
#
sub get_num {
    local ($prompt, $default) = @@_;
    local ($num);

    # loop until we have a valid number
    while (1) {
	&print_prompt ($prompt, $default);
	chop ($num = <STDIN>);

	# if they hit enter, use default
	if ($num eq "") {
	    $num = $default;
	    last;
a805 8

	# check if num consists of all digits
	if ($num =~ /^\d+$/) {
	    last;
	}

	print "Hmm... that doesn't look like a number.\n";
	print "Please try again...\n\n";
d808 1
a808 1
    return ($num);
d812 8
a819 10

####################################
## print_prompt
####################################
# print a simple prompt
#
sub print_prompt {
    local ($prompt, $default) = @@_;

    print "$prompt ($default): ";
d839 4
a842 4
#######################################
## welcome
#######################################
# Welcome the nice user
d844 2
a845 21
sub welcome {
    &print_heading ("httpd configuration");
    print "\n";
    print "Welcome to post-installation configuration of the CERN httpd.\n";
    print "Answering these questions will allow you to configure the daemon\n";
    print "to provide simple HTTP service on a port of your choice.\n";
    print "\n";
    print "The CERN httpd can provide much more complex service than that initiated by\n";
    print "this script.  If you are interested, look at the sample configuration files\n";
    print "in the directory:\n";
    print "  /usr/doc/examples\n";
    print "\n";
    print "Actually, you should probably look at the documentation regardless of\n";
    print "the complexity of your HTTP service.  After all, by running this server,\n";
    print "you're allowing others to anonymously access files on your machine.\n";
    print "\n";
    print "The documentation for the CERN httpd is available, surprisingly enough,\n";
    print "on the Web.  Point your favorite WWW client to the following URL:\n";
    print "  http://info.cern.ch/httpd/\n";
    print "\n";
}
d847 1
a847 46
###########################################
## pause
###########################################
sub pause {
    local ($discard);
   
    print "Press [enter] to continue: ";
    $discard = <STDIN>;
}

############################################
## usage
############################################
# prints usage message
#
sub usage {
    print STDERR "httpdconfig - http daemon configuration script\n";
    print STDERR "\n";
    print STDERR "usage: httpdconfig [option]\n";
    print STDERR "\n";
    print STDERR "valid options:\n";
    print STDERR "  --force      Force httpdconfig to replace existing httpd.conf file\n";
    print STDERR "  --help       Display this message\n";
    print STDERR "  --version    Display version and copyright information\n";
}

############################################
## version
############################################
# prints version and copyright information
#
sub version {
    print STDERR "httpdconfig - http daemon configuration script\n";
    print STDERR " version $Id: httpdconfig,v 0.13 1994/10/16 23:27:52 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
    print STDERR "\n";
    print STDERR "Copyright (C) 1994 by Ted Hajek <tedhajek@@boombox.micro.umn.edu>\n";
    print STDERR "\n";
    print STDERR "This program is free software; you can redistribute it and/or modify\n";
    print STDERR "it under the terms of the GNU General Public License as published by\n";
    print STDERR "the Free Software Foundation; either version 2 of the License, or\n";
    print STDERR "(at your option) any later version.\n";
    print STDERR "\n";
    print STDERR "This program is distributed in the hope that it will be useful,\n";
    print STDERR "but WITHOUT ANY WARRANTY; without even the implied warranty of\n";
    print STDERR "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n";
    print STDERR "GNU General Public License in the file `/usr/doc/copyright/GPL'.\n";
d924 5
a928 4
#####################################
# insert_sample_welcome_file
#####################################
# put a sample Welcome.html file in $doc_location
d930 11
a940 5
sub insert_sample_welcome_file {
    open (WELCOME, ">$doc_location/Welcome.html");
    print WELCOME <<END_WELCOME;
<HEAD>
<TITLE>Debian GNU/Linux System</TITLE>
a941 1
<BODY>
d943 21
a963 1
<H1>Howdy!</H1>
a964 1
Here are a couple of interesting things you should check out:
a965 7
<UL>
  <LI> <A HREF="http://info.cern.ch/httpd/">
       The CERN Hypertext Daemon</A> Installation
       and Administration Manual
  <LI> <A HREF="http://www.cl.cam.ac.uk/users/iwj10/debian-bugs/">
       Existing bugs</A> in Debian GNU/Linux
</UL>
d967 25
a991 4
Enjoy browsing!
END_WELCOME
    
    close (WELCOME);
d993 2
@


0.13
log
@Fixed problem in getting new group number; I had to sort the GID's for
my "largest/second-largest" algorithm to work correctly.

Converted mode to an octal number; now directory permissions on the
document directory are set correctly.

Fixed problem in get_num routine; need to read <STDIN> rather than <>.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.12 1994/10/16 23:05:29 tedhajek Exp tedhajek $	
d64 10
a73 15
$conf_file = "/etc/httpd.conf";
# $md5_hash_file = "/var/adm/dpkg/deb/cern-httpd/httpd.conf.md5";
## since the front-end isn't done yet, I have this as a fallback.
#$orig_config_hash = "af65dc437e7cc5d2ff8d72c36a7e7952  /etc/httpd.conf";
$default_port = 80;
#$default_nobody_uid = 65534;
$default_nogroup_gid = 65534;
$default_access_logging = "no";
$default_error_logging = "no";
$default_user_dir = "public_html";
$default_doc_location = "/home/httpd_data";
$default_use_doc_maint_group = "yes";
$default_doc_maint_group = "www-data";
$default_start_server = "no";
$default_dir_mode = 755;
d107 3
a109 27
#########
######### OLD - REMOVE
#########
## First things first:
##  If the user already has an /etc/httpd.conf file set up, we don't want
##  to do anything.
##
##  After dpkg-util.deb is executed, there'll be an MD5 hash of the default 
##  httpd.conf in the file /var/adm/dpkg/deb/cern-httpd/httpd.conf.md5.
##
##  We want to compute a MD5 hash of the existing /etc/httpd.conf file and
##  compare it to that of the default.
##
##  If they differ, it means that the user (or this script) has at some
##  point changed the httpd.conf file; we should leave it alone.
##     --> print some helpful message and exit.
##
##  If they're the same, we can safely take the user through the setup
##  procedure.
#$file_changed = &has_file_been_changed;
#
#if ($file_changed) {
#    print "You've already modified /etc/httpd.conf.\n";
#    print "No action taken.\n";
#    exit (0);
#}

d236 6
d326 1
a326 1

d337 1
a337 1

d942 1
a942 1
    print STDERR " version $Id: httpdconfig,v 0.12 1994/10/16 23:05:29 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
d1030 31
@


0.12
log
@Changed bug in "pause" subroutine that caused problems if script was
called with an argument.  I needed to read from <STDIN> rather than
<>.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.11 1994/10/16 23:01:11 tedhajek Exp tedhajek $	
d280 1
a280 1
	    chmod (2775, $filename); # directories should be SGID
d489 1
d499 6
d855 1
a855 1
	chop ($num = <>);
d965 1
a965 1
    print STDERR " version $Id: httpdconfig,v 0.11 1994/10/16 23:01:11 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


0.11
log
@Fixed some syntax errors introduced by editing wrong version (0.9)
instead of (0.9.1.1).  Oh, well...
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.10 1994/10/16 22:54:47 tedhajek Exp tedhajek $	
d932 1
a932 1
    $discard = <>;
d958 1
a958 1
    print STDERR " version $Id: httpdconfig,v 0.10 1994/10/16 22:54:47 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


0.10
log
@Removed debugging code used for creating document directory.

Removed "*" in passwd field of /etc/group line; no other groups use
it.

Fixed problem with group number generation; I had accidently commented
out the definition of the constant containing the GID for `nobody'.

Fixed error in creating seed file: I called it /tmp/httpd.config in
one place and /tmp/httpd.conf in another.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.9 1994/10/16 21:51:47 tedhajek Exp tedhajek $	
d88 1
a88 1
#die "You must be root to run this script." if ($> != 0);
d142 1
a142 1
if (-f /etc/httpd.conf) {
d144 1
a144 1
	if (-f /etc/httpd.conf.old) {
d958 1
a958 1
    print STDERR " version $Id: httpdconfig,v 0.9 1994/10/16 21:51:47 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


0.9
log
@Whew.  Changed this from being the post-installation script to being a
general configuration script (which just happens to be called by the
post-installation script) because of a problem in dpkg-util.deb.

Removed some debugging aids that spewed unnecessary output (anymore)
to the screen

Added option --help to print usage message.

Added option --version to print version and copyright information.

Added option --force to force overwriting of configuration file.

Now, the file /etc/httpd.conf isn't installed as part of the tarfile.
It's generated by this script in the postinstallation phase.  If
there's an existing httpd.conf file, we bail unless the `--force'
option is given.  In this case, /etc/httpd.conf is backed up with a
filename generated by the PID of the perl process running the script.

Got rid of code used to check existence of nobody/nogroup; these are
now included in the base system passwd and group files.

Added copyright information; released under GPL v.2
@
text
@d3 1
a3 1
# 	$Id$	
d70 1
a70 1
#$default_nogroup_gid = 65534;
d286 2
d468 1
a468 1
	    print GROUP $default_doc_maint_group . ":*:" . $group_num . ":\n";
a602 1
    print "before chop: $requested_path\n";
a604 1
    print "before getting rid of slash: $requested_path\n";
a607 2
    print "Before split: PATH = $requested_path\n";

a613 1
	print "Attempting to create: $done/$attempt\n";
a616 1
	    print "Created: $done\n";
d958 1
a958 1
    print STDERR " version $Id$	\n"; # this should grab RCS version number?
d980 1
a980 1
    open (SEED, ">/tmp/httpd.config") || die "Couldn't open temp file: $!";
@


0.9.1.1
log
@Fixed several syntax errors that prevented execution (whoops!)

Added code to check for EUID == root.
@
text
@d3 1
a3 1
# 	$Id: httpdconfig,v 0.9 1994/10/16 21:51:47 tedhajek Exp tedhajek $	
d88 1
a88 1
die "You must be root to run this script." if ($> != 0);
d142 1
a142 1
if (-f "/etc/httpd.conf") {
d144 1
a144 1
	if (-f "/etc/httpd.conf.old") {
d962 1
a962 1
    print STDERR " version $Id: httpdconfig,v 0.9 1994/10/16 21:51:47 tedhajek Exp tedhajek $	\n"; # this should grab RCS version number?
@


0.8
log
@*** empty log message ***
@
text
@d2 2
d6 1
a6 1
# debian.postinst - post-installation script for Debian GNU/Linux httpd package
d9 5
a13 1
#  29 Aug 1994
d15 2
a16 3
# This script should ONLY be run by the dpkg front-end after installation of
# the httpd package.  It performs very simple configuration of the http server.
# In particular, it only will set up a standalone server.  Perhaps later,
d18 2
d36 13
d59 4
a62 3
#######################################
# GLOBAL CONSTANTS (not really...)
#######################################
d65 3
a67 3
$md5_hash_file = "/var/adm/dpkg/deb/cern-httpd/httpd.conf.md5";
# since the front-end isn't done yet, I have this as a fallback.
$orig_config_hash = "af65dc437e7cc5d2ff8d72c36a7e7952  /etc/httpd.conf";
d69 2
a70 2
$default_nobody_uid = 65534;
$default_nogroup_gid = 65534;
d80 1
d88 7
a94 1
#die "You're not root!" if ($> != 0);
d96 15
d112 3
d131 27
a157 6
$file_changed = &has_file_been_changed;

if ($file_changed) {
    print "You've already modified /etc/httpd.conf.\n";
    print "No action taken.\n";
    exit (0);
a167 1

a169 2
print "I think that you said $port.\n";

a171 1
print "I think that you said $access_logging.\n";
a172 2
print "I think that you said $error_logging.\n";

a175 2
print "I think that you said $user_dir.\n";

a177 5
print "I think that you said $doc_location.\n";

# make sure "nobody" and "nogroup" exist
# &ensure_user_and_group;

a179 1
print "I think that you said $use_doc_maint_group.\n";
d189 2
a190 2
# Furthermore, we're sure that "nobody" and "nogroup" exist, and that
# the group for document maintenance exists.  Good.  
d197 1
a197 1
#    - Edit the /etc/httpd.conf file to reflect the changes
d212 8
a219 1
print "Editing configuration file...";
d221 2
a222 3
# open the original for reading
open (ORIG, "/etc/httpd.conf");
open (NEW, ">/tmp/httpd.conf.new");
d225 2
a226 2
print NEW "# This file was automatically generated by the postinstallation script.\n";
print NEW "#\n";
d228 1
a228 1
while (<ORIG>) {
d230 1
a230 1
	print NEW "Port\t$port\n";
d233 1
a233 1
	    print NEW $_;
d235 1
a235 1
	    print NEW "AccessLog\t/var/adm/httpd-access.log\n";
d239 1
a239 1
	    print NEW $_;
d241 1
a241 1
	    print NEW "ErrorLog\t/var/adm/httpd-error.log\n";
d245 1
a245 1
	    print NEW "# UserDir\tpublic_html\n";
d247 1
a247 1
	    print NEW "UserDir\t$user_dir\n";
d250 1
a250 1
	print NEW "Pass\t/*\t$doc_location/*\n";
d252 1
a252 1
	print NEW $_;
d256 2
a257 6
close ORIG;
close NEW;

# move the new file into place.
rename ("/etc/httpd.conf", "/etc/httpd.distrib");
rename ("/tmp/httpd.conf.new", "/etc/httpd.conf");
d264 1
a264 1
# we only want to do this if there already doesn't exist a Welcome.http file.
a359 4




d938 113
@
